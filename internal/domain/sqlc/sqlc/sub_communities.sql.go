// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sub_communities.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubCommunity = `-- name: CreateSubCommunity :one
INSERT INTO sub_communities (
   sub_community,
   communities_id
) VALUES
 ($1, $2)
 RETURNING id, sub_community, communities_id, created_at, updated_at, lng, lat, status, deleted_at, updated_by, sub_community_ar
`

type CreateSubCommunityParams struct {
	SubCommunity  string      `json:"sub_community"`
	CommunitiesID pgtype.Int8 `json:"communities_id"`
}

func (q *Queries) CreateSubCommunity(ctx context.Context, arg CreateSubCommunityParams) (SubCommunity, error) {
	row := q.db.QueryRow(ctx, createSubCommunity, arg.SubCommunity, arg.CommunitiesID)
	var i SubCommunity
	err := row.Scan(
		&i.ID,
		&i.SubCommunity,
		&i.CommunitiesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lng,
		&i.Lat,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.SubCommunityAr,
	)
	return i, err
}

const deleteSubCommunity = `-- name: DeleteSubCommunity :exec
DELETE FROM sub_communities
Where id =$1
`

func (q *Queries) DeleteSubCommunity(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSubCommunity, id)
	return err
}

const getAllSubCommunitiesByCommunitiesList = `-- name: GetAllSubCommunitiesByCommunitiesList :many
select id, sub_community, communities_id, created_at, updated_at, lng, lat, status, deleted_at, updated_by, sub_community_ar from sub_communities where communities_id = ANY($1::bigint[])
`

func (q *Queries) GetAllSubCommunitiesByCommunitiesList(ctx context.Context, dollar_1 []int64) ([]SubCommunity, error) {
	rows, err := q.db.Query(ctx, getAllSubCommunitiesByCommunitiesList, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubCommunity
	for rows.Next() {
		var i SubCommunity
		if err := rows.Scan(
			&i.ID,
			&i.SubCommunity,
			&i.CommunitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lng,
			&i.Lat,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.SubCommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubCommunityid = `-- name: GetAllSubCommunityid :many
SELECT id FROM sub_communities 
WHERE communities_id = $1
`

func (q *Queries) GetAllSubCommunityid(ctx context.Context, communitiesID pgtype.Int8) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllSubCommunityid, communitiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListOfSubCommunity = `-- name: GetListOfSubCommunity :many
SELECT id, sub_community, communities_id, created_at, updated_at, lng, lat, status, deleted_at, updated_by, sub_community_ar FROM sub_communities 
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetListOfSubCommunity(ctx context.Context, dollar_1 []int64) ([]SubCommunity, error) {
	rows, err := q.db.Query(ctx, getListOfSubCommunity, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubCommunity
	for rows.Next() {
		var i SubCommunity
		if err := rows.Scan(
			&i.ID,
			&i.SubCommunity,
			&i.CommunitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lng,
			&i.Lat,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.SubCommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListSubCommunity = `-- name: GetListSubCommunity :many
SELECT id, sub_community, communities_id, created_at, updated_at, lng, lat, status, deleted_at, updated_by, sub_community_ar FROM sub_communities
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetListSubCommunityParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetListSubCommunity(ctx context.Context, arg GetListSubCommunityParams) ([]SubCommunity, error) {
	rows, err := q.db.Query(ctx, getListSubCommunity, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubCommunity
	for rows.Next() {
		var i SubCommunity
		if err := rows.Scan(
			&i.ID,
			&i.SubCommunity,
			&i.CommunitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lng,
			&i.Lat,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.SubCommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubCommunity = `-- name: GetSubCommunity :one
SELECT id, sub_community, communities_id, created_at, updated_at, lng, lat, status, deleted_at, updated_by, sub_community_ar FROM sub_communities 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetSubCommunity(ctx context.Context, limit int32) (SubCommunity, error) {
	row := q.db.QueryRow(ctx, getSubCommunity, limit)
	var i SubCommunity
	err := row.Scan(
		&i.ID,
		&i.SubCommunity,
		&i.CommunitiesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lng,
		&i.Lat,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.SubCommunityAr,
	)
	return i, err
}

const getSubCommunityByCommunityId = `-- name: GetSubCommunityByCommunityId :many
SELECT id, sub_community, communities_id, created_at, updated_at, lng, lat, status, deleted_at, updated_by, sub_community_ar FROM sub_communities
Where communities_id = $1 AND status= $2::BIGINT ORDER BY id
`

type GetSubCommunityByCommunityIdParams struct {
	CommunitiesID pgtype.Int8 `json:"communities_id"`
	ActiveStatus  int64       `json:"active_status"`
}

func (q *Queries) GetSubCommunityByCommunityId(ctx context.Context, arg GetSubCommunityByCommunityIdParams) ([]SubCommunity, error) {
	rows, err := q.db.Query(ctx, getSubCommunityByCommunityId, arg.CommunitiesID, arg.ActiveStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubCommunity
	for rows.Next() {
		var i SubCommunity
		if err := rows.Scan(
			&i.ID,
			&i.SubCommunity,
			&i.CommunitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lng,
			&i.Lat,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.SubCommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubCommunityByName = `-- name: GetSubCommunityByName :one
SELECT id, sub_community, communities_id, created_at, updated_at, lng, lat, status, deleted_at, updated_by, sub_community_ar FROM sub_communities 
WHERE sub_community = $2 LIMIT $1
`

type GetSubCommunityByNameParams struct {
	Limit        int32  `json:"limit"`
	SubCommunity string `json:"sub_community"`
}

func (q *Queries) GetSubCommunityByName(ctx context.Context, arg GetSubCommunityByNameParams) (SubCommunity, error) {
	row := q.db.QueryRow(ctx, getSubCommunityByName, arg.Limit, arg.SubCommunity)
	var i SubCommunity
	err := row.Scan(
		&i.ID,
		&i.SubCommunity,
		&i.CommunitiesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lng,
		&i.Lat,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.SubCommunityAr,
	)
	return i, err
}

const updateSubCommunity = `-- name: UpdateSubCommunity :one
UPDATE sub_communities
SET sub_community = $2
Where id = $1
RETURNING id, sub_community, communities_id, created_at, updated_at, lng, lat, status, deleted_at, updated_by, sub_community_ar
`

type UpdateSubCommunityParams struct {
	ID           int64  `json:"id"`
	SubCommunity string `json:"sub_community"`
}

func (q *Queries) UpdateSubCommunity(ctx context.Context, arg UpdateSubCommunityParams) (SubCommunity, error) {
	row := q.db.QueryRow(ctx, updateSubCommunity, arg.ID, arg.SubCommunity)
	var i SubCommunity
	err := row.Scan(
		&i.ID,
		&i.SubCommunity,
		&i.CommunitiesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lng,
		&i.Lat,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.SubCommunityAr,
	)
	return i, err
}
