// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: country_settings.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCountrySettings = `-- name: CreateCountrySettings :exec
INSERT INTO countries (
    country,
    country_ar,
    flag,
    created_at, 
    updated_at,
    alpha2_code,
    alpha3_code,
    country_code, 
    name, 
    status, 
    updated_by
)VALUES (
    $1, $2, $3, $4, $5, $6,$7,$8,$9,$10,$11 
)
`

type CreateCountrySettingsParams struct {
	Country     string      `json:"country"`
	CountryAr   pgtype.Text `json:"country_ar"`
	Flag        string      `json:"flag"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Alpha2Code  pgtype.Text `json:"alpha2_code"`
	Alpha3Code  pgtype.Text `json:"alpha3_code"`
	CountryCode pgtype.Int8 `json:"country_code"`
	Name        string      `json:"name"`
	Status      int64       `json:"status"`
	UpdatedBy   int64       `json:"updated_by"`
}

func (q *Queries) CreateCountrySettings(ctx context.Context, arg CreateCountrySettingsParams) error {
	_, err := q.db.Exec(ctx, createCountrySettings,
		arg.Country,
		arg.CountryAr,
		arg.Flag,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Alpha2Code,
		arg.Alpha3Code,
		arg.CountryCode,
		arg.Name,
		arg.Status,
		arg.UpdatedBy,
	)
	return err
}

const deleteRestoreCountrySettings = `-- name: DeleteRestoreCountrySettings :exec
UPDATE countries 
SET 
    status = $4::BIGINT,
    updated_at = $2, 
    updated_by=$3
WHERE 
    id = $1
`

type DeleteRestoreCountrySettingsParams struct {
	ID        int64     `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
	UpdatedBy int64     `json:"updated_by"`
	Status    int64     `json:"status"`
}

func (q *Queries) DeleteRestoreCountrySettings(ctx context.Context, arg DeleteRestoreCountrySettingsParams) error {
	_, err := q.db.Exec(ctx, deleteRestoreCountrySettings,
		arg.ID,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
	)
	return err
}

const getAllCountriesSettings = `-- name: GetAllCountriesSettings :many
SELECT
    id,
    country,
    flag,
    alpha2_code,
    alpha3_code,
    country_code,
    status,
    updated_at,
    country_ar
FROM
    countries
WHERE 
    ($1::BIGINT = 6 AND status = 6) 
    OR ($1::BIGINT != 6 AND status IN (1, 2))
ORDER BY
    updated_at DESC
LIMIT $3 OFFSET $2
`

type GetAllCountriesSettingsParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllCountriesSettingsRow struct {
	ID          int64       `json:"id"`
	Country     string      `json:"country"`
	Flag        string      `json:"flag"`
	Alpha2Code  pgtype.Text `json:"alpha2_code"`
	Alpha3Code  pgtype.Text `json:"alpha3_code"`
	CountryCode pgtype.Int8 `json:"country_code"`
	Status      int64       `json:"status"`
	UpdatedAt   time.Time   `json:"updated_at"`
	CountryAr   pgtype.Text `json:"country_ar"`
}

func (q *Queries) GetAllCountriesSettings(ctx context.Context, arg GetAllCountriesSettingsParams) ([]GetAllCountriesSettingsRow, error) {
	rows, err := q.db.Query(ctx, getAllCountriesSettings, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCountriesSettingsRow
	for rows.Next() {
		var i GetAllCountriesSettingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Country,
			&i.Flag,
			&i.Alpha2Code,
			&i.Alpha3Code,
			&i.CountryCode,
			&i.Status,
			&i.UpdatedAt,
			&i.CountryAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountrySettingsByID = `-- name: GetCountrySettingsByID :one
SELECT country, flag,alpha2_code,alpha3_code,country_code,status,name,country_ar
FROM countries
WHERE id=$1 AND status!=6
`

type GetCountrySettingsByIDRow struct {
	Country     string      `json:"country"`
	Flag        string      `json:"flag"`
	Alpha2Code  pgtype.Text `json:"alpha2_code"`
	Alpha3Code  pgtype.Text `json:"alpha3_code"`
	CountryCode pgtype.Int8 `json:"country_code"`
	Status      int64       `json:"status"`
	Name        string      `json:"name"`
	CountryAr   pgtype.Text `json:"country_ar"`
}

func (q *Queries) GetCountrySettingsByID(ctx context.Context, id int64) (GetCountrySettingsByIDRow, error) {
	row := q.db.QueryRow(ctx, getCountrySettingsByID, id)
	var i GetCountrySettingsByIDRow
	err := row.Scan(
		&i.Country,
		&i.Flag,
		&i.Alpha2Code,
		&i.Alpha3Code,
		&i.CountryCode,
		&i.Status,
		&i.Name,
		&i.CountryAr,
	)
	return i, err
}

const getNumberOfCountriesSettings = `-- name: GetNumberOfCountriesSettings :one
SELECT
   COUNT(*)
FROM
    countries
WHERE 
    ($1::BIGINT = 6 AND status = 6) 
    OR ($1::BIGINT != 6 AND status IN (1, 2))
`

func (q *Queries) GetNumberOfCountriesSettings(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOfCountriesSettings, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateCountrySettings = `-- name: UpdateCountrySettings :exec
Update countries
SET 
    country=$2, 
    flag=$3, 
    updated_at=$4, 
    alpha2_code=$5, 
    alpha3_code=$6, 
    country_code=$7, 
    name=$8, 
    updated_by=$9, 
    status=$10,
    country_ar=$11
WHERE id=$1 AND status!= 6
`

type UpdateCountrySettingsParams struct {
	ID          int64       `json:"id"`
	Country     string      `json:"country"`
	Flag        string      `json:"flag"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Alpha2Code  pgtype.Text `json:"alpha2_code"`
	Alpha3Code  pgtype.Text `json:"alpha3_code"`
	CountryCode pgtype.Int8 `json:"country_code"`
	Name        string      `json:"name"`
	UpdatedBy   int64       `json:"updated_by"`
	Status      int64       `json:"status"`
	CountryAr   pgtype.Text `json:"country_ar"`
}

func (q *Queries) UpdateCountrySettings(ctx context.Context, arg UpdateCountrySettingsParams) error {
	_, err := q.db.Exec(ctx, updateCountrySettings,
		arg.ID,
		arg.Country,
		arg.Flag,
		arg.UpdatedAt,
		arg.Alpha2Code,
		arg.Alpha3Code,
		arg.CountryCode,
		arg.Name,
		arg.UpdatedBy,
		arg.Status,
		arg.CountryAr,
	)
	return err
}
