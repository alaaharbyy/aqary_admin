// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: finehome_lising.sql

package sqlc

import (
	"context"
)

const getAmenitiesByEntityTypeAndIDs = `-- name: GetAmenitiesByEntityTypeAndIDs :many
 
SELECT 
fa.id, fa.icon_url, fa.title, fa.type, fa.created_at, fa.updated_at, fa.categories, fa.updated_by, fa.title_ar,
fae.id as facility_amenity_entity_id
FROM  facilities_amenities_entity fae
LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id
WHERE fae.entity_type_id=$1 and fae.entity_id=$2
`

type GetAmenitiesByEntityTypeAndIDsParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
}

type GetAmenitiesByEntityTypeAndIDsRow struct {
	FacilitiesAmenity       FacilitiesAmenity `json:"facilities_amenity"`
	FacilityAmenityEntityID int64             `json:"facility_amenity_entity_id"`
}

// -- name: GetAmenitiesByEntityType :many
// SELECT
// sqlc.embed(fa)
// FROM  facilities_amenities_entity fae
// LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=2
// WHERE fae.entity_type_id=$1;
func (q *Queries) GetAmenitiesByEntityTypeAndIDs(ctx context.Context, arg GetAmenitiesByEntityTypeAndIDsParams) ([]GetAmenitiesByEntityTypeAndIDsRow, error) {
	rows, err := q.db.Query(ctx, getAmenitiesByEntityTypeAndIDs, arg.EntityTypeID, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAmenitiesByEntityTypeAndIDsRow
	for rows.Next() {
		var i GetAmenitiesByEntityTypeAndIDsRow
		if err := rows.Scan(
			&i.FacilitiesAmenity.ID,
			&i.FacilitiesAmenity.IconUrl,
			&i.FacilitiesAmenity.Title,
			&i.FacilitiesAmenity.Type,
			&i.FacilitiesAmenity.CreatedAt,
			&i.FacilitiesAmenity.UpdatedAt,
			&i.FacilitiesAmenity.Categories,
			&i.FacilitiesAmenity.UpdatedBy,
			&i.FacilitiesAmenity.TitleAr,
			&i.FacilityAmenityEntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFacilitiesByEntityTypeAndIDs = `-- name: GetFacilitiesByEntityTypeAndIDs :many
 
SELECT 
fa.id, fa.icon_url, fa.title, fa.type, fa.created_at, fa.updated_at, fa.categories, fa.updated_by, fa.title_ar
FROM  facilities_amenities_entity fae
LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=1
WHERE fae.entity_type_id=$1 and fae.entity_id=$2 and fa.id=ANY($3::bigint[])
`

type GetFacilitiesByEntityTypeAndIDsParams struct {
	EntityTypeID int64   `json:"entity_type_id"`
	EntityID     int64   `json:"entity_id"`
	Ids          []int64 `json:"ids"`
}

type GetFacilitiesByEntityTypeAndIDsRow struct {
	FacilitiesAmenity FacilitiesAmenity `json:"facilities_amenity"`
}

// -- name: GetFacilitiesByEntityType :many
// SELECT
// sqlc.embed(fa)
// FROM  facilities_amenities_entity fae
// LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=1
// WHERE fae.entity_type_id=$1;
func (q *Queries) GetFacilitiesByEntityTypeAndIDs(ctx context.Context, arg GetFacilitiesByEntityTypeAndIDsParams) ([]GetFacilitiesByEntityTypeAndIDsRow, error) {
	rows, err := q.db.Query(ctx, getFacilitiesByEntityTypeAndIDs, arg.EntityTypeID, arg.EntityID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFacilitiesByEntityTypeAndIDsRow
	for rows.Next() {
		var i GetFacilitiesByEntityTypeAndIDsRow
		if err := rows.Scan(
			&i.FacilitiesAmenity.ID,
			&i.FacilitiesAmenity.IconUrl,
			&i.FacilitiesAmenity.Title,
			&i.FacilitiesAmenity.Type,
			&i.FacilitiesAmenity.CreatedAt,
			&i.FacilitiesAmenity.UpdatedAt,
			&i.FacilitiesAmenity.Categories,
			&i.FacilitiesAmenity.UpdatedBy,
			&i.FacilitiesAmenity.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnit = `-- name: GetUnit :one


WITH facilities AS(
	SELECT uv.id, 
	array_agg(DISTINCT coalesce(fae.facility_amenity_id,0))::bigint[] AS facilities
	FROM unit_versions uv
	JOIN units u on u.id=uv.unit_id
	LEFT JOIN facilities_amenities_entity fae ON fae.entity_id=u.id AND fae.entity_type_id=5
	LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=1
	group by uv.id -- facilities
),
amenities AS(
	SELECT uv.id, 
	array_agg(DISTINCT coalesce(fae.facility_amenity_id,0))::bigint[] AS amenities
	FROM unit_versions uv
	JOIN units u on u.id=uv.unit_id
	LEFT JOIN facilities_amenities_entity fae ON fae.entity_id=u.id AND fae.entity_type_id=5
	LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=2
	group by uv.id -- amenities
),
reviews AS(
	SELECT uv.id, 
	array_agg(DISTINCT coalesce(rv.id,0))::bigint[] AS reviews
	FROM unit_versions uv 
	LEFT JOIN units_reviews rv on rv.units_id=uv.id
	group by uv.id 
)
SELECT 
uv.id, uv.title, uv.views_count, uv.title_arabic, uv.description, uv.description_arabic, uv.unit_id, uv.ref_no, uv.status, uv.type, uv.unit_rank, uv.created_at, uv.updated_at, uv.created_by, uv.updated_by, uv.facts, uv.listed_by, uv.has_gallery, uv.has_plans, uv.is_main, uv.is_verified, uv.exclusive, uv.start_date, uv.end_date, uv.slug, uv.is_hotdeal, uv.refreshed_at,
u.id, u.unit_no, u.unitno_is_public, u.notes, u.unit_title, u.description, u.description_arabic, u.unit_title_arabic, u.notes_arabic, u.notes_public, u.is_verified, u.entity_type_id, u.entity_id, u.created_at, u.updated_at, u.addresses_id, u.unit_type_id, u.created_by, u.updated_by, u.type_name_id, u.owner_users_id, u.from_xml, u.company_id, u.status, u.facts, u.is_project_unit, u.exclusive, u.start_date, u.end_date,
f.facilities,
am.amenities,
rvs.reviews
FROM unit_versions uv
JOIN units u on u.id=uv.unit_id
JOIN addresses a on u.addresses_id=a.id
LEFT JOIN facilities f ON f.id=uv.id
LEFT JOIN amenities am ON am.id=uv.id
LEFT JOIN reviews rvs ON rvs.id=uv.id
WHERE 
	uv.id=$1
`

type GetUnitRow struct {
	UnitVersion UnitVersion `json:"unit_version"`
	Unit        Unit        `json:"unit"`
	Facilities  []int64     `json:"facilities"`
	Amenities   []int64     `json:"amenities"`
	Reviews     []int64     `json:"reviews"`
}

// -- name: GetUnitsWithAdvancedSearch :many
// WITH facilities AS(
//
//	SELECT uv.id,
//	array_agg(DISTINCT coalesce(fae.facility_amenity_id,0))::bigint[] AS facilities
//	FROM unit_versions uv
//	JOIN units u on u.id=uv.unit_id
//	LEFT JOIN facilities_amenities_entity fae ON fae.entity_id=u.id AND fae.entity_type_id=5
//	LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=1
//	group by uv.id -- facilities
//
// ),
// amenities AS(
//
//	SELECT uv.id,
//	array_agg(DISTINCT coalesce(fae.facility_amenity_id,0))::bigint[] AS amenities
//	FROM unit_versions uv
//	JOIN units u on u.id=uv.unit_id
//	LEFT JOIN facilities_amenities_entity fae ON fae.entity_id=u.id AND fae.entity_type_id=5
//	LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=2
//	group by uv.id -- amenities
//
// )
// SELECT
// sqlc.embed(uv),
// sqlc.embed(u),
// sqlc.embed(a),
// f.facilities,
// am.amenities
// FROM unit_versions uv
// JOIN units u on u.id=uv.unit_id
// left JOIN addresses a on u.addresses_id=a.id
// LEFT JOIN cities ci ON a.cities_id = ci.id
// LEFT JOIN communities com ON a.communities_id = com.id
// LEFT JOIN sub_communities subcom ON a.sub_communities_id = subcom.id
// LEFT JOIN facilities f ON f.id=uv.id
// LEFT JOIN amenities am ON am.id=uv.id
// WHERE
//
//	(CASE WHEN @agent_id::bigint= 0 then true else uv.listed_by=  @agent_id::bigint end)
//
// AND
//
//	(@is_verified::bool IS NULL
//	    OR u.is_verified = @is_verified::bool)
//
// AND
//
//	(CASE WHEN  @country_id::bigint=0 THEN TRUE ELSE a.countries_id = @country_id::bigint end)
//
// AND
//
//	(CASE WHEN @company_id::bigint=0 THEN TRUE ELSE u.company_id= @company_id::bigint END)
//
// AND
//
//	-- 1=>Sale, 2=>Rent, 3=>Swap & 4=>Booking
//	uv."type" = @category::bigint
//
// AND
//
//	-- from unit type table
//	(CASE WHEN ARRAY_LENGTH(@unit_types::bigint[], 1) IS NULL THEN TRUE ELSE u.unit_type_id = ANY(@unit_types::bigint[]) END)
//
// AND
//
//		(case when @unit_no::varchar='' then true else  u.unit_no = @unit_no::varchar end )
//	   AND  u.unitno_is_public = TRUE  --unit no
//
// AND
//
//	(CASE WHEN @ref_no::varchar='' THEN TRUE ELSE uv.ref_no = @ref_no::varchar END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@keywords::VARCHAR[], 1) IS NULL --keywords
//	THEN TRUE ELSE
//	uv.title ILIKE ANY(@keywords::VARCHAR[])
//	OR uv.description ILIKE ANY(@keywords::VARCHAR[])
//	OR ci.city ILIKE ANY(@keywords::VARCHAR[])
//	OR com.community ILIKE ANY(@keywords::VARCHAR[])
//	OR subcom.sub_community ILIKE ANY(@keywords::VARCHAR[])
//	END)
//
// AND
//
//	    -- location
//	(CASE WHEN @city_id::bigint=0 THEN TRUE ELSE a.cities_id= @city_id::bigint END)
//	 AND
//	 (CASE WHEN @communities_id::bigint=0 THEN TRUE ELSE a.communities_id= @communities_id::bigint END)
//	 AND
//	 (CASE WHEN @sub_communities_id::bigint=0 THEN TRUE ELSE a.sub_communities_id= @sub_communities_id::bigint END)
//
// AND
//
//	    --created at
//	(CASE
//	WHEN @dates::BIGINT= 0 THEN true
//	WHEN COALESCE(@dates::BIGINT,1) =1 THEN true
//	WHEN @dates::BIGINT= 2 THEN uv.created_at >= DATE_TRUNC ('day', CURRENT_DATE)
//	WHEN @dates::BIGINT = 3 THEN uv.created_at >= DATE_TRUNC('week', CURRENT_DATE - INTERVAL '1 week')AND uv.created_at < DATE_TRUNC('week', CURRENT_DATE)
//	WHEN @dates::BIGINT = 4 THEN uv.created_at >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month') AND uv.created_at < DATE_TRUNC('month', CURRENT_DATE)
//	END)
//	--unit rank
//
// AND
//
//	(ARRAY_LENGTH(@rank::bigint [],1) IS NULL
//	    OR uv.unit_rank = ANY (@rank::bigint []))
//
// --FACTS STUFF--
// AND
//
//	(CASE WHEN @completion_status::bigint IS NULL THEN
//	    TRUE
//	WHEN @completion_status::bigint = 0 THEN
//	    TRUE
//	ELSE
//	    (u.facts->>'completion_status')::bigint = @completion_status::bigint
//	END)
//
// -- AND
// --     (u.facts->>'starting_price' >= @starting_price OR @disable_starting_price::BOOLEAN)
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@bedroom::VARCHAR[], 1) IS NULL THEN TRUE ELSE (u.facts->>'bedroom')::varchar = ANY(@bedroom::VARCHAR[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@bathroom::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'bathroom')::bigint = ANY(@bathroom::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@no_of_floor::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'no_of_floor')::bigint = ANY(@no_of_floor::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@no_of_payment::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'no_of_payment')::bigint = ANY(@no_of_payment::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@no_of_retail::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'no_of_retail')::bigint = ANY(@no_of_retail::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@no_of_pool::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'no_of_pool')::bigint = ANY(@no_of_pool::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@furnished::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'furnished')::bigint = ANY(@furnished::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@elevator::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'elevator')::bigint = ANY(@elevator::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@ownership::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'ownership')::bigint = ANY(@ownership::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@parking::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'parking')::bigint = ANY(@parking::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@views::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'views')::bigint[] && @views::bigint[] END)
//
// AND -- build up area
//
//	(CASE WHEN @min_built_up_area::float IS NULL THEN
//	    TRUE
//	WHEN @min_built_up_area::float = 0.0 THEN
//	    TRUE
//	ELSE
//	    (u.facts->>'built_up_area')::float >= @min_built_up_area::float
//	END
//	AND
//	CASE WHEN @max_built_up_area::float IS NULL THEN
//	    TRUE
//	WHEN @max_built_up_area::float = 0.0 THEN
//	    TRUE
//	ELSE
//	    (u.facts->>'built_up_area')::float <= @max_built_up_area::float
//	END)
//
// AND -- plot area
//
//	(CASE WHEN @min_plot_area::float IS NULL THEN
//	         TRUE
//	     WHEN @min_plot_area::float = 0.0 THEN
//	         TRUE
//	     ELSE
//	         (u.facts->>'plot_area')::float >= @min_plot_area::float
//	     END
//	     -- max plot area
//	     AND CASE WHEN @max_plot_area::float IS NULL THEN
//	         TRUE
//	     WHEN @max_plot_area::float = 0.0 THEN
//	         TRUE
//	     ELSE
//	         (u.facts->>'plot_area')::float <= @max_plot_area::float
//	     END)
//
// -- AND --price
//
//	-- ((u.facts->>'price')::bigint >= @min_price::bigint
//	-- -- max plot area
//	-- AND CASE
//	-- WHEN @max_price::bigint = 0 THEN
//	--     TRUE
//	-- ELSE
//	--     (u.facts->>'price')::bigint <= @max_price::bigint
//	-- END)
//
// --  amenities
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@amenities::bigint [],
//	        1) IS NULL THEN
//	        TRUE
//	    ELSE
//	        am.amenities && @amenities::bigint []
//	    END)
//	--  facilities
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@facilities::bigint [],
//	        1) IS NULL THEN
//	        TRUE
//	    ELSE
//	        f.facilities && @facilities::bigint []
//	    END)
//
// ORDER BY
//
//	   CASE
//	       WHEN @sort::bigint = 1 THEN uv.updated_at END DESC,
//	   CASE
//	       WHEN @sort::bigint = 4 THEN uv.unit_rank END ASC,
//	   CASE
//	       WHEN @sort::bigint = 2 THEN (u.facts->>'price')::bigint END ASC
//	LIMIT $1
//
// OFFSET $2;
// -- name: GetUnitsCountWithAdvancedSearch :one
// WITH facilities AS(
//
//	SELECT uv.id,
//	array_agg(DISTINCT coalesce(fae.facility_amenity_id,0))::bigint[] AS facilities
//	FROM unit_versions uv
//	JOIN units u on u.id=uv.unit_id
//	LEFT JOIN facilities_amenities_entity fae ON fae.entity_id=u.id AND fae.entity_type_id=5
//	LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=1
//	group by uv.id -- facilities
//
// ),
// amenities AS(
//
//	SELECT uv.id,
//	array_agg(DISTINCT coalesce(fae.facility_amenity_id,0))::bigint[] AS amenities
//	FROM unit_versions uv
//	JOIN units u on u.id=uv.unit_id
//	LEFT JOIN facilities_amenities_entity fae ON fae.entity_id=u.id AND fae.entity_type_id=5
//	LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id AND fa."type"=2
//	group by uv.id -- amenities
//
// )
// SELECT
// COUNT(uv.*)
// FROM unit_versions uv
// JOIN units u on u.id=uv.unit_id
// left JOIN addresses a on u.addresses_id=a.id
// LEFT JOIN cities ci ON a.cities_id = ci.id
// LEFT JOIN communities com ON a.communities_id = com.id
// LEFT JOIN sub_communities subcom ON a.sub_communities_id = subcom.id
// LEFT JOIN facilities f ON f.id=uv.id
// LEFT JOIN amenities am ON am.id=uv.id
// WHERE
//
//	(CASE WHEN @agent_id::bigint= 0 then true else uv.listed_by=  @agent_id::bigint end)
//
// AND
//
//	(@is_verified::bool IS NULL
//	    OR u.is_verified = @is_verified::bool)
//
// AND
//
//	(CASE WHEN  @country_id::bigint=0 THEN TRUE ELSE a.countries_id = @country_id::bigint end) --country
//
// AND
//
//	(CASE WHEN @company_id::bigint=0 THEN TRUE ELSE u.company_id= @company_id::bigint END)
//
// AND
//
//	-- 1=>Sale, 2=>Rent, 3=>Swap & 4=>Booking
//	uv."type" = @category::bigint
//
// AND
//
//	-- from unit type table
//	(CASE WHEN ARRAY_LENGTH(@unit_types::bigint[], 1) IS NULL THEN TRUE ELSE u.unit_type_id = ANY(@unit_types::bigint[]) END)
//
// AND
//
//		(case when @unit_no::varchar='' then true else  u.unit_no = @unit_no::varchar end )
//	   AND  u.unitno_is_public = TRUE  --unit no
//
// AND
//
//	(CASE WHEN @ref_no::varchar='' THEN TRUE ELSE uv.ref_no = @ref_no::varchar END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@keywords::VARCHAR[], 1) IS NULL --keywords
//	THEN TRUE ELSE
//	uv.title ILIKE ANY(@keywords::VARCHAR[])
//	OR uv.description ILIKE ANY(@keywords::VARCHAR[])
//	OR ci.city ILIKE ANY(@keywords::VARCHAR[])
//	OR com.community ILIKE ANY(@keywords::VARCHAR[])
//	OR subcom.sub_community ILIKE ANY(@keywords::VARCHAR[])
//	END)
//
// AND
//
//	    -- location
//	(CASE WHEN @city_id::bigint=0 THEN TRUE ELSE a.cities_id= @city_id::bigint END)
//	 AND
//	 (CASE WHEN @communities_id::bigint=0 THEN TRUE ELSE a.communities_id= @communities_id::bigint END)
//	 AND
//	 (CASE WHEN @sub_communities_id::bigint=0 THEN TRUE ELSE a.sub_communities_id= @sub_communities_id::bigint END)
//
// AND
//
//	    --created at
//	(CASE
//	WHEN @dates::BIGINT= 0 THEN true
//	WHEN COALESCE(@dates::BIGINT,1) =1 THEN true
//	WHEN @dates::BIGINT= 2 THEN uv.created_at >= DATE_TRUNC ('day', CURRENT_DATE)
//	WHEN @dates::BIGINT = 3 THEN uv.created_at >= DATE_TRUNC('week', CURRENT_DATE - INTERVAL '1 week')AND uv.created_at < DATE_TRUNC('week', CURRENT_DATE)
//	WHEN @dates::BIGINT = 4 THEN uv.created_at >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month') AND uv.created_at < DATE_TRUNC('month', CURRENT_DATE)
//	END)
//	--unit rank
//
// AND
//
//	(ARRAY_LENGTH(@rank::bigint [],1) IS NULL
//	    OR uv.unit_rank = ANY (@rank::bigint []))
//
// --FACTS STUFF--
// AND
//
//	(CASE WHEN @completion_status::bigint IS NULL THEN
//	    TRUE
//	WHEN @completion_status::bigint = 0 THEN
//	    TRUE
//	ELSE
//	    (u.facts->>'completion_status')::bigint = @completion_status::bigint
//	END)
//
// -- AND
// --     (u.facts->>'starting_price' >= @starting_price OR @disable_starting_price::BOOLEAN)
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@bedroom::VARCHAR[], 1) IS NULL THEN TRUE ELSE (u.facts->>'bedroom')::varchar = ANY(@bedroom::VARCHAR[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@bathroom::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'bathroom')::bigint = ANY(@bathroom::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@no_of_floor::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'no_of_floor')::bigint = ANY(@no_of_floor::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@no_of_payment::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'no_of_payment')::bigint = ANY(@no_of_payment::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@no_of_retail::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'no_of_retail')::bigint = ANY(@no_of_retail::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@no_of_pool::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'no_of_pool')::bigint = ANY(@no_of_pool::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@furnished::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'furnished')::bigint = ANY(@furnished::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@elevator::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'elevator')::bigint = ANY(@elevator::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@ownership::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'ownership')::bigint = ANY(@ownership::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@parking::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'parking')::bigint = ANY(@parking::bigint[]) END)
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@views::bigint[], 1) IS NULL THEN TRUE ELSE (u.facts->>'views')::bigint[] && @views::bigint[] END)
//
// AND -- build up area
//
//	(CASE WHEN @min_built_up_area::float IS NULL THEN
//	    TRUE
//	WHEN @min_built_up_area::float = 0.0 THEN
//	    TRUE
//	ELSE
//	    (u.facts->>'built_up_area')::float >= @min_built_up_area::float
//	END
//	AND
//	CASE WHEN @max_built_up_area::float IS NULL THEN
//	    TRUE
//	WHEN @max_built_up_area::float = 0.0 THEN
//	    TRUE
//	ELSE
//	    (u.facts->>'built_up_area')::float <= @max_built_up_area::float
//	END)
//
// AND -- plot area
//
//	(CASE WHEN @min_plot_area::float IS NULL THEN
//	         TRUE
//	     WHEN @min_plot_area::float = 0.0 THEN
//	         TRUE
//	     ELSE
//	         (u.facts->>'plot_area')::float >= @min_plot_area::float
//	     END
//	     -- max plot area
//	     AND CASE WHEN @max_plot_area::float IS NULL THEN
//	         TRUE
//	     WHEN @max_plot_area::float = 0.0 THEN
//	         TRUE
//	     ELSE
//	         (u.facts->>'plot_area')::float <= @max_plot_area::float
//	     END)
//
// -- AND --price
//
//	-- ((u.facts->>'price')::bigint >= @min_price::bigint
//	-- -- max plot area
//	-- AND CASE
//	-- WHEN @max_price::bigint = 0 THEN
//	--     TRUE
//	-- ELSE
//	--     (u.facts->>'price')::bigint <= @max_price::bigint
//	-- END)
//
// --  amenities
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@amenities::bigint [],
//	        1) IS NULL THEN
//	        TRUE
//	    ELSE
//	        am.amenities && @amenities::bigint []
//	    END)
//	--  facilities
//
// AND
//
//	(CASE WHEN ARRAY_LENGTH(@facilities::bigint [],
//	        1) IS NULL THEN
//	        TRUE
//	    ELSE
//	        f.facilities && @facilities::bigint []
//	    END);
func (q *Queries) GetUnit(ctx context.Context, id int64) (GetUnitRow, error) {
	row := q.db.QueryRow(ctx, getUnit, id)
	var i GetUnitRow
	err := row.Scan(
		&i.UnitVersion.ID,
		&i.UnitVersion.Title,
		&i.UnitVersion.ViewsCount,
		&i.UnitVersion.TitleArabic,
		&i.UnitVersion.Description,
		&i.UnitVersion.DescriptionArabic,
		&i.UnitVersion.UnitID,
		&i.UnitVersion.RefNo,
		&i.UnitVersion.Status,
		&i.UnitVersion.Type,
		&i.UnitVersion.UnitRank,
		&i.UnitVersion.CreatedAt,
		&i.UnitVersion.UpdatedAt,
		&i.UnitVersion.CreatedBy,
		&i.UnitVersion.UpdatedBy,
		&i.UnitVersion.Facts,
		&i.UnitVersion.ListedBy,
		&i.UnitVersion.HasGallery,
		&i.UnitVersion.HasPlans,
		&i.UnitVersion.IsMain,
		&i.UnitVersion.IsVerified,
		&i.UnitVersion.Exclusive,
		&i.UnitVersion.StartDate,
		&i.UnitVersion.EndDate,
		&i.UnitVersion.Slug,
		&i.UnitVersion.IsHotdeal,
		&i.UnitVersion.RefreshedAt,
		&i.Unit.ID,
		&i.Unit.UnitNo,
		&i.Unit.UnitnoIsPublic,
		&i.Unit.Notes,
		&i.Unit.UnitTitle,
		&i.Unit.Description,
		&i.Unit.DescriptionArabic,
		&i.Unit.UnitTitleArabic,
		&i.Unit.NotesArabic,
		&i.Unit.NotesPublic,
		&i.Unit.IsVerified,
		&i.Unit.EntityTypeID,
		&i.Unit.EntityID,
		&i.Unit.CreatedAt,
		&i.Unit.UpdatedAt,
		&i.Unit.AddressesID,
		&i.Unit.UnitTypeID,
		&i.Unit.CreatedBy,
		&i.Unit.UpdatedBy,
		&i.Unit.TypeNameID,
		&i.Unit.OwnerUsersID,
		&i.Unit.FromXml,
		&i.Unit.CompanyID,
		&i.Unit.Status,
		&i.Unit.Facts,
		&i.Unit.IsProjectUnit,
		&i.Unit.Exclusive,
		&i.Unit.StartDate,
		&i.Unit.EndDate,
		&i.Facilities,
		&i.Amenities,
		&i.Reviews,
	)
	return i, err
}

const getUnitTypeByID = `-- name: GetUnitTypeByID :one
SELECT id, type, code, facts, listing_facts, usage, created_at, updated_at, status, icon, type_ar FROM unit_type 
WHERE id=$1 AND status!=6
`

func (q *Queries) GetUnitTypeByID(ctx context.Context, id int64) (UnitType, error) {
	row := q.db.QueryRow(ctx, getUnitTypeByID, id)
	var i UnitType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.Facts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.TypeAr,
	)
	return i, err
}
