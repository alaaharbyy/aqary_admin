// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: global_plan.sql

package sqlc

import (
	"context"
	"time"
)

const createGlobalPlan = `-- name: CreateGlobalPlan :one
INSERT INTO plans(
	entity_type_id, 
	entity_id, 
	title, 
	file_urls, 
	created_at, 
	updated_at, 
	uploaded_by, 
	updated_by
)VALUES (
	$1, 
	$2, 
	$3, 
	$4, 
	$5, 
	$6, 
	$7, 
	$8)RETURNING id, entity_type_id, entity_id, title, file_urls, created_at, updated_at, uploaded_by, updated_by
`

type CreateGlobalPlanParams struct {
	EntityTypeID int64     `json:"entity_type_id"`
	EntityID     int64     `json:"entity_id"`
	Title        string    `json:"title"`
	FileUrls     []string  `json:"file_urls"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	UploadedBy   int64     `json:"uploaded_by"`
	UpdatedBy    int64     `json:"updated_by"`
}

func (q *Queries) CreateGlobalPlan(ctx context.Context, arg CreateGlobalPlanParams) (Plan, error) {
	row := q.db.QueryRow(ctx, createGlobalPlan,
		arg.EntityTypeID,
		arg.EntityID,
		arg.Title,
		arg.FileUrls,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UploadedBy,
		arg.UpdatedBy,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Title,
		&i.FileUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UploadedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteEntityGlobalPlan = `-- name: DeleteEntityGlobalPlan :exec
DELETE FROM plans WHERE id=$1
`

func (q *Queries) DeleteEntityGlobalPlan(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteEntityGlobalPlan, id)
	return err
}

const deleteEntityGlobalPlanByPlanId = `-- name: DeleteEntityGlobalPlanByPlanId :one
DELETE FROM plans WHERE plans.id =$1 AND 
COALESCE((SELECT CASE  plans.entity_type_id::BIGINT
               WHEN 1 THEN (SELECT projects.status::BIGINT FROM projects WHERE projects.id = plans.entity_id)
               WHEN 2 THEN (SELECT phases.status::BIGINT FROM phases WHERE phases.id = plans.entity_id)
               WHEN 3 THEN (SELECT property.status::BIGINT FROM property WHERE property.id = plans.entity_id)
               --WHEN 4 THEN (SELECT exhibitions.event_status::BIGINT FROM exhibitions WHERE exhibitions.id = plans.entity_id)
               WHEN 5 THEN (SELECT units.status::BIGINT FROM units WHERE units.id = plans.entity_id)
               WHEN 6 THEN (SELECT companies.status::BIGINT FROM companies WHERE companies.id = plans.entity_id)
               WHEN 7 THEN (SELECT 1 FROM profiles WHERE profiles.id = plans.entity_id)
               --WHEN 8 THEN (SELECT freelancers.status::BIGINT FROM freelancers WHERE freelancers.id = plans.entity_id)
               WHEN 9 THEN (SELECT users.status::BIGINT FROM users WHERE users.id = plans.entity_id)
               --WHEN 10 THEN (SELECT holiday_home.status::BIGINT FROM holiday_home WHERE holiday_home.id = plans.entity_id)
               --WHEN 16 THEN (SELECT 1 FROM publish_listing WHERE publish_listing.id = plans.entity_id::BIGINT)
                WHEN 18 THEN (SELECT 1 FROM company_profiles WHERE company_profiles.id = plans.entity_id)
               WHEN 19 THEN (SELECT 1 FROM company_profiles_projects WHERE company_profiles_projects.id = plans.entity_id)
               WHEN 20 THEN (SELECT 1 FROM company_profiles_phases WHERE company_profiles_phases.id = plans.entity_id)

               ELSE 0::BIGINT
           END),6::BIGINT) NOT IN (0,6)
RETURNING plans.file_urls
`

func (q *Queries) DeleteEntityGlobalPlanByPlanId(ctx context.Context, id int64) ([]string, error) {
	row := q.db.QueryRow(ctx, deleteEntityGlobalPlanByPlanId, id)
	var file_urls []string
	err := row.Scan(&file_urls)
	return file_urls, err
}

const deleteEntityGlobalPlanByURL = `-- name: DeleteEntityGlobalPlanByURL :one
UPDATE plans 
SET 
	file_urls = array_remove(file_urls, $2::VARCHAR),
	updated_at=$1 
WHERE 
	plans.id= $3 AND $2::VARCHAR = ANY(file_urls) AND 
	COALESCE((SELECT CASE  plans.entity_type_id::BIGINT
               WHEN 1 THEN (SELECT projects.status::BIGINT FROM projects WHERE projects.id = plans.entity_id)
               WHEN 2 THEN (SELECT phases.status::BIGINT FROM phases WHERE phases.id = plans.entity_id)
               WHEN 3 THEN (SELECT property.status::BIGINT FROM property WHERE property.id = plans.entity_id)
               --WHEN 4 THEN (SELECT exhibitions.event_status::BIGINT FROM exhibitions WHERE exhibitions.id = plans.entity_id)
               WHEN 5 THEN (SELECT units.status::BIGINT FROM units WHERE units.id = plans.entity_id)
               WHEN 6 THEN (SELECT companies.status::BIGINT FROM companies WHERE companies.id = plans.entity_id)
               WHEN 7 THEN (SELECT 1 FROM profiles WHERE profiles.id = plans.entity_id)
               --WHEN 8 THEN (SELECT freelancers.status::BIGINT FROM freelancers WHERE freelancers.id = plans.entity_id)
               WHEN 9 THEN (SELECT users.status::BIGINT FROM users WHERE users.id = plans.entity_id)
               --WHEN 10 THEN (SELECT holiday_home.status::BIGINT FROM holiday_home WHERE holiday_home.id = plans.entity_id)
               --WHEN 16 THEN (SELECT 1 FROM publish_listing WHERE publish_listing.id = plans.entity_id::BIGINT)
                WHEN 18 THEN (SELECT 1 FROM company_profiles WHERE company_profiles.id = $4::BIGINT)
               WHEN 19 THEN (SELECT 1 FROM company_profiles_projects WHERE company_profiles_projects.id = $4::BIGINT)
               WHEN 20 THEN (SELECT 1 FROM company_profiles_phases WHERE company_profiles_phases.id = $4::BIGINT)

               ELSE 0::BIGINT
           END),6::BIGINT) NOT IN (0,6)
RETURNING id, entity_type_id, entity_id, title, file_urls, created_at, updated_at, uploaded_by, updated_by
`

type DeleteEntityGlobalPlanByURLParams struct {
	UpdatedAt time.Time `json:"updated_at"`
	FileUrl   string    `json:"file_url"`
	PlanID    int64     `json:"plan_id"`
	EntityID  int64     `json:"entity_id"`
}

func (q *Queries) DeleteEntityGlobalPlanByURL(ctx context.Context, arg DeleteEntityGlobalPlanByURLParams) (Plan, error) {
	row := q.db.QueryRow(ctx, deleteEntityGlobalPlanByURL,
		arg.UpdatedAt,
		arg.FileUrl,
		arg.PlanID,
		arg.EntityID,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Title,
		&i.FileUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UploadedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteXMLGlobalPlan = `-- name: DeleteXMLGlobalPlan :exec
DELETE FROM plans
WHERE entity_type_id = $1
  AND entity_id = ANY($2::bigint[])
`

type DeleteXMLGlobalPlanParams struct {
	EntityTypeID int64   `json:"entity_type_id"`
	EntityIds    []int64 `json:"entity_ids"`
}

func (q *Queries) DeleteXMLGlobalPlan(ctx context.Context, arg DeleteXMLGlobalPlanParams) error {
	_, err := q.db.Exec(ctx, deleteXMLGlobalPlan, arg.EntityTypeID, arg.EntityIds)
	return err
}

const getEntityIdGlobalPlan = `-- name: GetEntityIdGlobalPlan :many
SELECT plans.id AS "global_plan_id",plans.title,plans.entity_id AS "entity_id" , plans.entity_type_id AS "entity_type_id" ,plans.created_at,plans.updated_at,plans.file_urls,plans.uploaded_by,plans.updated_by
FROM 
	plans
WHERE 
	plans.entity_id= $3::BIGINT AND plans.entity_type_id= $4::BIGINT AND
	COALESCE((SELECT CASE  $4::BIGINT
               WHEN 1 THEN (SELECT projects.status::BIGINT FROM projects WHERE projects.id = $3::BIGINT)
               WHEN 2 THEN (SELECT phases.status::BIGINT FROM phases WHERE phases.id = $3::BIGINT)
               WHEN 3 THEN (SELECT property.status::BIGINT FROM property WHERE property.id = $3::BIGINT)
               --WHEN 4 THEN (SELECT exhibitions.event_status::BIGINT FROM exhibitions WHERE exhibitions.id = @entity_id::BIGINT)
               WHEN 5 THEN (SELECT units.status::BIGINT FROM units WHERE units.id = $3::BIGINT)
               WHEN 6 THEN (SELECT companies.status::BIGINT FROM companies WHERE companies.id = $3::BIGINT)
               WHEN 7 THEN (SELECT 1 FROM profiles WHERE profiles.id = $3::BIGINT)
               --WHEN 8 THEN (SELECT freelancers.status::BIGINT FROM freelancers WHERE freelancers.id = @entity_id::BIGINT)
               WHEN 9 THEN (SELECT users.status::BIGINT FROM users WHERE users.id = $3::BIGINT)
               --WHEN 10 THEN (SELECT holiday_home.status::BIGINT FROM holiday_home WHERE holiday_home.id = @entity_id::BIGINT)
               --WHEN 16 THEN (SELECT 1 FROM publish_listing WHERE publish_listing.id = @entity_id::BIGINT)
                WHEN 18 THEN (SELECT 1 FROM company_profiles WHERE company_profiles.id = $3::BIGINT)
               WHEN 19 THEN (SELECT 1 FROM company_profiles_projects WHERE company_profiles_projects.id = $3::BIGINT)
               WHEN 20 THEN (SELECT 1 FROM company_profiles_phases WHERE company_profiles_phases.id = $3::BIGINT)
               
               ELSE 0::BIGINT
           END),6::BIGINT) NOT IN(0,6)
ORDER BY 
	plans.updated_at DESC
LIMIT $1 
OFFSET $2
`

type GetEntityIdGlobalPlanParams struct {
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	EntityID   int64 `json:"entity_id"`
	EntityType int64 `json:"entity_type"`
}

type GetEntityIdGlobalPlanRow struct {
	GlobalPlanID int64     `json:"global_plan_id"`
	Title        string    `json:"title"`
	EntityID     int64     `json:"entity_id"`
	EntityTypeID int64     `json:"entity_type_id"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	FileUrls     []string  `json:"file_urls"`
	UploadedBy   int64     `json:"uploaded_by"`
	UpdatedBy    int64     `json:"updated_by"`
}

func (q *Queries) GetEntityIdGlobalPlan(ctx context.Context, arg GetEntityIdGlobalPlanParams) ([]GetEntityIdGlobalPlanRow, error) {
	rows, err := q.db.Query(ctx, getEntityIdGlobalPlan,
		arg.Limit,
		arg.Offset,
		arg.EntityID,
		arg.EntityType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntityIdGlobalPlanRow
	for rows.Next() {
		var i GetEntityIdGlobalPlanRow
		if err := rows.Scan(
			&i.GlobalPlanID,
			&i.Title,
			&i.EntityID,
			&i.EntityTypeID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FileUrls,
			&i.UploadedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalPlan = `-- name: GetGlobalPlan :one
WITH status_calculation AS (
    SELECT CASE  $2::BIGINT
               WHEN 1 THEN (SELECT projects.status::BIGINT FROM projects WHERE projects.id = $3::BIGINT)
               WHEN 2 THEN (SELECT phases.status::BIGINT FROM phases WHERE phases.id = $3::BIGINT)
               WHEN 3 THEN (SELECT property.status::BIGINT FROM property WHERE property.id = $3::BIGINT)
               --WHEN 4 THEN (SELECT exhibitions.event_status::BIGINT FROM exhibitions WHERE exhibitions.id = @entity_id::BIGINT)
               WHEN 5 THEN (SELECT units.status::BIGINT FROM units WHERE units.id = $3::BIGINT)
               WHEN 6 THEN (SELECT companies.status::BIGINT FROM companies WHERE companies.id = $3::BIGINT)
               WHEN 7 THEN (SELECT 1 FROM profiles WHERE profiles.id = $3::BIGINT)
               --WHEN 8 THEN (SELECT freelancers.status::BIGINT FROM freelancers WHERE freelancers.id = @entity_id::BIGINT)
               WHEN 9 THEN (SELECT users.status::BIGINT FROM users WHERE users.id = $3::BIGINT)
               --WHEN 10 THEN (SELECT holiday_home.status::BIGINT FROM holiday_home WHERE holiday_home.id = @entity_id::BIGINT)
               --WHEN 16 THEN (SELECT 1 FROM publish_listing WHERE publish_listing.id = @entity_id::BIGINT)
                WHEN 18 THEN (SELECT 1 FROM company_profiles WHERE company_profiles.id = $3::BIGINT)
               WHEN 19 THEN (SELECT 1 FROM company_profiles_projects WHERE company_profiles_projects.id = $3::BIGINT)
               WHEN 20 THEN (SELECT 1 FROM company_profiles_phases WHERE company_profiles_phases.id = $3::BIGINT)

               ELSE 0::BIGINT
           END AS status
)
SELECT 
    COALESCE(plans.id, 0) AS "plan_id",
    COALESCE(plans.file_urls, ARRAY[]::VARCHAR[]) AS "file_urls",
    COALESCE(plans.entity_id, 0) AS "entity_id",
    COALESCE(status_calculation.status,-1::BIGINT) AS "status"
FROM 
    status_calculation 
LEFT JOIN 
    plans ON 
        plans.entity_type_id =  $2::BIGINT 
        AND plans.entity_id = $3::BIGINT 
        AND plans.title = $1
        AND status_calculation.status NOT IN (-1,0,6)
`

type GetGlobalPlanParams struct {
	Title      string `json:"title"`
	EntityType int64  `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
}

type GetGlobalPlanRow struct {
	PlanID   int64    `json:"plan_id"`
	FileUrls []string `json:"file_urls"`
	EntityID int64    `json:"entity_id"`
	Status   int64    `json:"status"`
}

func (q *Queries) GetGlobalPlan(ctx context.Context, arg GetGlobalPlanParams) (GetGlobalPlanRow, error) {
	row := q.db.QueryRow(ctx, getGlobalPlan, arg.Title, arg.EntityType, arg.EntityID)
	var i GetGlobalPlanRow
	err := row.Scan(
		&i.PlanID,
		&i.FileUrls,
		&i.EntityID,
		&i.Status,
	)
	return i, err
}

const getNumberOfEntityIdGlobalPlan = `-- name: GetNumberOfEntityIdGlobalPlan :one
SELECT COUNT(*) 
FROM 
	plans 
WHERE 
	entity_id= $1::BIGINT AND entity_type_id= $2::BIGINT
`

type GetNumberOfEntityIdGlobalPlanParams struct {
	EntityID   int64 `json:"entity_id"`
	EntityType int64 `json:"entity_type"`
}

func (q *Queries) GetNumberOfEntityIdGlobalPlan(ctx context.Context, arg GetNumberOfEntityIdGlobalPlanParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOfEntityIdGlobalPlan, arg.EntityID, arg.EntityType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateGlobalPlan = `-- name: UpdateGlobalPlan :one
UPDATE plans
SET 
	file_urls=$1, 
	updated_at=$2, 
	updated_by=$3
WHERE 
	entity_type_id=$4 AND entity_id=$5 AND title=$6
RETURNING id, entity_type_id, entity_id, title, file_urls, created_at, updated_at, uploaded_by, updated_by
`

type UpdateGlobalPlanParams struct {
	FileUrls     []string  `json:"file_urls"`
	UpdatedAt    time.Time `json:"updated_at"`
	UpdatedBy    int64     `json:"updated_by"`
	EntityTypeID int64     `json:"entity_type_id"`
	EntityID     int64     `json:"entity_id"`
	Title        string    `json:"title"`
}

func (q *Queries) UpdateGlobalPlan(ctx context.Context, arg UpdateGlobalPlanParams) (Plan, error) {
	row := q.db.QueryRow(ctx, updateGlobalPlan,
		arg.FileUrls,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.EntityTypeID,
		arg.EntityID,
		arg.Title,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Title,
		&i.FileUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UploadedBy,
		&i.UpdatedBy,
	)
	return i, err
}
