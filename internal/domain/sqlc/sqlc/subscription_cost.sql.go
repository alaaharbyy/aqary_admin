// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription_cost.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeStatusSubscriptionCost = `-- name: ChangeStatusSubscriptionCost :exec
UPDATE 
    subscription_cost
SET 
    status=$1,
    updated_at=$2
WHERE id=$3
`

type ChangeStatusSubscriptionCostParams struct {
	Status    int64     `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) ChangeStatusSubscriptionCost(ctx context.Context, arg ChangeStatusSubscriptionCostParams) error {
	_, err := q.db.Exec(ctx, changeStatusSubscriptionCost, arg.Status, arg.UpdatedAt, arg.ID)
	return err
}

const createSubscriptionCost = `-- name: CreateSubscriptionCost :exec
INSERT
    INTO subscription_cost(
        countries_id,
        subscriber_type_id,
        category_id,
        product,
        price_per_unit,
        created_by,
        created_at,
        updated_at,
        status
    )
VALUES(
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    )
`

type CreateSubscriptionCostParams struct {
	CountriesID      int64       `json:"countries_id"`
	SubscriberTypeID int64       `json:"subscriber_type_id"`
	CategoryID       pgtype.Int8 `json:"category_id"`
	Product          int64       `json:"product"`
	PricePerUnit     float64     `json:"price_per_unit"`
	CreatedBy        int64       `json:"created_by"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Status           int64       `json:"status"`
}

func (q *Queries) CreateSubscriptionCost(ctx context.Context, arg CreateSubscriptionCostParams) error {
	_, err := q.db.Exec(ctx, createSubscriptionCost,
		arg.CountriesID,
		arg.SubscriberTypeID,
		arg.CategoryID,
		arg.Product,
		arg.PricePerUnit,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
	)
	return err
}

const getAllSubscriptionCost = `-- name: GetAllSubscriptionCost :many
SELECT
    subscription_cost.id, subscription_cost.countries_id, subscription_cost.subscriber_type_id, subscription_cost.category_id, subscription_cost.product, subscription_cost.price_per_unit, subscription_cost.created_by, subscription_cost.created_at, subscription_cost.updated_at, subscription_cost.status,
    company_category.category_name,
    company_category.category_name_ar,
    subscription_products.product AS product_name,
    countries.country, 
    CASE
        subscription_cost.subscriber_type_id
        WHEN 1 THEN 'company'
        WHEN 2 THEN 'freelance'
        WHEN 3 THEN 'owner'
    END::VARCHAR AS  subscriber_type
FROM
    subscription_cost
    LEFT JOIN company_category ON company_category.id = subscription_cost.category_id
    AND company_category.status != 6
    INNER JOIN subscription_products ON subscription_products.id = subscription_cost.product
    AND subscription_products.status != 6
    INNER JOIN countries ON countries.id=subscription_cost.countries_id
WHERE
    subscription_cost.status = $1::BIGINT
ORDER BY subscription_cost.updated_at DESC
LIMIT $3
OFFSET $2
`

type GetAllSubscriptionCostParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllSubscriptionCostRow struct {
	ID               int64       `json:"id"`
	CountriesID      int64       `json:"countries_id"`
	SubscriberTypeID int64       `json:"subscriber_type_id"`
	CategoryID       pgtype.Int8 `json:"category_id"`
	Product          int64       `json:"product"`
	PricePerUnit     float64     `json:"price_per_unit"`
	CreatedBy        int64       `json:"created_by"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Status           int64       `json:"status"`
	CategoryName     pgtype.Text `json:"category_name"`
	CategoryNameAr   pgtype.Text `json:"category_name_ar"`
	ProductName      string      `json:"product_name"`
	Country          string      `json:"country"`
	SubscriberType   string      `json:"subscriber_type"`
}

func (q *Queries) GetAllSubscriptionCost(ctx context.Context, arg GetAllSubscriptionCostParams) ([]GetAllSubscriptionCostRow, error) {
	rows, err := q.db.Query(ctx, getAllSubscriptionCost, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriptionCostRow
	for rows.Next() {
		var i GetAllSubscriptionCostRow
		if err := rows.Scan(
			&i.ID,
			&i.CountriesID,
			&i.SubscriberTypeID,
			&i.CategoryID,
			&i.Product,
			&i.PricePerUnit,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.CategoryName,
			&i.CategoryNameAr,
			&i.ProductName,
			&i.Country,
			&i.SubscriberType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubscriptionCostCount = `-- name: GetAllSubscriptionCostCount :one
SELECT
    count(subscription_cost.id)
FROM
    subscription_cost
    INNER JOIN subscription_products ON subscription_products.id = subscription_cost.product
    AND subscription_products.status != 6
    INNER JOIN countries ON countries.id=subscription_cost.countries_id
WHERE
    subscription_cost.status = $1::BIGINT
`

func (q *Queries) GetAllSubscriptionCostCount(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAllSubscriptionCostCount, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSubscriptionCost = `-- name: GetSubscriptionCost :one
SELECT
    subscription_cost.id, subscription_cost.countries_id, subscription_cost.subscriber_type_id, subscription_cost.category_id, subscription_cost.product, subscription_cost.price_per_unit, subscription_cost.created_by, subscription_cost.created_at, subscription_cost.updated_at, subscription_cost.status,
    company_category.category_name,
    company_category.category_name_ar,
    subscription_products.product,
    CASE
        subscription_cost.subscriber_type_id
        WHEN 1 THEN 'company'
        WHEN 2 THEN 'freelance'
        WHEN 3 THEN 'owner'
    END
FROM
    subscription_cost
    LEFT JOIN company_category ON company_category.id = subscription_cost.category_id
    AND company_category.status != 6
    INNER JOIN subscription_products ON subscription_products.id = subscription_cost.product
    AND subscription_products.status != 6
WHERE
    subscription_cost.id = $1
    AND subscription_cost.status != 6
`

type GetSubscriptionCostRow struct {
	ID               int64       `json:"id"`
	CountriesID      int64       `json:"countries_id"`
	SubscriberTypeID int64       `json:"subscriber_type_id"`
	CategoryID       pgtype.Int8 `json:"category_id"`
	Product          int64       `json:"product"`
	PricePerUnit     float64     `json:"price_per_unit"`
	CreatedBy        int64       `json:"created_by"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Status           int64       `json:"status"`
	CategoryName     pgtype.Text `json:"category_name"`
	CategoryNameAr   pgtype.Text `json:"category_name_ar"`
	Product_2        string      `json:"product_2"`
	Column14         interface{} `json:"column_14"`
}

func (q *Queries) GetSubscriptionCost(ctx context.Context, id int64) (GetSubscriptionCostRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionCost, id)
	var i GetSubscriptionCostRow
	err := row.Scan(
		&i.ID,
		&i.CountriesID,
		&i.SubscriberTypeID,
		&i.CategoryID,
		&i.Product,
		&i.PricePerUnit,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CategoryName,
		&i.CategoryNameAr,
		&i.Product_2,
		&i.Column14,
	)
	return i, err
}

const updateSubscriptionCost = `-- name: UpdateSubscriptionCost :exec
UPDATE 
    subscription_cost
SET 
    countries_id=$2, 
    subscriber_type_id=$3, 
    category_id=$4, 
    product=$5, 
    price_per_unit=$6, 
    updated_at=$7
WHERE id=$1 AND status!=6
`

type UpdateSubscriptionCostParams struct {
	ID               int64       `json:"id"`
	CountriesID      int64       `json:"countries_id"`
	SubscriberTypeID int64       `json:"subscriber_type_id"`
	CategoryID       pgtype.Int8 `json:"category_id"`
	Product          int64       `json:"product"`
	PricePerUnit     float64     `json:"price_per_unit"`
	UpdatedAt        time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateSubscriptionCost(ctx context.Context, arg UpdateSubscriptionCostParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionCost,
		arg.ID,
		arg.CountriesID,
		arg.SubscriberTypeID,
		arg.CategoryID,
		arg.Product,
		arg.PricePerUnit,
		arg.UpdatedAt,
	)
	return err
}
