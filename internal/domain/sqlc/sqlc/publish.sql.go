// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: publish.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPublish = `-- name: CreatePublish :one
INSERT INTO publish_listing (
  entity_type_id,
  entity_id,
  share_id,
  is_internal,
  title,
  description,
  created_at,
  updated_at,
  created_by,
  webportal_id,
  is_enabled
 )VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
 ) RETURNING id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id
`

type CreatePublishParams struct {
	EntityTypeID int64       `json:"entity_type_id"`
	EntityID     int64       `json:"entity_id"`
	ShareID      pgtype.Int4 `json:"share_id"`
	IsInternal   pgtype.Bool `json:"is_internal"`
	Title        string      `json:"title"`
	Description  string      `json:"description"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	CreatedBy    int64       `json:"created_by"`
	WebportalID  int64       `json:"webportal_id"`
	IsEnabled    pgtype.Bool `json:"is_enabled"`
}

func (q *Queries) CreatePublish(ctx context.Context, arg CreatePublishParams) (PublishListing, error) {
	row := q.db.QueryRow(ctx, createPublish,
		arg.EntityTypeID,
		arg.EntityID,
		arg.ShareID,
		arg.IsInternal,
		arg.Title,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.WebportalID,
		arg.IsEnabled,
	)
	var i PublishListing
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.IsInternal,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.WebportalID,
		&i.IsEnabled,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}

const createPublishGallery = `-- name: CreatePublishGallery :one
INSERT INTO publish_gallery (
 publish_listing_id,
 image_url,  
 image360_url,  
 video_url,  
 panaroma_url, 
 main_media_section,
 created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at
`

type CreatePublishGalleryParams struct {
	PublishListingID pgtype.Int8 `json:"publish_listing_id"`
	ImageUrl         []string    `json:"image_url"`
	Image360Url      []string    `json:"image360_url"`
	VideoUrl         []string    `json:"video_url"`
	PanaromaUrl      []string    `json:"panaroma_url"`
	MainMediaSection string      `json:"main_media_section"`
	CreatedAt        time.Time   `json:"created_at"`
}

func (q *Queries) CreatePublishGallery(ctx context.Context, arg CreatePublishGalleryParams) (PublishGallery, error) {
	row := q.db.QueryRow(ctx, createPublishGallery,
		arg.PublishListingID,
		arg.ImageUrl,
		arg.Image360Url,
		arg.VideoUrl,
		arg.PanaromaUrl,
		arg.MainMediaSection,
		arg.CreatedAt,
	)
	var i PublishGallery
	err := row.Scan(
		&i.ID,
		&i.PublishListingID,
		&i.ImageUrl,
		&i.Image360Url,
		&i.VideoUrl,
		&i.PanaromaUrl,
		&i.MainMediaSection,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createPublishPlan = `-- name: CreatePublishPlan :one
INSERT INTO publish_plan (
 publish_listing_id,
 title,
 plan_url,
 created_at
) VALUES (
  $1, $2, $3, $4
) RETURNING id, publish_listing_id, title, plan_url, updated_at, created_at
`

type CreatePublishPlanParams struct {
	PublishListingID int64     `json:"publish_listing_id"`
	Title            string    `json:"title"`
	PlanUrl          []string  `json:"plan_url"`
	CreatedAt        time.Time `json:"created_at"`
}

func (q *Queries) CreatePublishPlan(ctx context.Context, arg CreatePublishPlanParams) (PublishPlan, error) {
	row := q.db.QueryRow(ctx, createPublishPlan,
		arg.PublishListingID,
		arg.Title,
		arg.PlanUrl,
		arg.CreatedAt,
	)
	var i PublishPlan
	err := row.Scan(
		&i.ID,
		&i.PublishListingID,
		&i.Title,
		&i.PlanUrl,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deletePublishByID = `-- name: DeletePublishByID :exec
DELETE FROM publish_listing 
WHERE id = $1
`

func (q *Queries) DeletePublishByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePublishByID, id)
	return err
}

const deletePublishGalleryByID = `-- name: DeletePublishGalleryByID :exec
DELETE FROM publish_gallery WHERE id = $1
`

func (q *Queries) DeletePublishGalleryByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePublishGalleryByID, id)
	return err
}

const getProjectPhasesPublishedCount = `-- name: GetProjectPhasesPublishedCount :one
SELECT 
	COUNT(pl)
FROM publish_listing AS pl
JOIN 
phases ON 
pl.entity_type_id= $1::BIGINT AND 
phases.id = pl.entity_id::BIGINT
WHERE
	phases.status!=6
AND 
	pl.created_by= $2::BIGINT
`

type GetProjectPhasesPublishedCountParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	PublishedBy  int64 `json:"published_by"`
}

func (q *Queries) GetProjectPhasesPublishedCount(ctx context.Context, arg GetProjectPhasesPublishedCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectPhasesPublishedCount, arg.EntityTypeID, arg.PublishedBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectPhasesPublishedListing = `-- name: GetProjectPhasesPublishedListing :many
SELECT 
  phases.id as phase_id,
	phases.phase_name,
	phases.ref_no,
	pl.id as publish_listing_id,
	projects.project_name,
	comp.company_name
FROM publish_listing AS pl 
JOIN 
phases ON 
pl.entity_type_id= $3::BIGINT AND 
phases.id = pl.entity_id::BIGINT
JOIN projects ON phases.projects_id = projects.id
LEFT JOIN companies comp ON comp.id=projects.developer_companies_id 
WHERE
	phases.status!=6
AND 
	($4 = '%%'
      OR phases.ref_no ILIKE $4
      OR phases.phase_name ILIKE $4
      OR projects.project_name ILIKE $4
      OR comp.company_name ILIKE $4
     )
AND 
	pl.created_by= $5::BIGINT
LIMIT $1
OFFSET $2
`

type GetProjectPhasesPublishedListingParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	EntityTypeID int64       `json:"entity_type_id"`
	Search       interface{} `json:"search"`
	PublishedBy  int64       `json:"published_by"`
}

type GetProjectPhasesPublishedListingRow struct {
	PhaseID          int64       `json:"phase_id"`
	PhaseName        string      `json:"phase_name"`
	RefNo            string      `json:"ref_no"`
	PublishListingID int64       `json:"publish_listing_id"`
	ProjectName      string      `json:"project_name"`
	CompanyName      pgtype.Text `json:"company_name"`
}

func (q *Queries) GetProjectPhasesPublishedListing(ctx context.Context, arg GetProjectPhasesPublishedListingParams) ([]GetProjectPhasesPublishedListingRow, error) {
	rows, err := q.db.Query(ctx, getProjectPhasesPublishedListing,
		arg.Limit,
		arg.Offset,
		arg.EntityTypeID,
		arg.Search,
		arg.PublishedBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectPhasesPublishedListingRow
	for rows.Next() {
		var i GetProjectPhasesPublishedListingRow
		if err := rows.Scan(
			&i.PhaseID,
			&i.PhaseName,
			&i.RefNo,
			&i.PublishListingID,
			&i.ProjectName,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectPropertiesPublishedCount = `-- name: GetProjectPropertiesPublishedCount :one
SELECT 
	count(pl)
FROM publish_listing  AS pl
JOIN property_versions ON pl.entity_type_id::BIGINT= $1 AND property_versions.id = pl.entity_id::BIGINT
JOIN property ON property.id = property_versions.property_id
left JOIN phases ON property.entity_id=phases.id AND property.entity_type_id= $2  
JOIN projects ON (property.entity_id=projects.id AND property.entity_type_id= $3 AND projects.is_multiphase=FALSE) OR (projects.id=phases.projects_id and projects.is_multiphase=true)
WHERE
	property_versions.status!=6 AND property.status!=6 AND projects.status!=6 AND phases.status!=6
AND 
	pl.created_by= $4::BIGINT
`

type GetProjectPropertiesPublishedCountParams struct {
	PropertyvEntityType int64 `json:"propertyv_entity_type"`
	PhasesEntityType    int64 `json:"phases_entity_type"`
	ProjectEntityType   int64 `json:"project_entity_type"`
	PublishedBy         int64 `json:"published_by"`
}

func (q *Queries) GetProjectPropertiesPublishedCount(ctx context.Context, arg GetProjectPropertiesPublishedCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectPropertiesPublishedCount,
		arg.PropertyvEntityType,
		arg.PhasesEntityType,
		arg.ProjectEntityType,
		arg.PublishedBy,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectPropertiesPublishedListing = `-- name: GetProjectPropertiesPublishedListing :many
SELECT 
	pl.id as publish_id,
	property_versions.id as property_id,
	property_versions.title as property_title,
	projects.id as phase_id, 
	projects.ref_number as project_ref_no,
	projects.project_name as project_name,
  coalesce(phases.id,0) as phase_id,
	coalesce(phases.phase_name,'Single Phase') as phase_name

FROM publish_listing  AS pl
JOIN property_versions ON pl.entity_type_id::BIGINT= $3 AND property_versions.id = pl.entity_id::BIGINT
JOIN property ON property.id = property_versions.property_id
left JOIN phases ON property.entity_id=phases.id AND property.entity_type_id= $4  
JOIN projects ON (property.entity_id=projects.id AND property.entity_type_id= $5 AND projects.is_multiphase=FALSE) OR (projects.id=phases.projects_id and projects.is_multiphase=true)
WHERE
	property_versions.status!=6 AND property.status!=6 AND projects.status!=6 AND phases.status!=6
AND 
	pl.created_by= $6::BIGINT
AND
	($7 = '%%'
      OR property.property_name ILIKE $7
      OR phases.phase_name ILIKE $7
      OR projects.project_name ILIKE $7
     )
LIMIT $1
OFFSET $2
`

type GetProjectPropertiesPublishedListingParams struct {
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
	PropertyvEntityType int64       `json:"propertyv_entity_type"`
	PhasesEntityType    int64       `json:"phases_entity_type"`
	ProjectEntityType   int64       `json:"project_entity_type"`
	PublishedBy         int64       `json:"published_by"`
	Search              interface{} `json:"search"`
}

type GetProjectPropertiesPublishedListingRow struct {
	PublishID     int64  `json:"publish_id"`
	PropertyID    int64  `json:"property_id"`
	PropertyTitle string `json:"property_title"`
	PhaseID       int64  `json:"phase_id"`
	ProjectRefNo  string `json:"project_ref_no"`
	ProjectName   string `json:"project_name"`
	PhaseID_2     int64  `json:"phase_id_2"`
	PhaseName     string `json:"phase_name"`
}

func (q *Queries) GetProjectPropertiesPublishedListing(ctx context.Context, arg GetProjectPropertiesPublishedListingParams) ([]GetProjectPropertiesPublishedListingRow, error) {
	rows, err := q.db.Query(ctx, getProjectPropertiesPublishedListing,
		arg.Limit,
		arg.Offset,
		arg.PropertyvEntityType,
		arg.PhasesEntityType,
		arg.ProjectEntityType,
		arg.PublishedBy,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectPropertiesPublishedListingRow
	for rows.Next() {
		var i GetProjectPropertiesPublishedListingRow
		if err := rows.Scan(
			&i.PublishID,
			&i.PropertyID,
			&i.PropertyTitle,
			&i.PhaseID,
			&i.ProjectRefNo,
			&i.ProjectName,
			&i.PhaseID_2,
			&i.PhaseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectUnitsPublishedCount = `-- name: GetProjectUnitsPublishedCount :one
SELECT 
	count(pl)
FROM publish_listing  AS pl
JOIN unit_versions as uv ON pl.entity_type_id::BIGINT= $1 AND uv.id = pl.entity_id::BIGINT 
JOIN units ON units.id=uv.unit_id AND units.is_project_unit=TRUE 
JOIN property ON property.id = units.entity_id::BIGINT 
left JOIN phases ON property.entity_id=phases.id AND property.entity_type_id= $2  
JOIN projects ON (property.entity_id=projects.id AND property.entity_type_id= $3 AND projects.is_multiphase=FALSE) OR (projects.id=phases.projects_id and projects.is_multiphase=true)
WHERE
	property.status!=6 AND projects.status!=6 AND units.status!=6 
AND 
	pl.created_by= $4::BIGINT
`

type GetProjectUnitsPublishedCountParams struct {
	UnitvEntityTypeID    int64 `json:"unitv_entity_type_id"`
	PropertyEntityTypeID int64 `json:"property_entity_type_id"`
	ProjectEntityTypeID  int64 `json:"project_entity_type_id"`
	PublishedBy          int64 `json:"published_by"`
}

func (q *Queries) GetProjectUnitsPublishedCount(ctx context.Context, arg GetProjectUnitsPublishedCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectUnitsPublishedCount,
		arg.UnitvEntityTypeID,
		arg.PropertyEntityTypeID,
		arg.ProjectEntityTypeID,
		arg.PublishedBy,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectUnitsPublishedListing = `-- name: GetProjectUnitsPublishedListing :many
SELECT 
	pl.id as publish_id,
	uv.id as unit_id,
	uv.title as unit_title,
	uv.type as category,
  projects.id as project_id,
  property.id as property_id,
	property.property_name as property_name,
	projects.ref_number as project_ref_no,
	projects.project_name as project_name,
  coalesce(phases.id,0) as phase_id,
	COALESCE(phases.phase_name,'Single Phase') as phase_name
	
FROM publish_listing  AS pl
JOIN unit_versions as uv ON pl.entity_type_id::BIGINT= $3 AND uv.id = pl.entity_id::BIGINT 
JOIN units ON units.id=uv.unit_id AND units.is_project_unit=TRUE 
JOIN property ON property.id = units.entity_id::BIGINT 
left JOIN phases ON property.entity_id=phases.id AND property.entity_type_id= $4  
JOIN projects ON (property.entity_id=projects.id AND property.entity_type_id= $5 AND projects.is_multiphase=FALSE) OR (projects.id=phases.projects_id and projects.is_multiphase=true)
WHERE
	property.status!=6 AND projects.status!=6 AND units.status!=6 
AND 
	pl.created_by= $6::BIGINT
AND
	($7 = '%%'
	  OR units.unit_title ILIKE $7
      OR property.property_name ILIKE $7
      OR phases.phase_name ILIKE $7
      OR projects.project_name ILIKE $7
     )
LIMIT $1
OFFSET $2
`

type GetProjectUnitsPublishedListingParams struct {
	Limit                int32       `json:"limit"`
	Offset               int32       `json:"offset"`
	UnitvEntityTypeID    int64       `json:"unitv_entity_type_id"`
	PropertyEntityTypeID int64       `json:"property_entity_type_id"`
	ProjectEntityTypeID  int64       `json:"project_entity_type_id"`
	PublishedBy          int64       `json:"published_by"`
	Search               interface{} `json:"search"`
}

type GetProjectUnitsPublishedListingRow struct {
	PublishID    int64  `json:"publish_id"`
	UnitID       int64  `json:"unit_id"`
	UnitTitle    string `json:"unit_title"`
	Category     int64  `json:"category"`
	ProjectID    int64  `json:"project_id"`
	PropertyID   int64  `json:"property_id"`
	PropertyName string `json:"property_name"`
	ProjectRefNo string `json:"project_ref_no"`
	ProjectName  string `json:"project_name"`
	PhaseID      int64  `json:"phase_id"`
	PhaseName    string `json:"phase_name"`
}

func (q *Queries) GetProjectUnitsPublishedListing(ctx context.Context, arg GetProjectUnitsPublishedListingParams) ([]GetProjectUnitsPublishedListingRow, error) {
	rows, err := q.db.Query(ctx, getProjectUnitsPublishedListing,
		arg.Limit,
		arg.Offset,
		arg.UnitvEntityTypeID,
		arg.PropertyEntityTypeID,
		arg.ProjectEntityTypeID,
		arg.PublishedBy,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectUnitsPublishedListingRow
	for rows.Next() {
		var i GetProjectUnitsPublishedListingRow
		if err := rows.Scan(
			&i.PublishID,
			&i.UnitID,
			&i.UnitTitle,
			&i.Category,
			&i.ProjectID,
			&i.PropertyID,
			&i.PropertyName,
			&i.ProjectRefNo,
			&i.ProjectName,
			&i.PhaseID,
			&i.PhaseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsPublishedCount = `-- name: GetProjectsPublishedCount :one
SELECT 
	COUNT(pl)
FROM publish_listing  AS pl
JOIN projects ON 
pl.entity_type_id= $1::BIGINT AND 
projects.id = pl.entity_id::BIGINT
WHERE
	projects.status!=6
AND 
	pl.created_by= $2::BIGINT
`

type GetProjectsPublishedCountParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	PublishedBy  int64 `json:"published_by"`
}

func (q *Queries) GetProjectsPublishedCount(ctx context.Context, arg GetProjectsPublishedCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectsPublishedCount, arg.EntityTypeID, arg.PublishedBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectsPublishedListing = `-- name: GetProjectsPublishedListing :many
with phaseCount as (
	SELECT projects.id as project_id , COALESCE(count(phases.id),0) as phases_count from projects
	LEFT JOIN phases on phases.projects_id=projects.id AND projects.is_multiphase=TRUE
	group by projects.id
)
SELECT 
	projects.id, projects.project_name, projects.ref_number, projects.no_of_views, projects.is_verified, projects.project_rank, projects.addresses_id, projects.status, projects.developer_companies_id, projects.developer_company_branches_id, projects.countries_id, projects.created_at, projects.updated_at, projects.is_multiphase, projects.live_status, projects.project_no, projects.license_no, projects.users_id, projects.description, projects.description_arabic, projects.rating, projects.polygon_coords, projects.facts, projects.exclusive, projects.start_date, projects.end_date, projects.slug, projects.deleted_at, projects.bank_name, projects.registration_date, projects.escrow_number, projects.refreshed_at,
  pl.id::bigint as publish_id,
  pc.phases_count::bigint,
	comp.company_name
FROM publish_listing  AS pl
JOIN projects ON 
pl.entity_type_id= $3::BIGINT AND 
projects.id = pl.entity_id::BIGINT
left JOIN companies comp ON comp.id= projects.developer_companies_id 
JOIN phaseCount pc ON pc.project_id= projects.id
WHERE
	projects.status!=6
AND
	($4 = '%%'
      OR comp.company_name ILIKE $4
      OR projects.project_name ILIKE $4
     )
AND 
	pl.created_by= $5::BIGINT
LIMIT $1
OFFSET $2
`

type GetProjectsPublishedListingParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	EntityTypeID int64       `json:"entity_type_id"`
	Search       interface{} `json:"search"`
	PublishedBy  int64       `json:"published_by"`
}

type GetProjectsPublishedListingRow struct {
	Project       Project     `json:"project"`
	PublishID     int64       `json:"publish_id"`
	PcPhasesCount int64       `json:"pc_phases_count"`
	CompanyName   pgtype.Text `json:"company_name"`
}

func (q *Queries) GetProjectsPublishedListing(ctx context.Context, arg GetProjectsPublishedListingParams) ([]GetProjectsPublishedListingRow, error) {
	rows, err := q.db.Query(ctx, getProjectsPublishedListing,
		arg.Limit,
		arg.Offset,
		arg.EntityTypeID,
		arg.Search,
		arg.PublishedBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsPublishedListingRow
	for rows.Next() {
		var i GetProjectsPublishedListingRow
		if err := rows.Scan(
			&i.Project.ID,
			&i.Project.ProjectName,
			&i.Project.RefNumber,
			&i.Project.NoOfViews,
			&i.Project.IsVerified,
			&i.Project.ProjectRank,
			&i.Project.AddressesID,
			&i.Project.Status,
			&i.Project.DeveloperCompaniesID,
			&i.Project.DeveloperCompanyBranchesID,
			&i.Project.CountriesID,
			&i.Project.CreatedAt,
			&i.Project.UpdatedAt,
			&i.Project.IsMultiphase,
			&i.Project.LiveStatus,
			&i.Project.ProjectNo,
			&i.Project.LicenseNo,
			&i.Project.UsersID,
			&i.Project.Description,
			&i.Project.DescriptionArabic,
			&i.Project.Rating,
			&i.Project.PolygonCoords,
			&i.Project.Facts,
			&i.Project.Exclusive,
			&i.Project.StartDate,
			&i.Project.EndDate,
			&i.Project.Slug,
			&i.Project.DeletedAt,
			&i.Project.BankName,
			&i.Project.RegistrationDate,
			&i.Project.EscrowNumber,
			&i.Project.RefreshedAt,
			&i.PublishID,
			&i.PcPhasesCount,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishByEntity = `-- name: GetPublishByEntity :one
SELECT id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id FROM publish_listing Where id = $1 LIMIT 1
`

func (q *Queries) GetPublishByEntity(ctx context.Context, id int64) (PublishListing, error) {
	row := q.db.QueryRow(ctx, getPublishByEntity, id)
	var i PublishListing
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.IsInternal,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.WebportalID,
		&i.IsEnabled,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}

const getPublishByID = `-- name: GetPublishByID :one
SELECT id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id FROM publish_listing Where id = $1 LIMIT 1
`

func (q *Queries) GetPublishByID(ctx context.Context, id int64) (PublishListing, error) {
	row := q.db.QueryRow(ctx, getPublishByID, id)
	var i PublishListing
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.IsInternal,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.WebportalID,
		&i.IsEnabled,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}

const getPublishByMe = `-- name: GetPublishByMe :one
 


SELECT id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id
FROM
    publish_listing pl
WHERE
    pl.entity_type_id = $1 :: BIGINT
    AND pl.entity_id = $2 :: BIGINT
    AND pl.created_by = $3 :: BIGINT
    AND pl.webportal_id = $4 :: BIGINT
`

type GetPublishByMeParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
	UserID       int64 `json:"user_id"`
	WebportalID  int64 `json:"webportal_id"`
}

// -- name: GetPublishByMe :one
// SELECT *,
//
//	CASE
//	  WHEN @check_for = 'unit' THEN
//	    CASE
//	      WHEN is_unit = @is_unit AND unit_id = @unit_id  AND unit_category =  @unit_category  AND webportal_id = @webportal_id
//	      THEN 'Unit query executed'
//	      ELSE 'No matching condition'
//	    END
//	  WHEN @check_for = 'property' THEN
//	    CASE
//	      WHEN  is_property = @is_property AND property_key = @property_key AND property_id = @property_id AND webportal_id = @webportal_id
//	       AND (is_unit IS NULL  OR is_unit IS FALSE) THEN 'Property query executed'
//	      ELSE 'No matching condition'
//	    END
//	  WHEN @check_for = 'project_with_phase' THEN
//	    CASE
//	      WHEN is_project = @is_project AND phase_id = @phase_id AND project_id = @project_id AND webportal_id = @webportal_id
//	       AND (is_property IS NULL OR is_property IS false)
//	      AND (is_unit IS NULL OR is_unit IS false)
//	       THEN 'Project with phase query executed'
//	      ELSE 'No matching condition'
//	    END
//	  WHEN @check_for = 'project_without_phase' THEN
//	    CASE
//	      WHEN is_project = @is_project AND phase_id IS NULL AND project_id = @project_id  AND webportal_id = @webportal_id
//	      AND (is_property IS NULL OR is_property IS false)
//	      AND (is_unit IS NULL OR is_unit IS false)
//	      THEN 'Project without phase query executed'
//	      ELSE 'No matching condition'
//	    END
//	  ELSE 'Invalid check_for parameter'
//	END AS query_executed
//
// FROM publish_listing
// WHERE
//
//	CASE
//	  WHEN @check_for = 'unit' THEN
//	    CASE
//	      WHEN is_unit = @is_unit AND unit_id = @unit_id  AND created_by = @user_id AND webportal_id = @webportal_id
//	       AND unit_category =  @unit_category  THEN TRUE
//	      ELSE FALSE
//	    END
//	  WHEN @check_for = 'property' THEN
//	    CASE
//	      WHEN is_property = @is_property AND property_key = @property_key AND property_id = @property_id  AND webportal_id = @webportal_id
//	       AND created_by = @user_id  AND (is_unit IS NULL  OR is_unit IS FALSE) THEN TRUE
//	      ELSE FALSE
//	    END
//	  WHEN @check_for = 'project_with_phase' THEN
//	    CASE
//	      WHEN is_project = @is_project AND phase_id = @phase_id AND project_id = @project_id  AND created_by = @user_id AND webportal_id = @webportal_id
//	       AND (is_property IS NULL OR is_property IS false)
//	      AND (is_unit IS NULL OR is_unit IS false)
//	       THEN TRUE
//	      ELSE FALSE
//	    END
//	  WHEN @check_for = 'project_without_phase' THEN
//	    CASE
//	      WHEN is_project = @is_project AND phase_id IS NULL AND project_id = @project_id  AND created_by = @user_id AND webportal_id = @webportal_id
//	       AND (is_property IS NULL OR is_property IS false)
//	      AND (is_unit IS NULL OR is_unit IS false)
//	       THEN TRUE
//	      ELSE FALSE
//	    END
//	  ELSE FALSE
//
// END;
func (q *Queries) GetPublishByMe(ctx context.Context, arg GetPublishByMeParams) (PublishListing, error) {
	row := q.db.QueryRow(ctx, getPublishByMe,
		arg.EntityTypeID,
		arg.EntityID,
		arg.UserID,
		arg.WebportalID,
	)
	var i PublishListing
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.IsInternal,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.WebportalID,
		&i.IsEnabled,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}

const getPublishGalleryByID = `-- name: GetPublishGalleryByID :one
SELECT id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at FROM publish_gallery WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPublishGalleryByID(ctx context.Context, id int64) (PublishGallery, error) {
	row := q.db.QueryRow(ctx, getPublishGalleryByID, id)
	var i PublishGallery
	err := row.Scan(
		&i.ID,
		&i.PublishListingID,
		&i.ImageUrl,
		&i.Image360Url,
		&i.VideoUrl,
		&i.PanaromaUrl,
		&i.MainMediaSection,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPublishGalleryByPublishID = `-- name: GetPublishGalleryByPublishID :many
SELECT id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at FROM publish_gallery
WHERE publish_listing_id = $1
`

func (q *Queries) GetPublishGalleryByPublishID(ctx context.Context, publishListingID pgtype.Int8) ([]PublishGallery, error) {
	rows, err := q.db.Query(ctx, getPublishGalleryByPublishID, publishListingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PublishGallery
	for rows.Next() {
		var i PublishGallery
		if err := rows.Scan(
			&i.ID,
			&i.PublishListingID,
			&i.ImageUrl,
			&i.Image360Url,
			&i.VideoUrl,
			&i.PanaromaUrl,
			&i.MainMediaSection,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishMediaByPublishListingIdAndMediaSection = `-- name: GetPublishMediaByPublishListingIdAndMediaSection :one
SELECT id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at FROM publish_gallery
WHERE publish_listing_id = $1 AND main_media_section = $2
`

type GetPublishMediaByPublishListingIdAndMediaSectionParams struct {
	PublishListingID pgtype.Int8 `json:"publish_listing_id"`
	MainMediaSection string      `json:"main_media_section"`
}

func (q *Queries) GetPublishMediaByPublishListingIdAndMediaSection(ctx context.Context, arg GetPublishMediaByPublishListingIdAndMediaSectionParams) (PublishGallery, error) {
	row := q.db.QueryRow(ctx, getPublishMediaByPublishListingIdAndMediaSection, arg.PublishListingID, arg.MainMediaSection)
	var i PublishGallery
	err := row.Scan(
		&i.ID,
		&i.PublishListingID,
		&i.ImageUrl,
		&i.Image360Url,
		&i.VideoUrl,
		&i.PanaromaUrl,
		&i.MainMediaSection,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPublishPlanByPublishID = `-- name: GetPublishPlanByPublishID :many
SELECT id, publish_listing_id, title, plan_url, updated_at, created_at FROM publish_plan
WHERE publish_listing_id = $1
`

func (q *Queries) GetPublishPlanByPublishID(ctx context.Context, publishListingID int64) ([]PublishPlan, error) {
	rows, err := q.db.Query(ctx, getPublishPlanByPublishID, publishListingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PublishPlan
	for rows.Next() {
		var i PublishPlan
		if err := rows.Scan(
			&i.ID,
			&i.PublishListingID,
			&i.Title,
			&i.PlanUrl,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusOfEntity = `-- name: GetStatusOfEntity :one
SELECT COALESCE(CASE $1::BIGINT 
		       WHEN 1 THEN (SELECT projects.status::BIGINT FROM projects WHERE projects.id = $2::BIGINT)
               WHEN 2 THEN (SELECT phases.status::BIGINT FROM phases WHERE phases.id = $2::BIGINT)
               WHEN 3 THEN (SELECT property.status::BIGINT FROM property WHERE property.id = $2::BIGINT)
               WHEN 4 THEN (SELECT exhibitions.event_status::BIGINT FROM exhibitions WHERE exhibitions.id = $2::BIGINT)
               WHEN 5 THEN (SELECT units.status::BIGINT FROM units WHERE units.id = $2::BIGINT)
               WHEN 6 THEN (SELECT companies.status::BIGINT FROM companies WHERE companies.id = $2::BIGINT)
               WHEN 7 THEN (SELECT 1 FROM profiles WHERE profiles.id = $2::BIGINT)
               WHEN 8 THEN (SELECT freelancers.status::BIGINT FROM freelancers WHERE freelancers.id = $2::BIGINT)
               WHEN 9 THEN (SELECT users.status::BIGINT FROM users WHERE users.id = $2::BIGINT)
               WHEN 10 THEN (SELECT holiday_home.status::BIGINT FROM holiday_home WHERE holiday_home.id = $2::BIGINT)
               WHEN 11 THEN (SELECT 1 FROM services WHERE services.id = $2::BIGINT)
               WHEN 14 THEN (SELECT unit_versions.status::BIGINT FROM unit_versions WHERE unit_versions.id= $2::BIGINT)
               WHEN 15 THEN (SELECT property_versions.status::BIGINT FROM property_versions WHERE property_versions.id = $2::BIGINT)
               WHEN 16 THEN (SELECT 1 FROM publish_listing WHERE publish_listing.id = $2::BIGINT)
               ELSE 0::BIGINT
           END,6::BIGINT)::BIGINT
`

type GetStatusOfEntityParams struct {
	EntityType int64 `json:"entity_type"`
	EntityID   int64 `json:"entity_id"`
}

func (q *Queries) GetStatusOfEntity(ctx context.Context, arg GetStatusOfEntityParams) (int64, error) {
	row := q.db.QueryRow(ctx, getStatusOfEntity, arg.EntityType, arg.EntityID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const isSharePublishedWithProject = `-- name: IsSharePublishedWithProject :one
 



SELECT id FROM publish_listing 
WHERE share_id = $1 AND project_id IS NOT NULL AND phase_id IS NULL 
      AND (is_property IS NULL OR is_property IS FALSE) AND (is_unit IS NULL OR is_unit IS FALSE) AND created_by = $2
`

type IsSharePublishedWithProjectParams struct {
	ShareID pgtype.Int4 `json:"share_id"`
	UserID  int64       `json:"user_id"`
}

// SELECT *,
//
//	CASE
//	  WHEN @check_for = 'unit' THEN
//	    CASE
//	      WHEN is_unit = @is_unit AND property_unit_id = @property_unit_id  AND unit_category =  @unit_category
//	      THEN 'Unit query executed'
//	      ELSE 'No matching condition'
//	    END
//	  WHEN @check_for = 'property' THEN
//	    CASE
//	      WHEN  is_property = @is_property AND property_key = @property_key AND property_unit_id = @property_unit_id
//	       AND (is_unit IS NULL  OR is_unit IS FALSE) THEN 'Property query executed'
//	      ELSE 'No matching condition'
//	    END
//	  WHEN @check_for = 'project_with_phase' THEN
//	    CASE
//	      WHEN is_project = @is_project AND phase_id = @phase_id AND project_id = @project_id
//	       AND (is_property IS NULL OR is_property IS false)
//	      AND (is_unit IS NULL OR is_unit IS false)
//	       THEN 'Project with phase query executed'
//	      ELSE 'No matching condition'
//	    END
//	  WHEN @check_for = 'project_without_phase' THEN
//	    CASE
//	      WHEN is_project = @is_project AND phase_id IS NULL AND project_id = @project_id
//	      AND (is_property IS NULL OR is_property IS false)
//	      AND (is_unit IS NULL OR is_unit IS false)
//	      THEN 'Project without phase query executed'
//	      ELSE 'No matching condition'
//	    END
//	  ELSE 'Invalid check_for parameter'
//	END AS query_executed
//
// FROM publish_listing
// WHERE
//
//	CASE
//	  WHEN @check_for = 'unit' THEN
//	    CASE
//	      WHEN is_unit = @is_unit AND property_unit_id = @property_unit_id  AND created_by = @user_id
//	       AND unit_category =  @unit_category  THEN TRUE
//	      ELSE FALSE
//	    END
//	  WHEN @check_for = 'property' THEN
//	    CASE
//	      WHEN is_property = @is_property AND property_key = @property_key AND property_unit_id = @property_unit_id
//	       AND created_by = @user_id  AND (is_unit IS NULL  OR is_unit IS FALSE) THEN TRUE
//	      ELSE FALSE
//	    END
//	  WHEN @check_for = 'project_with_phase' THEN
//	    CASE
//	      WHEN is_project = @is_project AND phase_id = @phase_id AND project_id = @project_id  AND created_by = @user_id
//	       AND (is_property IS NULL OR is_property IS false)
//	      AND (is_unit IS NULL OR is_unit IS false)
//	       THEN TRUE
//	      ELSE FALSE
//	    END
//	  WHEN @check_for = 'project_without_phase' THEN
//	    CASE
//	      WHEN is_project = @is_project AND phase_id IS NULL AND project_id = @project_id  AND created_by = @user_id
//	       AND (is_property IS NULL OR is_property IS false)
//	      AND (is_unit IS NULL OR is_unit IS false)
//	       THEN TRUE
//	      ELSE FALSE
//	    END
//	  ELSE FALSE
//
// END;
func (q *Queries) IsSharePublishedWithProject(ctx context.Context, arg IsSharePublishedWithProjectParams) (int64, error) {
	row := q.db.QueryRow(ctx, isSharePublishedWithProject, arg.ShareID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const isSharePublishedWithProjectPhase = `-- name: IsSharePublishedWithProjectPhase :one
SELECT id FROM publish_listing 
WHERE share_id = $1 AND project_id IS NOT NULL AND phase_id IS NOT NULL 
      AND (is_property IS NULL OR is_property IS FALSE) AND (is_unit IS NULL OR is_unit IS FALSE) AND created_by = $2
`

type IsSharePublishedWithProjectPhaseParams struct {
	ShareID pgtype.Int4 `json:"share_id"`
	UserID  int64       `json:"user_id"`
}

func (q *Queries) IsSharePublishedWithProjectPhase(ctx context.Context, arg IsSharePublishedWithProjectPhaseParams) (int64, error) {
	row := q.db.QueryRow(ctx, isSharePublishedWithProjectPhase, arg.ShareID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const isSharePublishedWithProperty = `-- name: IsSharePublishedWithProperty :one
SELECT id FROM publish_listing 
WHERE share_id = $1  AND is_property IS NOT NULL   
      AND (is_unit IS NULL OR is_unit IS FALSE) AND created_by = $2
`

type IsSharePublishedWithPropertyParams struct {
	ShareID pgtype.Int4 `json:"share_id"`
	UserID  int64       `json:"user_id"`
}

func (q *Queries) IsSharePublishedWithProperty(ctx context.Context, arg IsSharePublishedWithPropertyParams) (int64, error) {
	row := q.db.QueryRow(ctx, isSharePublishedWithProperty, arg.ShareID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const isSharePublishedWithUnit = `-- name: IsSharePublishedWithUnit :one
SELECT id FROM publish_listing 
WHERE share_id = $1  AND is_unit IS NOT NULL AND created_by = $2
`

type IsSharePublishedWithUnitParams struct {
	ShareID pgtype.Int4 `json:"share_id"`
	UserID  int64       `json:"user_id"`
}

func (q *Queries) IsSharePublishedWithUnit(ctx context.Context, arg IsSharePublishedWithUnitParams) (int64, error) {
	row := q.db.QueryRow(ctx, isSharePublishedWithUnit, arg.ShareID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updatePublishListingForEnables = `-- name: UpdatePublishListingForEnables :many
 
    
 





 




 


    
















Update publish_listing
SET  is_enabled = $2
Where id = ANY($1::bigint[])
RETURNING id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id
`

type UpdatePublishListingForEnablesParams struct {
	Column1   []int64     `json:"column_1"`
	IsEnabled pgtype.Bool `json:"is_enabled"`
}

// ! -------------------------  FROM HERE PROJECT PUBLISH QUERIES --------------------------------------------- !--
// -- name: GetProjectPublishByMe :many
// SELECT DISTINCT ON (publish_listing.project_id)
// publish_listing.project_id,  *
// FROM publish_listing
//
//	--  all inner joins
//	   LEFT JOIN projects p ON publish_listing.project_id = p.id
//	   LEFT JOIN addresses ON p.addresses_id = addresses.id
//	   LEFT JOIN countries ON addresses.countries_id = countries.id
//	   LEFT JOIN states ON addresses.states_id = states.id
//	   LEFT JOIN cities ON addresses.cities_id = cities.id
//	   LEFT JOIN companies ON p.developer_companies_id = companies.id
//	   LEFT JOIN properties_facts ON p.id = properties_facts.project_id AND properties_facts.is_project_fact = true
//
// WHERE
//
//	-- Search criteria
//	  (@search = '%%' OR
//	   p.project_name % @search OR
//	   p.ref_number % @search OR
//	   countries.country % @search OR
//	   states."state" % @search OR
//	   cities.city % @search OR
//	   companies.company_name % @search
//	    OR (CASE
//	      WHEN 'ready' ILIKE @search THEN properties_facts.completion_status = 5
//	      WHEN 'off plan' ILIKE @search  THEN properties_facts.completion_status = 4
//	      WHEN '^[0-9]+$' ~ @search  THEN properties_facts.completion_percentage::TEXT % @search
//	      WHEN 'draft' ILIKE @search  THEN p.status = 1
//	      WHEN 'available' ILIKE @search  THEN p.status = 2
//	      WHEN 'block' ILIKE @search  THEN p.status = 5
//	      WHEN 'single' ILIKE @search  THEN p.is_multiphase = false
//	      WHEN 'multiple' ILIKE @search  THEN p.is_multiphase = true
//	      ELSE FALSE
//	    END )
//	    ) AND
//	   is_project IS TRUE AND phase_id IS NULL
//	   AND (is_property IS NULL OR is_property IS FALSE)
//	   AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id
//
// ORDER BY publish_listing.project_id, publish_listing.updated_at DESC  LIMIT $1 OFFSET $2;
// -- name: CountProjectPublishByMe :one
// SELECT COUNT(DISTINCT publish_listing.project_id)
// FROM publish_listing
//
//	--  all inner joins
//	   LEFT JOIN projects p ON publish_listing.project_id = p.id
//	   LEFT JOIN addresses ON p.addresses_id = addresses.id
//	   LEFT JOIN countries ON addresses.countries_id = countries.id
//	   LEFT JOIN states ON addresses.states_id = states.id
//	   LEFT JOIN cities ON addresses.cities_id = cities.id
//	   LEFT JOIN companies ON p.developer_companies_id = companies.id
//	   LEFT JOIN properties_facts ON p.id = properties_facts.project_id AND properties_facts.is_project_fact = true
//
// WHERE
//
//	-- Search criteria
//	  (@search = '%%' OR
//	   p.project_name % @search OR
//	   p.ref_number % @search OR
//	   countries.country % @search OR
//	   states."state" % @search OR
//	   cities.city % @search OR
//	   companies.company_name % @search
//	    OR (CASE
//	      WHEN 'ready' ILIKE @search THEN properties_facts.completion_status = 5
//	      WHEN 'off plan' ILIKE @search  THEN properties_facts.completion_status = 4
//	      WHEN '^[0-9]+$' ~ @search  THEN properties_facts.completion_percentage::TEXT % @search
//	      WHEN 'draft' ILIKE @search  THEN p.status = 1
//	      WHEN 'available' ILIKE @search  THEN p.status = 2
//	      WHEN 'block' ILIKE @search  THEN p.status = 5
//	      WHEN 'single' ILIKE @search  THEN p.is_multiphase = false
//	      WHEN 'multiple' ILIKE @search  THEN p.is_multiphase = true
//	      ELSE FALSE
//	    END )
//	    ) AND
//	   is_project IS TRUE AND phase_id IS NULL
//	   AND (is_property IS NULL OR is_property IS FALSE)
//	   AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id;
//
// -- name: GetAProjectPublishByMe :one
// SELECT DISTINCT ON (publish_listing.project_id) publish_listing.project_id,  *
// FROM publish_listing
//
//	--  all inner joins
//	   LEFT JOIN projects p ON publish_listing.project_id = p.id
//
// WHERE
//
//	publish_listing.project_id =  @project_id
//	AND is_project IS TRUE AND phase_id IS NULL
//	AND (is_property IS NULL OR is_property IS FALSE)
//	AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id;
//
// --! ------------  FROM HERE PROJECT PHASES PUBLISH  QUERIES --------------------------------------------- !--
// -- name: GetProjectPhasesPublishByMe :many
// SELECT DISTINCT ON (publish_listing.phase_id) publish_listing.phase_id, *
// FROM publish_listing
//
//	LEFT JOIN projects p ON publish_listing.project_id = p.id
//	LEFT JOIN phases ON p.id = phases.projects_id
//	LEFT JOIN phases_facts ON phases.id = phases_facts.phases_id
//	LEFT JOIN companies ON p.developer_companies_id = companies.id
//
// WHERE
//
//	(@search = '%%'
//	    OR phases.ref_no ILIKE @search
//	     OR p.project_name ILIKE @search
//	     OR companies.company_name ILIKE @search
//	     OR phases.phase_name ILIKE @search
//	      OR (CASE
//	       WHEN 'ready' ILIKE @search THEN phases_facts.completion_status = 5
//	       WHEN 'off plan'ILIKE @search  THEN phases_facts.completion_status = 4
//	       WHEN '^[0-9]+$' ~ @search  THEN phases_facts.completion_percentage::TEXT % @search
//	       ELSE FALSE
//	     END)
//	    ) AND
//	  is_project IS TRUE AND phase_id IS NOT NULL
//	    AND (is_property IS NULL OR is_property IS FALSE)
//	    AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id
//
// ORDER BY publish_listing.phase_id,  publish_listing.updated_at DESC  LIMIT $1 OFFSET $2;
// -- name: CountProjectPhasesPublishByMe :one
// SELECT COUNT(DISTINCT publish_listing.phase_id)
// FROM publish_listing
//
//	LEFT JOIN projects p ON publish_listing.project_id = p.id
//	LEFT JOIN phases ON p.id = phases.projects_id
//	LEFT JOIN phases_facts ON phases.id = phases_facts.phases_id
//	LEFT JOIN companies ON p.developer_companies_id = companies.id
//
// WHERE
//
//	(@search = '%%'
//	    OR phases.ref_no ILIKE @search
//	     OR p.project_name ILIKE @search
//	     OR companies.company_name ILIKE @search
//	     OR phases.phase_name ILIKE @search
//	      OR (CASE
//	       WHEN 'ready' ILIKE @search THEN phases_facts.completion_status = 5
//	       WHEN 'off plan'ILIKE @search  THEN phases_facts.completion_status = 4
//	       WHEN '^[0-9]+$' ~ @search  THEN phases_facts.completion_percentage::TEXT % @search
//	       ELSE FALSE
//	     END)
//	    ) AND
//	  is_project IS TRUE AND phase_id IS NOT NULL
//	    AND (is_property IS NULL OR is_property IS FALSE)
//
// AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id;
// -- name: GetAProjectPhasesPublishByMe :one
// SELECT DISTINCT ON (publish_listing.phase_id) publish_listing.phase_id, *
// FROM publish_listing
//
//	LEFT JOIN projects p ON publish_listing.project_id = p.id
//	LEFT JOIN phases ON p.id = phases.projects_id
//
// WHERE
//
//	 publish_listing.phase_id = @phase_id
//	AND  is_project IS TRUE AND phase_id IS NOT NULL
//	   AND (is_property IS NULL OR is_property IS FALSE)
//
// AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id;
// --! ------------  FROM HERE PROJECT PROPERTY PUBLISH  QUERIES --------------------------------------------- !--
// -- name: GetProjectPropertyPublishByMe :many
// SELECT DISTINCT ON (publish_listing.property_id) publish_listing.property_id, *
// FROM publish_listing
//
//	    LEFT JOIN projects ON publish_listing.project_id = projects.id
//		LEFT JOIN phases ON publish_listing.phase_id = phases.id
//	    LEFT JOIN project_properties ON publish_listing.property_id =  project_properties.id
//
// WHERE
//
//	( @search = '%%'
//	 OR projects.project_name ILIKE @search
//	 OR project_properties.ref_no ILIKE @search
//	 OR project_properties.property_name ILIKE @search
//	 OR phases.phase_name ILIKE @search
//	) AND
//	is_property IS TRUE AND property_id IS NOT NULL AND property_key IS NOT NULL
//	AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id
//
// ORDER BY publish_listing.property_id, publish_listing.updated_at DESC  LIMIT $1 OFFSET $2;
// -- name: CountProjectPropertyPublishByMe :one
// SELECT COUNT(DISTINCT publish_listing.property_id)
// FROM publish_listing
//
//	    LEFT JOIN projects ON publish_listing.project_id = projects.id
//		LEFT JOIN phases ON publish_listing.phase_id = phases.id
//	    LEFT JOIN project_properties ON publish_listing.property_id =  project_properties.id
//
// WHERE
//
//	   ( @search = '%%'
//	    OR projects.project_name ILIKE @search
//	    OR project_properties.ref_no ILIKE @search
//	    OR project_properties.property_name ILIKE @search
//	    OR phases.phase_name ILIKE @search
//	   ) AND
//	is_property IS TRUE AND property_id IS NOT NULL AND property_key IS NOT NULL
//
// AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id;
// -- name: GetAProjectPropertyPublishByMe :one
// SELECT DISTINCT ON (publish_listing.property_id) publish_listing.property_id, *
// FROM publish_listing
//
//	LEFT JOIN project_properties ON publish_listing.property_id =  project_properties.id
//
// WHERE
//
//	  publish_listing.property_id =  @project_property_id
//	  AND
//	is_property IS TRUE AND property_id IS NOT NULL AND property_key IS NOT NULL
//
// AND (is_unit IS NULL OR is_unit IS FALSE) AND publish_listing.created_by =  @user_id;
// --! ------------  FROM HERE PROJECT PROPERTY UNIT PUBLISH  QUERIES --------------------------------------------- !--
// -- name: GetProjectPropertyUnitPublishByMe :many
// SELECT DISTINCT ON (publish_listing.unit_id) publish_listing.unit_id, *
// FROM publish_listing
//
//	LEFT JOIN projects ON publish_listing.project_id = projects.id
//	LEFT JOIN project_properties ON publish_listing.property_id =  project_properties.id
//	LEFT JOIN phases ON publish_listing.phase_id = phases.id
//	LEFT JOIN units ON publish_listing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%')
//	LEFT JOIN sale_unit ON units.id = sale_unit.unit_id AND unit_category ILIKE '%sale%'
//	LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%'
//
// WHERE
//
//	(@search = '%%'
//	   OR  units.ref_no ILIKE @search
//	   OR  projects.project_name ILIKE @search
//	   OR  project_properties.property_name ILIKE @search
//	   OR  phases.phase_name ILIKE @search
//	   OR  publish_listing.unit_category ILIKE @search
//	   OR  sale_unit.title ILIKE @search
//	   OR  rent_unit.title ILIKE @search
//	 ) AND
//	 publish_listing.is_unit IS TRUE
//	  AND publish_listing.unit_id IS NOT NULL
//	  AND publish_listing.created_by =  @user_id
//
// ORDER BY publish_listing.unit_id, publish_listing.updated_at DESC LIMIT $1 OFFSET $2;
// -- name: CountProjectPropertyUnitPublishByMe :one
// SELECT COUNT(DISTINCT publish_listing.unit_id)
// FROM publish_listing
//
//	LEFT JOIN projects ON publish_listing.project_id = projects.id
//	LEFT JOIN project_properties ON publish_listing.property_id =  project_properties.id
//	LEFT JOIN phases ON publish_listing.phase_id = phases.id
//	LEFT JOIN units ON publish_listing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%')
//	LEFT JOIN sale_unit ON units.id = sale_unit.unit_id AND unit_category ILIKE '%sale%'
//	LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%'
//
// WHERE
//
//	(@search = '%%'
//	   OR  units.ref_no ILIKE @search
//	   OR  projects.project_name ILIKE @search
//	   OR  project_properties.property_name ILIKE @search
//	   OR  phases.phase_name ILIKE @search
//	   OR  publish_listing.unit_category ILIKE @search
//	   OR  sale_unit.title ILIKE @search
//	   OR  rent_unit.title ILIKE @search
//	 ) AND
//	 publish_listing.is_unit IS TRUE
//	  AND publish_listing.unit_id IS NOT NULL
//
// AND publish_listing.created_by =  @user_id;
// -- name: GetAProjectPropertyUnitPublishByMe :one
// SELECT DISTINCT ON (publish_listing.unit_id) publish_listing.unit_id, *
// FROM publish_listing
//
//	LEFT JOIN units ON publish_listing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%')
//	LEFT JOIN sale_unit ON units.id = sale_unit.unit_id AND unit_category ILIKE '%sale%'
//	LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%'
//
// WHERE
//
//	publish_listing.unit_id = @unit_id
//	AND
//	publish_listing.is_unit IS TRUE
//	 AND publish_listing.unit_id IS NOT NULL
//
// AND publish_listing.created_by =  @user_id;
// --  ! --------------------------------------------------------------------------------------------------
// -- name: GetPublishedPortals :many
// SELECT
//
//	w.*,
//	pl.id as publish_id,
//	CASE WHEN pl.webportal_id IS NULL THEN
//		FALSE
//	ELSE
//		pl.is_enabled::bool
//	END AS is_enabled,
//	CASE WHEN @check_for = 'unit' THEN
//		CASE WHEN pl.is_unit = @is_unit
//			AND pl.unit_id = @unit_id
//			AND pl.unit_category = @unit_category THEN
//			'Unit query executed'
//		ELSE
//			'No matching condition'
//		END
//	WHEN @check_for = 'property' THEN
//		CASE WHEN pl.is_property = @is_property
//			AND pl.property_key = @property_key
//			AND pl.property_id = @property_id
//			AND(pl.is_unit IS NULL
//				OR pl.is_unit IS FALSE) THEN
//			'Property query executed'
//		ELSE
//			'No matching condition'
//		END
//	WHEN @check_for = 'project_with_phase' THEN
//		CASE WHEN pl.is_project = @is_project
//			AND pl.phase_id = @phase_id
//			AND pl.project_id = @project_id
//			AND(pl.is_property IS NULL
//				OR pl.is_property IS FALSE)
//			AND(pl.is_unit IS NULL
//				OR pl.is_unit IS FALSE) THEN
//			'Project with phase query executed'
//		ELSE
//			'No matching condition'
//		END
//	WHEN @check_for = 'project_without_phase' THEN
//		CASE WHEN pl.is_project = @is_project
//			AND pl.phase_id IS NULL
//			AND pl.project_id = @project_id
//			AND(pl.is_property IS NULL
//				OR pl.is_property IS FALSE)
//			AND(pl.is_unit IS NULL
//				OR pl.is_unit IS FALSE) THEN
//			'Project without phase query executed'
//		ELSE
//			'No matching condition'
//		END
//	ELSE
//		'Invalid check_for parameter'
//	END AS query_executed
//
// FROM
//
//	webportals w
//	INNER JOIN publish_listing pl ON w.id = pl.webportal_id
//		AND((@check_for = 'unit'
//			AND pl.is_unit = @is_unit
//			AND pl.unit_id = @unit_id
//			AND pl.unit_category = @unit_category)
//		OR(@check_for = 'property'
//			AND pl.is_property = @is_property
//			AND pl.property_key = @property_key
//			AND pl.property_id = @property_id
//			AND(pl.is_unit IS NULL
//				OR pl.is_unit IS FALSE))
//		OR(@check_for = 'project_with_phase'
//			AND pl.is_project = @is_project
//			AND pl.phase_id = @phase_id
//			AND pl.project_id = @project_id
//			AND(pl.is_property IS NULL
//				OR pl.is_property IS FALSE)
//			AND(pl.is_unit IS NULL
//				OR pl.is_unit IS FALSE))
//		OR(@check_for = 'project_without_phase'
//			AND pl.is_project = @is_project
//			AND pl.phase_id IS NULL
//			AND pl.project_id = @project_id
//			AND(pl.is_property IS NULL
//				OR pl.is_property IS FALSE)
//			AND(pl.is_unit IS NULL
//				OR pl.is_unit IS FALSE)))
//
// WHERE
//
//	w.created_by = @user_id;
func (q *Queries) UpdatePublishListingForEnables(ctx context.Context, arg UpdatePublishListingForEnablesParams) ([]PublishListing, error) {
	rows, err := q.db.Query(ctx, updatePublishListingForEnables, arg.Column1, arg.IsEnabled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PublishListing
	for rows.Next() {
		var i PublishListing
		if err := rows.Scan(
			&i.ID,
			&i.ShareID,
			&i.IsInternal,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.WebportalID,
			&i.IsEnabled,
			&i.EntityTypeID,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePublishMedia = `-- name: UpdatePublishMedia :one
UPDATE publish_gallery
SET    image_url = $2,
     image360_url = $3,
     video_url = $4,
     panaroma_url = $5,
     main_media_section = $6,
    updated_at = $7
Where id = $1
RETURNING id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at
`

type UpdatePublishMediaParams struct {
	ID               int64     `json:"id"`
	ImageUrl         []string  `json:"image_url"`
	Image360Url      []string  `json:"image360_url"`
	VideoUrl         []string  `json:"video_url"`
	PanaromaUrl      []string  `json:"panaroma_url"`
	MainMediaSection string    `json:"main_media_section"`
	UpdatedAt        time.Time `json:"updated_at"`
}

func (q *Queries) UpdatePublishMedia(ctx context.Context, arg UpdatePublishMediaParams) (PublishGallery, error) {
	row := q.db.QueryRow(ctx, updatePublishMedia,
		arg.ID,
		arg.ImageUrl,
		arg.Image360Url,
		arg.VideoUrl,
		arg.PanaromaUrl,
		arg.MainMediaSection,
		arg.UpdatedAt,
	)
	var i PublishGallery
	err := row.Scan(
		&i.ID,
		&i.PublishListingID,
		&i.ImageUrl,
		&i.Image360Url,
		&i.VideoUrl,
		&i.PanaromaUrl,
		&i.MainMediaSection,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
