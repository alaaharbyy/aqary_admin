// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sub_community_guidelines.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubCommunityGuideline = `-- name: CreateSubCommunityGuideline :one
INSERT INTO sub_community_guidelines (
  country_id, state_id, city_id, community_id,
  sub_community_id, description, cover_image,
  insights, sub_insights, status, about,
  created_at, update_at, deleted_at
) VALUES (
  $1, $2, $3, $4,
  $5, $6, $7,
  $8, $9, $10, $11,
  $12, $13, $14
)
RETURNING id, country_id, state_id, city_id, community_id, sub_community_id, description, cover_image, insights, sub_insights, status, about, created_at, update_at, deleted_at
`

type CreateSubCommunityGuidelineParams struct {
	CountryID      int64              `json:"country_id"`
	StateID        int64              `json:"state_id"`
	CityID         int64              `json:"city_id"`
	CommunityID    int64              `json:"community_id"`
	SubCommunityID int64              `json:"sub_community_id"`
	Description    string             `json:"description"`
	CoverImage     string             `json:"cover_image"`
	Insights       []int64            `json:"insights"`
	SubInsights    []int64            `json:"sub_insights"`
	Status         int64              `json:"status"`
	About          pgtype.Text        `json:"about"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdateAt       time.Time          `json:"update_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) CreateSubCommunityGuideline(ctx context.Context, arg CreateSubCommunityGuidelineParams) (SubCommunityGuideline, error) {
	row := q.db.QueryRow(ctx, createSubCommunityGuideline,
		arg.CountryID,
		arg.StateID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.Description,
		arg.CoverImage,
		arg.Insights,
		arg.SubInsights,
		arg.Status,
		arg.About,
		arg.CreatedAt,
		arg.UpdateAt,
		arg.DeletedAt,
	)
	var i SubCommunityGuideline
	err := row.Scan(
		&i.ID,
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.CommunityID,
		&i.SubCommunityID,
		&i.Description,
		&i.CoverImage,
		&i.Insights,
		&i.SubInsights,
		&i.Status,
		&i.About,
		&i.CreatedAt,
		&i.UpdateAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteSubCommunityGuideline = `-- name: DeleteSubCommunityGuideline :exec
DELETE FROM sub_community_guidelines
WHERE id = $1
`

func (q *Queries) DeleteSubCommunityGuideline(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSubCommunityGuideline, id)
	return err
}

const getDeletedSubCommunityGuidesLines = `-- name: GetDeletedSubCommunityGuidesLines :many
SELECT 
  DISTINCT ON (sub_community_guidelines.id)
  sub_community_guidelines.id, sub_community_guidelines.country_id, sub_community_guidelines.state_id, sub_community_guidelines.city_id, sub_community_guidelines.community_id, sub_community_guidelines.sub_community_id, sub_community_guidelines.description, sub_community_guidelines.cover_image, sub_community_guidelines.insights, sub_community_guidelines.sub_insights, sub_community_guidelines.status, sub_community_guidelines.about, sub_community_guidelines.created_at, sub_community_guidelines.update_at, sub_community_guidelines.deleted_at,
  sub_communities.sub_community,
  communities.community,
  cities.city,
  states.state,
  countries.country
  -- media.media
FROM sub_community_guidelines 
JOIN sub_communities ON sub_community_guidelines.sub_community_id = sub_communities.id
JOIN communities ON sub_community_guidelines.community_id = communities.id
JOIN cities ON cities.id = sub_community_guidelines.city_id
JOIN states ON states.id = sub_community_guidelines.state_id
JOIN countries ON countries.id = sub_community_guidelines.country_id
WHERE sub_community_guidelines.status=6
ORDER BY sub_community_guidelines.id,deleted_at DESC
LIMIT $2
OFFSET $1
`

type GetDeletedSubCommunityGuidesLinesParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetDeletedSubCommunityGuidesLinesRow struct {
	SubCommunityGuideline SubCommunityGuideline `json:"sub_community_guideline"`
	SubCommunity          string                `json:"sub_community"`
	Community             string                `json:"community"`
	City                  string                `json:"city"`
	State                 string                `json:"state"`
	Country               string                `json:"country"`
}

// LEFT JOIN media ON media.community_guidelines_id = community_guidelines.id
func (q *Queries) GetDeletedSubCommunityGuidesLines(ctx context.Context, arg GetDeletedSubCommunityGuidesLinesParams) ([]GetDeletedSubCommunityGuidesLinesRow, error) {
	rows, err := q.db.Query(ctx, getDeletedSubCommunityGuidesLines, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeletedSubCommunityGuidesLinesRow
	for rows.Next() {
		var i GetDeletedSubCommunityGuidesLinesRow
		if err := rows.Scan(
			&i.SubCommunityGuideline.ID,
			&i.SubCommunityGuideline.CountryID,
			&i.SubCommunityGuideline.StateID,
			&i.SubCommunityGuideline.CityID,
			&i.SubCommunityGuideline.CommunityID,
			&i.SubCommunityGuideline.SubCommunityID,
			&i.SubCommunityGuideline.Description,
			&i.SubCommunityGuideline.CoverImage,
			&i.SubCommunityGuideline.Insights,
			&i.SubCommunityGuideline.SubInsights,
			&i.SubCommunityGuideline.Status,
			&i.SubCommunityGuideline.About,
			&i.SubCommunityGuideline.CreatedAt,
			&i.SubCommunityGuideline.UpdateAt,
			&i.SubCommunityGuideline.DeletedAt,
			&i.SubCommunity,
			&i.Community,
			&i.City,
			&i.State,
			&i.Country,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedSubCommunityGuidesLinesCount = `-- name: GetDeletedSubCommunityGuidesLinesCount :one
SELECT 
 count(sub_community_guidelines) 
FROM sub_community_guidelines 
JOIN sub_communities ON sub_community_guidelines.sub_community_id = sub_communities.id
WHERE sub_community_guidelines.status=6
`

func (q *Queries) GetDeletedSubCommunityGuidesLinesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getDeletedSubCommunityGuidesLinesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSubCommunityGuideLines = `-- name: GetSubCommunityGuideLines :one
SELECT 
  DISTINCT ON (sub_community_guidelines.id)
  sub_community_guidelines.id, sub_community_guidelines.country_id, sub_community_guidelines.state_id, sub_community_guidelines.city_id, sub_community_guidelines.community_id, sub_community_guidelines.sub_community_id, sub_community_guidelines.description, sub_community_guidelines.cover_image, sub_community_guidelines.insights, sub_community_guidelines.sub_insights, sub_community_guidelines.status, sub_community_guidelines.about, sub_community_guidelines.created_at, sub_community_guidelines.update_at, sub_community_guidelines.deleted_at,
  sub_communities.sub_community,
  communities.community,
  cities.city,
  states.state,
  countries.country,
  (
    SELECT jsonb_agg(jsonb_build_object('id', i.id, 'label', i.insight_name))
    FROM community_guidelines_insight i
    WHERE i.id = ANY(sub_community_guidelines.insights)
  ) AS community_guidelines_insight,
  (
    SELECT jsonb_agg(jsonb_build_object('id', s.id, 'label', s.subinsight_name))
    FROM community_guidelines_subinsight s
    WHERE s.id = ANY(sub_community_guidelines.sub_insights)
  ) AS community_guidelines_subinsight

FROM sub_community_guidelines 
JOIN sub_communities ON sub_community_guidelines.sub_community_id = sub_communities.id
JOIN communities ON sub_community_guidelines.community_id = communities.id
JOIN cities ON cities.id = sub_community_guidelines.city_id
JOIN states ON states.id = sub_community_guidelines.state_id
JOIN countries ON countries.id = sub_community_guidelines.country_id
WHERE sub_community_guidelines.id = $1
ORDER BY sub_community_guidelines.id
LIMIT 1
`

type GetSubCommunityGuideLinesRow struct {
	SubCommunityGuideline         SubCommunityGuideline `json:"sub_community_guideline"`
	SubCommunity                  string                `json:"sub_community"`
	Community                     string                `json:"community"`
	City                          string                `json:"city"`
	State                         string                `json:"state"`
	Country                       string                `json:"country"`
	CommunityGuidelinesInsight    []byte                `json:"community_guidelines_insight"`
	CommunityGuidelinesSubinsight []byte                `json:"community_guidelines_subinsight"`
}

func (q *Queries) GetSubCommunityGuideLines(ctx context.Context, id int64) (GetSubCommunityGuideLinesRow, error) {
	row := q.db.QueryRow(ctx, getSubCommunityGuideLines, id)
	var i GetSubCommunityGuideLinesRow
	err := row.Scan(
		&i.SubCommunityGuideline.ID,
		&i.SubCommunityGuideline.CountryID,
		&i.SubCommunityGuideline.StateID,
		&i.SubCommunityGuideline.CityID,
		&i.SubCommunityGuideline.CommunityID,
		&i.SubCommunityGuideline.SubCommunityID,
		&i.SubCommunityGuideline.Description,
		&i.SubCommunityGuideline.CoverImage,
		&i.SubCommunityGuideline.Insights,
		&i.SubCommunityGuideline.SubInsights,
		&i.SubCommunityGuideline.Status,
		&i.SubCommunityGuideline.About,
		&i.SubCommunityGuideline.CreatedAt,
		&i.SubCommunityGuideline.UpdateAt,
		&i.SubCommunityGuideline.DeletedAt,
		&i.SubCommunity,
		&i.Community,
		&i.City,
		&i.State,
		&i.Country,
		&i.CommunityGuidelinesInsight,
		&i.CommunityGuidelinesSubinsight,
	)
	return i, err
}

const getSubCommunityGuidelineBySubID = `-- name: GetSubCommunityGuidelineBySubID :one
SELECT id, country_id, state_id, city_id, community_id, sub_community_id, description, cover_image, insights, sub_insights, status, about, created_at, update_at, deleted_at FROM sub_community_guidelines
WHERE sub_community_id = $1 LIMIT 1
`

func (q *Queries) GetSubCommunityGuidelineBySubID(ctx context.Context, subCommunityID int64) (SubCommunityGuideline, error) {
	row := q.db.QueryRow(ctx, getSubCommunityGuidelineBySubID, subCommunityID)
	var i SubCommunityGuideline
	err := row.Scan(
		&i.ID,
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.CommunityID,
		&i.SubCommunityID,
		&i.Description,
		&i.CoverImage,
		&i.Insights,
		&i.SubInsights,
		&i.Status,
		&i.About,
		&i.CreatedAt,
		&i.UpdateAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSubCommunityGuidesLines = `-- name: GetSubCommunityGuidesLines :many
SELECT 
  DISTINCT ON (sub_community_guidelines.id)
  sub_community_guidelines.id, sub_community_guidelines.country_id, sub_community_guidelines.state_id, sub_community_guidelines.city_id, sub_community_guidelines.community_id,sub_community_guidelines.sub_community_id, sub_community_guidelines.cover_image, sub_community_guidelines.insights, sub_community_guidelines.sub_insights, sub_community_guidelines.status, sub_community_guidelines.about, sub_community_guidelines.created_at, sub_community_guidelines.update_at, sub_community_guidelines.deleted_at,
  sub_communities.sub_community,
  communities.community,
  cities.city,
  states.state,
  countries.country,
  COALESCE((
    SELECT jsonb_agg(jsonb_build_object('id', i.id, 'label', i.insight_name))
    FROM community_guidelines_insight i
    WHERE i.id = ANY(sub_community_guidelines.insights)
      AND i.status NOT IN (5, 6)
  ), '[]'::jsonb)::jsonb AS community_guidelines_insight,

  COALESCE((
    SELECT jsonb_agg(jsonb_build_object('id', s.id, 'label', s.subinsight_name))
    FROM community_guidelines_subinsight s
    WHERE s.id = ANY(sub_community_guidelines.sub_insights)
      AND s.status NOT IN (5, 6)
  ), '[]'::jsonb)::jsonb AS community_guidelines_subinsight

FROM sub_community_guidelines 
JOIN sub_communities ON sub_community_guidelines.sub_community_id = sub_communities.id
JOIN communities ON sub_community_guidelines.community_id = communities.id
JOIN cities ON cities.id = sub_community_guidelines.city_id
JOIN states ON states.id = sub_community_guidelines.state_id
JOIN countries ON countries.id = sub_community_guidelines.country_id
WHERE sub_community_guidelines.status NOT IN (5, 6)
ORDER BY sub_community_guidelines.id desc
LIMIT $2
OFFSET $1
`

type GetSubCommunityGuidesLinesParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetSubCommunityGuidesLinesRow struct {
	ID                            int64              `json:"id"`
	CountryID                     int64              `json:"country_id"`
	StateID                       int64              `json:"state_id"`
	CityID                        int64              `json:"city_id"`
	CommunityID                   int64              `json:"community_id"`
	SubCommunityID                int64              `json:"sub_community_id"`
	CoverImage                    string             `json:"cover_image"`
	Insights                      []int64            `json:"insights"`
	SubInsights                   []int64            `json:"sub_insights"`
	Status                        int64              `json:"status"`
	About                         pgtype.Text        `json:"about"`
	CreatedAt                     time.Time          `json:"created_at"`
	UpdateAt                      time.Time          `json:"update_at"`
	DeletedAt                     pgtype.Timestamptz `json:"deleted_at"`
	SubCommunity                  string             `json:"sub_community"`
	Community                     string             `json:"community"`
	City                          string             `json:"city"`
	State                         string             `json:"state"`
	Country                       string             `json:"country"`
	CommunityGuidelinesInsight    []byte             `json:"community_guidelines_insight"`
	CommunityGuidelinesSubinsight []byte             `json:"community_guidelines_subinsight"`
}

// AND communities.status NOT IN (5, 6)
func (q *Queries) GetSubCommunityGuidesLines(ctx context.Context, arg GetSubCommunityGuidesLinesParams) ([]GetSubCommunityGuidesLinesRow, error) {
	rows, err := q.db.Query(ctx, getSubCommunityGuidesLines, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubCommunityGuidesLinesRow
	for rows.Next() {
		var i GetSubCommunityGuidesLinesRow
		if err := rows.Scan(
			&i.ID,
			&i.CountryID,
			&i.StateID,
			&i.CityID,
			&i.CommunityID,
			&i.SubCommunityID,
			&i.CoverImage,
			&i.Insights,
			&i.SubInsights,
			&i.Status,
			&i.About,
			&i.CreatedAt,
			&i.UpdateAt,
			&i.DeletedAt,
			&i.SubCommunity,
			&i.Community,
			&i.City,
			&i.State,
			&i.Country,
			&i.CommunityGuidelinesInsight,
			&i.CommunityGuidelinesSubinsight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubCommunityGuidesLinesCount = `-- name: GetSubCommunityGuidesLinesCount :one
SELECT 
  COUNT(DISTINCT sub_community_guidelines.id)
FROM sub_community_guidelines 
JOIN sub_communities ON sub_community_guidelines.sub_community_id = sub_communities.id
JOIN communities ON sub_community_guidelines.community_id = communities.id
JOIN cities ON cities.id = sub_community_guidelines.city_id
JOIN states ON states.id = sub_community_guidelines.state_id
JOIN countries ON countries.id = sub_community_guidelines.country_id
WHERE sub_community_guidelines.status NOT IN (5, 6)
  AND sub_communities.status NOT IN (5, 6)
`

func (q *Queries) GetSubCommunityGuidesLinesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getSubCommunityGuidesLinesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listSubCommunityGuidelines = `-- name: ListSubCommunityGuidelines :many
SELECT id, country_id, state_id, city_id, community_id, sub_community_id, description, cover_image, insights, sub_insights, status, about, created_at, update_at, deleted_at FROM sub_community_guidelines
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListSubCommunityGuidelinesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSubCommunityGuidelines(ctx context.Context, arg ListSubCommunityGuidelinesParams) ([]SubCommunityGuideline, error) {
	rows, err := q.db.Query(ctx, listSubCommunityGuidelines, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubCommunityGuideline
	for rows.Next() {
		var i SubCommunityGuideline
		if err := rows.Scan(
			&i.ID,
			&i.CountryID,
			&i.StateID,
			&i.CityID,
			&i.CommunityID,
			&i.SubCommunityID,
			&i.Description,
			&i.CoverImage,
			&i.Insights,
			&i.SubInsights,
			&i.Status,
			&i.About,
			&i.CreatedAt,
			&i.UpdateAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubCommunityGuideline = `-- name: UpdateSubCommunityGuideline :one
UPDATE sub_community_guidelines
SET 
  country_id = $2,
  state_id = $3,
  city_id = $4,
  community_id = $5,
  sub_community_id = $6,
  description = $7,
  cover_image = $8,
  insights = $9,
  sub_insights = $10,
  status = $11,
  about = $12,
  created_at = $13,
  update_at = $14,
  deleted_at = $15
WHERE id = $1
RETURNING id, country_id, state_id, city_id, community_id, sub_community_id, description, cover_image, insights, sub_insights, status, about, created_at, update_at, deleted_at
`

type UpdateSubCommunityGuidelineParams struct {
	ID             int64              `json:"id"`
	CountryID      int64              `json:"country_id"`
	StateID        int64              `json:"state_id"`
	CityID         int64              `json:"city_id"`
	CommunityID    int64              `json:"community_id"`
	SubCommunityID int64              `json:"sub_community_id"`
	Description    string             `json:"description"`
	CoverImage     string             `json:"cover_image"`
	Insights       []int64            `json:"insights"`
	SubInsights    []int64            `json:"sub_insights"`
	Status         int64              `json:"status"`
	About          pgtype.Text        `json:"about"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdateAt       time.Time          `json:"update_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) UpdateSubCommunityGuideline(ctx context.Context, arg UpdateSubCommunityGuidelineParams) (SubCommunityGuideline, error) {
	row := q.db.QueryRow(ctx, updateSubCommunityGuideline,
		arg.ID,
		arg.CountryID,
		arg.StateID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.Description,
		arg.CoverImage,
		arg.Insights,
		arg.SubInsights,
		arg.Status,
		arg.About,
		arg.CreatedAt,
		arg.UpdateAt,
		arg.DeletedAt,
	)
	var i SubCommunityGuideline
	err := row.Scan(
		&i.ID,
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.CommunityID,
		&i.SubCommunityID,
		&i.Description,
		&i.CoverImage,
		&i.Insights,
		&i.SubInsights,
		&i.Status,
		&i.About,
		&i.CreatedAt,
		&i.UpdateAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSubCommunityGuidelinesStatus = `-- name: UpdateSubCommunityGuidelinesStatus :one
UPDATE sub_community_guidelines
SET 
    status=$1,
    update_at=$2,
    deleted_at=$3
WHERE id=$4
RETURNING id, country_id, state_id, city_id, community_id, sub_community_id, description, cover_image, insights, sub_insights, status, about, created_at, update_at, deleted_at
`

type UpdateSubCommunityGuidelinesStatusParams struct {
	Status    int64              `json:"status"`
	UpdateAt  time.Time          `json:"update_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	ID        int64              `json:"id"`
}

func (q *Queries) UpdateSubCommunityGuidelinesStatus(ctx context.Context, arg UpdateSubCommunityGuidelinesStatusParams) (SubCommunityGuideline, error) {
	row := q.db.QueryRow(ctx, updateSubCommunityGuidelinesStatus,
		arg.Status,
		arg.UpdateAt,
		arg.DeletedAt,
		arg.ID,
	)
	var i SubCommunityGuideline
	err := row.Scan(
		&i.ID,
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.CommunityID,
		&i.SubCommunityID,
		&i.Description,
		&i.CoverImage,
		&i.Insights,
		&i.SubInsights,
		&i.Status,
		&i.About,
		&i.CreatedAt,
		&i.UpdateAt,
		&i.DeletedAt,
	)
	return i, err
}
