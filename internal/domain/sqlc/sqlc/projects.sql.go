// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: projects.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    project_name,
    ref_number,
    no_of_views,
    is_verified,
    project_rank,
    addresses_id,
    status,
    developer_companies_id,
    developer_company_branches_id,
    countries_id,
    created_at,
    updated_at,
    is_multiphase,
    live_status,
    project_no,
    license_no,
    users_id,
    description,
    description_arabic,
    rating,
    polygon_coords, 
    facts,
    bank_name,
    registration_date,
    escrow_number
)VALUES (
    $1 ,$2,$3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22,$23, $24, $25
) RETURNING id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at
`

type CreateProjectParams struct {
	ProjectName                string      `json:"project_name"`
	RefNumber                  string      `json:"ref_number"`
	NoOfViews                  int64       `json:"no_of_views"`
	IsVerified                 pgtype.Bool `json:"is_verified"`
	ProjectRank                int64       `json:"project_rank"`
	AddressesID                int64       `json:"addresses_id"`
	Status                     int64       `json:"status"`
	DeveloperCompaniesID       int64       `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8 `json:"developer_company_branches_id"`
	CountriesID                int64       `json:"countries_id"`
	CreatedAt                  time.Time   `json:"created_at"`
	UpdatedAt                  time.Time   `json:"updated_at"`
	IsMultiphase               pgtype.Bool `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool `json:"live_status"`
	ProjectNo                  string      `json:"project_no"`
	LicenseNo                  string      `json:"license_no"`
	UsersID                    int64       `json:"users_id"`
	Description                string      `json:"description"`
	DescriptionArabic          pgtype.Text `json:"description_arabic"`
	Rating                     float64     `json:"rating"`
	PolygonCoords              []byte      `json:"polygon_coords"`
	Facts                      []byte      `json:"facts"`
	BankName                   pgtype.Text `json:"bank_name"`
	RegistrationDate           pgtype.Date `json:"registration_date"`
	EscrowNumber               pgtype.Text `json:"escrow_number"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.ProjectName,
		arg.RefNumber,
		arg.NoOfViews,
		arg.IsVerified,
		arg.ProjectRank,
		arg.AddressesID,
		arg.Status,
		arg.DeveloperCompaniesID,
		arg.DeveloperCompanyBranchesID,
		arg.CountriesID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsMultiphase,
		arg.LiveStatus,
		arg.ProjectNo,
		arg.LicenseNo,
		arg.UsersID,
		arg.Description,
		arg.DescriptionArabic,
		arg.Rating,
		arg.PolygonCoords,
		arg.Facts,
		arg.BankName,
		arg.RegistrationDate,
		arg.EscrowNumber,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const getAllProjec = `-- name: GetAllProjec :many
select id from projects
`

func (q *Queries) GetAllProjec(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllProjec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProject = `-- name: GetAllProject :many
SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at FROM projects
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllProjectParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProject(ctx context.Context, arg GetAllProjectParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getAllProject, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectByCompanyId = `-- name: GetAllProjectByCompanyId :many
SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at FROM projects
Where developer_companies_id = $1 AND (status != 5 AND status != 6)
ORDER BY id
LIMIT $2
OFFSET $3
`

type GetAllProjectByCompanyIdParams struct {
	DeveloperCompaniesID int64 `json:"developer_companies_id"`
	Limit                int32 `json:"limit"`
	Offset               int32 `json:"offset"`
}

func (q *Queries) GetAllProjectByCompanyId(ctx context.Context, arg GetAllProjectByCompanyIdParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getAllProjectByCompanyId, arg.DeveloperCompaniesID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectByCompanyIdCount = `-- name: GetAllProjectByCompanyIdCount :one
SELECT COUNT(*) from projects
WHERE developer_companies_id = $1 AND (status != 5 AND status != 6)
LIMIT 1
`

func (q *Queries) GetAllProjectByCompanyIdCount(ctx context.Context, developerCompaniesID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAllProjectByCompanyIdCount, developerCompaniesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllProjectDetailsWithAdvancedFilter = `-- name: GetAllProjectDetailsWithAdvancedFilter :many
select p.id, p.project_name, pm.id as "image_id", pm.file_urls, pf.starting_price, p.is_verified, p.project_rank, p.rating, p.ref_number, pf.completion_percentage, c.id as "city_id", c.city, com.id as "community_id", com.community, scom.id as "subcommunity_id", scom.sub_community, p.created_at, pf.built_up_area from projects p join properties_facts pf on pf.project_id = p.id and pf.is_project_fact is true
left join addresses a on p.addresses_id = a.id
LEFT JOIN states s on a.states_id = s.id
left join cities c on a.cities_id = c.id
left join communities com on a.communities_id = com.id
left join sub_communities scom on a.sub_communities_id = scom.id
left join project_media pm on p.id = pm.projects_id and pm.gallery_type = 'Main' and pm.media_type = 1
where (pf.starting_price >= $3 or $4) AND (pf.starting_price <= $5 or $6) and (p.is_verified = $7 or $8::BOOLEAN) and 
(CASE WHEN ARRAY_LENGTH($9::BIGINT[], 1) IS NULL THEN TRUE ELSE pf.completion_status = ANY($9::BIGINT[]) END) AND
(CASE WHEN ARRAY_LENGTH($10::BIGINT[], 1) IS NULL THEN TRUE ELSE p.project_rank = ANY($10::bigint[]) END) AND p.status!= 6 AND 
s.id = $11::bigint AND
(CASE WHEN ARRAY_LENGTH($12::VARCHAR[], 1) IS NULL THEN TRUE ELSE p.ref_number  ILIKE ANY($12::VARCHAR[]) OR p.project_name ILIKE ANY($12::VARCHAR[]) OR p.description ILIKE ANY($12::VARCHAR[]) OR  p.description_arabic ILIKE ANY($12::VARCHAR[]) END) AND
(CASE WHEN ARRAY_LENGTH($13::bigint[], 1) IS NULL THEN TRUE ELSE p.amenities_id && $13::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($14::bigint[], 1) IS NULL THEN TRUE ELSE p.facilities_id && $14::bigint[] END) AND
(CASE WHEN COALESCE($15::BIGINT,1) =1 THEN true WHEN $15::BIGINT= 2 THEN p.created_at >= DATE_TRUNC('day', CURRENT_DATE) WHEN $15::BIGINT = 3 THEN p.created_at >= DATE_TRUNC('week', CURRENT_DATE - INTERVAL '1 week')
	  AND p.created_at < DATE_TRUNC('week', CURRENT_DATE) WHEN $15::BIGINT = 4 THEN p.created_at >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
	  AND p.created_at < DATE_TRUNC('month', CURRENT_DATE) END) AND 
(CASE WHEN ARRAY_LENGTH($16::bigint[], 1) IS NULL THEN TRUE ELSE c.id = ANY($16::bigint[]) END)  AND 
(CASE WHEN ARRAY_LENGTH($17::bigint[], 1) IS NULL THEN TRUE ELSE com.id = ANY($17::bigint[])END) AND 
(CASE WHEN ARRAY_LENGTH($18::bigint[], 1) IS NULL THEN TRUE ELSE scom.id = ANY($18::bigint[]) END) AND 
(((select count(*) from sale_unit su
left join unit_facts uf on su.unit_facts_id = uf.id
left join units u on su.unit_id = u.id
where 
(CASE WHEN ARRAY_LENGTH($19::varchar[], 1) IS NULL THEN TRUE ELSE uf.bedroom = ANY($19::varchar[]) END) AND
(CASE WHEN ARRAY_LENGTH($20::bigint[], 1) IS NULL THEN TRUE ELSE uf.bathroom = ANY($20::bigint[]) END) AND
(CASE WHEN $21::FLOAT =-1 AND $22::FLOAT =-1 THEN true ELSE  uf.plot_area BETWEEN $21 ::FLOAT AND $22::FLOAT END) AND
(CASE WHEN $23::FLOAT =-1 AND  $24::FLOAT =-1 THEN true ELSE uf.built_up_area BETWEEN $23::FLOAT AND $24::FLOAT END) AND
(CASE WHEN ARRAY_LENGTH($25::BIGINT[], 1) IS NULL THEN TRUE ELSE uf.no_of_payment = ANY($25::BIGINT[]) END) AND
(CASE WHEN ARRAY_LENGTH($26::BIGINT[], 1) IS NULL THEN TRUE ELSE uf.ownership = ANY($26::BIGINT[]) END) AND
(CASE WHEN $27::BIGINT = -1 AND $28::BIGINT =-1 THEN true ELSE uf.service_charge BETWEEN $27::BIGINT AND $28::BIGINT END) AND
(CASE WHEN ARRAY_LENGTH($29::bigint[], 1) IS NULL THEN TRUE ELSE uf.furnished = ANY($29::bigint[]) END) AND
(CASE WHEN ARRAY_LENGTH($30::bigint[], 1) IS NULL THEN TRUE ELSE uf.parking = ANY($30::bigint[]) END) AND
(CASE WHEN ARRAY_LENGTH($31::bigint[], 1) IS NULL THEN TRUE ELSE uf.view && $31::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($13::bigint[], 1) IS NULL THEN TRUE ELSE u.amenities_id && $13::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($32::bigint[], 1) IS NULL THEN TRUE ELSE u.property_types_id = ANY($32::bigint[]) END) AND 
u.property = 1 AND su.status != 6 AND
u.properties_id IN (select pp.id from project_properties pp where pp.projects_id = p.id)

)
+
(select count(*) from sale_unit su
left join unit_facts uf on su.unit_facts_id = uf.id
left join units u on su.unit_id = u.id
where 
(CASE WHEN ARRAY_LENGTH($19::varchar[], 1) IS NULL THEN TRUE ELSE uf.bedroom = ANY($19::varchar[]) END) AND
(CASE WHEN ARRAY_LENGTH($20::bigint[], 1) IS NULL THEN TRUE ELSE uf.bathroom = ANY($20::bigint[]) END) AND
(CASE WHEN $21::FLOAT =-1 AND $22::FLOAT =-1 THEN true ELSE  uf.plot_area BETWEEN $21 ::FLOAT AND $22::FLOAT END) AND
(CASE WHEN $23::FLOAT =-1 AND  $24::FLOAT =-1 THEN true ELSE uf.built_up_area BETWEEN $23::FLOAT AND $24::FLOAT END) AND
(CASE WHEN ARRAY_LENGTH($25::BIGINT[], 1) IS NULL THEN TRUE ELSE uf.no_of_payment = ANY($25::BIGINT[]) END) AND
(CASE WHEN ARRAY_LENGTH($26::BIGINT[], 1) IS NULL THEN TRUE ELSE uf.ownership = ANY($26::BIGINT[]) END) AND
(CASE WHEN $27::BIGINT = -1 AND $28::BIGINT =-1 THEN true ELSE uf.service_charge BETWEEN $27::BIGINT AND $28::BIGINT END) AND
(CASE WHEN ARRAY_LENGTH($29::bigint[], 1) IS NULL THEN TRUE ELSE uf.furnished = ANY($29::bigint[]) END) AND
(CASE WHEN ARRAY_LENGTH($30::bigint[], 1) IS NULL THEN TRUE ELSE uf.parking = ANY($30::bigint[]) END) AND
(CASE WHEN ARRAY_LENGTH($31::bigint[], 1) IS NULL THEN TRUE ELSE uf.view && $31::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($13::bigint[], 1) IS NULL THEN TRUE ELSE u.amenities_id && $13::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($32::bigint[], 1) IS NULL THEN TRUE ELSE u.property_types_id = ANY($32::bigint[]) END) AND 
u.property = 1 AND su.status != 6 AND
u.properties_id IN (select pp.id from project_properties pp where pp.projects_id = p.id)
)
) > 0) 
ORDER BY 
    CASE 
        WHEN $33::bigint = 1 THEN p.project_rank END ASC,
    CASE
        WHEN $33::bigint = 2 THEN p.created_at END DESC,
    CASE 
        WHEN $33::bigint = 3 THEN pf.starting_price END DESC,
    CASE
        WHEN $33::bigint = 4 THEN pf.starting_price END ASC LIMIT $1 OFFSET $2
`

type GetAllProjectDetailsWithAdvancedFilterParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	MinPrice          pgtype.Int8 `json:"min_price"`
	DisableMinPrice   interface{} `json:"disable_min_price"`
	MaxPrice          pgtype.Int8 `json:"max_price"`
	DisableMaxPrice   interface{} `json:"disable_max_price"`
	IsVerified        pgtype.Bool `json:"is_verified"`
	DisableIsVerified bool        `json:"disable_is_verified"`
	CompletionStatus  []int64     `json:"completion_status"`
	ProjectRanks      []int64     `json:"project_ranks"`
	StateID           int64       `json:"state_id"`
	Keywords          []string    `json:"keywords"`
	Amenities         []int64     `json:"amenities"`
	Facilities        []int64     `json:"facilities"`
	Dates             int64       `json:"dates"`
	CitiesID          []int64     `json:"cities_id"`
	CommunitiesID     []int64     `json:"communities_id"`
	SubcommunitiesID  []int64     `json:"subcommunities_id"`
	Bedroom           []string    `json:"bedroom"`
	Bathroom          []int64     `json:"bathroom"`
	MinPlotArea       float64     `json:"min_plot_area"`
	MaxPlotArea       float64     `json:"max_plot_area"`
	MinBuiltUpArea    float64     `json:"min_built_up_area"`
	MaxBuiltUpArea    float64     `json:"max_built_up_area"`
	NoOfPayment       []int64     `json:"no_of_payment"`
	Ownership         []int64     `json:"ownership"`
	MinServiceCharge  int64       `json:"min_service_charge"`
	MaxServiceCharge  int64       `json:"max_service_charge"`
	Furnished         []int64     `json:"furnished"`
	Parking           []int64     `json:"parking"`
	View              []int64     `json:"view"`
	TypeNames         []int64     `json:"type_names"`
	Sort              int64       `json:"sort"`
}

type GetAllProjectDetailsWithAdvancedFilterRow struct {
	ID                   int64         `json:"id"`
	ProjectName          string        `json:"project_name"`
	ImageID              pgtype.Int8   `json:"image_id"`
	FileUrls             []string      `json:"file_urls"`
	StartingPrice        pgtype.Int8   `json:"starting_price"`
	IsVerified           pgtype.Bool   `json:"is_verified"`
	ProjectRank          int64         `json:"project_rank"`
	Rating               float64       `json:"rating"`
	RefNumber            string        `json:"ref_number"`
	CompletionPercentage pgtype.Int8   `json:"completion_percentage"`
	CityID               pgtype.Int8   `json:"city_id"`
	City                 pgtype.Text   `json:"city"`
	CommunityID          pgtype.Int8   `json:"community_id"`
	Community            pgtype.Text   `json:"community"`
	SubcommunityID       pgtype.Int8   `json:"subcommunity_id"`
	SubCommunity         pgtype.Text   `json:"sub_community"`
	CreatedAt            time.Time     `json:"created_at"`
	BuiltUpArea          pgtype.Float8 `json:"built_up_area"`
}

func (q *Queries) GetAllProjectDetailsWithAdvancedFilter(ctx context.Context, arg GetAllProjectDetailsWithAdvancedFilterParams) ([]GetAllProjectDetailsWithAdvancedFilterRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectDetailsWithAdvancedFilter,
		arg.Limit,
		arg.Offset,
		arg.MinPrice,
		arg.DisableMinPrice,
		arg.MaxPrice,
		arg.DisableMaxPrice,
		arg.IsVerified,
		arg.DisableIsVerified,
		arg.CompletionStatus,
		arg.ProjectRanks,
		arg.StateID,
		arg.Keywords,
		arg.Amenities,
		arg.Facilities,
		arg.Dates,
		arg.CitiesID,
		arg.CommunitiesID,
		arg.SubcommunitiesID,
		arg.Bedroom,
		arg.Bathroom,
		arg.MinPlotArea,
		arg.MaxPlotArea,
		arg.MinBuiltUpArea,
		arg.MaxBuiltUpArea,
		arg.NoOfPayment,
		arg.Ownership,
		arg.MinServiceCharge,
		arg.MaxServiceCharge,
		arg.Furnished,
		arg.Parking,
		arg.View,
		arg.TypeNames,
		arg.Sort,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectDetailsWithAdvancedFilterRow
	for rows.Next() {
		var i GetAllProjectDetailsWithAdvancedFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.ImageID,
			&i.FileUrls,
			&i.StartingPrice,
			&i.IsVerified,
			&i.ProjectRank,
			&i.Rating,
			&i.RefNumber,
			&i.CompletionPercentage,
			&i.CityID,
			&i.City,
			&i.CommunityID,
			&i.Community,
			&i.SubcommunityID,
			&i.SubCommunity,
			&i.CreatedAt,
			&i.BuiltUpArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectNames = `-- name: GetAllProjectNames :many
SELECT id,project_name FROM projects WHERE is_multiphase = $1 ORDER BY id
`

type GetAllProjectNamesRow struct {
	ID          int64  `json:"id"`
	ProjectName string `json:"project_name"`
}

func (q *Queries) GetAllProjectNames(ctx context.Context, isMultiphase pgtype.Bool) ([]GetAllProjectNamesRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectNames, isMultiphase)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectNamesRow
	for rows.Next() {
		var i GetAllProjectNamesRow
		if err := rows.Scan(&i.ID, &i.ProjectName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectRefrenceNumber = `-- name: GetAllProjectRefrenceNumber :many
SELECT ref_number FROM projects LIMIT $1 OFFSET $2
`

type GetAllProjectRefrenceNumberParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProjectRefrenceNumber(ctx context.Context, arg GetAllProjectRefrenceNumberParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllProjectRefrenceNumber, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var ref_number string
		if err := rows.Scan(&ref_number); err != nil {
			return nil, err
		}
		items = append(items, ref_number)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectsByRank = `-- name: GetAllProjectsByRank :many
SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at FROM projects 
Where project_rank = $3 ORDER BY id LIMIT $1 OFFSET $2
`

type GetAllProjectsByRankParams struct {
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
	ProjectRank int64 `json:"project_rank"`
}

func (q *Queries) GetAllProjectsByRank(ctx context.Context, arg GetAllProjectsByRankParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getAllProjectsByRank, arg.Limit, arg.Offset, arg.ProjectRank)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectsByRanksAndIsVerified = `-- name: GetAllProjectsByRanksAndIsVerified :many
SELECT id,project_name,ref_number,no_of_views,is_verified,project_rank,addresses_id,status,developer_companies_id,developer_company_branches_id,countries_id,created_at,updated_at,is_multiphase,live_status,project_no,license_no, bank_name, registration_date, escrow_number
FROM projects WHERE is_verified=$3 AND project_rank  = ANY($4::bigint[])  AND status!=5 AND status!=6 ORDER BY is_verified DESC,CASE project_rank WHEN 4 THEN 1 WHEN 3 THEN 2 WHEN 2 THEN 3 WHEN 1 THEN 4 ELSE 5 END LIMIT $1 OFFSET $2
`

type GetAllProjectsByRanksAndIsVerifiedParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	IsVerified pgtype.Bool `json:"is_verified"`
	Column4    []int64     `json:"column_4"`
}

type GetAllProjectsByRanksAndIsVerifiedRow struct {
	ID                         int64       `json:"id"`
	ProjectName                string      `json:"project_name"`
	RefNumber                  string      `json:"ref_number"`
	NoOfViews                  int64       `json:"no_of_views"`
	IsVerified                 pgtype.Bool `json:"is_verified"`
	ProjectRank                int64       `json:"project_rank"`
	AddressesID                int64       `json:"addresses_id"`
	Status                     int64       `json:"status"`
	DeveloperCompaniesID       int64       `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8 `json:"developer_company_branches_id"`
	CountriesID                int64       `json:"countries_id"`
	CreatedAt                  time.Time   `json:"created_at"`
	UpdatedAt                  time.Time   `json:"updated_at"`
	IsMultiphase               pgtype.Bool `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool `json:"live_status"`
	ProjectNo                  string      `json:"project_no"`
	LicenseNo                  string      `json:"license_no"`
	BankName                   pgtype.Text `json:"bank_name"`
	RegistrationDate           pgtype.Date `json:"registration_date"`
	EscrowNumber               pgtype.Text `json:"escrow_number"`
}

func (q *Queries) GetAllProjectsByRanksAndIsVerified(ctx context.Context, arg GetAllProjectsByRanksAndIsVerifiedParams) ([]GetAllProjectsByRanksAndIsVerifiedRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectsByRanksAndIsVerified,
		arg.Limit,
		arg.Offset,
		arg.IsVerified,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectsByRanksAndIsVerifiedRow
	for rows.Next() {
		var i GetAllProjectsByRanksAndIsVerifiedRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectsForMobile = `-- name: GetAllProjectsForMobile :many
SELECT id,project_name,ref_number,no_of_views,is_verified,project_rank,addresses_id,status,developer_companies_id,developer_company_branches_id,countries_id,created_at,updated_at,is_multiphase,live_status,project_no,license_no,bank_name, registration_date, escrow_number
FROM projects where status!=5 and status!=6 ORDER BY is_verified desc,CASE project_rank WHEN 4 THEN 1 WHEN 3 THEN 2 WHEN 2 THEN 3 WHEN 1 THEN 4 ELSE 5 END limit $1 offset $2
`

type GetAllProjectsForMobileParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllProjectsForMobileRow struct {
	ID                         int64       `json:"id"`
	ProjectName                string      `json:"project_name"`
	RefNumber                  string      `json:"ref_number"`
	NoOfViews                  int64       `json:"no_of_views"`
	IsVerified                 pgtype.Bool `json:"is_verified"`
	ProjectRank                int64       `json:"project_rank"`
	AddressesID                int64       `json:"addresses_id"`
	Status                     int64       `json:"status"`
	DeveloperCompaniesID       int64       `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8 `json:"developer_company_branches_id"`
	CountriesID                int64       `json:"countries_id"`
	CreatedAt                  time.Time   `json:"created_at"`
	UpdatedAt                  time.Time   `json:"updated_at"`
	IsMultiphase               pgtype.Bool `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool `json:"live_status"`
	ProjectNo                  string      `json:"project_no"`
	LicenseNo                  string      `json:"license_no"`
	BankName                   pgtype.Text `json:"bank_name"`
	RegistrationDate           pgtype.Date `json:"registration_date"`
	EscrowNumber               pgtype.Text `json:"escrow_number"`
}

func (q *Queries) GetAllProjectsForMobile(ctx context.Context, arg GetAllProjectsForMobileParams) ([]GetAllProjectsForMobileRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectsForMobile, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectsForMobileRow
	for rows.Next() {
		var i GetAllProjectsForMobileRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectsForMobileIsVerified = `-- name: GetAllProjectsForMobileIsVerified :many
SELECT id,project_name,ref_number,no_of_views,is_verified,project_rank,addresses_id,status,developer_companies_id,developer_company_branches_id,countries_id,created_at,updated_at,is_multiphase,live_status,project_no,license_no,bank_name, registration_date, escrow_number FROM projects where status!=5 and is_verified=$3 and status!=6 ORDER BY is_verified desc,CASE project_rank WHEN 4 THEN 1 WHEN 3 THEN 2 WHEN 2 THEN 3 WHEN 1 THEN 4 ELSE 5 END limit $1 offset $2
`

type GetAllProjectsForMobileIsVerifiedParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	IsVerified pgtype.Bool `json:"is_verified"`
}

type GetAllProjectsForMobileIsVerifiedRow struct {
	ID                         int64       `json:"id"`
	ProjectName                string      `json:"project_name"`
	RefNumber                  string      `json:"ref_number"`
	NoOfViews                  int64       `json:"no_of_views"`
	IsVerified                 pgtype.Bool `json:"is_verified"`
	ProjectRank                int64       `json:"project_rank"`
	AddressesID                int64       `json:"addresses_id"`
	Status                     int64       `json:"status"`
	DeveloperCompaniesID       int64       `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8 `json:"developer_company_branches_id"`
	CountriesID                int64       `json:"countries_id"`
	CreatedAt                  time.Time   `json:"created_at"`
	UpdatedAt                  time.Time   `json:"updated_at"`
	IsMultiphase               pgtype.Bool `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool `json:"live_status"`
	ProjectNo                  string      `json:"project_no"`
	LicenseNo                  string      `json:"license_no"`
	BankName                   pgtype.Text `json:"bank_name"`
	RegistrationDate           pgtype.Date `json:"registration_date"`
	EscrowNumber               pgtype.Text `json:"escrow_number"`
}

func (q *Queries) GetAllProjectsForMobileIsVerified(ctx context.Context, arg GetAllProjectsForMobileIsVerifiedParams) ([]GetAllProjectsForMobileIsVerifiedRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectsForMobileIsVerified, arg.Limit, arg.Offset, arg.IsVerified)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectsForMobileIsVerifiedRow
	for rows.Next() {
		var i GetAllProjectsForMobileIsVerifiedRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectsRefNo = `-- name: GetAllProjectsRefNo :many
SELECT id,ref_number FROM projects  LIMIT $1 OFFSET $2
`

type GetAllProjectsRefNoParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllProjectsRefNoRow struct {
	ID        int64  `json:"id"`
	RefNumber string `json:"ref_number"`
}

func (q *Queries) GetAllProjectsRefNo(ctx context.Context, arg GetAllProjectsRefNoParams) ([]GetAllProjectsRefNoRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectsRefNo, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectsRefNoRow
	for rows.Next() {
		var i GetAllProjectsRefNoRow
		if err := rows.Scan(&i.ID, &i.RefNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedProjectPropertyByIds = `-- name: GetAllSharedProjectPropertyByIds :many



WITH project_property_ids AS (
  SELECT unnest($1::bigint[]) AS id,
         row_number() OVER () AS rn
)
SELECT p.id, p.ref_no, p.is_multiphase, p.phases_id, p.projects_id, p.property_name
FROM project_properties p
CROSS JOIN project_property_ids ppi
WHERE p.id = ppi.id
ORDER BY ppi.rn
`

type GetAllSharedProjectPropertyByIdsRow struct {
	ID           int64       `json:"id"`
	RefNo        string      `json:"ref_no"`
	IsMultiphase pgtype.Bool `json:"is_multiphase"`
	PhasesID     pgtype.Int8 `json:"phases_id"`
	ProjectsID   int64       `json:"projects_id"`
	PropertyName string      `json:"property_name"`
}

// SELECT p.id, p.ref_number, p.project_name, p.is_multiphase, p.description, p.addresses_id,
//
//	dc.company_name, pr.project_clean, pr.project_location, pr.project_facilities, pr.project_securities,
//	pf.completion_percentage, (SELECT COUNT(*) FROM phases ph WHERE ph.projects_id = p.id) AS no_of_phases
//
// FROM projects p
// CROSS JOIN LATERAL UNNEST($1::bigint[]) AS arr(value)
// LEFT JOIN developer_companies dc ON p.developer_companies_id = dc.id
// LEFT JOIN project_reviews pr ON pr.projects_id = p.id
// LEFT JOIN properties_facts pf ON pf.project_id = p.id AND pf.is_project_fact = TRUE
// WHERE p.id = arr.value;
func (q *Queries) GetAllSharedProjectPropertyByIds(ctx context.Context, dollar_1 []int64) ([]GetAllSharedProjectPropertyByIdsRow, error) {
	rows, err := q.db.Query(ctx, getAllSharedProjectPropertyByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSharedProjectPropertyByIdsRow
	for rows.Next() {
		var i GetAllSharedProjectPropertyByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.IsMultiphase,
			&i.PhasesID,
			&i.ProjectsID,
			&i.PropertyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedProjectsByIds = `-- name: GetAllSharedProjectsByIds :many
WITH project_ids AS (
    SELECT unnest($1::bigint[]) AS id, row_number() OVER () AS rn
)
SELECT p.id, p.ref_number, p.project_name, p.is_multiphase, p.description, p.addresses_id,
       dc.company_name, pr.project_clean, pr.project_location, pr.project_facilities,
       pr.project_securities, pf.completion_percentage, pf.completion_status,p.bank_name, p.registration_date, p.escrow_number,
       (SELECT COUNT(*) FROM phases ph WHERE ph.projects_id = p.id) AS no_of_phases
FROM projects p
CROSS JOIN project_ids pi
LEFT JOIN developer_companies dc ON p.developer_companies_id = dc.id
LEFT JOIN project_reviews pr ON pr.projects_id = p.id
LEFT JOIN properties_facts pf ON pf.project_id = p.id AND pf.is_project_fact = TRUE
WHERE p.id = pi.id
ORDER BY pi.rn
`

type GetAllSharedProjectsByIdsRow struct {
	ID                   int64         `json:"id"`
	RefNumber            string        `json:"ref_number"`
	ProjectName          string        `json:"project_name"`
	IsMultiphase         pgtype.Bool   `json:"is_multiphase"`
	Description          string        `json:"description"`
	AddressesID          int64         `json:"addresses_id"`
	CompanyName          pgtype.Text   `json:"company_name"`
	ProjectClean         pgtype.Float8 `json:"project_clean"`
	ProjectLocation      pgtype.Float8 `json:"project_location"`
	ProjectFacilities    pgtype.Float8 `json:"project_facilities"`
	ProjectSecurities    pgtype.Float8 `json:"project_securities"`
	CompletionPercentage pgtype.Int8   `json:"completion_percentage"`
	CompletionStatus     pgtype.Int8   `json:"completion_status"`
	BankName             pgtype.Text   `json:"bank_name"`
	RegistrationDate     pgtype.Date   `json:"registration_date"`
	EscrowNumber         pgtype.Text   `json:"escrow_number"`
	NoOfPhases           int64         `json:"no_of_phases"`
}

func (q *Queries) GetAllSharedProjectsByIds(ctx context.Context, dollar_1 []int64) ([]GetAllSharedProjectsByIdsRow, error) {
	rows, err := q.db.Query(ctx, getAllSharedProjectsByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSharedProjectsByIdsRow
	for rows.Next() {
		var i GetAllSharedProjectsByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNumber,
			&i.ProjectName,
			&i.IsMultiphase,
			&i.Description,
			&i.AddressesID,
			&i.CompanyName,
			&i.ProjectClean,
			&i.ProjectLocation,
			&i.ProjectFacilities,
			&i.ProjectSecurities,
			&i.CompletionPercentage,
			&i.CompletionStatus,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.NoOfPhases,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllProjectDetailsWithAdvancedFilter = `-- name: GetCountAllProjectDetailsWithAdvancedFilter :one
select count (p.*) from projects p join properties_facts pf on pf.project_id = p.id and pf.is_project_fact is true
left join addresses a on p.addresses_id = a.id
LEFT JOIN states s on a.states_id = s.id
left join cities c on a.cities_id = c.id
left join communities com on a.communities_id = com.id
left join sub_communities scom on a.sub_communities_id = scom.id
where (pf.starting_price >= $1 or $2) AND (pf.starting_price <= $3 or $4)  and (p.is_verified = $5 or $6::BOOLEAN) and
(CASE WHEN ARRAY_LENGTH($7::BIGINT[], 1) IS NULL THEN TRUE ELSE pf.completion_status = ANY($7::BIGINT[]) END) AND
(CASE WHEN ARRAY_LENGTH($8::BIGINT[], 1) IS NULL THEN TRUE ELSE p.project_rank = ANY($8::bigint[]) END) AND p.status!= 6 AND 
s.id = $9::bigint AND
(CASE WHEN ARRAY_LENGTH($10::VARCHAR[], 1) IS NULL THEN TRUE ELSE p.ref_number  ILIKE ANY($10::VARCHAR[]) OR p.project_name ILIKE ANY($10::VARCHAR[]) OR p.description ILIKE ANY($10::VARCHAR[]) OR  p.description_arabic ILIKE ANY($10::VARCHAR[]) END) AND
(CASE WHEN ARRAY_LENGTH($11::bigint[], 1) IS NULL THEN TRUE ELSE p.amenities_id && $11::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($12::bigint[], 1) IS NULL THEN TRUE ELSE p.facilities_id && $12::bigint[] END) AND
(CASE WHEN COALESCE($13::BIGINT,1) =1 THEN true WHEN $13::BIGINT= 2 THEN p.created_at >= DATE_TRUNC('day', CURRENT_DATE) WHEN $13::BIGINT = 3 THEN p.created_at >= DATE_TRUNC('week', CURRENT_DATE - INTERVAL '1 week')
	  AND p.created_at < DATE_TRUNC('week', CURRENT_DATE) WHEN $13::BIGINT = 4 THEN p.created_at >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
	  AND p.created_at < DATE_TRUNC('month', CURRENT_DATE) END) AND 
(CASE WHEN ARRAY_LENGTH($14::bigint[], 1) IS NULL THEN TRUE ELSE c.id = ANY($14::bigint[]) END)  AND 
(CASE WHEN ARRAY_LENGTH($15::bigint[], 1) IS NULL THEN TRUE ELSE com.id = ANY($15::bigint[])END) AND 
(CASE WHEN ARRAY_LENGTH($16::bigint[], 1) IS NULL THEN TRUE ELSE scom.id = ANY($16::bigint[]) END) AND 
(((select count(*) from sale_unit su
left join unit_facts uf on su.unit_facts_id = uf.id
left join units u on su.unit_id = u.id
where 
(CASE WHEN ARRAY_LENGTH($17::varchar[], 1) IS NULL THEN TRUE ELSE uf.bedroom = ANY($17::varchar[]) END) AND
(CASE WHEN ARRAY_LENGTH($18::bigint[], 1) IS NULL THEN TRUE ELSE uf.bathroom = ANY($18::bigint[]) END) AND
(CASE WHEN $19::FLOAT =-1 AND $20::FLOAT =-1 THEN true ELSE  uf.plot_area BETWEEN $19 ::FLOAT AND $20::FLOAT END) AND
(CASE WHEN $21::FLOAT =-1 AND  $22::FLOAT =-1 THEN true ELSE uf.built_up_area BETWEEN $21::FLOAT AND $22::FLOAT END) AND
(CASE WHEN ARRAY_LENGTH($23::BIGINT[], 1) IS NULL THEN TRUE ELSE uf.no_of_payment = ANY($23::BIGINT[]) END) AND
(CASE WHEN ARRAY_LENGTH($24::BIGINT[], 1) IS NULL THEN TRUE ELSE uf.ownership = ANY($24::BIGINT[]) END) AND
(CASE WHEN $25::BIGINT = -1 AND $26::BIGINT =-1 THEN true ELSE uf.service_charge BETWEEN $25::BIGINT AND $26::BIGINT END) AND
(CASE WHEN ARRAY_LENGTH($27::bigint[], 1) IS NULL THEN TRUE ELSE uf.furnished = ANY($27::bigint[]) END) AND
(CASE WHEN ARRAY_LENGTH($28::bigint[], 1) IS NULL THEN TRUE ELSE uf.parking = ANY($28::bigint[]) END) AND
(CASE WHEN ARRAY_LENGTH($29::bigint[], 1) IS NULL THEN TRUE ELSE uf.view && $29::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($11::bigint[], 1) IS NULL THEN TRUE ELSE u.amenities_id && $11::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($30::bigint[], 1) IS NULL THEN TRUE ELSE u.property_types_id = ANY($30::bigint[]) END) AND 
u.property = 1 AND su.status != 6 AND
u.properties_id IN (select pp.id from project_properties pp where pp.projects_id = p.id)

)
+
(select count(*) from sale_unit su
left join unit_facts uf on su.unit_facts_id = uf.id
left join units u on su.unit_id = u.id
where 
(CASE WHEN ARRAY_LENGTH($17::varchar[], 1) IS NULL THEN TRUE ELSE uf.bedroom = ANY($17::varchar[]) END) AND
(CASE WHEN ARRAY_LENGTH($18::bigint[], 1) IS NULL THEN TRUE ELSE uf.bathroom = ANY($18::bigint[]) END) AND
(CASE WHEN $19::FLOAT =-1 AND $20::FLOAT =-1 THEN true ELSE  uf.plot_area BETWEEN $19 ::FLOAT AND $20::FLOAT END) AND
(CASE WHEN $21::FLOAT =-1 AND  $22::FLOAT =-1 THEN true ELSE uf.built_up_area BETWEEN $21::FLOAT AND $22::FLOAT END) AND
(CASE WHEN ARRAY_LENGTH($23::BIGINT[], 1) IS NULL THEN TRUE ELSE uf.no_of_payment = ANY($23::BIGINT[]) END) AND
(CASE WHEN ARRAY_LENGTH($24::BIGINT[], 1) IS NULL THEN TRUE ELSE uf.ownership = ANY($24::BIGINT[]) END) AND
(CASE WHEN $25::BIGINT = -1 AND $26::BIGINT =-1 THEN true ELSE uf.service_charge BETWEEN $25::BIGINT AND $26::BIGINT END) AND
(CASE WHEN ARRAY_LENGTH($27::bigint[], 1) IS NULL THEN TRUE ELSE uf.furnished = ANY($27::bigint[]) END) AND
(CASE WHEN ARRAY_LENGTH($28::bigint[], 1) IS NULL THEN TRUE ELSE uf.parking = ANY($28::bigint[]) END) AND
(CASE WHEN ARRAY_LENGTH($29::bigint[], 1) IS NULL THEN TRUE ELSE uf.view && $29::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($11::bigint[], 1) IS NULL THEN TRUE ELSE u.amenities_id && $11::bigint[] END) AND
(CASE WHEN ARRAY_LENGTH($30::bigint[], 1) IS NULL THEN TRUE ELSE u.property_types_id = ANY($30::bigint[]) END) AND 
u.property = 1 AND su.status != 6 AND
u.properties_id IN (select pp.id from project_properties pp where pp.projects_id = p.id)
)
) > 0)
`

type GetCountAllProjectDetailsWithAdvancedFilterParams struct {
	MinPrice          pgtype.Int8 `json:"min_price"`
	DisableMinPrice   interface{} `json:"disable_min_price"`
	MaxPrice          pgtype.Int8 `json:"max_price"`
	DisableMaxPrice   interface{} `json:"disable_max_price"`
	IsVerified        pgtype.Bool `json:"is_verified"`
	DisableIsVerified bool        `json:"disable_is_verified"`
	CompletionStatus  []int64     `json:"completion_status"`
	ProjectRanks      []int64     `json:"project_ranks"`
	StateID           int64       `json:"state_id"`
	Keywords          []string    `json:"keywords"`
	Amenities         []int64     `json:"amenities"`
	Facilities        []int64     `json:"facilities"`
	Dates             int64       `json:"dates"`
	CitiesID          []int64     `json:"cities_id"`
	CommunitiesID     []int64     `json:"communities_id"`
	SubcommunitiesID  []int64     `json:"subcommunities_id"`
	Bedroom           []string    `json:"bedroom"`
	Bathroom          []int64     `json:"bathroom"`
	MinPlotArea       float64     `json:"min_plot_area"`
	MaxPlotArea       float64     `json:"max_plot_area"`
	MinBuiltUpArea    float64     `json:"min_built_up_area"`
	MaxBuiltUpArea    float64     `json:"max_built_up_area"`
	NoOfPayment       []int64     `json:"no_of_payment"`
	Ownership         []int64     `json:"ownership"`
	MinServiceCharge  int64       `json:"min_service_charge"`
	MaxServiceCharge  int64       `json:"max_service_charge"`
	Furnished         []int64     `json:"furnished"`
	Parking           []int64     `json:"parking"`
	View              []int64     `json:"view"`
	TypeNames         []int64     `json:"type_names"`
}

func (q *Queries) GetCountAllProjectDetailsWithAdvancedFilter(ctx context.Context, arg GetCountAllProjectDetailsWithAdvancedFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllProjectDetailsWithAdvancedFilter,
		arg.MinPrice,
		arg.DisableMinPrice,
		arg.MaxPrice,
		arg.DisableMaxPrice,
		arg.IsVerified,
		arg.DisableIsVerified,
		arg.CompletionStatus,
		arg.ProjectRanks,
		arg.StateID,
		arg.Keywords,
		arg.Amenities,
		arg.Facilities,
		arg.Dates,
		arg.CitiesID,
		arg.CommunitiesID,
		arg.SubcommunitiesID,
		arg.Bedroom,
		arg.Bathroom,
		arg.MinPlotArea,
		arg.MaxPlotArea,
		arg.MinBuiltUpArea,
		arg.MaxBuiltUpArea,
		arg.NoOfPayment,
		arg.Ownership,
		arg.MinServiceCharge,
		arg.MaxServiceCharge,
		arg.Furnished,
		arg.Parking,
		arg.View,
		arg.TypeNames,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllProjectsByRank = `-- name: GetCountAllProjectsByRank :one
SELECT COUNT(*) FROM projects 
Where project_rank = $1
`

func (q *Queries) GetCountAllProjectsByRank(ctx context.Context, projectRank int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllProjectsByRank, projectRank)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllProjectsByRanksAndIsVerified = `-- name: GetCountAllProjectsByRanksAndIsVerified :one
SELECT COUNT(*) FROM projects where project_rank = ANY($1::bigint[]) and status != 5 and status != 6 AND is_verified = $2
`

type GetCountAllProjectsByRanksAndIsVerifiedParams struct {
	Column1    []int64     `json:"column_1"`
	IsVerified pgtype.Bool `json:"is_verified"`
}

func (q *Queries) GetCountAllProjectsByRanksAndIsVerified(ctx context.Context, arg GetCountAllProjectsByRanksAndIsVerifiedParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllProjectsByRanksAndIsVerified, arg.Column1, arg.IsVerified)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllProjectsForMobile = `-- name: GetCountAllProjectsForMobile :one
SELECT COUNT(*) FROM projects where status != 5 and status != 6
`

func (q *Queries) GetCountAllProjectsForMobile(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllProjectsForMobile)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllProjectsForMobileIsVerified = `-- name: GetCountAllProjectsForMobileIsVerified :one
SELECT COUNT(*) FROM projects where status!=5 and is_verified=$1 and status!=6
`

func (q *Queries) GetCountAllProjectsForMobileIsVerified(ctx context.Context, isVerified pgtype.Bool) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllProjectsForMobileIsVerified, isVerified)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllPropertyPosts = `-- name: GetCountAllPropertyPosts :one
SELECT count(*) FROM aqary_property_posts
`

func (q *Queries) GetCountAllPropertyPosts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllPropertyPosts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountOfProjectsListForCity = `-- name: GetCountOfProjectsListForCity :one
SELECT count(*)
FROM projects p
JOIN addresses a ON a.id = p.addresses_id
JOIN cities c ON a.cities_id = c.id
WHERE a.cities_id=$1 AND p.status!=6
`

func (q *Queries) GetCountOfProjectsListForCity(ctx context.Context, citiesID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfProjectsListForCity, citiesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountProjectByCounrty = `-- name: GetCountProjectByCounrty :one
SELECT COUNT(*)
FROM projects
INNER JOIN addresses ON projects.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id    
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
INNER JOIN companies ON projects.developer_companies_id = companies.id    
WHERE
	(CASE WHEN $1::bigint= 0 then true else companies.id= $1::bigint END)
	AND 
    -- Search criteria
    ($2 = '%%' OR 
     projects.project_name % $2 OR 
     projects.ref_number % $2 OR
     countries.country % $2 OR 
     states."state" % $2 OR 
     cities.city % $2 OR 
      communities.community % $2 OR 
     sub_communities.sub_community % $2 OR
      (projects.facts->>'starting_price')::TEXT % $2 OR
     companies.company_name % $2  
      OR (CASE 
        WHEN 'ready' ILIKE $2 THEN (projects.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $2  THEN (projects.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $2  THEN (projects.facts->>'completion_percentage')::TEXT % $2
        WHEN 'draft'ILIKE $2  THEN projects.status = 1
        WHEN 'available'ILIKE $2  THEN projects.status = 2
        WHEN 'block'ILIKE $2  THEN projects.status = 5
        WHEN 'single'ILIKE $2  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $2  THEN projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
    --  -- Company and branch permissions
    --  AND (
    --     @is_company_user != true
    --     OR (
    --         (@company_branch != false OR projects.developer_companies_id = @company_id::bigint)
    --         AND (@company_branch != true OR projects.developer_company_branches_id = @company_id::bigint)
    --     )
    -- )
    -- Location filters
    AND ($3::bigint = 0 OR addresses.countries_id = $3::bigint)
    -- -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    -- AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
    -- AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
    -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
    -- Status filter
AND projects.status NOT IN (5,6)
`

type GetCountProjectByCounrtyParams struct {
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
	CountryID int64       `json:"country_id"`
}

func (q *Queries) GetCountProjectByCounrty(ctx context.Context, arg GetCountProjectByCounrtyParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProjectByCounrty, arg.CompanyID, arg.Search, arg.CountryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountProjectByCountryNotEqual = `-- name: GetCountProjectByCountryNotEqual :one
SELECT COUNT(projects.*)
FROM projects
INNER JOIN addresses ON projects.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
INNER JOIN companies ON projects.developer_companies_id = companies.id    
WHERE
	(CASE WHEN $1::bigint= 0 then true else companies.id= $1::bigint END)
	AND 
    -- Search criteria
    ($2 = '%%' OR 
     projects.project_name % $2 OR 
     projects.ref_number % $2 OR
     countries.country % $2 OR 
     states."state" % $2 OR 
     cities.city % $2 OR 
     communities.community % $2 OR 
     sub_communities.sub_community % $2 OR
     (projects.facts->>'starting_price')::TEXT % $2 OR
     companies.company_name % $2  
       OR (CASE 
        WHEN 'ready' ILIKE $2 THEN (projects.facts->>'completion_status')::BIGINT  = 5
        WHEN 'off plan'ILIKE $2  THEN (projects.facts->>'completion_status')::BIGINT= 4
        WHEN '^[0-9]+$' ~ $2  THEN (projects.facts->>'completion_percentage')::TEXT % $2
        WHEN 'draft'ILIKE $2  THEN projects.status = 1
        WHEN 'available'ILIKE $2  THEN projects.status = 2
        WHEN 'block'ILIKE $2  THEN projects.status = 5
        WHEN 'single'ILIKE $2  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $2  THEN projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
    --  -- Company and branch permissions
    --  AND (
    --     @is_company_user != true
    --     OR (
    --         (@company_branch != false OR projects.developer_companies_id = @company_id::bigint)
    --         AND (@company_branch != true OR projects.developer_company_branches_id = @company_id::bigint)
    --     )
    -- )
    -- Location filters
    AND ($3::bigint = 0 OR addresses.countries_id != $3::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    -- AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
    -- AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
    -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
    -- Status filter
    AND projects.status NOT IN (5,6)
`

type GetCountProjectByCountryNotEqualParams struct {
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
	CountryID int64       `json:"country_id"`
}

// INNER JOIN properties_facts ON projects.id = properties_facts.project_id AND properties_facts.is_project_fact = true
func (q *Queries) GetCountProjectByCountryNotEqual(ctx context.Context, arg GetCountProjectByCountryNotEqualParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProjectByCountryNotEqual, arg.CompanyID, arg.Search, arg.CountryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountProjectByStatus = `-- name: GetCountProjectByStatus :one
SELECT COUNT(projects.id)
FROM projects
INNER JOIN addresses ON projects.addresses_id = addresses.id 
LEFT JOIN countries ON addresses.countries_id = countries.id  
LEFT JOIN states ON addresses.states_id = states.id   
LEFT JOIN cities ON addresses.cities_id = cities.id  
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id  
LEFT JOIN companies ON projects.developer_companies_id = companies.id    
WHERE
	(CASE WHEN $1::bigint=0 then true else companies.id= $1::bigint END)
	AND  
    ($2 = '%%' OR 
     projects.project_name % $2 OR 
     projects.ref_number % $2 OR
     countries.country % $2 OR 
     states."state" % $2 OR 
     cities.city % $2 OR 
     communities.community % $2 OR 
     sub_communities.sub_community % $2 OR
     (projects.facts->>'starting_price')::TEXT % $2 OR
     companies.company_name % $2  
       OR (CASE 
        WHEN 'ready' ILIKE $2 THEN (projects.facts->>'completion_status')::BIGINT  = 5
        WHEN 'off plan'ILIKE $2  THEN (projects.facts->>'completion_status')::BIGINT= 4
        WHEN '^[0-9]+$' ~ $2  THEN (projects.facts->>'completion_percentage')::TEXT % $2
        WHEN 'draft'ILIKE $2  THEN projects.status = 1
        WHEN 'available'ILIKE $2  THEN projects.status = 2
        WHEN 'block'ILIKE $2  THEN projects.status = 5
        WHEN 'single'ILIKE $2  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $2  THEN projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
     -- Company and branch permissions
    -- AND CASE 
    --     WHEN @is_company_user != true THEN true
    --     WHEN 
    --         CASE 
    --             WHEN @company_branch != false THEN true
    --             ELSE projects.developer_companies_id = @company_id::bigint
    --         END
    --     THEN 
    --         CASE 
    --             WHEN @company_branch != true THEN true
    --             ELSE projects.developer_company_branches_id = @company_id::bigint
    --         END
    --     ELSE false
    -- END
    -- AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id = @country_id::bigint END
    -- AND CASE WHEN @city_id::bigint = 0 THEN true ELSE addresses.cities_id = @city_id::bigint END
    -- AND CASE WHEN @community_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
    -- AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint END
AND projects.status  = $3
`

type GetCountProjectByStatusParams struct {
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
	Status    int64       `json:"status"`
}

// LEFT JOIN properties_facts ON projects.id = properties_facts.project_id AND properties_facts.is_project_fact = true
// Search criteria
func (q *Queries) GetCountProjectByStatus(ctx context.Context, arg GetCountProjectByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProjectByStatus, arg.CompanyID, arg.Search, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountProjects = `-- name: GetCountProjects :one
SELECT COUNT(*) from projects
`

func (q *Queries) GetCountProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountPromotionsByProjectFilter = `-- name: GetCountPromotionsByProjectFilter :one
SELECT COUNT(pp.*)
FROM project_promotions pp
INNER JOIN projects p ON p.id = pp.projects_id 
INNER JOIN addresses a ON a.id = p.addresses_id
WHERE
    a.countries_id = $1::bigint
    AND CASE WHEN $2::bigint = 0 Then true ELSE a.cities_id = $2::bigint END
    AND CASE WHEN $3::bigint = 0 THEN true ELSE a.communities_id = $3::bigint END
    AND CASE WHEN $4::bigint = 0 THEN true ELSE a.sub_communities_id = $4::bigint END
    AND pp.status !=5 AND pp.status != 
    6
`

type GetCountPromotionsByProjectFilterParams struct {
	CountryID      int64 `json:"country_id"`
	CityID         int64 `json:"city_id"`
	CommunityID    int64 `json:"community_id"`
	SubCommunityID int64 `json:"sub_community_id"`
}

func (q *Queries) GetCountPromotionsByProjectFilter(ctx context.Context, arg GetCountPromotionsByProjectFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountPromotionsByProjectFilter,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getExternalShareByID = `-- name: GetExternalShareByID :one
SELECT id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id FROM external_sharing WHERE id = $1
`

func (q *Queries) GetExternalShareByID(ctx context.Context, id int64) (ExternalSharing, error) {
	row := q.db.QueryRow(ctx, getExternalShareByID, id)
	var i ExternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.ExternalCompanyType,
		&i.ExternalIsBranch,
		&i.ExternalCompanyID,
		&i.ExternalIsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const getExternalShareByUserIDAndID = `-- name: GetExternalShareByUserIDAndID :one
SELECT id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id FROM external_sharing WHERE created_by = $1 and id = $2
`

type GetExternalShareByUserIDAndIDParams struct {
	UsersID int64 `json:"users_id"`
	ID      int64 `json:"id"`
}

func (q *Queries) GetExternalShareByUserIDAndID(ctx context.Context, arg GetExternalShareByUserIDAndIDParams) (ExternalSharing, error) {
	row := q.db.QueryRow(ctx, getExternalShareByUserIDAndID, arg.UsersID, arg.ID)
	var i ExternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.ExternalCompanyType,
		&i.ExternalIsBranch,
		&i.ExternalCompanyID,
		&i.ExternalIsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const getLocalProjects = `-- name: GetLocalProjects :many
SELECT DISTINCT projects.id, projects.project_name, projects.ref_number, projects.no_of_views, projects.is_verified, projects.project_rank, projects.addresses_id, projects.status, projects.developer_companies_id, projects.developer_company_branches_id, projects.countries_id, projects.created_at, projects.updated_at, projects.is_multiphase, projects.live_status, projects.project_no, projects.license_no, projects.users_id, projects.description, projects.description_arabic, projects.rating, projects.polygon_coords, projects.facts, projects.exclusive, projects.start_date, projects.end_date, projects.slug, projects.deleted_at, projects.bank_name, projects.registration_date, projects.escrow_number, projects.refreshed_at, addresses.full_address,companies.company_name
FROM projects
INNER JOIN addresses ON projects.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
INNER JOIN companies ON projects.developer_companies_id = companies.id    
WHERE
	(CASE WHEN $3::bigint= 0 then true else companies.id= $3::bigint END)
	AND 
    -- Search criteria
    ($4 = '%%' OR 
     projects.project_name % $4 OR 
     projects.ref_number % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     communities.community % $4 OR 
     sub_communities.sub_community % $4 OR
     (projects.facts->>'starting_price')::TEXT % $4 OR
     companies.company_name % $4 
      OR (CASE 
        WHEN 'ready' ILIKE $4 THEN (projects.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $4  THEN (projects.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $4  THEN (projects.facts->>'completion_percentage')::TEXT % $4
        WHEN 'draft' ILIKE $4  THEN projects.status = 1
        WHEN 'available'ILIKE $4  THEN projects.status = 2
        WHEN 'block'ILIKE $4  THEN projects.status = 5
        WHEN 'single'ILIKE $4  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $4  THEN projects.is_multiphase = true 
        ELSE FALSE
       END)
      )
    -- --  Company and branch permissions
    --  AND (
    --     @is_company_user != true
    --     OR (
    --         (@company_branch != false OR projects.developer_companies_id = @company_id::bigint)
    --         AND (@company_branch != true OR projects.developer_company_branches_id = @company_id::bigint)
    --     )
    -- )
    -- Location filters
    AND ($5::bigint = 0 OR addresses.countries_id = $5::bigint)
    -- -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    -- AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
    -- AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
    -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
    
    -- Status filter
    AND projects.status NOT IN (5,6)  
ORDER BY projects.created_at DESC
LIMIT $1 OFFSET $2
`

type GetLocalProjectsParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
	CountryID int64       `json:"country_id"`
}

type GetLocalProjectsRow struct {
	ID                         int64              `json:"id"`
	ProjectName                string             `json:"project_name"`
	RefNumber                  string             `json:"ref_number"`
	NoOfViews                  int64              `json:"no_of_views"`
	IsVerified                 pgtype.Bool        `json:"is_verified"`
	ProjectRank                int64              `json:"project_rank"`
	AddressesID                int64              `json:"addresses_id"`
	Status                     int64              `json:"status"`
	DeveloperCompaniesID       int64              `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8        `json:"developer_company_branches_id"`
	CountriesID                int64              `json:"countries_id"`
	CreatedAt                  time.Time          `json:"created_at"`
	UpdatedAt                  time.Time          `json:"updated_at"`
	IsMultiphase               pgtype.Bool        `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool        `json:"live_status"`
	ProjectNo                  string             `json:"project_no"`
	LicenseNo                  string             `json:"license_no"`
	UsersID                    int64              `json:"users_id"`
	Description                string             `json:"description"`
	DescriptionArabic          pgtype.Text        `json:"description_arabic"`
	Rating                     float64            `json:"rating"`
	PolygonCoords              []byte             `json:"polygon_coords"`
	Facts                      []byte             `json:"facts"`
	Exclusive                  bool               `json:"exclusive"`
	StartDate                  pgtype.Date        `json:"start_date"`
	EndDate                    pgtype.Date        `json:"end_date"`
	Slug                       string             `json:"slug"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
	BankName                   pgtype.Text        `json:"bank_name"`
	RegistrationDate           pgtype.Date        `json:"registration_date"`
	EscrowNumber               pgtype.Text        `json:"escrow_number"`
	RefreshedAt                pgtype.Timestamptz `json:"refreshed_at"`
	FullAddress                pgtype.Text        `json:"full_address"`
	CompanyName                string             `json:"company_name"`
}

func (q *Queries) GetLocalProjects(ctx context.Context, arg GetLocalProjectsParams) ([]GetLocalProjectsRow, error) {
	rows, err := q.db.Query(ctx, getLocalProjects,
		arg.Limit,
		arg.Offset,
		arg.CompanyID,
		arg.Search,
		arg.CountryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocalProjectsRow
	for rows.Next() {
		var i GetLocalProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
			&i.FullAddress,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProject = `-- name: GetProject :one
SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at FROM projects 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const getProjectByCountryId = `-- name: GetProjectByCountryId :many
SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at FROM projects 
WHERE countries_id = $3 AND (status != 5 AND status != 6)  ORDER BY id  LIMIT $1 OFFSET $2
`

type GetProjectByCountryIdParams struct {
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
	CountriesID int64 `json:"countries_id"`
}

func (q *Queries) GetProjectByCountryId(ctx context.Context, arg GetProjectByCountryIdParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectByCountryId, arg.Limit, arg.Offset, arg.CountriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByName = `-- name: GetProjectByName :one
SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at FROM projects 
WHERE project_name = $2 LIMIT $1
`

type GetProjectByNameParams struct {
	Limit       int32  `json:"limit"`
	ProjectName string `json:"project_name"`
}

func (q *Queries) GetProjectByName(ctx context.Context, arg GetProjectByNameParams) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByName, arg.Limit, arg.ProjectName)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const getProjectByRefrenceNumber = `-- name: GetProjectByRefrenceNumber :one
SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at FROM projects WHERE ref_number = $1 LIMIT 1
`

func (q *Queries) GetProjectByRefrenceNumber(ctx context.Context, refNumber string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByRefrenceNumber, refNumber)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const getProjectByStatusId = `-- name: GetProjectByStatusId :many
SELECT projects.id, projects.project_name, projects.ref_number, projects.no_of_views, projects.is_verified, projects.project_rank, projects.addresses_id, projects.status, projects.developer_companies_id, projects.developer_company_branches_id, projects.countries_id, projects.created_at, projects.updated_at, projects.is_multiphase, projects.live_status, projects.project_no, projects.license_no, projects.users_id, projects.description, projects.description_arabic, projects.rating, projects.polygon_coords, projects.facts, projects.exclusive, projects.start_date, projects.end_date, projects.slug, projects.deleted_at, projects.bank_name, projects.registration_date, projects.escrow_number, projects.refreshed_at, addresses.full_address,companies.company_name
FROM projects
INNER JOIN addresses ON projects.addresses_id = addresses.id 
LEFT JOIN countries ON addresses.countries_id = countries.id  
LEFT JOIN states ON addresses.states_id = states.id   
LEFT JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
LEFT JOIN companies ON projects.developer_companies_id = companies.id    
WHERE
	(CASE WHEN $3::bigint=0 then true else companies.id= $3::bigint END)
	AND 
 -- Search criteria
    ($4 = '%%' OR 
     projects.project_name % $4 OR 
     projects.ref_number % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     communities.community % $4 OR 
     sub_communities.sub_community % $4 OR
     (projects.facts->>'starting_price')::TEXT % $4 OR
     companies.company_name % $4 
      OR (CASE 
        WHEN 'ready' ILIKE $4 THEN (projects.facts->>'completion_status')::BIGINT  = 5
        WHEN 'off plan'ILIKE $4  THEN (projects.facts->>'completion_status')::BIGINT= 4
        WHEN '^[0-9]+$' ~ $4  THEN (projects.facts->>'completion_percentage')::TEXT % $4
        WHEN 'draft' ILIKE $4  THEN projects.status = 1
        WHEN 'available'ILIKE $4  THEN projects.status = 2
        WHEN 'block'ILIKE $4  THEN projects.status = 5
        WHEN 'single'ILIKE $4  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $4  THEN projects.is_multiphase = true 
        ELSE FALSE
       END)
      )
    -- AND
    -- CASE 
    --     WHEN @is_company_user != true THEN true
    --     WHEN 
    --         CASE 
    --             WHEN @company_branch != false THEN true
    --             ELSE projects.developer_companies_id = @company_id::bigint
    --         END
    --     THEN 
    --         CASE 
    --             WHEN @company_branch != true THEN true
    --             ELSE projects.developer_company_branches_id = @company_id::bigint
    --         END
    --     ELSE false
    -- END
    -- AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id = @country_id::bigint END
    -- AND CASE WHEN @city_id::bigint = 0 THEN true ELSE addresses.cities_id = @city_id::bigint END
    -- AND CASE WHEN @community_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
    -- AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint END
    AND projects.status = $5
ORDER BY projects.updated_at DESC LIMIT $1 OFFSET $2
`

type GetProjectByStatusIdParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
	Status    int64       `json:"status"`
}

type GetProjectByStatusIdRow struct {
	ID                         int64              `json:"id"`
	ProjectName                string             `json:"project_name"`
	RefNumber                  string             `json:"ref_number"`
	NoOfViews                  int64              `json:"no_of_views"`
	IsVerified                 pgtype.Bool        `json:"is_verified"`
	ProjectRank                int64              `json:"project_rank"`
	AddressesID                int64              `json:"addresses_id"`
	Status                     int64              `json:"status"`
	DeveloperCompaniesID       int64              `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8        `json:"developer_company_branches_id"`
	CountriesID                int64              `json:"countries_id"`
	CreatedAt                  time.Time          `json:"created_at"`
	UpdatedAt                  time.Time          `json:"updated_at"`
	IsMultiphase               pgtype.Bool        `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool        `json:"live_status"`
	ProjectNo                  string             `json:"project_no"`
	LicenseNo                  string             `json:"license_no"`
	UsersID                    int64              `json:"users_id"`
	Description                string             `json:"description"`
	DescriptionArabic          pgtype.Text        `json:"description_arabic"`
	Rating                     float64            `json:"rating"`
	PolygonCoords              []byte             `json:"polygon_coords"`
	Facts                      []byte             `json:"facts"`
	Exclusive                  bool               `json:"exclusive"`
	StartDate                  pgtype.Date        `json:"start_date"`
	EndDate                    pgtype.Date        `json:"end_date"`
	Slug                       string             `json:"slug"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
	BankName                   pgtype.Text        `json:"bank_name"`
	RegistrationDate           pgtype.Date        `json:"registration_date"`
	EscrowNumber               pgtype.Text        `json:"escrow_number"`
	RefreshedAt                pgtype.Timestamptz `json:"refreshed_at"`
	FullAddress                pgtype.Text        `json:"full_address"`
	CompanyName                pgtype.Text        `json:"company_name"`
}

// LEFT JOIN properties_facts ON projects.id = properties_facts.project_id AND properties_facts.is_project_fact = true
func (q *Queries) GetProjectByStatusId(ctx context.Context, arg GetProjectByStatusIdParams) ([]GetProjectByStatusIdRow, error) {
	rows, err := q.db.Query(ctx, getProjectByStatusId,
		arg.Limit,
		arg.Offset,
		arg.CompanyID,
		arg.Search,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectByStatusIdRow
	for rows.Next() {
		var i GetProjectByStatusIdRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
			&i.FullAddress,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectExceptDeletedAndBlocked = `-- name: GetProjectExceptDeletedAndBlocked :one

SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at FROM projects 
WHERE id = $1 AND (status != 5 AND status != 6) LIMIT 1
`

// -- name: GetAllSharedProjectPropertyUnitByPropertyID :many
// WITH unit_ids AS (
//
//	SELECT unnest($1::bigint[]) AS id,
//	       row_number() OVER () AS rn
//
// )
// SELECT u.id, u.ref_no, u.properties_id
// FROM units u
// CROSS JOIN unit_ids ui
// WHERE u.id = ui.id
// ORDER BY ui.rn;
// SELECT
//
//	u.id,
//	u.ref_no,
//	u.properties_id
//
// FROM units u
// WHERE u.id = ANY($1::bigint[]);
func (q *Queries) GetProjectExceptDeletedAndBlocked(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectExceptDeletedAndBlocked, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const getProjectIdByLicenseNo = `-- name: GetProjectIdByLicenseNo :one
SELECT id FROM projects WHERE license_no = $1 LIMIT 1
`

func (q *Queries) GetProjectIdByLicenseNo(ctx context.Context, licenseNo string) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectIdByLicenseNo, licenseNo)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getProjectIdByProjectNo = `-- name: GetProjectIdByProjectNo :one

SELECT id FROM projects WHERE project_no = $1 LIMIT 1
`

// SELECT COUNT(pp.*)
// FROM projects p
// JOIN project_promotions pp ON p.id = pp.projects_id
// WHERE
//
//	CASE
//	    WHEN $1::bigint = 0 THEN true
//	    WHEN $1::bigint = 1 THEN p.addresses_id IN (SELECT id FROM addresses WHERE addresses.cities_id = $2)
//	    WHEN $1::bigint = 2 THEN p.addresses_id IN (SELECT id FROM addresses WHERE addresses.cities_id = $2 AND communities_id = ANY($3::bigint[]))
//	    WHEN $1::bigint = 3 THEN p.addresses_id IN (SELECT id FROM addresses WHERE addresses.cities_id = $2 AND communities_id = ANY($3::bigint[]) AND sub_communities_id = ANY($4::bigint[]))
//	    WHEN $1::bigint = 4 THEN p.addresses_id IN (SELECT id FROM addresses WHERE addresses.cities_id = $2 AND communities_id = ANY($3::bigint[]) AND sub_communities_id = ANY($4::bigint[]) AND addresses.locations_id = $5)
//	END
//	AND pp.projects_id = p.id;
func (q *Queries) GetProjectIdByProjectNo(ctx context.Context, projectNo string) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectIdByProjectNo, projectNo)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getProjectName = `-- name: GetProjectName :one
SELECT project_name FROM projects
WHERE id = $1
`

func (q *Queries) GetProjectName(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getProjectName, id)
	var project_name string
	err := row.Scan(&project_name)
	return project_name, err
}

const getProjectNotEqualToCountryId = `-- name: GetProjectNotEqualToCountryId :many
SELECT DISTINCT 
    projects.id, projects.project_name, projects.ref_number, projects.no_of_views, projects.is_verified, projects.project_rank, projects.addresses_id, projects.status, projects.developer_companies_id, projects.developer_company_branches_id, projects.countries_id, projects.created_at, projects.updated_at, projects.is_multiphase, projects.live_status, projects.project_no, projects.license_no, projects.users_id, projects.description, projects.description_arabic, projects.rating, projects.polygon_coords, projects.facts, projects.exclusive, projects.start_date, projects.end_date, projects.slug, projects.deleted_at, projects.bank_name, projects.registration_date, projects.escrow_number, projects.refreshed_at, addresses.full_address, companies.company_name
FROM projects
INNER JOIN addresses ON projects.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
INNER JOIN companies ON projects.developer_companies_id = companies.id    
WHERE
	(CASE WHEN $3::bigint=0 then true else companies.id= $3::bigint END)
	AND 
    -- Search criteria
    ($4 = '%%' OR 
     projects.project_name % $4 OR 
     projects.ref_number % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     communities.community % $4 OR 
     sub_communities.sub_community % $4 OR
     (projects.facts->>'starting_price')::TEXT % $4 OR
     companies.company_name % $4  
       OR (CASE 
        WHEN 'ready' ILIKE $4 THEN (projects.facts->>'completion_status')::BIGINT  = 5
        WHEN 'off plan'ILIKE $4  THEN (projects.facts->>'completion_status')::BIGINT= 4
        WHEN '^[0-9]+$' ~ $4  THEN (projects.facts->>'completion_percentage')::TEXT % $4
        WHEN 'draft'ILIKE $4  THEN projects.status = 1
        WHEN 'available'ILIKE $4  THEN projects.status = 2
        WHEN 'block'ILIKE $4  THEN projects.status = 5
        WHEN 'single'ILIKE $4  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $4  THEN projects.is_multiphase = true 
        ELSE FALSE
      END)
      )

    -- Location filters
    AND ($5::bigint = 0 OR addresses.countries_id != $5::bigint)

    -- Status filter
    AND projects.status NOT IN (5,6)  
ORDER BY projects.created_at DESC
LIMIT $1 OFFSET $2
`

type GetProjectNotEqualToCountryIdParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
	CountryID int64       `json:"country_id"`
}

type GetProjectNotEqualToCountryIdRow struct {
	ID                         int64              `json:"id"`
	ProjectName                string             `json:"project_name"`
	RefNumber                  string             `json:"ref_number"`
	NoOfViews                  int64              `json:"no_of_views"`
	IsVerified                 pgtype.Bool        `json:"is_verified"`
	ProjectRank                int64              `json:"project_rank"`
	AddressesID                int64              `json:"addresses_id"`
	Status                     int64              `json:"status"`
	DeveloperCompaniesID       int64              `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8        `json:"developer_company_branches_id"`
	CountriesID                int64              `json:"countries_id"`
	CreatedAt                  time.Time          `json:"created_at"`
	UpdatedAt                  time.Time          `json:"updated_at"`
	IsMultiphase               pgtype.Bool        `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool        `json:"live_status"`
	ProjectNo                  string             `json:"project_no"`
	LicenseNo                  string             `json:"license_no"`
	UsersID                    int64              `json:"users_id"`
	Description                string             `json:"description"`
	DescriptionArabic          pgtype.Text        `json:"description_arabic"`
	Rating                     float64            `json:"rating"`
	PolygonCoords              []byte             `json:"polygon_coords"`
	Facts                      []byte             `json:"facts"`
	Exclusive                  bool               `json:"exclusive"`
	StartDate                  pgtype.Date        `json:"start_date"`
	EndDate                    pgtype.Date        `json:"end_date"`
	Slug                       string             `json:"slug"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
	BankName                   pgtype.Text        `json:"bank_name"`
	RegistrationDate           pgtype.Date        `json:"registration_date"`
	EscrowNumber               pgtype.Text        `json:"escrow_number"`
	RefreshedAt                pgtype.Timestamptz `json:"refreshed_at"`
	FullAddress                pgtype.Text        `json:"full_address"`
	CompanyName                string             `json:"company_name"`
}

// INNER JOIN properties_facts ON projects.id = properties_facts.project_id AND properties_facts.is_project_fact = true
//
//	 -- Company and branch permissions
//	 AND (
//	    @is_company_user != true
//	    OR (
//	        (@company_branch != false OR projects.developer_companies_id = @company_id::bigint)
//	        AND (@company_branch != true OR projects.developer_company_branches_id = @company_id::bigint)
//	    )
//	)
//	-- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
//	AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
//	AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
//	AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
func (q *Queries) GetProjectNotEqualToCountryId(ctx context.Context, arg GetProjectNotEqualToCountryIdParams) ([]GetProjectNotEqualToCountryIdRow, error) {
	rows, err := q.db.Query(ctx, getProjectNotEqualToCountryId,
		arg.Limit,
		arg.Offset,
		arg.CompanyID,
		arg.Search,
		arg.CountryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectNotEqualToCountryIdRow
	for rows.Next() {
		var i GetProjectNotEqualToCountryIdRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
			&i.FullAddress,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectStatusAndVerificationAndRank = `-- name: GetProjectStatusAndVerificationAndRank :one
SELECT 
status,is_verified,project_rank, project_name
FROM projects 
WHERE id = $1
`

type GetProjectStatusAndVerificationAndRankRow struct {
	Status      int64       `json:"status"`
	IsVerified  pgtype.Bool `json:"is_verified"`
	ProjectRank int64       `json:"project_rank"`
	ProjectName string      `json:"project_name"`
}

func (q *Queries) GetProjectStatusAndVerificationAndRank(ctx context.Context, id int64) (GetProjectStatusAndVerificationAndRankRow, error) {
	row := q.db.QueryRow(ctx, getProjectStatusAndVerificationAndRank, id)
	var i GetProjectStatusAndVerificationAndRankRow
	err := row.Scan(
		&i.Status,
		&i.IsVerified,
		&i.ProjectRank,
		&i.ProjectName,
	)
	return i, err
}

const getProjectsCountPerFeaturedCity = `-- name: GetProjectsCountPerFeaturedCity :many
SELECT c.id, c.city, COUNT(p.id) AS project_count
FROM projects p
JOIN addresses a ON a.id = p.addresses_id
JOIN cities c ON a.cities_id = c.id
WHERE p.status!=6
GROUP BY c.id, c.city
`

type GetProjectsCountPerFeaturedCityRow struct {
	ID           int64  `json:"id"`
	City         string `json:"city"`
	ProjectCount int64  `json:"project_count"`
}

func (q *Queries) GetProjectsCountPerFeaturedCity(ctx context.Context) ([]GetProjectsCountPerFeaturedCityRow, error) {
	rows, err := q.db.Query(ctx, getProjectsCountPerFeaturedCity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsCountPerFeaturedCityRow
	for rows.Next() {
		var i GetProjectsCountPerFeaturedCityRow
		if err := rows.Scan(&i.ID, &i.City, &i.ProjectCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsForCities = `-- name: GetProjectsForCities :many
WITH FeaturedCities AS (
    SELECT c.id, c.city
    FROM projects p
    JOIN addresses a ON a.id = p.addresses_id
    JOIN cities c ON a.cities_id = c.id
    GROUP BY c.id, c.city
),
RankedProjects AS (
    SELECT 
        p.id, p.project_name, p.ref_number, p.no_of_views, p.is_verified, p.project_rank, p.addresses_id, p.status, p.developer_companies_id, p.developer_company_branches_id, p.countries_id, p.created_at, p.updated_at, p.is_multiphase, p.live_status, p.project_no, p.license_no, p.users_id, p.description, p.description_arabic, p.rating, p.polygon_coords, p.facts, p.exclusive, p.start_date, p.end_date, p.slug, p.deleted_at, p.bank_name, p.registration_date, p.escrow_number, p.refreshed_at,
        a.cities_id,
        ROW_NUMBER() OVER (PARTITION BY a.cities_id ORDER BY p.created_at DESC) as rn
    FROM projects p
    JOIN addresses a ON a.id = p.addresses_id
    WHERE p.status!=6
)
SELECT 
    fc.id AS city_id, 
    fc.city, 
    json_agg(
        json_build_object(
            'project_id', rp.id,
            'project_name', rp.project_name,
            'ref_number', rp.ref_number,
            'no_of_views', rp.no_of_views,
            'is_verified', rp.is_verified,
            'project_rank', rp.project_rank,
            'addresses_id', rp.addresses_id,
            'status', rp.status,
            'developer_companies_id', rp.developer_companies_id,
            'developer_company_branches_id', rp.developer_company_branches_id,
            'countries_id', rp.countries_id,
            'created_at', rp.created_at,
            'updated_at', rp.updated_at,
            'is_multiphase', rp.is_multiphase,
            'live_status', rp.live_status,
            'project_no', rp.project_no,
            'license_no', rp.license_no,
            'users_id', rp.users_id,
            'facilities_id', rp.facilities_id,
            'amenities_id', rp.amenities_id,
            'description', rp.description,
            'description_arabic', rp.description_arabic,
            'rating', rp.rating
        )
    ) AS project
FROM 
    FeaturedCities fc
JOIN RankedProjects rp ON rp.cities_id = fc.id
WHERE rp.rn <= 6 
GROUP BY 
    fc.id, fc.city
ORDER BY 
    fc.city
`

type GetProjectsForCitiesRow struct {
	CityID  int64  `json:"city_id"`
	City    string `json:"city"`
	Project []byte `json:"project"`
}

func (q *Queries) GetProjectsForCities(ctx context.Context) ([]GetProjectsForCitiesRow, error) {
	rows, err := q.db.Query(ctx, getProjectsForCities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsForCitiesRow
	for rows.Next() {
		var i GetProjectsForCitiesRow
		if err := rows.Scan(&i.CityID, &i.City, &i.Project); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsListForCity = `-- name: GetProjectsListForCity :many
WITH PhasesCount AS (
    SELECT
        p.id AS project_id,
        COUNT(ph.*) AS phases_count
    FROM
        projects p
    JOIN phases ph ON ph.projects_id = p.id
    WHERE
        p.is_multiphase = TRUE AND ph.status!=6
    GROUP BY
        p.id
),
PropertiesCount AS (
    SELECT
        p.id AS project_id,
        COUNT(prop.*) AS properties_count
    FROM
        projects p
    JOIN project_properties prop ON prop.projects_id = p.id 
    WHERE  prop.status!=6
    GROUP BY
        p.id
)
SELECT
	p.id, p.project_name, p.ref_number, p.no_of_views, p.is_verified, p.project_rank, p.addresses_id, p.status, p.developer_companies_id, p.developer_company_branches_id, p.countries_id, p.created_at, p.updated_at, p.is_multiphase, p.live_status, p.project_no, p.license_no, p.users_id, p.description, p.description_arabic, p.rating, p.polygon_coords, p.facts, p.exclusive, p.start_date, p.end_date, p.slug, p.deleted_at, p.bank_name, p.registration_date, p.escrow_number, p.refreshed_at,
	pf.id, pf.bedroom, pf.bathroom, pf.plot_area, pf.built_up_area, pf.view, pf.furnished, pf.ownership, pf.completion_status, pf.start_date, pf.completion_date, pf.handover_date, pf.no_of_floor, pf.no_of_units, pf.min_area, pf.max_area, pf.service_charge, pf.parking, pf.ask_price, pf.price, pf.rent_type, pf.no_of_payment, pf.no_of_retail, pf.no_of_pool, pf.elevator, pf.starting_price, pf.life_style, pf.properties_id, pf.property, pf.is_branch, pf.created_at, pf.updated_at, pf.available_units, pf.commercial_tax, pf.municipality_tax, pf.is_project_fact, pf.project_id, pf.completion_percentage, pf.completion_percentage_date, pf.type_name_id, pf.sc_currency_id, pf.unit_of_measure,
	c.id, c.city, c.states_id, c.created_at, c.updated_at, c.lat, c.lng, c.status, c.deleted_at, c.updated_by, c.city_ar, c.cover_image, c.description,
	co.id, co.country, co.flag, co.created_at, co.updated_at, co.alpha2_code, co.alpha3_code, co.country_code, co.lat, co.lng, co.name, co.numcode, co.default_settings, co.status, co.deleted_at, co.updated_by, co.country_ar,
	s.id, s.state, s.countries_id, s.is_capital, s.created_at, s.updated_at, s.lat, s.lng, s.status, s.deleted_at, s.updated_by, s.state_ar,
	com.id, com.community, com.cities_id, com.created_at, com.updated_at, com.lat, com.lng, com.status, com.deleted_at, com.updated_by, com.community_ar,
	scom.id, scom.sub_community, scom.communities_id, scom.created_at, scom.updated_at, scom.lng, scom.lat, scom.status, scom.deleted_at, scom.updated_by, scom.sub_community_ar,
    COALESCE(pm.id, 0) AS media_id,
    COALESCE(pm.file_urls, ARRAY[]::text[]) AS images,
    COALESCE(pc.phases_count, 0) AS phases_count,
    COALESCE(prc.properties_count, 0) AS properties_count
FROM
    projects p
JOIN addresses a ON a.id = p.addresses_id
JOIN cities c ON a.cities_id = c.id
JOIN countries co ON a.countries_id = co.id
JOIN states s ON s.id = a.states_id
JOIN properties_facts pf ON pf.project_id = p.id AND pf.is_project_fact = TRUE
LEFT JOIN communities com ON com.id = a.communities_id
LEFT JOIN sub_communities scom ON scom.id = a.sub_communities_id
LEFT JOIN project_media pm ON pm.projects_id = p.id AND pm.media_type = 1 AND pm.gallery_type = 'Main'
LEFT JOIN PhasesCount pc ON pc.project_id = p.id
LEFT JOIN PropertiesCount prc ON prc.project_id = p.id
WHERE
    c.id = $1 AND p.status != 6
LIMIT $2 OFFSET $3
`

type GetProjectsListForCityParams struct {
	ID     int64 `json:"id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProjectsListForCityRow struct {
	Project         Project        `json:"project"`
	PropertiesFact  PropertiesFact `json:"properties_fact"`
	City            City           `json:"city"`
	Country         Country        `json:"country"`
	State           State          `json:"state"`
	Community       Community      `json:"community"`
	SubCommunity    SubCommunity   `json:"sub_community"`
	MediaID         int64          `json:"media_id"`
	Images          []string       `json:"images"`
	PhasesCount     int64          `json:"phases_count"`
	PropertiesCount int64          `json:"properties_count"`
}

func (q *Queries) GetProjectsListForCity(ctx context.Context, arg GetProjectsListForCityParams) ([]GetProjectsListForCityRow, error) {
	rows, err := q.db.Query(ctx, getProjectsListForCity, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsListForCityRow
	for rows.Next() {
		var i GetProjectsListForCityRow
		if err := rows.Scan(
			&i.Project.ID,
			&i.Project.ProjectName,
			&i.Project.RefNumber,
			&i.Project.NoOfViews,
			&i.Project.IsVerified,
			&i.Project.ProjectRank,
			&i.Project.AddressesID,
			&i.Project.Status,
			&i.Project.DeveloperCompaniesID,
			&i.Project.DeveloperCompanyBranchesID,
			&i.Project.CountriesID,
			&i.Project.CreatedAt,
			&i.Project.UpdatedAt,
			&i.Project.IsMultiphase,
			&i.Project.LiveStatus,
			&i.Project.ProjectNo,
			&i.Project.LicenseNo,
			&i.Project.UsersID,
			&i.Project.Description,
			&i.Project.DescriptionArabic,
			&i.Project.Rating,
			&i.Project.PolygonCoords,
			&i.Project.Facts,
			&i.Project.Exclusive,
			&i.Project.StartDate,
			&i.Project.EndDate,
			&i.Project.Slug,
			&i.Project.DeletedAt,
			&i.Project.BankName,
			&i.Project.RegistrationDate,
			&i.Project.EscrowNumber,
			&i.Project.RefreshedAt,
			&i.PropertiesFact.ID,
			&i.PropertiesFact.Bedroom,
			&i.PropertiesFact.Bathroom,
			&i.PropertiesFact.PlotArea,
			&i.PropertiesFact.BuiltUpArea,
			&i.PropertiesFact.View,
			&i.PropertiesFact.Furnished,
			&i.PropertiesFact.Ownership,
			&i.PropertiesFact.CompletionStatus,
			&i.PropertiesFact.StartDate,
			&i.PropertiesFact.CompletionDate,
			&i.PropertiesFact.HandoverDate,
			&i.PropertiesFact.NoOfFloor,
			&i.PropertiesFact.NoOfUnits,
			&i.PropertiesFact.MinArea,
			&i.PropertiesFact.MaxArea,
			&i.PropertiesFact.ServiceCharge,
			&i.PropertiesFact.Parking,
			&i.PropertiesFact.AskPrice,
			&i.PropertiesFact.Price,
			&i.PropertiesFact.RentType,
			&i.PropertiesFact.NoOfPayment,
			&i.PropertiesFact.NoOfRetail,
			&i.PropertiesFact.NoOfPool,
			&i.PropertiesFact.Elevator,
			&i.PropertiesFact.StartingPrice,
			&i.PropertiesFact.LifeStyle,
			&i.PropertiesFact.PropertiesID,
			&i.PropertiesFact.Property,
			&i.PropertiesFact.IsBranch,
			&i.PropertiesFact.CreatedAt,
			&i.PropertiesFact.UpdatedAt,
			&i.PropertiesFact.AvailableUnits,
			&i.PropertiesFact.CommercialTax,
			&i.PropertiesFact.MunicipalityTax,
			&i.PropertiesFact.IsProjectFact,
			&i.PropertiesFact.ProjectID,
			&i.PropertiesFact.CompletionPercentage,
			&i.PropertiesFact.CompletionPercentageDate,
			&i.PropertiesFact.TypeNameID,
			&i.PropertiesFact.ScCurrencyID,
			&i.PropertiesFact.UnitOfMeasure,
			&i.City.ID,
			&i.City.City,
			&i.City.StatesID,
			&i.City.CreatedAt,
			&i.City.UpdatedAt,
			&i.City.Lat,
			&i.City.Lng,
			&i.City.Status,
			&i.City.DeletedAt,
			&i.City.UpdatedBy,
			&i.City.CityAr,
			&i.City.CoverImage,
			&i.City.Description,
			&i.Country.ID,
			&i.Country.Country,
			&i.Country.Flag,
			&i.Country.CreatedAt,
			&i.Country.UpdatedAt,
			&i.Country.Alpha2Code,
			&i.Country.Alpha3Code,
			&i.Country.CountryCode,
			&i.Country.Lat,
			&i.Country.Lng,
			&i.Country.Name,
			&i.Country.Numcode,
			&i.Country.DefaultSettings,
			&i.Country.Status,
			&i.Country.DeletedAt,
			&i.Country.UpdatedBy,
			&i.Country.CountryAr,
			&i.State.ID,
			&i.State.State,
			&i.State.CountriesID,
			&i.State.IsCapital,
			&i.State.CreatedAt,
			&i.State.UpdatedAt,
			&i.State.Lat,
			&i.State.Lng,
			&i.State.Status,
			&i.State.DeletedAt,
			&i.State.UpdatedBy,
			&i.State.StateAr,
			&i.Community.ID,
			&i.Community.Community,
			&i.Community.CitiesID,
			&i.Community.CreatedAt,
			&i.Community.UpdatedAt,
			&i.Community.Lat,
			&i.Community.Lng,
			&i.Community.Status,
			&i.Community.DeletedAt,
			&i.Community.UpdatedBy,
			&i.Community.CommunityAr,
			&i.SubCommunity.ID,
			&i.SubCommunity.SubCommunity,
			&i.SubCommunity.CommunitiesID,
			&i.SubCommunity.CreatedAt,
			&i.SubCommunity.UpdatedAt,
			&i.SubCommunity.Lng,
			&i.SubCommunity.Lat,
			&i.SubCommunity.Status,
			&i.SubCommunity.DeletedAt,
			&i.SubCommunity.UpdatedBy,
			&i.SubCommunity.SubCommunityAr,
			&i.MediaID,
			&i.Images,
			&i.PhasesCount,
			&i.PropertiesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsRefNoBySearch = `-- name: GetProjectsRefNoBySearch :many
SELECT id,ref_number FROM projects WHERE ref_number ILIKE $1
`

type GetProjectsRefNoBySearchRow struct {
	ID        int64  `json:"id"`
	RefNumber string `json:"ref_number"`
}

func (q *Queries) GetProjectsRefNoBySearch(ctx context.Context, refNumber string) ([]GetProjectsRefNoBySearchRow, error) {
	rows, err := q.db.Query(ctx, getProjectsRefNoBySearch, refNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsRefNoBySearchRow
	for rows.Next() {
		var i GetProjectsRefNoBySearchRow
		if err := rows.Scan(&i.ID, &i.RefNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPromotionsByProjectFilter = `-- name: GetPromotionsByProjectFilter :many
SELECT pp.id, pp.promotion_types_id, pp.description, pp.expiry_date, pp.status, pp.projects_id, pp.phases_id, pp.created_at, pp.updated_at, pp.live_status, pp.ref_no, pp.is_phase
FROM project_promotions pp
INNER JOIN projects p ON p.id = pp.projects_id 
INNER JOIN addresses a ON a.id = p.addresses_id
WHERE
     a.countries_id = $3::bigint
    AND CASE WHEN $4::bigint = 0 Then true ELSE a.cities_id = $4::bigint END
    AND CASE WHEN $5::bigint = 0 THEN true ELSE a.communities_id = $5::bigint END
    AND CASE WHEN $6::bigint = 0 THEN true ELSE a.sub_communities_id = $6::bigint END
    AND pp.status !=5 AND pp.status != 6
ORDER BY pp.created_at DESC LIMIT $1 OFFSET $2
`

type GetPromotionsByProjectFilterParams struct {
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
	CountryID      int64 `json:"country_id"`
	CityID         int64 `json:"city_id"`
	CommunityID    int64 `json:"community_id"`
	SubCommunityID int64 `json:"sub_community_id"`
}

func (q *Queries) GetPromotionsByProjectFilter(ctx context.Context, arg GetPromotionsByProjectFilterParams) ([]ProjectPromotion, error) {
	rows, err := q.db.Query(ctx, getPromotionsByProjectFilter,
		arg.Limit,
		arg.Offset,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectPromotion
	for rows.Next() {
		var i ProjectPromotion
		if err := rows.Scan(
			&i.ID,
			&i.PromotionTypesID,
			&i.Description,
			&i.ExpiryDate,
			&i.Status,
			&i.ProjectsID,
			&i.PhasesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LiveStatus,
			&i.RefNo,
			&i.IsPhase,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAccessForProject = `-- name: GetUserAccessForProject :many
SELECT id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at
FROM projects p
WHERE
    CASE
        WHEN $3::bigint = 0 THEN true
        WHEN $3::bigint = 1 THEN p.addresses_id IN (SELECT id FROM addresses WHERE addresses.cities_id = $4)
        WHEN $3::bigint = 2 THEN p.addresses_id IN (SELECT id FROM addresses WHERE addresses.cities_id = $4 AND communities_id = ANY($5::bigint[]))
        WHEN $3::bigint = 3 THEN p.addresses_id IN (SELECT id FROM addresses WHERE addresses.cities_id = $4 AND communities_id = ANY($5::bigint[]) AND sub_communities_id = ANY($6::bigint[]))
        WHEN $3::bigint = 4 THEN p.addresses_id IN (SELECT id FROM addresses WHERE addresses.cities_id = $4 AND communities_id = ANY($5::bigint[]) AND sub_communities_id = ANY($6::bigint[]) AND addresses.locations_id = $7)
    END AND
    (status != 5 AND status != 6)
    AND p.id = $8
ORDER BY id LIMIT $1 OFFSET $2
`

type GetUserAccessForProjectParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	Column3     int64       `json:"column_3"`
	CitiesID    pgtype.Int8 `json:"cities_id"`
	Column5     []int64     `json:"column_5"`
	Column6     []int64     `json:"column_6"`
	LocationsID pgtype.Int8 `json:"locations_id"`
	ID          int64       `json:"id"`
}

func (q *Queries) GetUserAccessForProject(ctx context.Context, arg GetUserAccessForProjectParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getUserAccessForProject,
		arg.Limit,
		arg.Offset,
		arg.Column3,
		arg.CitiesID,
		arg.Column5,
		arg.Column6,
		arg.LocationsID,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isMultiPhaseProject = `-- name: IsMultiPhaseProject :one



SELECT is_multiphase FROM projects 
WHERE id = $1 AND status!=6
`

// -- name: GetAmenitiesForProjectByCatg :many
// SELECT
//
//	a.*,
//	fmc.category
//
// FROM
//
//	projects p
//
// JOIN LATERAL unnest(p.amenities_id) AS amenity_id ON true
// JOIN amenities a ON a.id = amenity_id
// JOIN facilities_amenities_categories fmc ON a.category_id=fmc.id
// WHERE p.id=$1 AND a.category_id=$2;
func (q *Queries) IsMultiPhaseProject(ctx context.Context, id int64) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, isMultiPhaseProject, id)
	var is_multiphase pgtype.Bool
	err := row.Scan(&is_multiphase)
	return is_multiphase, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET  project_name = $2,
    ref_number = $3,
    no_of_views = $4,
    is_verified = $5,
    project_rank = $6,
    addresses_id = $7,
    status = $8,
    developer_companies_id = $9,
    developer_company_branches_id = $10,
    countries_id = $11,
    created_at = $12,
    updated_at = $13,
    is_multiphase = $14,
    live_status = $15,
    project_no = $16,
    license_no = $17,
    users_id = $18,
    description = $19,
    description_arabic = $20,
    polygon_coords = $21, 
    facts=$22,
    bank_name=$23,
    registration_date=$24,
    escrow_number=$25
Where id = $1
RETURNING id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at
`

type UpdateProjectParams struct {
	ID                         int64       `json:"id"`
	ProjectName                string      `json:"project_name"`
	RefNumber                  string      `json:"ref_number"`
	NoOfViews                  int64       `json:"no_of_views"`
	IsVerified                 pgtype.Bool `json:"is_verified"`
	ProjectRank                int64       `json:"project_rank"`
	AddressesID                int64       `json:"addresses_id"`
	Status                     int64       `json:"status"`
	DeveloperCompaniesID       int64       `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8 `json:"developer_company_branches_id"`
	CountriesID                int64       `json:"countries_id"`
	CreatedAt                  time.Time   `json:"created_at"`
	UpdatedAt                  time.Time   `json:"updated_at"`
	IsMultiphase               pgtype.Bool `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool `json:"live_status"`
	ProjectNo                  string      `json:"project_no"`
	LicenseNo                  string      `json:"license_no"`
	UsersID                    int64       `json:"users_id"`
	Description                string      `json:"description"`
	DescriptionArabic          pgtype.Text `json:"description_arabic"`
	PolygonCoords              []byte      `json:"polygon_coords"`
	Facts                      []byte      `json:"facts"`
	BankName                   pgtype.Text `json:"bank_name"`
	RegistrationDate           pgtype.Date `json:"registration_date"`
	EscrowNumber               pgtype.Text `json:"escrow_number"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.ProjectName,
		arg.RefNumber,
		arg.NoOfViews,
		arg.IsVerified,
		arg.ProjectRank,
		arg.AddressesID,
		arg.Status,
		arg.DeveloperCompaniesID,
		arg.DeveloperCompanyBranchesID,
		arg.CountriesID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsMultiphase,
		arg.LiveStatus,
		arg.ProjectNo,
		arg.LicenseNo,
		arg.UsersID,
		arg.Description,
		arg.DescriptionArabic,
		arg.PolygonCoords,
		arg.Facts,
		arg.BankName,
		arg.RegistrationDate,
		arg.EscrowNumber,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const updateProjectByStatus = `-- name: UpdateProjectByStatus :one
UPDATE projects SET status = $2,
updated_at = $3, deleted_at = $4
WHERE id = $1 RETURNING id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at
`

type UpdateProjectByStatusParams struct {
	ID        int64              `json:"id"`
	Status    int64              `json:"status"`
	UpdatedAt time.Time          `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) UpdateProjectByStatus(ctx context.Context, arg UpdateProjectByStatusParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectByStatus,
		arg.ID,
		arg.Status,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const updateProjectLiveStatus = `-- name: UpdateProjectLiveStatus :one
UPDATE projects 
SET live_status = $2 
WHERE projects.id = $1 
RETURNING id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at
`

type UpdateProjectLiveStatusParams struct {
	ID         int64       `json:"id"`
	LiveStatus pgtype.Bool `json:"live_status"`
}

func (q *Queries) UpdateProjectLiveStatus(ctx context.Context, arg UpdateProjectLiveStatusParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectLiveStatus, arg.ID, arg.LiveStatus)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const updateProjectRankInProject = `-- name: UpdateProjectRankInProject :one

UPDATE projects SET project_rank = $2 WHERE id = $1 RETURNING id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at
`

type UpdateProjectRankInProjectParams struct {
	ID          int64 `json:"id"`
	ProjectRank int64 `json:"project_rank"`
}

// -- name: DeleteProject :exec
// DELETE FROM projects
// Where id = $1;
func (q *Queries) UpdateProjectRankInProject(ctx context.Context, arg UpdateProjectRankInProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectRankInProject, arg.ID, arg.ProjectRank)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}

const updateProjectTriggerStatus = `-- name: UpdateProjectTriggerStatus :many
UPDATE trigger_status
SET is_active = true
WHERE table_name IN ('projects', 'addresses', 'properties_facts')
RETURNING table_name, is_active
`

func (q *Queries) UpdateProjectTriggerStatus(ctx context.Context) ([]TriggerStatus, error) {
	rows, err := q.db.Query(ctx, updateProjectTriggerStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TriggerStatus
	for rows.Next() {
		var i TriggerStatus
		if err := rows.Scan(&i.TableName, &i.IsActive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProjectVerification = `-- name: UpdateProjectVerification :one
UPDATE projects SET is_verified = $2 WHERE id = $1 RETURNING id, project_name, ref_number, no_of_views, is_verified, project_rank, addresses_id, status, developer_companies_id, developer_company_branches_id, countries_id, created_at, updated_at, is_multiphase, live_status, project_no, license_no, users_id, description, description_arabic, rating, polygon_coords, facts, exclusive, start_date, end_date, slug, deleted_at, bank_name, registration_date, escrow_number, refreshed_at
`

type UpdateProjectVerificationParams struct {
	ID         int64       `json:"id"`
	IsVerified pgtype.Bool `json:"is_verified"`
}

func (q *Queries) UpdateProjectVerification(ctx context.Context, arg UpdateProjectVerificationParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectVerification, arg.ID, arg.IsVerified)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
	)
	return i, err
}
