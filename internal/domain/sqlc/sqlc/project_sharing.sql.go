// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_sharing.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllProjectPropertyUnitSharing = `-- name: CountAllProjectPropertyUnitSharing :one
WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        external_sharing.unit_id,
        unit_category,
        property_id,
        phase_id,
        sale_unit.title,
        rent_unit.title as rent_title       
    FROM
        external_sharing
    INNER JOIN
        users ON users.id = external_sharing.created_by
    LEFT JOIN units ON external_sharing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%')
    LEFT JOIN sale_unit ON units.id = sale_unit.unit_id AND unit_category ILIKE '%sale%' 
    LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%' 
    WHERE
         external_sharing.is_project = true
         AND external_sharing.unit_id IS NOT NULL
         AND external_sharing.is_unit = true
         -- 
      AND CASE WHEN $2::bigint = 0 THEN true ELSE  $2::bigint = external_sharing.created_by  END 
    UNION ALL 
           
  SELECT
          internal_sharing.project_id as project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        internal_sharing.unit_id,
        unit_category,
        property_id,
        phase_id,
        sale_unit.title,
        rent_unit.title as rent_title 
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
     LEFT JOIN units ON internal_sharing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%' )
     LEFT JOIN sale_unit ON units.id = sale_unit.unit_id   AND unit_category ILIKE '%sale%'
     LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%'
    Where internal_sharing.is_project = true 
    AND internal_sharing.is_unit = true  
    AND internal_sharing.unit_id IS NOT NULL
    ---
    AND CASE WHEN $2::bigint = 0 THEN true ELSE  $2::bigint =  internal_sharing.created_by  END 
)
SELECT
  COUNT(DISTINCT x.unit_id) AS total_count
    -- x.external_id,
    -- x.project_id,
    -- x.created_by,
    -- MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    -- MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    -- CASE WHEN @user_id::bigint = x.created_by THEN true ELSE false END AS unshared_available,
    -- x.created_at,
    -- x.unit_id,
    -- x.unit_category,
    -- x.property_id,
    -- x.phase_id,
    -- MAX(x.title) as title,
    -- MAX(x.rent_title)as rent_title
FROM
    x
    LEFT JOIN projects ON x.project_id = projects.id
    LEFT JOIN units ON x.unit_id = units.id
    LEFT JOIN project_properties ON x.property_id =  project_properties.id
    LEFT JOIN phases ON x.phase_id = phases.id
WHERE 
   ($1 = '%%'
     OR  units.ref_no ILIKE $1
     OR  projects.project_name ILIKE $1
     OR  project_properties.property_name ILIKE $1
     OR  phases.phase_name ILIKE $1
     OR  x.unit_category ILIKE $1
     OR  x.title ILIKE $1
     OR  x.rent_title ILIKE $1
   )
`

type CountAllProjectPropertyUnitSharingParams struct {
	Search interface{} `json:"search"`
	UserID int64       `json:"user_id"`
}

func (q *Queries) CountAllProjectPropertyUnitSharing(ctx context.Context, arg CountAllProjectPropertyUnitSharingParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProjectPropertyUnitSharing, arg.Search, arg.UserID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countProjectPropertySharing = `-- name: CountProjectPropertySharing :one
WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        property_id,
        phase_id
    FROM
        external_sharing
    INNER JOIN
        users ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = true 
        AND external_sharing.property_key IS NOT NULL
        AND external_sharing.property_id IS NOT NULL
        AND external_sharing.is_property = true
        AND (external_sharing.is_unit IS false OR external_sharing.is_unit IS NULL)
        AND CASE WHEN $2::bigint = 0 THEN true ELSE $2::bigint = created_by END 
    UNION ALL 
           
    SELECT
        internal_sharing.project_id as project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        property_id,
        phase_id
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
    WHERE
        internal_sharing.is_project = true 
        AND internal_sharing.is_property = true
        AND internal_sharing.property_key IS NOT NULL
        AND internal_sharing.property_id IS NOT NULL
        AND (internal_sharing.is_unit IS false OR internal_sharing.is_unit IS NULL)
        AND CASE WHEN $2::bigint = 0 THEN true ELSE $2::bigint = created_by END 
)
SELECT
    COUNT(DISTINCT x.property_id) AS total_count
FROM
    x
    LEFT JOIN projects ON project_id = projects.id
	LEFT JOIN phases ON x.phase_id = phases.id
    LEFT JOIN project_properties ON x.property_id =  project_properties.id    
WHERE 
   ( $1 = '%%'
      OR  projects.project_name ILIKE $1
      OR project_properties.ref_no ILIKE $1
      OR project_properties.property_name ILIKE $1
      OR phases.phase_name ILIKE $1
     )
`

type CountProjectPropertySharingParams struct {
	Search interface{} `json:"search"`
	UserID int64       `json:"user_id"`
}

// FROM
//
//	x
//	INNER JOIN project_properties pp ON x.property_id = pp.id;
func (q *Queries) CountProjectPropertySharing(ctx context.Context, arg CountProjectPropertySharingParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectPropertySharing, arg.Search, arg.UserID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getAllProjectPropertySharing = `-- name: GetAllProjectPropertySharing :many
WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        property_id,
        phase_id
    FROM
        external_sharing
    INNER JOIN
        users  ON users.id = external_sharing.created_by
    WHERE
         external_sharing.is_project = true 
         AND external_sharing.property_key IS NOT NULL
         AND external_sharing.property_id IS NOT NULL
         AND external_sharing.is_property = true
         AND (external_sharing.is_unit IS false OR external_sharing.is_unit IS NULL)
         ---
         AND CASE WHEN $3::bigint = 0 THEN true ELSE  $3::bigint =  created_by END 
    UNION ALL 
           
  SELECT
         internal_sharing.project_id as project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        property_id,
        phase_id
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
    Where internal_sharing.is_project = true 
    AND internal_sharing.is_property = true AND internal_sharing.property_key  IS NOT NULL
    AND internal_sharing.property_id  IS NOT NULL
    AND (internal_sharing.is_unit IS false OR internal_sharing.is_unit IS NULL)
    ---
    AND CASE WHEN $3::bigint = 0 THEN true ELSE  $3::bigint =  created_by  END 
)
SELECT
    x.external_id,
    x.project_id,
    x.created_by,
    MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = x.created_by THEN true ELSE false END AS unshared_available,
    x.created_at,
    x.property_id,
    x.phase_id
FROM
    x
    LEFT JOIN projects ON project_id = projects.id
	LEFT JOIN phases ON x.phase_id = phases.id
    LEFT JOIN project_properties ON x.property_id =  project_properties.id
     
WHERE 
   ( $4 = '%%'
      OR  projects.project_name ILIKE $4
      OR project_properties.ref_no ILIKE $4
      OR project_properties.property_name ILIKE $4
      OR phases.phase_name ILIKE $4
     ) 
GROUP BY
    project_id,
    x.created_by,
    x.external_id,
    x.created_at,
    x.property_id,
    x.phase_id
    ORDER BY created_at DESC
    LIMIT $1 OFFSET $2
`

type GetAllProjectPropertySharingParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	UserID int64       `json:"user_id"`
	Search interface{} `json:"search"`
}

type GetAllProjectPropertySharingRow struct {
	ExternalID        int64       `json:"external_id"`
	ProjectID         pgtype.Int8 `json:"project_id"`
	CreatedBy         int64       `json:"created_by"`
	Internal          string      `json:"internal"`
	External          string      `json:"external"`
	UnsharedAvailable pgtype.Bool `json:"unshared_available"`
	CreatedAt         time.Time   `json:"created_at"`
	PropertyID        pgtype.Int8 `json:"property_id"`
	PhaseID           pgtype.Int8 `json:"phase_id"`
}

func (q *Queries) GetAllProjectPropertySharing(ctx context.Context, arg GetAllProjectPropertySharingParams) ([]GetAllProjectPropertySharingRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertySharing,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPropertySharingRow
	for rows.Next() {
		var i GetAllProjectPropertySharingRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.ProjectID,
			&i.CreatedBy,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
			&i.CreatedAt,
			&i.PropertyID,
			&i.PhaseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertyUnitSharing = `-- name: GetAllProjectPropertyUnitSharing :many
WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        external_sharing.unit_id,
        unit_category,
        property_id,
        phase_id,
        sale_unit.title,
        rent_unit.title as rent_title       
    FROM
        external_sharing
    INNER JOIN
        users ON users.id = external_sharing.created_by
    LEFT JOIN units ON external_sharing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%')
    LEFT JOIN sale_unit ON units.id = sale_unit.unit_id AND unit_category ILIKE '%sale%' 
    LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%' 
    WHERE
         external_sharing.is_project = true
         AND external_sharing.unit_id IS NOT NULL
         AND external_sharing.is_unit = true
         -- 
      AND CASE WHEN $3::bigint = 0 THEN true ELSE  $3::bigint = external_sharing.created_by  END 
    UNION ALL 
           
  SELECT
          internal_sharing.project_id as project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        internal_sharing.unit_id,
        unit_category,
        property_id,
        phase_id,
        sale_unit.title,
        rent_unit.title as rent_title 
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
     LEFT JOIN units ON internal_sharing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%' )
     LEFT JOIN sale_unit ON units.id = sale_unit.unit_id   AND unit_category ILIKE '%sale%'
     LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%'
    Where internal_sharing.is_project = true 
    AND internal_sharing.is_unit = true  
    AND internal_sharing.unit_id IS NOT NULL
    ---
    AND CASE WHEN $3::bigint = 0 THEN true ELSE  $3::bigint =  internal_sharing.created_by  END 
)
SELECT
    x.external_id,
    x.project_id,
    x.created_by,
    MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = x.created_by THEN true ELSE false END AS unshared_available,
    x.created_at,
    x.unit_id,
    x.unit_category,
    x.property_id,
    x.phase_id,
    MAX(x.title) as title,
    MAX(x.rent_title)as rent_title
FROM
    x
    LEFT JOIN projects ON x.project_id = projects.id
    LEFT JOIN units ON x.unit_id = units.id
    LEFT JOIN project_properties ON x.property_id =  project_properties.id
    LEFT JOIN phases ON x.phase_id = phases.id
WHERE 
   ($4 = '%%'
     OR  units.ref_no ILIKE $4
     OR  projects.project_name ILIKE $4
     OR  project_properties.property_name ILIKE $4
     OR  phases.phase_name ILIKE $4
     OR  x.unit_category ILIKE $4
     OR  x.title ILIKE $4
     OR  x.rent_title ILIKE $4
   ) 
GROUP BY
    x.project_id,
    x.created_by,
    x.external_id,
    x.created_at,
    x.unit_id,
    x.unit_category,
    x.property_id,
    x.phase_id,
    x.title,
    x.rent_title
    ORDER BY x.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllProjectPropertyUnitSharingParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	UserID int64       `json:"user_id"`
	Search interface{} `json:"search"`
}

type GetAllProjectPropertyUnitSharingRow struct {
	ExternalID        int64       `json:"external_id"`
	ProjectID         pgtype.Int8 `json:"project_id"`
	CreatedBy         int64       `json:"created_by"`
	Internal          string      `json:"internal"`
	External          string      `json:"external"`
	UnsharedAvailable pgtype.Bool `json:"unshared_available"`
	CreatedAt         time.Time   `json:"created_at"`
	UnitID            pgtype.Int8 `json:"unit_id"`
	UnitCategory      pgtype.Text `json:"unit_category"`
	PropertyID        pgtype.Int8 `json:"property_id"`
	PhaseID           pgtype.Int8 `json:"phase_id"`
	Title             interface{} `json:"title"`
	RentTitle         interface{} `json:"rent_title"`
}

func (q *Queries) GetAllProjectPropertyUnitSharing(ctx context.Context, arg GetAllProjectPropertyUnitSharingParams) ([]GetAllProjectPropertyUnitSharingRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertyUnitSharing,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPropertyUnitSharingRow
	for rows.Next() {
		var i GetAllProjectPropertyUnitSharingRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.ProjectID,
			&i.CreatedBy,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
			&i.CreatedAt,
			&i.UnitID,
			&i.UnitCategory,
			&i.PropertyID,
			&i.PhaseID,
			&i.Title,
			&i.RentTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
