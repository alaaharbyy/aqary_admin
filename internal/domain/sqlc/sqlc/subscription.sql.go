// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAgentProductByUserID = `-- name: GetAgentProductByUserID :many
SELECT 
    u.id AS user_id,
   subscription_products.product,
    ap.no_of_products
FROM 
    users u
JOIN 
    company_users cu ON u.id = cu.users_id
LEFT JOIN 
    agent_products ap ON cu.id = ap.company_user_id
    
INNER JOIN subscription_products ON ap.product =  subscription_products.id
WHERE 
    u.id = $1
`

type GetAgentProductByUserIDRow struct {
	UserID       int64       `json:"user_id"`
	Product      string      `json:"product"`
	NoOfProducts pgtype.Int4 `json:"no_of_products"`
}

func (q *Queries) GetAgentProductByUserID(ctx context.Context, userID int64) ([]GetAgentProductByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getAgentProductByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAgentProductByUserIDRow
	for rows.Next() {
		var i GetAgentProductByUserIDRow
		if err := rows.Scan(&i.UserID, &i.Product, &i.NoOfProducts); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAgentProducts = `-- name: GetAgentProducts :one
SELECT id, company_user_id, product, no_of_products, created_by, created_at, updated_at FROM agent_products
WHERE company_user_id = $1 AND product = $2
`

type GetAgentProductsParams struct {
	CompanyUserID int64 `json:"company_user_id"`
	ProductID     int64 `json:"product_id"`
}

func (q *Queries) GetAgentProducts(ctx context.Context, arg GetAgentProductsParams) (AgentProduct, error) {
	row := q.db.QueryRow(ctx, getAgentProducts, arg.CompanyUserID, arg.ProductID)
	var i AgentProduct
	err := row.Scan(
		&i.ID,
		&i.CompanyUserID,
		&i.Product,
		&i.NoOfProducts,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllPaymentsBySubscriptionOrder = `-- name: GetAllPaymentsBySubscriptionOrder :many
SELECT p.id, p.order_id, p.due_date, p.payment_method, p.amount, p.payment_date, p.bank, p.cheque_no, p.reference_no, p.invoice_file, p.status, p.created_by, p.created_at, p.updated_at, so.order_no
FROM payments p
INNER JOIN subscription_order so ON p.order_id = so.id
WHERE so.id = $3
ORDER BY p.updated_at DESC 
LIMIT $1 
OFFSET $2
`

type GetAllPaymentsBySubscriptionOrderParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	ID     int64 `json:"id"`
}

type GetAllPaymentsBySubscriptionOrderRow struct {
	ID            int64              `json:"id"`
	OrderID       int64              `json:"order_id"`
	DueDate       time.Time          `json:"due_date"`
	PaymentMethod pgtype.Int8        `json:"payment_method"`
	Amount        float64            `json:"amount"`
	PaymentDate   pgtype.Timestamptz `json:"payment_date"`
	Bank          pgtype.Text        `json:"bank"`
	ChequeNo      pgtype.Text        `json:"cheque_no"`
	ReferenceNo   pgtype.Text        `json:"reference_no"`
	InvoiceFile   pgtype.Text        `json:"invoice_file"`
	Status        int64              `json:"status"`
	CreatedBy     int64              `json:"created_by"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	OrderNo       string             `json:"order_no"`
}

// ba.bank_name AS bank
// LEFT JOIN bank_account_details ba ON p.bank != null
// AND p.bank = ba.id
func (q *Queries) GetAllPaymentsBySubscriptionOrder(ctx context.Context, arg GetAllPaymentsBySubscriptionOrderParams) ([]GetAllPaymentsBySubscriptionOrderRow, error) {
	rows, err := q.db.Query(ctx, getAllPaymentsBySubscriptionOrder, arg.Limit, arg.Offset, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPaymentsBySubscriptionOrderRow
	for rows.Next() {
		var i GetAllPaymentsBySubscriptionOrderRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.DueDate,
			&i.PaymentMethod,
			&i.Amount,
			&i.PaymentDate,
			&i.Bank,
			&i.ChequeNo,
			&i.ReferenceNo,
			&i.InvoiceFile,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrderNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPaymentsBySubscriptionOrderCounts = `-- name: GetAllPaymentsBySubscriptionOrderCounts :one
SELECT COUNT(p.id)
FROM payments p
WHERE p.order_id = $1
`

func (q *Queries) GetAllPaymentsBySubscriptionOrderCounts(ctx context.Context, orderID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAllPaymentsBySubscriptionOrderCounts, orderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllSubscriptionOrders = `-- name: GetAllSubscriptionOrders :many



















SELECT
    so.id,
    so.order_no,
    so.start_date,
    so.end_date,
    so.total_amount,
    so.no_of_payments,
    so.payment_plan,
    so.status,
    ad.countries_id,
    TRIM(CONCAT(countries.alpha3_code, ', ', states.state)) AS location,
    CASE
        WHEN so.subscriber_type = 1 THEN companies.company_name
        ELSE TRIM(CONCAT(pr.first_name, ' ', pr.last_name))
    END::VARCHAR AS "subscriber_name",
    so.subscriber_type,
    CASE
        WHEN so.subscriber_type = 2 THEN 'Freelancer'
        WHEN so.subscriber_type = 3 THEN 'Owner'
        ELSE company_category.category_name
    END::VARCHAR AS "category_name",
    CASE WHEN (so.contract_file IS NULL OR so.contract_file = '') THEN so.draft_contract ELSE so.contract_file END::VARCHAR AS contract_file 
FROM
    subscription_order so
    LEFT JOIN companies ON so.subscriber_type = 1
    AND companies.status != 6
    AND companies.id = so.subscriber_id
    LEFT JOIN users ON so.subscriber_type IN (2, 3)
    AND users.status != 6
    AND users.id = so.subscriber_id 
    AND users.user_types_id IN (3, 4)
    LEFT JOIN profiles pr ON so.subscriber_type IN (2, 3)
    AND users.id = pr.users_id
    LEFT JOIN company_activities ON companies.company_activities_id[1] = company_activities.id
    LEFT JOIN company_category ON company_activities.company_category_id = company_category.id
    LEFT JOIN addresses ad ON ad.id = CASE WHEN so.subscriber_type = 2 THEN pr.addresses_id WHEN  so.subscriber_type = 3 THEN pr.addresses_id WHEN so.subscriber_type = 1 THEN companies.addresses_id END
    LEFT JOIN countries ON ad.countries_id = countries.id
    LEFT JOIN states ON ad.states_id = states.id
WHERE
      (users.status!=6 OR companies.status!=6)
ORDER BY so.updated_at DESC 
LIMIT $1 
OFFSET $2
`

type GetAllSubscriptionOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllSubscriptionOrdersRow struct {
	ID             int64              `json:"id"`
	OrderNo        string             `json:"order_no"`
	StartDate      pgtype.Timestamptz `json:"start_date"`
	EndDate        pgtype.Timestamptz `json:"end_date"`
	TotalAmount    float64            `json:"total_amount"`
	NoOfPayments   int64              `json:"no_of_payments"`
	PaymentPlan    pgtype.Int8        `json:"payment_plan"`
	Status         int64              `json:"status"`
	CountriesID    pgtype.Int8        `json:"countries_id"`
	Location       string             `json:"location"`
	SubscriberName string             `json:"subscriber_name"`
	SubscriberType int64              `json:"subscriber_type"`
	CategoryName   string             `json:"category_name"`
	ContractFile   string             `json:"contract_file"`
}

// ----------------------------------------------------------------------------------
func (q *Queries) GetAllSubscriptionOrders(ctx context.Context, arg GetAllSubscriptionOrdersParams) ([]GetAllSubscriptionOrdersRow, error) {
	rows, err := q.db.Query(ctx, getAllSubscriptionOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriptionOrdersRow
	for rows.Next() {
		var i GetAllSubscriptionOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.StartDate,
			&i.EndDate,
			&i.TotalAmount,
			&i.NoOfPayments,
			&i.PaymentPlan,
			&i.Status,
			&i.CountriesID,
			&i.Location,
			&i.SubscriberName,
			&i.SubscriberType,
			&i.CategoryName,
			&i.ContractFile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOFSubscriptionOrders = `-- name: GetNumberOFSubscriptionOrders :one
SELECT
    COUNT(*)
FROM
    subscription_order so
LEFT JOIN companies ON so.subscriber_type = 1
    AND companies.status != 6
    AND companies.id = so.subscriber_id
    LEFT JOIN users ON so.subscriber_type IN (2, 3)
    AND users.status != 6
    AND users.id = so.subscriber_id 
    AND users.user_types_id=  so.subscriber_type

WHERE
    so.status != 6 AND (users.status!=6 OR companies.status!=6)
`

func (q *Queries) GetNumberOFSubscriptionOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOFSubscriptionOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOverDuePayments = `-- name: GetOverDuePayments :many
SELECT id, order_id, due_date, amount
FROM payments
WHERE due_date < CURRENT_TIMESTAMP
AND status = 1 
AND order_id = $1
ORDER BY due_date ASC
`

type GetOverDuePaymentsRow struct {
	ID      int64     `json:"id"`
	OrderID int64     `json:"order_id"`
	DueDate time.Time `json:"due_date"`
	Amount  float64   `json:"amount"`
}

func (q *Queries) GetOverDuePayments(ctx context.Context, orderID int64) ([]GetOverDuePaymentsRow, error) {
	rows, err := q.db.Query(ctx, getOverDuePayments, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOverDuePaymentsRow
	for rows.Next() {
		var i GetOverDuePaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.DueDate,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionOrderDetail = `-- name: GetSubscriptionOrderDetail :many
SELECT so.id, so.order_no, so.subscriber_id, so.subscriber_type, so.start_date, so.end_date, so.sign_date, so.total_amount, so.vat, so.no_of_payments, so.payment_plan, so.notes, so.status, so.created_by, so.created_at, so.updated_at, so.draft_contract, so.contract_file,
CASE
        WHEN so.subscriber_type = 1 THEN companies.company_name
        ELSE TRIM(CONCAT(pr.first_name, ' ', pr.last_name))
    END::VARCHAR AS "subscriber_name",
    company_types.id AS company_type_id,
    company_types.title AS company_type_title,
    company_types.title_ar AS company_type_title_ar,
    JSON_AGG(subscription_package) AS packages FROM  subscription_order so
INNER JOIN subscription_package ON subscription_package.subscription_order_id = so.id
LEFT JOIN companies ON so.subscriber_type = 1
    AND companies.id = so.subscriber_id
 LEFT JOIN company_types ON company_types.id = companies.company_type
    LEFT JOIN users ON so.subscriber_type IN (2, 3)
    AND users.id = so.subscriber_id 
    AND users.user_types_id IN (3, 4)
    LEFT JOIN profiles pr ON so.subscriber_type IN (2, 3)
    AND users.id = pr.users_id
WHERE order_no = $1
GROUP BY so.id,companies.id,pr.id,company_types.id
`

type GetSubscriptionOrderDetailRow struct {
	ID                 int64              `json:"id"`
	OrderNo            string             `json:"order_no"`
	SubscriberID       int64              `json:"subscriber_id"`
	SubscriberType     int64              `json:"subscriber_type"`
	StartDate          pgtype.Timestamptz `json:"start_date"`
	EndDate            pgtype.Timestamptz `json:"end_date"`
	SignDate           pgtype.Timestamptz `json:"sign_date"`
	TotalAmount        float64            `json:"total_amount"`
	Vat                float64            `json:"vat"`
	NoOfPayments       int64              `json:"no_of_payments"`
	PaymentPlan        pgtype.Int8        `json:"payment_plan"`
	Notes              string             `json:"notes"`
	Status             int64              `json:"status"`
	CreatedBy          int64              `json:"created_by"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
	DraftContract      string             `json:"draft_contract"`
	ContractFile       pgtype.Text        `json:"contract_file"`
	SubscriberName     string             `json:"subscriber_name"`
	CompanyTypeID      pgtype.Int8        `json:"company_type_id"`
	CompanyTypeTitle   pgtype.Text        `json:"company_type_title"`
	CompanyTypeTitleAr pgtype.Text        `json:"company_type_title_ar"`
	Packages           []byte             `json:"packages"`
}

func (q *Queries) GetSubscriptionOrderDetail(ctx context.Context, orderNo string) ([]GetSubscriptionOrderDetailRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionOrderDetail, orderNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionOrderDetailRow
	for rows.Next() {
		var i GetSubscriptionOrderDetailRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.SubscriberID,
			&i.SubscriberType,
			&i.StartDate,
			&i.EndDate,
			&i.SignDate,
			&i.TotalAmount,
			&i.Vat,
			&i.NoOfPayments,
			&i.PaymentPlan,
			&i.Notes,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DraftContract,
			&i.ContractFile,
			&i.SubscriberName,
			&i.CompanyTypeID,
			&i.CompanyTypeTitle,
			&i.CompanyTypeTitleAr,
			&i.Packages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionOrdersByCompany = `-- name: GetSubscriptionOrdersByCompany :many
SELECT 
  so.id AS subscription_order_id, 
  so.order_no,
  companies.company_name::VARCHAR AS "subscriber_name", 
  so.start_date, 
  so.end_date, 
  so.total_amount, 
  so.status,
  JSON_AGG(
    JSON_BUILD_OBJECT(
      'product', sp.product, 'product_name', 
      spp.product, 'no_of_products', sp.no_of_products, 
      'product_discount', sp.product_discount,
      'original_price_per_unit', sp.original_price_per_unit,
      'start_date', sp.start_date,
      'end_date', sp.end_date
    )
  ) AS products 
FROM 
  subscription_order so 
  JOIN subscription_package sp ON so.id = sp.subscription_order_id 
  LEFT JOIN subscription_products spp ON sp.product = spp.id 
  LEFT JOIN companies ON companies.id = so.subscriber_id 
  AND companies.status != 6
  LEFT JOIN addresses ad ON ad.id = companies.addresses_id 
  LEFT JOIN countries ON ad.countries_id = countries.id 
  LEFT JOIN states ON ad.states_id = states.id 
WHERE 
  so.subscriber_id = $1::bigint
  AND so.subscriber_type = 1 
  AND so.status != 6
  AND CASE WHEN $2::bigint = 0 THEN so.total_amount = 0 ELSE so.total_amount > 0 END 
GROUP BY 
  so.id, 
  companies.company_name, 
  so.start_date, 
  so.end_date, 
  so.total_amount 
LIMIT $4
OFFSET $3
`

type GetSubscriptionOrdersByCompanyParams struct {
	CompanyID int64       `json:"company_id"`
	Type      int64       `json:"type"`
	Offset    pgtype.Int4 `json:"offset"`
	Limit     pgtype.Int4 `json:"limit"`
}

type GetSubscriptionOrdersByCompanyRow struct {
	SubscriptionOrderID int64              `json:"subscription_order_id"`
	OrderNo             string             `json:"order_no"`
	SubscriberName      string             `json:"subscriber_name"`
	StartDate           pgtype.Timestamptz `json:"start_date"`
	EndDate             pgtype.Timestamptz `json:"end_date"`
	TotalAmount         float64            `json:"total_amount"`
	Status              int64              `json:"status"`
	Products            []byte             `json:"products"`
}

func (q *Queries) GetSubscriptionOrdersByCompany(ctx context.Context, arg GetSubscriptionOrdersByCompanyParams) ([]GetSubscriptionOrdersByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionOrdersByCompany,
		arg.CompanyID,
		arg.Type,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionOrdersByCompanyRow
	for rows.Next() {
		var i GetSubscriptionOrdersByCompanyRow
		if err := rows.Scan(
			&i.SubscriptionOrderID,
			&i.OrderNo,
			&i.SubscriberName,
			&i.StartDate,
			&i.EndDate,
			&i.TotalAmount,
			&i.Status,
			&i.Products,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionOrdersCountByCompany = `-- name: GetSubscriptionOrdersCountByCompany :one
SELECT
    COUNT(*)
FROM
    subscription_order so
LEFT JOIN companies ON companies.id = so.subscriber_id
WHERE
    so.status != 6 AND companies.status!=6
    AND companies.id = $1::bigint
    AND so.subscriber_type = 1 
    AND CASE WHEN $2::bigint = 0 THEN so.total_amount = 0 ELSE so.total_amount > 0 END
`

type GetSubscriptionOrdersCountByCompanyParams struct {
	CompanyID int64 `json:"company_id"`
	Type      int64 `json:"type"`
}

func (q *Queries) GetSubscriptionOrdersCountByCompany(ctx context.Context, arg GetSubscriptionOrdersCountByCompanyParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSubscriptionOrdersCountByCompany, arg.CompanyID, arg.Type)
	var count int64
	err := row.Scan(&count)
	return count, err
}
