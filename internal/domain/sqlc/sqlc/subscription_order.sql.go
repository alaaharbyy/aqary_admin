// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription_order.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateSubscriptionOrder = `-- name: ActivateSubscriptionOrder :one
UPDATE subscription_order
SET status = $1
WHERE id = $2
RETURNING id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file
`

type ActivateSubscriptionOrderParams struct {
	Status int64 `json:"status"`
	ID     int64 `json:"id"`
}

func (q *Queries) ActivateSubscriptionOrder(ctx context.Context, arg ActivateSubscriptionOrderParams) (SubscriptionOrder, error) {
	row := q.db.QueryRow(ctx, activateSubscriptionOrder, arg.Status, arg.ID)
	var i SubscriptionOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.SubscriberID,
		&i.SubscriberType,
		&i.StartDate,
		&i.EndDate,
		&i.SignDate,
		&i.TotalAmount,
		&i.Vat,
		&i.NoOfPayments,
		&i.PaymentPlan,
		&i.Notes,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DraftContract,
		&i.ContractFile,
	)
	return i, err
}

const addDraftContractFile = `-- name: AddDraftContractFile :exec
UPDATE subscription_order SET draft_contract = $1 WHERE id = $2
`

type AddDraftContractFileParams struct {
	DraftContract string `json:"draft_contract"`
	ID            int64  `json:"id"`
}

func (q *Queries) AddDraftContractFile(ctx context.Context, arg AddDraftContractFileParams) error {
	_, err := q.db.Exec(ctx, addDraftContractFile, arg.DraftContract, arg.ID)
	return err
}

const addFinalContractFile = `-- name: AddFinalContractFile :exec
UPDATE subscription_order SET contract_file = $1 WHERE id = $2
`

type AddFinalContractFileParams struct {
	ContractFile pgtype.Text `json:"contract_file"`
	ID           int64       `json:"id"`
}

func (q *Queries) AddFinalContractFile(ctx context.Context, arg AddFinalContractFileParams) error {
	_, err := q.db.Exec(ctx, addFinalContractFile, arg.ContractFile, arg.ID)
	return err
}

const checkIfSubscriptionOrderExistBySubscriberId = `-- name: CheckIfSubscriptionOrderExistBySubscriberId :one
SELECT id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file FROM subscription_order WHERE status != 4 AND subscriber_id = $1 AND subscriber_type = $2 AND total_amount = $3
`

type CheckIfSubscriptionOrderExistBySubscriberIdParams struct {
	SubscriberID   int64   `json:"subscriber_id"`
	SubscriberType int64   `json:"subscriber_type"`
	TotalAmount    float64 `json:"total_amount"`
}

func (q *Queries) CheckIfSubscriptionOrderExistBySubscriberId(ctx context.Context, arg CheckIfSubscriptionOrderExistBySubscriberIdParams) (SubscriptionOrder, error) {
	row := q.db.QueryRow(ctx, checkIfSubscriptionOrderExistBySubscriberId, arg.SubscriberID, arg.SubscriberType, arg.TotalAmount)
	var i SubscriptionOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.SubscriberID,
		&i.SubscriberType,
		&i.StartDate,
		&i.EndDate,
		&i.SignDate,
		&i.TotalAmount,
		&i.Vat,
		&i.NoOfPayments,
		&i.PaymentPlan,
		&i.Notes,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DraftContract,
		&i.ContractFile,
	)
	return i, err
}

const createInitialOrderPaymentBulk = `-- name: CreateInitialOrderPaymentBulk :exec
INSERT INTO payments(
    order_id,
    due_date,
    amount,
    created_by
)VALUES(
    $1,
    unnest($2::timestamptz[]),
    $3,
    $4
)
`

type CreateInitialOrderPaymentBulkParams struct {
	OrderID   int64       `json:"order_id"`
	DueDate   []time.Time `json:"due_date"`
	Amount    float64     `json:"amount"`
	CreatedBy int64       `json:"created_by"`
}

func (q *Queries) CreateInitialOrderPaymentBulk(ctx context.Context, arg CreateInitialOrderPaymentBulkParams) error {
	_, err := q.db.Exec(ctx, createInitialOrderPaymentBulk,
		arg.OrderID,
		arg.DueDate,
		arg.Amount,
		arg.CreatedBy,
	)
	return err
}

const createOrderPayment = `-- name: CreateOrderPayment :one
INSERT INTO payments(
    order_id,
    due_date,
    payment_method,
    amount,
    payment_date,
    bank,
    cheque_no,
    invoice_file,
    status,
    created_by
)VALUES(
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)RETURNING id, order_id, due_date, payment_method, amount, payment_date, bank, cheque_no, reference_no, invoice_file, status, created_by, created_at, updated_at
`

type CreateOrderPaymentParams struct {
	OrderID       int64              `json:"order_id"`
	DueDate       time.Time          `json:"due_date"`
	PaymentMethod pgtype.Int8        `json:"payment_method"`
	Amount        float64            `json:"amount"`
	PaymentDate   pgtype.Timestamptz `json:"payment_date"`
	Bank          pgtype.Text        `json:"bank"`
	ChequeNo      pgtype.Text        `json:"cheque_no"`
	InvoiceFile   pgtype.Text        `json:"invoice_file"`
	Status        int64              `json:"status"`
	CreatedBy     int64              `json:"created_by"`
}

func (q *Queries) CreateOrderPayment(ctx context.Context, arg CreateOrderPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createOrderPayment,
		arg.OrderID,
		arg.DueDate,
		arg.PaymentMethod,
		arg.Amount,
		arg.PaymentDate,
		arg.Bank,
		arg.ChequeNo,
		arg.InvoiceFile,
		arg.Status,
		arg.CreatedBy,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.DueDate,
		&i.PaymentMethod,
		&i.Amount,
		&i.PaymentDate,
		&i.Bank,
		&i.ChequeNo,
		&i.ReferenceNo,
		&i.InvoiceFile,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubscriptionOrder = `-- name: CreateSubscriptionOrder :one
INSERT INTO "subscription_order" (
    "order_no", 
    "subscriber_id", 
    "subscriber_type", 
    "start_date", 
    "end_date", 
    "sign_date", 
    "total_amount", 
    "vat", 
    "no_of_payments", 
    "payment_plan", 
    "notes", 
    "status", 
    "created_by",
    "draft_contract"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file
`

type CreateSubscriptionOrderParams struct {
	OrderNo        string             `json:"order_no"`
	SubscriberID   int64              `json:"subscriber_id"`
	SubscriberType int64              `json:"subscriber_type"`
	StartDate      pgtype.Timestamptz `json:"start_date"`
	EndDate        pgtype.Timestamptz `json:"end_date"`
	SignDate       pgtype.Timestamptz `json:"sign_date"`
	TotalAmount    float64            `json:"total_amount"`
	Vat            float64            `json:"vat"`
	NoOfPayments   int64              `json:"no_of_payments"`
	PaymentPlan    pgtype.Int8        `json:"payment_plan"`
	Notes          string             `json:"notes"`
	Status         int64              `json:"status"`
	CreatedBy      int64              `json:"created_by"`
	DraftContract  string             `json:"draft_contract"`
}

// Create a new subscription order and return the inserted row
func (q *Queries) CreateSubscriptionOrder(ctx context.Context, arg CreateSubscriptionOrderParams) (SubscriptionOrder, error) {
	row := q.db.QueryRow(ctx, createSubscriptionOrder,
		arg.OrderNo,
		arg.SubscriberID,
		arg.SubscriberType,
		arg.StartDate,
		arg.EndDate,
		arg.SignDate,
		arg.TotalAmount,
		arg.Vat,
		arg.NoOfPayments,
		arg.PaymentPlan,
		arg.Notes,
		arg.Status,
		arg.CreatedBy,
		arg.DraftContract,
	)
	var i SubscriptionOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.SubscriberID,
		&i.SubscriberType,
		&i.StartDate,
		&i.EndDate,
		&i.SignDate,
		&i.TotalAmount,
		&i.Vat,
		&i.NoOfPayments,
		&i.PaymentPlan,
		&i.Notes,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DraftContract,
		&i.ContractFile,
	)
	return i, err
}

const deleteSubscriptionOrder = `-- name: DeleteSubscriptionOrder :exec
DELETE FROM "subscription_order"
WHERE "id" = $1
`

// Delete a subscription order by ID
func (q *Queries) DeleteSubscriptionOrder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionOrder, id)
	return err
}

const deleteSubscriptionOrderPayments = `-- name: DeleteSubscriptionOrderPayments :exec
DELETE FROM payments
USING subscription_order
WHERE payments.order_id = subscription_order.id 
AND subscription_order.order_no = $1 
AND payments.status = 1 -- only unpaid
AND subscription_order.status = 1
`

func (q *Queries) DeleteSubscriptionOrderPayments(ctx context.Context, orderNo string) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionOrderPayments, orderNo)
	return err
}

const getAllSubscriberContracts = `-- name: GetAllSubscriberContracts :many
SELECT 
companies.ref_no,companies.company_name,
subscription_order.start_date,subscription_order.end_date,
subscription_order.status,subscription_order.order_no,
subscription_order.contract_file,
subscription_order.draft_contract,
COUNT(subscription_order.id) OVER() AS total_count
FROM subscription_order
LEFT JOIN companies ON companies.id = subscription_order.subscriber_id AND subscription_order.subscriber_type = 1 -- company subscriber
WHERE companies.status IN (8,9)
LIMIT $2 OFFSET $1
`

type GetAllSubscriberContractsParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllSubscriberContractsRow struct {
	RefNo         pgtype.Text        `json:"ref_no"`
	CompanyName   pgtype.Text        `json:"company_name"`
	StartDate     pgtype.Timestamptz `json:"start_date"`
	EndDate       pgtype.Timestamptz `json:"end_date"`
	Status        int64              `json:"status"`
	OrderNo       string             `json:"order_no"`
	ContractFile  pgtype.Text        `json:"contract_file"`
	DraftContract string             `json:"draft_contract"`
	TotalCount    int64              `json:"total_count"`
}

func (q *Queries) GetAllSubscriberContracts(ctx context.Context, arg GetAllSubscriberContractsParams) ([]GetAllSubscriberContractsRow, error) {
	rows, err := q.db.Query(ctx, getAllSubscriberContracts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriberContractsRow
	for rows.Next() {
		var i GetAllSubscriberContractsRow
		if err := rows.Scan(
			&i.RefNo,
			&i.CompanyName,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.OrderNo,
			&i.ContractFile,
			&i.DraftContract,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompaniesByLocationAndTypeID = `-- name: GetCompaniesByLocationAndTypeID :many
SELECT companies.id, companies.company_name
FROM companies 
LEFT JOIN addresses ON companies.addresses_id = addresses.id
WHERE companies.company_type = $1::bigint
AND companies.status NOT IN (5,6)
AND 
(CASE WHEN $2::bigint = 0 THEN true ELSE addresses.countries_id = $2::bigint END)
AND 
(CASE WHEN $3::bigint = 0 THEN true ELSE addresses.sub_communities_id = $3::bigint END)
AND
(CASE WHEN $4::bigint = 0 THEN true  ELSE addresses.communities_id = $4::bigint END)
AND
(CASE WHEN $5::bigint = 0 THEN true ELSE addresses.cities_id = $5::bigint END)
AND
(CASE WHEN $6::bigint = 0 THEN true  ELSE addresses.states_id = $6::bigint END)
`

type GetCompaniesByLocationAndTypeIDParams struct {
	CompanyType    int64 `json:"company_type"`
	CountryID      int64 `json:"country_id"`
	SubCommunities int64 `json:"sub_communities"`
	Communities    int64 `json:"communities"`
	Cities         int64 `json:"cities"`
	States         int64 `json:"states"`
}

type GetCompaniesByLocationAndTypeIDRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
}

func (q *Queries) GetCompaniesByLocationAndTypeID(ctx context.Context, arg GetCompaniesByLocationAndTypeIDParams) ([]GetCompaniesByLocationAndTypeIDRow, error) {
	rows, err := q.db.Query(ctx, getCompaniesByLocationAndTypeID,
		arg.CompanyType,
		arg.CountryID,
		arg.SubCommunities,
		arg.Communities,
		arg.Cities,
		arg.States,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompaniesByLocationAndTypeIDRow
	for rows.Next() {
		var i GetCompaniesByLocationAndTypeIDRow
		if err := rows.Scan(&i.ID, &i.CompanyName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSubscriptionProductCost = `-- name: GetLatestSubscriptionProductCost :many
WITH RankedCosts AS (
    SELECT
        sc.id,
        sc.price_per_unit,
        sp.id AS product_id,
        sp.product,
        sc.created_at,
        ROW_NUMBER() OVER (
            PARTITION BY sc.product
            ORDER BY sc.created_at DESC
        ) AS rn
    FROM
        subscription_cost sc
        INNER JOIN subscription_products sp ON sp.id = sc.product
        LEFT JOIN companies ON companies.id = $1 AND $2::bigint = 1 -- when  subscriber type is company
        LEFT JOIN addresses a1 ON a1.id = companies.addresses_id
        LEFT JOIN company_activities ON company_activities.id = ANY(companies.company_activities_id)
        LEFT JOIN company_category ON company_category.id = company_activities.company_category_id
        LEFT JOIN users ON users.id = $1 AND $2::bigint != 1 -- when  subscriber type is freelancer or owner
        LEFT JOIN profiles ON profiles.users_id = users.id
        LEFT JOIN addresses a2 ON a2.id = profiles.addresses_id
    WHERE
        sc.subscriber_type_id = $2::bigint
        AND (CASE WHEN $2::bigint = 1 THEN sc.countries_id = a1.countries_id ELSE sc.countries_id = a2.countries_id END)
        AND (
            $2::bigint != 1 -- when  subscriber type is freelancer or owner
            OR sc.category_id = company_category.id -- when subscriber type is company
        ) AND sp.id = ANY($3::bigint[])
)
SELECT
    id,
    price_per_unit,
    product_id,
    product AS product_name
FROM
    RankedCosts
WHERE
    rn = 1
`

type GetLatestSubscriptionProductCostParams struct {
	SubscriberID       int64   `json:"subscriber_id"`
	SubscriberTypeID   int64   `json:"subscriber_type_id"`
	ProductConstantIds []int64 `json:"product_constant_ids"`
}

type GetLatestSubscriptionProductCostRow struct {
	ID           int64   `json:"id"`
	PricePerUnit float64 `json:"price_per_unit"`
	ProductID    int64   `json:"product_id"`
	ProductName  string  `json:"product_name"`
}

func (q *Queries) GetLatestSubscriptionProductCost(ctx context.Context, arg GetLatestSubscriptionProductCostParams) ([]GetLatestSubscriptionProductCostRow, error) {
	rows, err := q.db.Query(ctx, getLatestSubscriptionProductCost, arg.SubscriberID, arg.SubscriberTypeID, arg.ProductConstantIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestSubscriptionProductCostRow
	for rows.Next() {
		var i GetLatestSubscriptionProductCostRow
		if err := rows.Scan(
			&i.ID,
			&i.PricePerUnit,
			&i.ProductID,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderPaymentById = `-- name: GetOrderPaymentById :one
SELECT payments.id, payments.order_id, payments.due_date, payments.payment_method, payments.amount, payments.payment_date, payments.bank, payments.cheque_no, payments.reference_no, payments.invoice_file, payments.status, payments.created_by, payments.created_at, payments.updated_at,order_no FROM payments
INNER JOIN subscription_order ON subscription_order.id = payments.order_id
WHERE payments.id = $1
`

type GetOrderPaymentByIdRow struct {
	ID            int64              `json:"id"`
	OrderID       int64              `json:"order_id"`
	DueDate       time.Time          `json:"due_date"`
	PaymentMethod pgtype.Int8        `json:"payment_method"`
	Amount        float64            `json:"amount"`
	PaymentDate   pgtype.Timestamptz `json:"payment_date"`
	Bank          pgtype.Text        `json:"bank"`
	ChequeNo      pgtype.Text        `json:"cheque_no"`
	ReferenceNo   pgtype.Text        `json:"reference_no"`
	InvoiceFile   pgtype.Text        `json:"invoice_file"`
	Status        int64              `json:"status"`
	CreatedBy     int64              `json:"created_by"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	OrderNo       string             `json:"order_no"`
}

func (q *Queries) GetOrderPaymentById(ctx context.Context, id int64) (GetOrderPaymentByIdRow, error) {
	row := q.db.QueryRow(ctx, getOrderPaymentById, id)
	var i GetOrderPaymentByIdRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.DueDate,
		&i.PaymentMethod,
		&i.Amount,
		&i.PaymentDate,
		&i.Bank,
		&i.ChequeNo,
		&i.ReferenceNo,
		&i.InvoiceFile,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrderNo,
	)
	return i, err
}

const getPackageDetailsForContract = `-- name: GetPackageDetailsForContract :one
SELECT
      subscription_order_id, 
    
 	COALESCE(MAX(CASE WHEN product = 1 THEN no_of_products END),0)::bigint AS standard,
    COALESCE(MAX(CASE WHEN product = 1 THEN product_discount END),0)::float AS standard_discount,
    COALESCE(MAX(CASE WHEN product = 1 THEN original_price_per_unit END),0)::float AS standard_unit_price,
  COALESCE( MAX(CASE WHEN product = 1 THEN start_date END),'0001-01-01')::DATE AS standard_start_date,
    COALESCE(MAX(CASE WHEN product = 1 THEN end_date  END),'0001-01-01')::DATE AS standard_end_date,
   
    
   COALESCE(MAX(CASE WHEN product = 2 THEN no_of_products END),0)::bigint AS featured,
   COALESCE(MAX(CASE WHEN product = 2 THEN product_discount END),0)::float AS featured_discount,
   COALESCE(MAX(CASE WHEN product = 2 THEN original_price_per_unit END),0)::float AS featured_unit_price,
  COALESCE(  MAX(CASE WHEN product = 2 THEN start_date END),'0001-01-01')::DATE AS featured_start_date,
  COALESCE(  MAX(CASE WHEN product = 2 THEN end_date END),'0001-01-01')::DATE AS featured_end_date,
    
    
   COALESCE(MAX(CASE WHEN product = 3 THEN no_of_products END),0)::bigint AS premium,
   COALESCE(MAX(CASE WHEN product = 3 THEN product_discount END),0)::float AS premium_discount,
   COALESCE(MAX(CASE WHEN product = 3 THEN original_price_per_unit END),0)::float AS premium_unit_price,
  COALESCE(  MAX(CASE WHEN product = 3 THEN start_date END),'0001-01-01')::DATE AS premium_start_date,
 COALESCE(   MAX(CASE WHEN product = 3 THEN end_date END),'0001-01-01')::DATE AS premium_end_date, 
    
    COALESCE(MAX(CASE WHEN product = 4 THEN no_of_products END),0)::bigint AS topdeals,
   COALESCE(MAX(CASE WHEN product = 4 THEN product_discount END),0)::float AS topdeals_discount,
   COALESCE(MAX(CASE WHEN product = 4 THEN original_price_per_unit END),0)::float AS topdeals_unit_price,
  COALESCE(  MAX(CASE WHEN product = 4 THEN start_date END),'0001-01-01')::DATE AS topdeals_start_date,
  COALESCE(  MAX(CASE WHEN product = 4 THEN end_date END),'0001-01-01')::DATE AS topdeals_end_date
FROM (
    SELECT 
    
        subscription_order_id, 
        no_of_products,
        product, 
        product_discount,
        original_price_per_unit,
        start_date,
        end_date, 
        ROW_NUMBER() OVER (PARTITION BY subscription_order_id ORDER BY id) AS row_num
    FROM 
        subscription_package
    WHERE 
        subscription_order_id = $1
) AS numbered_packages
GROUP BY subscription_order_id
`

type GetPackageDetailsForContractRow struct {
	SubscriptionOrderID int64     `json:"subscription_order_id"`
	Standard            int64     `json:"standard"`
	StandardDiscount    float64   `json:"standard_discount"`
	StandardUnitPrice   float64   `json:"standard_unit_price"`
	StandardStartDate   time.Time `json:"standard_start_date"`
	StandardEndDate     time.Time `json:"standard_end_date"`
	Featured            int64     `json:"featured"`
	FeaturedDiscount    float64   `json:"featured_discount"`
	FeaturedUnitPrice   float64   `json:"featured_unit_price"`
	FeaturedStartDate   time.Time `json:"featured_start_date"`
	FeaturedEndDate     time.Time `json:"featured_end_date"`
	Premium             int64     `json:"premium"`
	PremiumDiscount     float64   `json:"premium_discount"`
	PremiumUnitPrice    float64   `json:"premium_unit_price"`
	PremiumStartDate    time.Time `json:"premium_start_date"`
	PremiumEndDate      time.Time `json:"premium_end_date"`
	Topdeals            int64     `json:"topdeals"`
	TopdealsDiscount    float64   `json:"topdeals_discount"`
	TopdealsUnitPrice   float64   `json:"topdeals_unit_price"`
	TopdealsStartDate   time.Time `json:"topdeals_start_date"`
	TopdealsEndDate     time.Time `json:"topdeals_end_date"`
}

func (q *Queries) GetPackageDetailsForContract(ctx context.Context, subscriptionOrderID int64) (GetPackageDetailsForContractRow, error) {
	row := q.db.QueryRow(ctx, getPackageDetailsForContract, subscriptionOrderID)
	var i GetPackageDetailsForContractRow
	err := row.Scan(
		&i.SubscriptionOrderID,
		&i.Standard,
		&i.StandardDiscount,
		&i.StandardUnitPrice,
		&i.StandardStartDate,
		&i.StandardEndDate,
		&i.Featured,
		&i.FeaturedDiscount,
		&i.FeaturedUnitPrice,
		&i.FeaturedStartDate,
		&i.FeaturedEndDate,
		&i.Premium,
		&i.PremiumDiscount,
		&i.PremiumUnitPrice,
		&i.PremiumStartDate,
		&i.PremiumEndDate,
		&i.Topdeals,
		&i.TopdealsDiscount,
		&i.TopdealsUnitPrice,
		&i.TopdealsStartDate,
		&i.TopdealsEndDate,
	)
	return i, err
}

const getSubscriptionByOrderNo = `-- name: GetSubscriptionByOrderNo :one
SELECT id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file FROM subscription_order
WHERE order_no = $1
`

func (q *Queries) GetSubscriptionByOrderNo(ctx context.Context, orderNo string) (SubscriptionOrder, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByOrderNo, orderNo)
	var i SubscriptionOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.SubscriberID,
		&i.SubscriberType,
		&i.StartDate,
		&i.EndDate,
		&i.SignDate,
		&i.TotalAmount,
		&i.Vat,
		&i.NoOfPayments,
		&i.PaymentPlan,
		&i.Notes,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DraftContract,
		&i.ContractFile,
	)
	return i, err
}

const getSubscriptionOrder = `-- name: GetSubscriptionOrder :one
SELECT id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file FROM "subscription_order"
WHERE "id" = $1
`

// Get a subscription order by ID
func (q *Queries) GetSubscriptionOrder(ctx context.Context, id int64) (SubscriptionOrder, error) {
	row := q.db.QueryRow(ctx, getSubscriptionOrder, id)
	var i SubscriptionOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.SubscriberID,
		&i.SubscriberType,
		&i.StartDate,
		&i.EndDate,
		&i.SignDate,
		&i.TotalAmount,
		&i.Vat,
		&i.NoOfPayments,
		&i.PaymentPlan,
		&i.Notes,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DraftContract,
		&i.ContractFile,
	)
	return i, err
}

const getSubscriptionOrderByOrderNo = `-- name: GetSubscriptionOrderByOrderNo :many
SELECT id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file FROM subscription_order
WHERE order_no = $1
`

func (q *Queries) GetSubscriptionOrderByOrderNo(ctx context.Context, orderNo string) ([]SubscriptionOrder, error) {
	rows, err := q.db.Query(ctx, getSubscriptionOrderByOrderNo, orderNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionOrder
	for rows.Next() {
		var i SubscriptionOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.SubscriberID,
			&i.SubscriberType,
			&i.StartDate,
			&i.EndDate,
			&i.SignDate,
			&i.TotalAmount,
			&i.Vat,
			&i.NoOfPayments,
			&i.PaymentPlan,
			&i.Notes,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DraftContract,
			&i.ContractFile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionOrderBySubscriberID = `-- name: GetSubscriptionOrderBySubscriberID :one
SELECT id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file FROM subscription_order 
WHERE subscriber_id = $1
`

func (q *Queries) GetSubscriptionOrderBySubscriberID(ctx context.Context, subscriberID int64) (SubscriptionOrder, error) {
	row := q.db.QueryRow(ctx, getSubscriptionOrderBySubscriberID, subscriberID)
	var i SubscriptionOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.SubscriberID,
		&i.SubscriberType,
		&i.StartDate,
		&i.EndDate,
		&i.SignDate,
		&i.TotalAmount,
		&i.Vat,
		&i.NoOfPayments,
		&i.PaymentPlan,
		&i.Notes,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DraftContract,
		&i.ContractFile,
	)
	return i, err
}

const getSubscriptionOrderBySubscriberIDAndType = `-- name: GetSubscriptionOrderBySubscriberIDAndType :many
SELECT id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file FROM subscription_order 
WHERE subscriber_id = $1 AND subscriber_type = $2
`

type GetSubscriptionOrderBySubscriberIDAndTypeParams struct {
	SubscriberID   int64 `json:"subscriber_id"`
	SubscriberType int64 `json:"subscriber_type"`
}

func (q *Queries) GetSubscriptionOrderBySubscriberIDAndType(ctx context.Context, arg GetSubscriptionOrderBySubscriberIDAndTypeParams) ([]SubscriptionOrder, error) {
	rows, err := q.db.Query(ctx, getSubscriptionOrderBySubscriberIDAndType, arg.SubscriberID, arg.SubscriberType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionOrder
	for rows.Next() {
		var i SubscriptionOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.SubscriberID,
			&i.SubscriberType,
			&i.StartDate,
			&i.EndDate,
			&i.SignDate,
			&i.TotalAmount,
			&i.Vat,
			&i.NoOfPayments,
			&i.PaymentPlan,
			&i.Notes,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DraftContract,
			&i.ContractFile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionOrderDetailsForContract = `-- name: GetSubscriptionOrderDetailsForContract :many
WITH licenses AS (
SELECT id, license_file_url, license_no, license_issue_date, license_registration_date, license_expiry_date, license_type_id, state_id, entity_type_id, entity_id, metadata FROM license WHERE license.license_type_id IN (1,2) AND entity_type_id IN (6,9)
)SELECT
    so.id AS subscription_order_id,
    so.start_date AS contract_start_date,
    so.end_date AS contract_end_date,
    so.total_amount,
    
   CASE WHEN so.subscriber_type IN (2,3) THEN CONCAT(p.first_name, ' ', p.last_name) ELSE companies.company_name END::VARCHAR AS subscriber_name,
   CASE WHEN so.subscriber_type IN (2,3) THEN p.ref_no ELSE companies.ref_no END::VARCHAR AS ref_no,
    
    companies.vat_no AS tax_registration_no,
    
    CONCAT(p.first_name, ' ', p.last_name)::VARCHAR AS user_name,
   a.email::VARCHAR AS email,
    a.phone_number AS user_phone,
   addr.full_address::VARCHAR AS address,
   a.user_types_id::bigint AS user_type,
    notes,
    -- Aggregate the license numbers into single columns
    MAX(CASE WHEN licenses.license_type_id = 1 THEN licenses.license_no ELSE '' END)::VARCHAR AS commercial_no,
    MAX(CASE WHEN licenses.license_type_id = 2 THEN licenses.license_no ELSE '' END)::VARCHAR AS rera_no
FROM
    subscription_order so
    LEFT JOIN companies ON companies.id = so.subscriber_id AND so.subscriber_type = 1
        LEFT JOIN users a ON a.id = CASE WHEN so.subscriber_type = 1 THEN companies.users_id ELSE so.subscriber_id END
    LEFT JOIN profiles p ON p.users_id = a.id
    LEFT JOIN addresses addr ON addr.id = CASE WHEN so.subscriber_type = 1 THEN companies.addresses_id ELSE p.addresses_id END
    LEFT JOIN licenses ON licenses.entity_id = companies.id  AND so.subscriber_type = 1
    
WHERE
    order_no = $1
    GROUP BY
    so.id,
    companies.id,
    p.id,
    a.id,
    addr.id
`

type GetSubscriptionOrderDetailsForContractRow struct {
	SubscriptionOrderID int64              `json:"subscription_order_id"`
	ContractStartDate   pgtype.Timestamptz `json:"contract_start_date"`
	ContractEndDate     pgtype.Timestamptz `json:"contract_end_date"`
	TotalAmount         float64            `json:"total_amount"`
	SubscriberName      string             `json:"subscriber_name"`
	RefNo               string             `json:"ref_no"`
	TaxRegistrationNo   pgtype.Text        `json:"tax_registration_no"`
	UserName            string             `json:"user_name"`
	Email               string             `json:"email"`
	UserPhone           pgtype.Text        `json:"user_phone"`
	Address             string             `json:"address"`
	UserType            int64              `json:"user_type"`
	Notes               string             `json:"notes"`
	CommercialNo        string             `json:"commercial_no"`
	ReraNo              string             `json:"rera_no"`
}

func (q *Queries) GetSubscriptionOrderDetailsForContract(ctx context.Context, orderNo string) ([]GetSubscriptionOrderDetailsForContractRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionOrderDetailsForContract, orderNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionOrderDetailsForContractRow
	for rows.Next() {
		var i GetSubscriptionOrderDetailsForContractRow
		if err := rows.Scan(
			&i.SubscriptionOrderID,
			&i.ContractStartDate,
			&i.ContractEndDate,
			&i.TotalAmount,
			&i.SubscriberName,
			&i.RefNo,
			&i.TaxRegistrationNo,
			&i.UserName,
			&i.Email,
			&i.UserPhone,
			&i.Address,
			&i.UserType,
			&i.Notes,
			&i.CommercialNo,
			&i.ReraNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionOrderPackageDetail = `-- name: GetSubscriptionOrderPackageDetail :many
SELECT 
    subscription_order.id,
    subscription_order.order_no,
    subscription_order.start_date AS subscription_start_date,
    subscription_order.end_date AS subscription_end_date,
    subscription_products.product,
    subscription_package.no_of_products,
    subscription_package.original_price_per_unit,
    subscription_package.product_discount,
    subscription_package.start_date,
    subscription_package.end_date
FROM subscription_order
INNER JOIN subscription_package ON subscription_package.subscription_order_id = subscription_order.id
INNER JOIN subscription_products ON subscription_package.product = subscription_products.id
WHERE subscription_order.order_no = $1
`

type GetSubscriptionOrderPackageDetailRow struct {
	ID                    int64              `json:"id"`
	OrderNo               string             `json:"order_no"`
	SubscriptionStartDate pgtype.Timestamptz `json:"subscription_start_date"`
	SubscriptionEndDate   pgtype.Timestamptz `json:"subscription_end_date"`
	Product               string             `json:"product"`
	NoOfProducts          int64              `json:"no_of_products"`
	OriginalPricePerUnit  float64            `json:"original_price_per_unit"`
	ProductDiscount       float64            `json:"product_discount"`
	StartDate             pgtype.Timestamptz `json:"start_date"`
	EndDate               pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) GetSubscriptionOrderPackageDetail(ctx context.Context, orderNo string) ([]GetSubscriptionOrderPackageDetailRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionOrderPackageDetail, orderNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionOrderPackageDetailRow
	for rows.Next() {
		var i GetSubscriptionOrderPackageDetailRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.SubscriptionStartDate,
			&i.SubscriptionEndDate,
			&i.Product,
			&i.NoOfProducts,
			&i.OriginalPricePerUnit,
			&i.ProductDiscount,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionOrderPackageDetailByUserID = `-- name: GetSubscriptionOrderPackageDetailByUserID :many





SELECT
    subscription_order.id as order_id, 
    subscription_package.id, 
    subscription_products.product, 
  	subscription_package.no_of_products,
  	subscription_package.product_discount,
  	subscription_package.original_price_per_unit,
  	 -- total units 
  	 subscription_order.total_amount,
  	 -- duration
  	  subscription_package.start_date,
  	  subscription_package.end_date,
  	  subscription_order.status
FROM subscription_order
INNER JOIN subscription_package ON subscription_package.subscription_order_id = subscription_order.id
INNER JOIN subscription_products ON subscription_package.product = subscription_products.id 
WHERE  subscription_order.subscriber_type = $1 AND CASE WHEN $2=0 THEN true ELSE  subscription_order.total_amount  = 0  END
AND CASE WHEN $3=0 THEN true ELSE  subscription_order.total_amount  != 0  END AND subscription_order.subscriber_id = $4
`

type GetSubscriptionOrderPackageDetailByUserIDParams struct {
	SubscriptionType int64       `json:"subscription_type"`
	Free             interface{} `json:"free"`
	Paid             interface{} `json:"paid"`
	SubscriberID     int64       `json:"subscriber_id"`
}

type GetSubscriptionOrderPackageDetailByUserIDRow struct {
	OrderID              int64              `json:"order_id"`
	ID                   int64              `json:"id"`
	Product              string             `json:"product"`
	NoOfProducts         int64              `json:"no_of_products"`
	ProductDiscount      float64            `json:"product_discount"`
	OriginalPricePerUnit float64            `json:"original_price_per_unit"`
	TotalAmount          float64            `json:"total_amount"`
	StartDate            pgtype.Timestamptz `json:"start_date"`
	EndDate              pgtype.Timestamptz `json:"end_date"`
	Status               int64              `json:"status"`
}

// -- name: GetCompanyLatestActiveSubscriptionOrder :many
// SELECT
//
//	subscription_products.product,
//	subscription_products.id AS product_id,
//	SUM(subscription_package.no_of_products) AS total_no_of_products
//
// FROM
//
//	subscription_order
//
// INNER JOIN
//
//	subscription_package ON subscription_order.id = subscription_package.subscription_order_id
//
// INNER JOIN
//
//	subscription_products ON subscription_package.product = subscription_products.id
//
// WHERE
//
//	subscriber_id = @company_id
//	AND subscriber_type = 1
//	AND subscription_order.status = 2 -- active subscription order
//
// GROUP BY
//
//	subscription_products.id, subscription_products.product
//
// ORDER BY
//
//	subscription_products.id;
func (q *Queries) GetSubscriptionOrderPackageDetailByUserID(ctx context.Context, arg GetSubscriptionOrderPackageDetailByUserIDParams) ([]GetSubscriptionOrderPackageDetailByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionOrderPackageDetailByUserID,
		arg.SubscriptionType,
		arg.Free,
		arg.Paid,
		arg.SubscriberID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionOrderPackageDetailByUserIDRow
	for rows.Next() {
		var i GetSubscriptionOrderPackageDetailByUserIDRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ID,
			&i.Product,
			&i.NoOfProducts,
			&i.ProductDiscount,
			&i.OriginalPricePerUnit,
			&i.TotalAmount,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inActiveSubscriptionOrder = `-- name: InActiveSubscriptionOrder :one

UPDATE subscription_order
SET status = 3
WHERE order_no = $1 AND status != 4 -- exclude expired subscription order
RETURNING id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file
`

// only draft subscription order
func (q *Queries) InActiveSubscriptionOrder(ctx context.Context, orderNo string) (SubscriptionOrder, error) {
	row := q.db.QueryRow(ctx, inActiveSubscriptionOrder, orderNo)
	var i SubscriptionOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.SubscriberID,
		&i.SubscriberType,
		&i.StartDate,
		&i.EndDate,
		&i.SignDate,
		&i.TotalAmount,
		&i.Vat,
		&i.NoOfPayments,
		&i.PaymentPlan,
		&i.Notes,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DraftContract,
		&i.ContractFile,
	)
	return i, err
}

const listSubscriptionOrders = `-- name: ListSubscriptionOrders :many
SELECT id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file FROM "subscription_order"
ORDER BY "created_at" DESC
`

// List all subscription orders
func (q *Queries) ListSubscriptionOrders(ctx context.Context) ([]SubscriptionOrder, error) {
	rows, err := q.db.Query(ctx, listSubscriptionOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionOrder
	for rows.Next() {
		var i SubscriptionOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.SubscriberID,
			&i.SubscriberType,
			&i.StartDate,
			&i.EndDate,
			&i.SignDate,
			&i.TotalAmount,
			&i.Vat,
			&i.NoOfPayments,
			&i.PaymentPlan,
			&i.Notes,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DraftContract,
			&i.ContractFile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderPayment = `-- name: UpdateOrderPayment :one
UPDATE payments
SET payment_method = $2,
    payment_date = $3,
    bank = $4,
    cheque_no = $5,
    invoice_file = $6,
    reference_no = $7,
    status = $8
WHERE id = $1
RETURNING id, order_id, due_date, payment_method, amount, payment_date, bank, cheque_no, reference_no, invoice_file, status, created_by, created_at, updated_at
`

type UpdateOrderPaymentParams struct {
	ID            int64              `json:"id"`
	PaymentMethod pgtype.Int8        `json:"payment_method"`
	PaymentDate   pgtype.Timestamptz `json:"payment_date"`
	Bank          pgtype.Text        `json:"bank"`
	ChequeNo      pgtype.Text        `json:"cheque_no"`
	InvoiceFile   pgtype.Text        `json:"invoice_file"`
	ReferenceNo   pgtype.Text        `json:"reference_no"`
	Status        int64              `json:"status"`
}

func (q *Queries) UpdateOrderPayment(ctx context.Context, arg UpdateOrderPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updateOrderPayment,
		arg.ID,
		arg.PaymentMethod,
		arg.PaymentDate,
		arg.Bank,
		arg.ChequeNo,
		arg.InvoiceFile,
		arg.ReferenceNo,
		arg.Status,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.DueDate,
		&i.PaymentMethod,
		&i.Amount,
		&i.PaymentDate,
		&i.Bank,
		&i.ChequeNo,
		&i.ReferenceNo,
		&i.InvoiceFile,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscriptionOrder = `-- name: UpdateSubscriptionOrder :one
UPDATE "subscription_order"
SET  
    "start_date" = $2, 
    "end_date" = $3, 
    "total_amount" = $4, 
    "no_of_payments" = $5, 
    "payment_plan" = $6, 
    "notes" = $7, 
    "updated_at" = $8
WHERE "id" = $1
RETURNING id, order_no, subscriber_id, subscriber_type, start_date, end_date, sign_date, total_amount, vat, no_of_payments, payment_plan, notes, status, created_by, created_at, updated_at, draft_contract, contract_file
`

type UpdateSubscriptionOrderParams struct {
	ID           int64              `json:"id"`
	StartDate    pgtype.Timestamptz `json:"start_date"`
	EndDate      pgtype.Timestamptz `json:"end_date"`
	TotalAmount  float64            `json:"total_amount"`
	NoOfPayments int64              `json:"no_of_payments"`
	PaymentPlan  pgtype.Int8        `json:"payment_plan"`
	Notes        string             `json:"notes"`
	UpdatedAt    time.Time          `json:"updated_at"`
}

// Update a subscription order and return the updated row
func (q *Queries) UpdateSubscriptionOrder(ctx context.Context, arg UpdateSubscriptionOrderParams) (SubscriptionOrder, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionOrder,
		arg.ID,
		arg.StartDate,
		arg.EndDate,
		arg.TotalAmount,
		arg.NoOfPayments,
		arg.PaymentPlan,
		arg.Notes,
		arg.UpdatedAt,
	)
	var i SubscriptionOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.SubscriberID,
		&i.SubscriberType,
		&i.StartDate,
		&i.EndDate,
		&i.SignDate,
		&i.TotalAmount,
		&i.Vat,
		&i.NoOfPayments,
		&i.PaymentPlan,
		&i.Notes,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DraftContract,
		&i.ContractFile,
	)
	return i, err
}
