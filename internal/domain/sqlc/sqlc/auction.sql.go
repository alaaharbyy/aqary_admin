// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: auction.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActivitiesByType = `-- name: CountActivitiesByType :one
SELECT COUNT(id) FROM
    auctions_activities
WHERE activity_type = $1
    AND ($2::TEXT IS NULL OR activity ILIKE '%' || $2 || '%')
`

type CountActivitiesByTypeParams struct {
	ActivityType int64  `json:"activity_type"`
	Column2      string `json:"column_2"`
}

func (q *Queries) CountActivitiesByType(ctx context.Context, arg CountActivitiesByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countActivitiesByType, arg.ActivityType, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllFAQs = `-- name: CountAllFAQs :one
SELECT COUNT(*)
FROM auctions_faqs
WHERE deleted_at IS NULL AND (
    $1::TEXT IS NULL
    OR question ILIKE '%' || $1 || '%'
    OR answer ILIKE '%' || $1 || '%')
`

func (q *Queries) CountAllFAQs(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countAllFAQs, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuctionDocumentsByAuctionID = `-- name: CountAuctionDocumentsByAuctionID :one
SELECT COUNT(id)
FROM auctions_documents
WHERE deleted_at IS NULL
    AND auction_id = $1
`

func (q *Queries) CountAuctionDocumentsByAuctionID(ctx context.Context, auctionID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countAuctionDocumentsByAuctionID, auctionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuctionMediaRecordByAuctionID = `-- name: CountAuctionMediaRecordByAuctionID :one
SELECT COUNT(id)
FROM auctions_media
WHERE deleted_at IS NULL
    AND auction_id = $1
`

func (q *Queries) CountAuctionMediaRecordByAuctionID(ctx context.Context, auctionID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countAuctionMediaRecordByAuctionID, auctionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuctionPartners = `-- name: CountAuctionPartners :one
SELECT COUNT(*)
FROM auctions_partners
WHERE deleted_at IS NULL
    AND auction_id = $1
    AND ($2::TEXT IS NULL
    OR partner_name ILIKE '%' || $2 || '%'
    OR website ILIKE '%' || $2 || '%'
)
`

type CountAuctionPartnersParams struct {
	AuctionID int64  `json:"auction_id"`
	Column2   string `json:"column_2"`
}

func (q *Queries) CountAuctionPartners(ctx context.Context, arg CountAuctionPartnersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuctionPartners, arg.AuctionID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuctionPlansByAuctionID = `-- name: CountAuctionPlansByAuctionID :one
SELECT COUNT(id)
FROM auctions_plans
WHERE deleted_at IS NULL AND auction_id = $1
`

func (q *Queries) CountAuctionPlansByAuctionID(ctx context.Context, auctionID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countAuctionPlansByAuctionID, auctionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuctions = `-- name: CountAuctions :one
SELECT COUNT(id)
FROM auctions
WHERE deleted_at IS NULL
AND ($1::bigint IS NULL OR auction_type = $1::bigint)
AND (
    $2::TEXT IS NULL OR
    auction_title ILIKE '%' || $2 || '%' OR
    description ILIKE '%' || $2 || '%' OR
    auction_description ILIKE '%' || $2 || '%' OR
    auction_url ILIKE '%' || $2 || '%'
)
`

type CountAuctionsParams struct {
	Column1 int64  `json:"column_1"`
	Column2 string `json:"column_2"`
}

func (q *Queries) CountAuctions(ctx context.Context, arg CountAuctionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuctions, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChangesByActivityID = `-- name: CountChangesByActivityID :one
SELECT COUNT(id) FROM
    auctions_activity_changes
WHERE
    activities_id = $1
    AND ($2::TEXT IS NULL OR
        field_name ILIKE '%' || $2 || '%' OR
        before ILIKE '%' || $2 || '%' OR
        after ILIKE '%' || $2 || '%')
`

type CountChangesByActivityIDParams struct {
	ActivitiesID int64  `json:"activities_id"`
	Column2      string `json:"column_2"`
}

func (q *Queries) CountChangesByActivityID(ctx context.Context, arg CountChangesByActivityIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChangesByActivityID, arg.ActivitiesID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDeletedAuctionPartners = `-- name: CountDeletedAuctionPartners :one
SELECT COUNT(*)
FROM auctions_partners
WHERE deleted_at IS  NOT NULL
    AND ($1::TEXT IS NULL
    OR partner_name ILIKE '%' || $1 || '%'
    OR website ILIKE '%' || $1 || '%')
`

func (q *Queries) CountDeletedAuctionPartners(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countDeletedAuctionPartners, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDeletedAuctions = `-- name: CountDeletedAuctions :one
SELECT COUNT(id)
FROM auctions
WHERE deleted_at IS NOT NULL
AND (
    $1::TEXT IS NULL OR
    auction_title ILIKE '%' || $1 || '%' OR
    auction_description ILIKE '%' || $1 || '%' OR
    description ILIKE '%' || $1 || '%' OR
    auction_url ILIKE '%' || $1 || '%'
)
`

func (q *Queries) CountDeletedAuctions(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countDeletedAuctions, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDeletedFaqs = `-- name: CountDeletedFaqs :one
SELECT COUNT(id)
FROM auctions_faqs
WHERE deleted_at IS NOT NULL
    AND ($1::TEXT IS NULL OR question ILIKE '%' || $1 || '%' OR answer ILIKE '%' || $1 || '%')
`

func (q *Queries) CountDeletedFaqs(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countDeletedFaqs, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createActivityChange = `-- name: CreateActivityChange :one
INSERT INTO auctions_activity_changes (
    section_id, activities_id, field_name, before, after,
    activity_date, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW()
)RETURNING id, section_id, activities_id, field_name, before, after, activity_date, created_at, updated_at
`

type CreateActivityChangeParams struct {
	SectionID    int64              `json:"section_id"`
	ActivitiesID int64              `json:"activities_id"`
	FieldName    pgtype.Text        `json:"field_name"`
	Before       pgtype.Text        `json:"before"`
	After        pgtype.Text        `json:"after"`
	ActivityDate pgtype.Timestamptz `json:"activity_date"`
}

func (q *Queries) CreateActivityChange(ctx context.Context, arg CreateActivityChangeParams) (AuctionsActivityChange, error) {
	row := q.db.QueryRow(ctx, createActivityChange,
		arg.SectionID,
		arg.ActivitiesID,
		arg.FieldName,
		arg.Before,
		arg.After,
		arg.ActivityDate,
	)
	var i AuctionsActivityChange
	err := row.Scan(
		&i.ID,
		&i.SectionID,
		&i.ActivitiesID,
		&i.FieldName,
		&i.Before,
		&i.After,
		&i.ActivityDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAuction = `-- name: CreateAuction :one
INSERT INTO auctions (
    ref_no, auction_title, auction_description, auction_category, companies_id, mobile_number,
    email_address,whatsapp,select_type,property_name, property_category,
    property_usage, properties_unites_id, plot_no, sector_no, has_tenants, lat, lng,
    prebid_start_date, start_date, end_date, min_bid_amount, min_increment_amount,
    winning_bid_amount, auction_url, auction_type, description, description_ar,
    addresses_id, location_url, ownership_id, auction_status, tags_id, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11, $12, $13,
    $14, $15, $16, $17, $18,
    $19, $20, $21, $22, $23,
    $24, $25, $26, $27, $28,
    $29, $30, $31, $32, $33, now(), now()
) RETURNING id, ref_no, auction_title, auction_description, auction_category, companies_id, mobile_number, email_address, whatsapp, select_type, property_name, property_category, property_usage, properties_unites_id, plot_no, sector_no, has_tenants, lat, lng, prebid_start_date, start_date, end_date, min_bid_amount, min_increment_amount, winning_bid_amount, auction_url, auction_type, description, description_ar, addresses_id, location_url, ownership_id, auction_status, tags_id, created_at, updated_at, deleted_at
`

type CreateAuctionParams struct {
	RefNo              pgtype.Text        `json:"ref_no"`
	AuctionTitle       pgtype.Text        `json:"auction_title"`
	AuctionDescription pgtype.Text        `json:"auction_description"`
	AuctionCategory    pgtype.Int8        `json:"auction_category"`
	CompaniesID        pgtype.Int8        `json:"companies_id"`
	MobileNumber       pgtype.Text        `json:"mobile_number"`
	EmailAddress       pgtype.Text        `json:"email_address"`
	Whatsapp           pgtype.Text        `json:"whatsapp"`
	SelectType         int64              `json:"select_type"`
	PropertyName       pgtype.Text        `json:"property_name"`
	PropertyCategory   pgtype.Int8        `json:"property_category"`
	PropertyUsage      pgtype.Int8        `json:"property_usage"`
	PropertiesUnitesID pgtype.Int8        `json:"properties_unites_id"`
	PlotNo             string             `json:"plot_no"`
	SectorNo           string             `json:"sector_no"`
	HasTenants         pgtype.Bool        `json:"has_tenants"`
	Lat                pgtype.Float8      `json:"lat"`
	Lng                pgtype.Float8      `json:"lng"`
	PrebidStartDate    pgtype.Timestamptz `json:"prebid_start_date"`
	StartDate          pgtype.Timestamptz `json:"start_date"`
	EndDate            pgtype.Timestamptz `json:"end_date"`
	MinBidAmount       pgtype.Float8      `json:"min_bid_amount"`
	MinIncrementAmount pgtype.Float8      `json:"min_increment_amount"`
	WinningBidAmount   pgtype.Float8      `json:"winning_bid_amount"`
	AuctionUrl         pgtype.Text        `json:"auction_url"`
	AuctionType        pgtype.Int8        `json:"auction_type"`
	Description        string             `json:"description"`
	DescriptionAr      pgtype.Text        `json:"description_ar"`
	AddressesID        pgtype.Int8        `json:"addresses_id"`
	LocationUrl        pgtype.Text        `json:"location_url"`
	OwnershipID        pgtype.Int8        `json:"ownership_id"`
	AuctionStatus      pgtype.Int8        `json:"auction_status"`
	TagsID             []int64            `json:"tags_id"`
}

func (q *Queries) CreateAuction(ctx context.Context, arg CreateAuctionParams) (Auction, error) {
	row := q.db.QueryRow(ctx, createAuction,
		arg.RefNo,
		arg.AuctionTitle,
		arg.AuctionDescription,
		arg.AuctionCategory,
		arg.CompaniesID,
		arg.MobileNumber,
		arg.EmailAddress,
		arg.Whatsapp,
		arg.SelectType,
		arg.PropertyName,
		arg.PropertyCategory,
		arg.PropertyUsage,
		arg.PropertiesUnitesID,
		arg.PlotNo,
		arg.SectorNo,
		arg.HasTenants,
		arg.Lat,
		arg.Lng,
		arg.PrebidStartDate,
		arg.StartDate,
		arg.EndDate,
		arg.MinBidAmount,
		arg.MinIncrementAmount,
		arg.WinningBidAmount,
		arg.AuctionUrl,
		arg.AuctionType,
		arg.Description,
		arg.DescriptionAr,
		arg.AddressesID,
		arg.LocationUrl,
		arg.OwnershipID,
		arg.AuctionStatus,
		arg.TagsID,
	)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.AuctionTitle,
		&i.AuctionDescription,
		&i.AuctionCategory,
		&i.CompaniesID,
		&i.MobileNumber,
		&i.EmailAddress,
		&i.Whatsapp,
		&i.SelectType,
		&i.PropertyName,
		&i.PropertyCategory,
		&i.PropertyUsage,
		&i.PropertiesUnitesID,
		&i.PlotNo,
		&i.SectorNo,
		&i.HasTenants,
		&i.Lat,
		&i.Lng,
		&i.PrebidStartDate,
		&i.StartDate,
		&i.EndDate,
		&i.MinBidAmount,
		&i.MinIncrementAmount,
		&i.WinningBidAmount,
		&i.AuctionUrl,
		&i.AuctionType,
		&i.Description,
		&i.DescriptionAr,
		&i.AddressesID,
		&i.LocationUrl,
		&i.OwnershipID,
		&i.AuctionStatus,
		&i.TagsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createAuctionActivity = `-- name: CreateAuctionActivity :one
INSERT INTO auctions_activities (
    auction_id, activity_type, file_category, file_url, portal_url, activity, user_id,
    activity_date, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,$8, NOW()
)RETURNING id, auction_id, activity_type, file_category, file_url, portal_url, activity, user_id, activity_date, created_at, updated_at
`

type CreateAuctionActivityParams struct {
	AuctionID    int64       `json:"auction_id"`
	ActivityType int64       `json:"activity_type"`
	FileCategory pgtype.Int8 `json:"file_category"`
	FileUrl      pgtype.Text `json:"file_url"`
	PortalUrl    pgtype.Text `json:"portal_url"`
	Activity     string      `json:"activity"`
	UserID       int64       `json:"user_id"`
	ActivityDate time.Time   `json:"activity_date"`
}

func (q *Queries) CreateAuctionActivity(ctx context.Context, arg CreateAuctionActivityParams) (AuctionsActivity, error) {
	row := q.db.QueryRow(ctx, createAuctionActivity,
		arg.AuctionID,
		arg.ActivityType,
		arg.FileCategory,
		arg.FileUrl,
		arg.PortalUrl,
		arg.Activity,
		arg.UserID,
		arg.ActivityDate,
	)
	var i AuctionsActivity
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.ActivityType,
		&i.FileCategory,
		&i.FileUrl,
		&i.PortalUrl,
		&i.Activity,
		&i.UserID,
		&i.ActivityDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAuctionDocument = `-- name: CreateAuctionDocument :one

INSERT INTO auctions_documents (auction_id, document_type, document_url, created_at)
VALUES ($1, $2, $3, NOW())
RETURNING id, auction_id, document_type, document_url, created_at, updated_at, deleted_at
`

type CreateAuctionDocumentParams struct {
	AuctionID    pgtype.Int8 `json:"auction_id"`
	DocumentType pgtype.Int8 `json:"document_type"`
	DocumentUrl  []string    `json:"document_url"`
}

// query.sql
func (q *Queries) CreateAuctionDocument(ctx context.Context, arg CreateAuctionDocumentParams) (AuctionsDocument, error) {
	row := q.db.QueryRow(ctx, createAuctionDocument, arg.AuctionID, arg.DocumentType, arg.DocumentUrl)
	var i AuctionsDocument
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createAuctionMedia = `-- name: CreateAuctionMedia :one
INSERT INTO auctions_media (auction_id, gallery_type, media_type, media_url, created_at)
VALUES ($1, $2, $3, $4, NOW())
RETURNING id, auction_id, gallery_type, media_type, media_url, created_at, updated_at, deleted_at
`

type CreateAuctionMediaParams struct {
	AuctionID   int64    `json:"auction_id"`
	GalleryType int64    `json:"gallery_type"`
	MediaType   int64    `json:"media_type"`
	MediaUrl    []string `json:"media_url"`
}

func (q *Queries) CreateAuctionMedia(ctx context.Context, arg CreateAuctionMediaParams) (AuctionsMedium, error) {
	row := q.db.QueryRow(ctx, createAuctionMedia,
		arg.AuctionID,
		arg.GalleryType,
		arg.MediaType,
		arg.MediaUrl,
	)
	var i AuctionsMedium
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.GalleryType,
		&i.MediaType,
		&i.MediaUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createAuctionPartner = `-- name: CreateAuctionPartner :one
INSERT INTO auctions_partners (ref_no, auction_id, partner_name, partner_logo, website, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
RETURNING id, ref_no, auction_id, partner_name, partner_logo, website, created_at, updated_at, deleted_at
`

type CreateAuctionPartnerParams struct {
	RefNo       pgtype.Text `json:"ref_no"`
	AuctionID   int64       `json:"auction_id"`
	PartnerName string      `json:"partner_name"`
	PartnerLogo string      `json:"partner_logo"`
	Website     pgtype.Text `json:"website"`
}

func (q *Queries) CreateAuctionPartner(ctx context.Context, arg CreateAuctionPartnerParams) (AuctionsPartner, error) {
	row := q.db.QueryRow(ctx, createAuctionPartner,
		arg.RefNo,
		arg.AuctionID,
		arg.PartnerName,
		arg.PartnerLogo,
		arg.Website,
	)
	var i AuctionsPartner
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.AuctionID,
		&i.PartnerName,
		&i.PartnerLogo,
		&i.Website,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createAuctionPlan = `-- name: CreateAuctionPlan :one
INSERT INTO auctions_plans (auction_id, plan_title, plan_url, created_at)
VALUES ($1, $2, $3, NOW())
RETURNING id, auction_id, plan_title, plan_url, created_at, updated_at, deleted_at
`

type CreateAuctionPlanParams struct {
	AuctionID pgtype.Int8 `json:"auction_id"`
	PlanTitle pgtype.Int8 `json:"plan_title"`
	PlanUrl   []string    `json:"plan_url"`
}

func (q *Queries) CreateAuctionPlan(ctx context.Context, arg CreateAuctionPlanParams) (AuctionsPlan, error) {
	row := q.db.QueryRow(ctx, createAuctionPlan, arg.AuctionID, arg.PlanTitle, arg.PlanUrl)
	var i AuctionsPlan
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.PlanTitle,
		&i.PlanUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createAuctionsAddresses = `-- name: CreateAuctionsAddresses :one

INSERT INTO auctions_addresses (
    country, state, city, community, sub_community, location_url, lat, lng
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, country, state, city, community, sub_community, location_url, lat, lng, created_at, updated_at, deleted_at
`

type CreateAuctionsAddressesParams struct {
	Country      int64         `json:"country"`
	State        int64         `json:"state"`
	City         int64         `json:"city"`
	Community    pgtype.Int8   `json:"community"`
	SubCommunity pgtype.Int8   `json:"sub_community"`
	LocationUrl  pgtype.Text   `json:"location_url"`
	Lat          pgtype.Float8 `json:"lat"`
	Lng          pgtype.Float8 `json:"lng"`
}

// query.sql
// Insert a new addresses
func (q *Queries) CreateAuctionsAddresses(ctx context.Context, arg CreateAuctionsAddressesParams) (AuctionsAddress, error) {
	row := q.db.QueryRow(ctx, createAuctionsAddresses,
		arg.Country,
		arg.State,
		arg.City,
		arg.Community,
		arg.SubCommunity,
		arg.LocationUrl,
		arg.Lat,
		arg.Lng,
	)
	var i AuctionsAddress
	err := row.Scan(
		&i.ID,
		&i.Country,
		&i.State,
		&i.City,
		&i.Community,
		&i.SubCommunity,
		&i.LocationUrl,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createAuctionsUnitFact = `-- name: CreateAuctionsUnitFact :one
INSERT INTO auctions_unit_facts (
    bedroom,
    bathroom,
    plot_area,
    built_up_area,
    view,
    furnished,
    ownership,
    completion_status,
    start_date,
    completion_date,
    handover_date,
    no_of_floor,
    no_of_units,
    min_area,
    max_area,
    service_charge,
    parking,
    ask_price,
    price,
    rent_type,
    no_of_payment,
    no_of_retail,
    no_of_pool,
    elevator,
    starting_price,
    life_style,
    unit_id,
    category,
    is_branch,
    commercial_tax,
    municipality_tax,
    sc_currency_id,
    unit_of_measure,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32,$33, NOW()
) RETURNING id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, unit_id, category, is_branch, commercial_tax, municipality_tax, sc_currency_id, unit_of_measure, created_at, updated_at
`

type CreateAuctionsUnitFactParams struct {
	Bedroom          pgtype.Text        `json:"bedroom"`
	Bathroom         pgtype.Int8        `json:"bathroom"`
	PlotArea         pgtype.Float8      `json:"plot_area"`
	BuiltUpArea      pgtype.Float8      `json:"built_up_area"`
	View             []int64            `json:"view"`
	Furnished        pgtype.Int8        `json:"furnished"`
	Ownership        pgtype.Int8        `json:"ownership"`
	CompletionStatus pgtype.Int8        `json:"completion_status"`
	StartDate        pgtype.Timestamptz `json:"start_date"`
	CompletionDate   pgtype.Timestamptz `json:"completion_date"`
	HandoverDate     pgtype.Timestamptz `json:"handover_date"`
	NoOfFloor        pgtype.Int8        `json:"no_of_floor"`
	NoOfUnits        pgtype.Int8        `json:"no_of_units"`
	MinArea          pgtype.Float8      `json:"min_area"`
	MaxArea          pgtype.Float8      `json:"max_area"`
	ServiceCharge    pgtype.Int8        `json:"service_charge"`
	Parking          pgtype.Int8        `json:"parking"`
	AskPrice         pgtype.Bool        `json:"ask_price"`
	Price            pgtype.Float8      `json:"price"`
	RentType         pgtype.Int8        `json:"rent_type"`
	NoOfPayment      pgtype.Int8        `json:"no_of_payment"`
	NoOfRetail       pgtype.Int8        `json:"no_of_retail"`
	NoOfPool         pgtype.Int8        `json:"no_of_pool"`
	Elevator         pgtype.Int8        `json:"elevator"`
	StartingPrice    pgtype.Int8        `json:"starting_price"`
	LifeStyle        pgtype.Int8        `json:"life_style"`
	UnitID           int64              `json:"unit_id"`
	Category         string             `json:"category"`
	IsBranch         pgtype.Bool        `json:"is_branch"`
	CommercialTax    pgtype.Float8      `json:"commercial_tax"`
	MunicipalityTax  pgtype.Float8      `json:"municipality_tax"`
	ScCurrencyID     pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure    pgtype.Text        `json:"unit_of_measure"`
}

func (q *Queries) CreateAuctionsUnitFact(ctx context.Context, arg CreateAuctionsUnitFactParams) (AuctionsUnitFact, error) {
	row := q.db.QueryRow(ctx, createAuctionsUnitFact,
		arg.Bedroom,
		arg.Bathroom,
		arg.PlotArea,
		arg.BuiltUpArea,
		arg.View,
		arg.Furnished,
		arg.Ownership,
		arg.CompletionStatus,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.NoOfFloor,
		arg.NoOfUnits,
		arg.MinArea,
		arg.MaxArea,
		arg.ServiceCharge,
		arg.Parking,
		arg.AskPrice,
		arg.Price,
		arg.RentType,
		arg.NoOfPayment,
		arg.NoOfRetail,
		arg.NoOfPool,
		arg.Elevator,
		arg.StartingPrice,
		arg.LifeStyle,
		arg.UnitID,
		arg.Category,
		arg.IsBranch,
		arg.CommercialTax,
		arg.MunicipalityTax,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
	)
	var i AuctionsUnitFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.UnitID,
		&i.Category,
		&i.IsBranch,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAuctionsUnits = `-- name: CreateAuctionsUnits :one
INSERT INTO auctions_units (
    ref_no,
    unit_no,
    unitno_is_public,
    notes,
    notes_arabic,
    notes_public,
    is_verified,
    amenities_id,
    property_unit_rank,
    properties_id,
    property,
    addresses_id,
    countries_id,
    property_types_id,
    created_by,
    property_name,
    section,
    type_name_id,
    owner_users_id,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, DEFAULT, DEFAULT
) RETURNING id, unit_no, unitno_is_public, notes, notes_arabic, notes_public, is_verified, amenities_id, property_unit_rank, properties_id, property, created_at, updated_at, ref_no, addresses_id, countries_id, property_types_id, created_by, property_name, section, type_name_id, owner_users_id
`

type CreateAuctionsUnitsParams struct {
	RefNo            pgtype.Text `json:"ref_no"`
	UnitNo           pgtype.Text `json:"unit_no"`
	UnitnoIsPublic   pgtype.Bool `json:"unitno_is_public"`
	Notes            pgtype.Text `json:"notes"`
	NotesArabic      pgtype.Text `json:"notes_arabic"`
	NotesPublic      pgtype.Bool `json:"notes_public"`
	IsVerified       pgtype.Bool `json:"is_verified"`
	AmenitiesID      []int64     `json:"amenities_id"`
	PropertyUnitRank pgtype.Int8 `json:"property_unit_rank"`
	PropertiesID     pgtype.Int8 `json:"properties_id"`
	Property         pgtype.Int8 `json:"property"`
	AddressesID      int64       `json:"addresses_id"`
	CountriesID      int64       `json:"countries_id"`
	PropertyTypesID  int64       `json:"property_types_id"`
	CreatedBy        pgtype.Int8 `json:"created_by"`
	PropertyName     string      `json:"property_name"`
	Section          string      `json:"section"`
	TypeNameID       pgtype.Int8 `json:"type_name_id"`
	OwnerUsersID     pgtype.Int8 `json:"owner_users_id"`
}

func (q *Queries) CreateAuctionsUnits(ctx context.Context, arg CreateAuctionsUnitsParams) (AuctionsUnit, error) {
	row := q.db.QueryRow(ctx, createAuctionsUnits,
		arg.RefNo,
		arg.UnitNo,
		arg.UnitnoIsPublic,
		arg.Notes,
		arg.NotesArabic,
		arg.NotesPublic,
		arg.IsVerified,
		arg.AmenitiesID,
		arg.PropertyUnitRank,
		arg.PropertiesID,
		arg.Property,
		arg.AddressesID,
		arg.CountriesID,
		arg.PropertyTypesID,
		arg.CreatedBy,
		arg.PropertyName,
		arg.Section,
		arg.TypeNameID,
		arg.OwnerUsersID,
	)
	var i AuctionsUnit
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.AmenitiesID,
		&i.PropertyUnitRank,
		&i.PropertiesID,
		&i.Property,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.AddressesID,
		&i.CountriesID,
		&i.PropertyTypesID,
		&i.CreatedBy,
		&i.PropertyName,
		&i.Section,
		&i.TypeNameID,
		&i.OwnerUsersID,
	)
	return i, err
}

const createFAQ = `-- name: CreateFAQ :one
INSERT INTO auctions_faqs (ref_no, question, answer, created_at)
VALUES ($1, $2, $3, NOW())
RETURNING id, ref_no, question, answer, created_at, updated_at, deleted_at
`

type CreateFAQParams struct {
	RefNo    pgtype.Text `json:"ref_no"`
	Question pgtype.Text `json:"question"`
	Answer   pgtype.Text `json:"answer"`
}

func (q *Queries) CreateFAQ(ctx context.Context, arg CreateFAQParams) (AuctionsFaq, error) {
	row := q.db.QueryRow(ctx, createFAQ, arg.RefNo, arg.Question, arg.Answer)
	var i AuctionsFaq
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Question,
		&i.Answer,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createPropertiesFact = `-- name: CreatePropertiesFact :one
INSERT INTO auctions_properties_facts (
    bedroom,
    plot_area,
    built_up_area,
    view,
    furnished,
    ownership,
    completion_status,
    start_date,
    completion_date,
    handover_date,
    no_of_floor,
    no_of_units,
    min_area,
    max_area,
    service_charge,
    parking,
    ask_price,
    price,
    rent_type,
    no_of_payment,
    no_of_retail,
    no_of_pool,
    elevator,
    starting_price,
    life_style,
    properties_id,
    property,
    is_branch,
    available_units,
    commercial_tax,
    municipality_tax,
    is_project_fact,
    project_id,
    completion_percentage,
    completion_percentage_date,
    type_name_id,
    sc_currency_id,
    unit_of_measure,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37,$38, NOW()
) RETURNING id, bedroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure, created_at, updated_at
`

type CreatePropertiesFactParams struct {
	Bedroom                  pgtype.Text        `json:"bedroom"`
	PlotArea                 pgtype.Float8      `json:"plot_area"`
	BuiltUpArea              pgtype.Float8      `json:"built_up_area"`
	View                     []int64            `json:"view"`
	Furnished                pgtype.Int8        `json:"furnished"`
	Ownership                pgtype.Int8        `json:"ownership"`
	CompletionStatus         pgtype.Int8        `json:"completion_status"`
	StartDate                pgtype.Timestamptz `json:"start_date"`
	CompletionDate           pgtype.Timestamptz `json:"completion_date"`
	HandoverDate             pgtype.Timestamptz `json:"handover_date"`
	NoOfFloor                pgtype.Int8        `json:"no_of_floor"`
	NoOfUnits                pgtype.Int8        `json:"no_of_units"`
	MinArea                  pgtype.Float8      `json:"min_area"`
	MaxArea                  pgtype.Float8      `json:"max_area"`
	ServiceCharge            pgtype.Int8        `json:"service_charge"`
	Parking                  pgtype.Int8        `json:"parking"`
	AskPrice                 pgtype.Bool        `json:"ask_price"`
	Price                    pgtype.Float8      `json:"price"`
	RentType                 pgtype.Int8        `json:"rent_type"`
	NoOfPayment              pgtype.Int8        `json:"no_of_payment"`
	NoOfRetail               pgtype.Int8        `json:"no_of_retail"`
	NoOfPool                 pgtype.Int8        `json:"no_of_pool"`
	Elevator                 pgtype.Int8        `json:"elevator"`
	StartingPrice            pgtype.Int8        `json:"starting_price"`
	LifeStyle                pgtype.Int8        `json:"life_style"`
	PropertiesID             pgtype.Int8        `json:"properties_id"`
	Property                 int64              `json:"property"`
	IsBranch                 pgtype.Bool        `json:"is_branch"`
	AvailableUnits           pgtype.Int8        `json:"available_units"`
	CommercialTax            pgtype.Float8      `json:"commercial_tax"`
	MunicipalityTax          pgtype.Float8      `json:"municipality_tax"`
	IsProjectFact            pgtype.Bool        `json:"is_project_fact"`
	ProjectID                pgtype.Int8        `json:"project_id"`
	CompletionPercentage     pgtype.Int8        `json:"completion_percentage"`
	CompletionPercentageDate pgtype.Timestamptz `json:"completion_percentage_date"`
	TypeNameID               pgtype.Int8        `json:"type_name_id"`
	ScCurrencyID             pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure            pgtype.Text        `json:"unit_of_measure"`
}

func (q *Queries) CreatePropertiesFact(ctx context.Context, arg CreatePropertiesFactParams) (AuctionsPropertiesFact, error) {
	row := q.db.QueryRow(ctx, createPropertiesFact,
		arg.Bedroom,
		arg.PlotArea,
		arg.BuiltUpArea,
		arg.View,
		arg.Furnished,
		arg.Ownership,
		arg.CompletionStatus,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.NoOfFloor,
		arg.NoOfUnits,
		arg.MinArea,
		arg.MaxArea,
		arg.ServiceCharge,
		arg.Parking,
		arg.AskPrice,
		arg.Price,
		arg.RentType,
		arg.NoOfPayment,
		arg.NoOfRetail,
		arg.NoOfPool,
		arg.Elevator,
		arg.StartingPrice,
		arg.LifeStyle,
		arg.PropertiesID,
		arg.Property,
		arg.IsBranch,
		arg.AvailableUnits,
		arg.CommercialTax,
		arg.MunicipalityTax,
		arg.IsProjectFact,
		arg.ProjectID,
		arg.CompletionPercentage,
		arg.CompletionPercentageDate,
		arg.TypeNameID,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
	)
	var i AuctionsPropertiesFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.PropertiesID,
		&i.Property,
		&i.IsBranch,
		&i.AvailableUnits,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.IsProjectFact,
		&i.ProjectID,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.TypeNameID,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProperty = `-- name: CreateProperty :one
INSERT INTO auctions_properties (
    ref_no, companies_id, property_title, property_title_arabic,
    description, description_arabic, is_verified, property_rank,
    addresses_id, property_types_id, status, facilities_id, amenities_id,
    is_show_owner_info, property, category, investment, contract_start_datetime,
    contract_end_datetime, amount, unit_types, property_name, from_xml,
    list_of_date, list_of_notes, list_of_agent, owner_users_id,
    created_at, updated_at
) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19,
        $20, $21, $22, $23, $24, $25, $26, $27, NOW(), NOW()
) RETURNING id, companies_id, property_title, property_title_arabic, description, description_arabic, is_verified, property_rank, addresses_id, property_types_id, status, created_at, updated_at, facilities_id, amenities_id, is_show_owner_info, property, ref_no, category, investment, contract_start_datetime, contract_end_datetime, amount, unit_types, property_name, from_xml, list_of_date, list_of_notes, list_of_agent, owner_users_id
`

type CreatePropertyParams struct {
	RefNo                 string             `json:"ref_no"`
	CompaniesID           int64              `json:"companies_id"`
	PropertyTitle         string             `json:"property_title"`
	PropertyTitleArabic   string             `json:"property_title_arabic"`
	Description           string             `json:"description"`
	DescriptionArabic     string             `json:"description_arabic"`
	IsVerified            pgtype.Bool        `json:"is_verified"`
	PropertyRank          pgtype.Int8        `json:"property_rank"`
	AddressesID           int64              `json:"addresses_id"`
	PropertyTypesID       int64              `json:"property_types_id"`
	Status                pgtype.Int8        `json:"status"`
	FacilitiesID          []int64            `json:"facilities_id"`
	AmenitiesID           []int64            `json:"amenities_id"`
	IsShowOwnerInfo       pgtype.Bool        `json:"is_show_owner_info"`
	Property              pgtype.Int8        `json:"property"`
	Category              int64              `json:"category"`
	Investment            pgtype.Bool        `json:"investment"`
	ContractStartDatetime pgtype.Timestamptz `json:"contract_start_datetime"`
	ContractEndDatetime   pgtype.Timestamptz `json:"contract_end_datetime"`
	Amount                pgtype.Float8      `json:"amount"`
	UnitTypes             []int64            `json:"unit_types"`
	PropertyName          string             `json:"property_name"`
	FromXml               pgtype.Bool        `json:"from_xml"`
	ListOfDate            []time.Time        `json:"list_of_date"`
	ListOfNotes           []string           `json:"list_of_notes"`
	ListOfAgent           []int64            `json:"list_of_agent"`
	OwnerUsersID          pgtype.Int8        `json:"owner_users_id"`
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (AuctionsProperty, error) {
	row := q.db.QueryRow(ctx, createProperty,
		arg.RefNo,
		arg.CompaniesID,
		arg.PropertyTitle,
		arg.PropertyTitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.IsVerified,
		arg.PropertyRank,
		arg.AddressesID,
		arg.PropertyTypesID,
		arg.Status,
		arg.FacilitiesID,
		arg.AmenitiesID,
		arg.IsShowOwnerInfo,
		arg.Property,
		arg.Category,
		arg.Investment,
		arg.ContractStartDatetime,
		arg.ContractEndDatetime,
		arg.Amount,
		arg.UnitTypes,
		arg.PropertyName,
		arg.FromXml,
		arg.ListOfDate,
		arg.ListOfNotes,
		arg.ListOfAgent,
		arg.OwnerUsersID,
	)
	var i AuctionsProperty
	err := row.Scan(
		&i.ID,
		&i.CompaniesID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.IsVerified,
		&i.PropertyRank,
		&i.AddressesID,
		&i.PropertyTypesID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FacilitiesID,
		&i.AmenitiesID,
		&i.IsShowOwnerInfo,
		&i.Property,
		&i.RefNo,
		&i.Category,
		&i.Investment,
		&i.ContractStartDatetime,
		&i.ContractEndDatetime,
		&i.Amount,
		&i.UnitTypes,
		&i.PropertyName,
		&i.FromXml,
		&i.ListOfDate,
		&i.ListOfNotes,
		&i.ListOfAgent,
		&i.OwnerUsersID,
	)
	return i, err
}

const deleteAuctionDocument = `-- name: DeleteAuctionDocument :exec
UPDATE auctions_documents
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteAuctionDocument(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAuctionDocument, id)
	return err
}

const deleteAuctionMedia = `-- name: DeleteAuctionMedia :exec
UPDATE auctions_media
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteAuctionMedia(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAuctionMedia, id)
	return err
}

const deleteAuctionPlan = `-- name: DeleteAuctionPlan :exec
UPDATE auctions_plans
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteAuctionPlan(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAuctionPlan, id)
	return err
}

const getActivitiesByType = `-- name: GetActivitiesByType :many
SELECT id, auction_id, activity_type, file_category, file_url, portal_url, activity, user_id, activity_date, created_at, updated_at FROM
    auctions_activities
WHERE activity_type = $1
    AND ($2::TEXT IS NULL OR activity ILIKE '%' || $2 || '%')
ORDER BY
    created_at DESC
LIMIT $3 OFFSET $4
`

type GetActivitiesByTypeParams struct {
	ActivityType int64  `json:"activity_type"`
	Column2      string `json:"column_2"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

func (q *Queries) GetActivitiesByType(ctx context.Context, arg GetActivitiesByTypeParams) ([]AuctionsActivity, error) {
	rows, err := q.db.Query(ctx, getActivitiesByType,
		arg.ActivityType,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsActivity
	for rows.Next() {
		var i AuctionsActivity
		if err := rows.Scan(
			&i.ID,
			&i.AuctionID,
			&i.ActivityType,
			&i.FileCategory,
			&i.FileUrl,
			&i.PortalUrl,
			&i.Activity,
			&i.UserID,
			&i.ActivityDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAddressByID = `-- name: GetAddressByID :one
SELECT id, country, state, city, community, sub_community, location_url, lat, lng, created_at, updated_at, deleted_at FROM auctions_addresses WHERE id = $1
`

// Get a addresses by ID
func (q *Queries) GetAddressByID(ctx context.Context, id int64) (AuctionsAddress, error) {
	row := q.db.QueryRow(ctx, getAddressByID, id)
	var i AuctionsAddress
	err := row.Scan(
		&i.ID,
		&i.Country,
		&i.State,
		&i.City,
		&i.Community,
		&i.SubCommunity,
		&i.LocationUrl,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAuctionByAuctionTitle = `-- name: GetAuctionByAuctionTitle :one
SELECT id, ref_no, auction_title, auction_description, auction_category, companies_id, mobile_number, email_address, whatsapp, select_type, property_name, property_category, property_usage, properties_unites_id, plot_no, sector_no, has_tenants, lat, lng, prebid_start_date, start_date, end_date, min_bid_amount, min_increment_amount, winning_bid_amount, auction_url, auction_type, description, description_ar, addresses_id, location_url, ownership_id, auction_status, tags_id, created_at, updated_at, deleted_at
FROM auctions
WHERE deleted_at IS NULL
    AND auction_title = $1
`

func (q *Queries) GetAuctionByAuctionTitle(ctx context.Context, auctionTitle pgtype.Text) (Auction, error) {
	row := q.db.QueryRow(ctx, getAuctionByAuctionTitle, auctionTitle)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.AuctionTitle,
		&i.AuctionDescription,
		&i.AuctionCategory,
		&i.CompaniesID,
		&i.MobileNumber,
		&i.EmailAddress,
		&i.Whatsapp,
		&i.SelectType,
		&i.PropertyName,
		&i.PropertyCategory,
		&i.PropertyUsage,
		&i.PropertiesUnitesID,
		&i.PlotNo,
		&i.SectorNo,
		&i.HasTenants,
		&i.Lat,
		&i.Lng,
		&i.PrebidStartDate,
		&i.StartDate,
		&i.EndDate,
		&i.MinBidAmount,
		&i.MinIncrementAmount,
		&i.WinningBidAmount,
		&i.AuctionUrl,
		&i.AuctionType,
		&i.Description,
		&i.DescriptionAr,
		&i.AddressesID,
		&i.LocationUrl,
		&i.OwnershipID,
		&i.AuctionStatus,
		&i.TagsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAuctionByID = `-- name: GetAuctionByID :one
SELECT
    a.id, a.ref_no, a.auction_title, a.auction_description, a.auction_category, a.companies_id, a.mobile_number, a.email_address, a.whatsapp, a.select_type, a.property_name, a.property_category, a.property_usage, a.properties_unites_id, a.plot_no, a.sector_no, a.has_tenants, a.lat, a.lng, a.prebid_start_date, a.start_date, a.end_date, a.min_bid_amount, a.min_increment_amount, a.winning_bid_amount, a.auction_url, a.auction_type, a.description, a.description_ar, a.addresses_id, a.location_url, a.ownership_id, a.auction_status, a.tags_id, a.created_at, a.updated_at, a.deleted_at,
    COUNT(DISTINCT pb.bidder_id) AS number_of_bidder,
    COALESCE(MAX(pb.amount), 0)::float8 AS current_max_bid_amount
FROM
    auctions a
LEFT JOIN
    auctions_pre_bids pb ON a.id = pb.auction_id
WHERE a.deleted_at IS NULL AND a.id = $1
GROUP BY a.id
`

type GetAuctionByIDRow struct {
	ID                  int64              `json:"id"`
	RefNo               pgtype.Text        `json:"ref_no"`
	AuctionTitle        pgtype.Text        `json:"auction_title"`
	AuctionDescription  pgtype.Text        `json:"auction_description"`
	AuctionCategory     pgtype.Int8        `json:"auction_category"`
	CompaniesID         pgtype.Int8        `json:"companies_id"`
	MobileNumber        pgtype.Text        `json:"mobile_number"`
	EmailAddress        pgtype.Text        `json:"email_address"`
	Whatsapp            pgtype.Text        `json:"whatsapp"`
	SelectType          int64              `json:"select_type"`
	PropertyName        pgtype.Text        `json:"property_name"`
	PropertyCategory    pgtype.Int8        `json:"property_category"`
	PropertyUsage       pgtype.Int8        `json:"property_usage"`
	PropertiesUnitesID  pgtype.Int8        `json:"properties_unites_id"`
	PlotNo              string             `json:"plot_no"`
	SectorNo            string             `json:"sector_no"`
	HasTenants          pgtype.Bool        `json:"has_tenants"`
	Lat                 pgtype.Float8      `json:"lat"`
	Lng                 pgtype.Float8      `json:"lng"`
	PrebidStartDate     pgtype.Timestamptz `json:"prebid_start_date"`
	StartDate           pgtype.Timestamptz `json:"start_date"`
	EndDate             pgtype.Timestamptz `json:"end_date"`
	MinBidAmount        pgtype.Float8      `json:"min_bid_amount"`
	MinIncrementAmount  pgtype.Float8      `json:"min_increment_amount"`
	WinningBidAmount    pgtype.Float8      `json:"winning_bid_amount"`
	AuctionUrl          pgtype.Text        `json:"auction_url"`
	AuctionType         pgtype.Int8        `json:"auction_type"`
	Description         string             `json:"description"`
	DescriptionAr       pgtype.Text        `json:"description_ar"`
	AddressesID         pgtype.Int8        `json:"addresses_id"`
	LocationUrl         pgtype.Text        `json:"location_url"`
	OwnershipID         pgtype.Int8        `json:"ownership_id"`
	AuctionStatus       pgtype.Int8        `json:"auction_status"`
	TagsID              []int64            `json:"tags_id"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DeletedAt           pgtype.Timestamptz `json:"deleted_at"`
	NumberOfBidder      int64              `json:"number_of_bidder"`
	CurrentMaxBidAmount float64            `json:"current_max_bid_amount"`
}

func (q *Queries) GetAuctionByID(ctx context.Context, id int64) (GetAuctionByIDRow, error) {
	row := q.db.QueryRow(ctx, getAuctionByID, id)
	var i GetAuctionByIDRow
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.AuctionTitle,
		&i.AuctionDescription,
		&i.AuctionCategory,
		&i.CompaniesID,
		&i.MobileNumber,
		&i.EmailAddress,
		&i.Whatsapp,
		&i.SelectType,
		&i.PropertyName,
		&i.PropertyCategory,
		&i.PropertyUsage,
		&i.PropertiesUnitesID,
		&i.PlotNo,
		&i.SectorNo,
		&i.HasTenants,
		&i.Lat,
		&i.Lng,
		&i.PrebidStartDate,
		&i.StartDate,
		&i.EndDate,
		&i.MinBidAmount,
		&i.MinIncrementAmount,
		&i.WinningBidAmount,
		&i.AuctionUrl,
		&i.AuctionType,
		&i.Description,
		&i.DescriptionAr,
		&i.AddressesID,
		&i.LocationUrl,
		&i.OwnershipID,
		&i.AuctionStatus,
		&i.TagsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.NumberOfBidder,
		&i.CurrentMaxBidAmount,
	)
	return i, err
}

const getAuctionDocumentByID = `-- name: GetAuctionDocumentByID :one
SELECT id, auction_id, document_type, document_url, created_at, updated_at, deleted_at
FROM auctions_documents
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetAuctionDocumentByID(ctx context.Context, id int64) (AuctionsDocument, error) {
	row := q.db.QueryRow(ctx, getAuctionDocumentByID, id)
	var i AuctionsDocument
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAuctionDocumentsByAuctionID = `-- name: GetAuctionDocumentsByAuctionID :many
SELECT id, auction_id, document_type, document_url, created_at, updated_at, deleted_at
FROM auctions_documents
WHERE deleted_at IS NULL
    AND auction_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuctionDocumentsByAuctionIDParams struct {
	AuctionID pgtype.Int8 `json:"auction_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetAuctionDocumentsByAuctionID(ctx context.Context, arg GetAuctionDocumentsByAuctionIDParams) ([]AuctionsDocument, error) {
	rows, err := q.db.Query(ctx, getAuctionDocumentsByAuctionID, arg.AuctionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsDocument
	for rows.Next() {
		var i AuctionsDocument
		if err := rows.Scan(
			&i.ID,
			&i.AuctionID,
			&i.DocumentType,
			&i.DocumentUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuctionMediaByAuctionID = `-- name: GetAuctionMediaByAuctionID :many
SELECT id, auction_id, gallery_type, media_type, media_url, created_at, updated_at, deleted_at
FROM auctions_media
WHERE deleted_at IS NULL
    AND auction_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuctionMediaByAuctionIDParams struct {
	AuctionID int64 `json:"auction_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetAuctionMediaByAuctionID(ctx context.Context, arg GetAuctionMediaByAuctionIDParams) ([]AuctionsMedium, error) {
	rows, err := q.db.Query(ctx, getAuctionMediaByAuctionID, arg.AuctionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsMedium
	for rows.Next() {
		var i AuctionsMedium
		if err := rows.Scan(
			&i.ID,
			&i.AuctionID,
			&i.GalleryType,
			&i.MediaType,
			&i.MediaUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuctionMediaByID = `-- name: GetAuctionMediaByID :one
SELECT id, auction_id, gallery_type, media_type, media_url, created_at, updated_at, deleted_at
FROM auctions_media
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetAuctionMediaByID(ctx context.Context, id int64) (AuctionsMedium, error) {
	row := q.db.QueryRow(ctx, getAuctionMediaByID, id)
	var i AuctionsMedium
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.GalleryType,
		&i.MediaType,
		&i.MediaUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAuctionPartnerByID = `-- name: GetAuctionPartnerByID :one
SELECT id, ref_no, auction_id, partner_name, partner_logo, website, created_at, updated_at, deleted_at
FROM auctions_partners
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetAuctionPartnerByID(ctx context.Context, id int64) (AuctionsPartner, error) {
	row := q.db.QueryRow(ctx, getAuctionPartnerByID, id)
	var i AuctionsPartner
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.AuctionID,
		&i.PartnerName,
		&i.PartnerLogo,
		&i.Website,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAuctionPlanByID = `-- name: GetAuctionPlanByID :one
SELECT id, auction_id, plan_title, plan_url, created_at, updated_at, deleted_at
FROM auctions_plans
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetAuctionPlanByID(ctx context.Context, id int64) (AuctionsPlan, error) {
	row := q.db.QueryRow(ctx, getAuctionPlanByID, id)
	var i AuctionsPlan
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.PlanTitle,
		&i.PlanUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAuctionPlansByAuctionID = `-- name: GetAuctionPlansByAuctionID :many
SELECT id, auction_id, plan_title, plan_url, created_at, updated_at, deleted_at
FROM auctions_plans
WHERE deleted_at IS NULL AND auction_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuctionPlansByAuctionIDParams struct {
	AuctionID pgtype.Int8 `json:"auction_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetAuctionPlansByAuctionID(ctx context.Context, arg GetAuctionPlansByAuctionIDParams) ([]AuctionsPlan, error) {
	rows, err := q.db.Query(ctx, getAuctionPlansByAuctionID, arg.AuctionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsPlan
	for rows.Next() {
		var i AuctionsPlan
		if err := rows.Scan(
			&i.ID,
			&i.AuctionID,
			&i.PlanTitle,
			&i.PlanUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangesByActivityID = `-- name: GetChangesByActivityID :many
SELECT id, section_id, activities_id, field_name, before, after, activity_date, created_at, updated_at FROM
    auctions_activity_changes
WHERE
    activities_id = $1
    AND ($2::TEXT IS NULL OR
        field_name ILIKE '%' || $2 || '%' OR
        before ILIKE '%' || $2 || '%' OR
        after ILIKE '%' || $2 || '%')
ORDER BY
    created_at DESC
LIMIT $3 OFFSET $4
`

type GetChangesByActivityIDParams struct {
	ActivitiesID int64  `json:"activities_id"`
	Column2      string `json:"column_2"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

func (q *Queries) GetChangesByActivityID(ctx context.Context, arg GetChangesByActivityIDParams) ([]AuctionsActivityChange, error) {
	rows, err := q.db.Query(ctx, getChangesByActivityID,
		arg.ActivitiesID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsActivityChange
	for rows.Next() {
		var i AuctionsActivityChange
		if err := rows.Scan(
			&i.ID,
			&i.SectionID,
			&i.ActivitiesID,
			&i.FieldName,
			&i.Before,
			&i.After,
			&i.ActivityDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyDetailsById = `-- name: GetCompanyDetailsById :one

 -- AND auction_title = $1;










 



SELECT id, logo_url, website_url, company_name, is_verified, created_at, updated_at, deleted_at FROM auctions_companies
WHERE deleted_at IS NULL AND id = $1
`

// -- name: GetAuctionByID :one
// SELECT
//
//	a.*,
//	COUNT(DISTINCT pb.bidder_id) AS number_of_bidder,
//	COALESCE(MAX(pb.amount), 0)::float8 AS current_max_bid_amount
//
// FROM
//
//	auctions a
//
// LEFT JOIN
//
//	auctions_pre_bids pb ON a.id = pb.auction_id
//
// WHERE a.deleted_at IS NULL AND a.id = $1
// GROUP BY a.id;
// -- name: GetAuctionByAuctionTitle :one
// SELECT *
// FROM auctions
// WHERE deleted_at IS NULL
// -- name: ListAuctions :many
// SELECT
//
//	a.*,
//	COUNT(DISTINCT pb.bidder_id) AS number_of_bidder,
//	COALESCE(MAX(pb.amount), 0)::float8 AS current_max_bid_amount
//
// FROM
//
//	auctions a
//
// LEFT JOIN
//
//	auctions_pre_bids pb ON a.id = pb.auction_id
//
// WHERE a.deleted_at IS NULL
// AND ($1::BIGINT IS NULL OR a.auction_type = $1)  --local OR internation
// AND ($2::TEXT IS NULL OR
//
//	a.auction_title ILIKE '%' || $2 || '%' OR
//	a.description ILIKE '%' || $2 || '%' OR
//	a.auction_description ILIKE '%' || $2 || '%' OR
//	a.auction_url ILIKE '%' || $2 || '%'
//
// )
// GROUP BY a.id
// ORDER BY a.created_at DESC
// LIMIT $3 OFFSET $4;
// -- name: CountAuctions :one
// SELECT COUNT(id)
// FROM auctions
// WHERE deleted_at IS NULL
// AND ($1::bigint IS NULL OR auction_type = $1::bigint)
// AND (
//
//	$2::TEXT IS NULL OR
//	auction_title ILIKE '%' || $2 || '%' OR
//	description ILIKE '%' || $2 || '%' OR
//	auction_description ILIKE '%' || $2 || '%' OR
//	auction_url ILIKE '%' || $2 || '%'
//
// );
// -- name: UpdateAuction :one
// UPDATE auctions SET
//
//	auction_title = $2, auction_description = $3, auction_category = $4,select_type = $5, property_name = $6, property_category = $7,
//	property_usage = $8, properties_unites_id = $9, plot_no = $10, sector_no = $11, has_tenants = $12, lat = $13, lng = $14,
//	prebid_start_date = $15, start_date = $16, end_date = $17, min_bid_amount = $18, min_increment_amount = $19,
//	auction_url = $20, auction_type = $21, description = $22, description_ar = $23,
//	addresses_id = $24, location_url = $25, ownership_id = $26, updated_at = now(), auction_status = $27, tags_id = $28
//
// WHERE id = $1
// RETURNING *;
// -- name: SoftDeleteAuction :exec
// UPDATE auctions SET
//
//	auction_status = $2, -- DELETED
//	updated_at = now(),
//	deleted_at = now()
//
// WHERE id = $1;
// -- name: ListDeletedAuctions :many
// SELECT
//
//	a.*,
//	COUNT(DISTINCT pb.bidder_id) AS number_of_bidder,
//	COALESCE(MAX(pb.amount), 0)::float8 AS current_max_bid_amount
//
// FROM
//
//	auctions a
//
// LEFT JOIN
//
//	auctions_pre_bids pb ON a.id = pb.auction_id
//
// WHERE a.deleted_at IS NOT NULL
// AND (
//
//	$1::TEXT IS NULL OR
//	a.auction_title ILIKE '%' || $1 || '%' OR
//	a.auction_description ILIKE '%' || $1 || '%' OR
//	a.description ILIKE '%' || $1 || '%' OR
//	a.auction_url ILIKE '%' || $1 || '%'
//
// )
// GROUP BY a.id
// ORDER BY a.created_at DESC
// LIMIT $2 OFFSET $3;
// -- name: CountDeletedAuctions :one
// SELECT COUNT(id)
// FROM auctions
// WHERE deleted_at IS NOT NULL
// AND (
//
//	$1::TEXT IS NULL OR
//	auction_title ILIKE '%' || $1 || '%' OR
//	auction_description ILIKE '%' || $1 || '%' OR
//	description ILIKE '%' || $1 || '%' OR
//	auction_url ILIKE '%' || $1 || '%'
//
// );
// -- name: RestoreAuctionById :exec
// UPDATE auctions SET
//
//	auction_status = $2,
//	updated_at = now(),
//	deleted_at = NULL
//
// WHERE id = $1 AND deleted_at IS NOT NULL;
func (q *Queries) GetCompanyDetailsById(ctx context.Context, id int64) (AuctionsCompany, error) {
	row := q.db.QueryRow(ctx, getCompanyDetailsById, id)
	var i AuctionsCompany
	err := row.Scan(
		&i.ID,
		&i.LogoUrl,
		&i.WebsiteUrl,
		&i.CompanyName,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCompanyDetailsByUserId = `-- name: GetCompanyDetailsByUserId :one
SELECT
    c.id, c.logo_url, c.website_url, c.company_name, c.is_verified, c.created_at, c.updated_at, c.deleted_at
FROM
    auctions_users u
JOIN
    auctions_companies c ON u.company_id = c.id
WHERE c.deleted_at IS NULL
    AND u.id = $1
`

func (q *Queries) GetCompanyDetailsByUserId(ctx context.Context, id int64) (AuctionsCompany, error) {
	row := q.db.QueryRow(ctx, getCompanyDetailsByUserId, id)
	var i AuctionsCompany
	err := row.Scan(
		&i.ID,
		&i.LogoUrl,
		&i.WebsiteUrl,
		&i.CompanyName,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDeletedFAQs = `-- name: GetDeletedFAQs :many
SELECT id, ref_no, question, answer, created_at, updated_at, deleted_at
FROM auctions_faqs
WHERE deleted_at IS NOT NULL
    AND ($1::TEXT IS NULL OR question ILIKE '%' || $1 || '%' OR answer ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetDeletedFAQsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) GetDeletedFAQs(ctx context.Context, arg GetDeletedFAQsParams) ([]AuctionsFaq, error) {
	rows, err := q.db.Query(ctx, getDeletedFAQs, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsFaq
	for rows.Next() {
		var i AuctionsFaq
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.Question,
			&i.Answer,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentByDocumentTypeAndAuctionID = `-- name: GetDocumentByDocumentTypeAndAuctionID :one
SELECT id, auction_id, document_type, document_url, created_at, updated_at, deleted_at
FROM auctions_documents
WHERE deleted_at IS NULL
    AND auction_id = $1
    AND document_type = $2
`

type GetDocumentByDocumentTypeAndAuctionIDParams struct {
	AuctionID    pgtype.Int8 `json:"auction_id"`
	DocumentType pgtype.Int8 `json:"document_type"`
}

func (q *Queries) GetDocumentByDocumentTypeAndAuctionID(ctx context.Context, arg GetDocumentByDocumentTypeAndAuctionIDParams) (AuctionsDocument, error) {
	row := q.db.QueryRow(ctx, getDocumentByDocumentTypeAndAuctionID, arg.AuctionID, arg.DocumentType)
	var i AuctionsDocument
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFAQByID = `-- name: GetFAQByID :one
SELECT id, ref_no, question, answer, created_at, updated_at, deleted_at
FROM auctions_faqs
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetFAQByID(ctx context.Context, id int64) (AuctionsFaq, error) {
	row := q.db.QueryRow(ctx, getFAQByID, id)
	var i AuctionsFaq
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Question,
		&i.Answer,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMediaCountOfAuction = `-- name: GetMediaCountOfAuction :one
SELECT COUNT(unnested_media) AS media_count
FROM auctions_media,
UNNEST(media_url) AS unnested_media
WHERE auction_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMediaCountOfAuction(ctx context.Context, auctionID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getMediaCountOfAuction, auctionID)
	var media_count int64
	err := row.Scan(&media_count)
	return media_count, err
}

const getPlansByPlanTitleAndAuctionID = `-- name: GetPlansByPlanTitleAndAuctionID :one
SELECT id, auction_id, plan_title, plan_url, created_at, updated_at, deleted_at
FROM auctions_plans
WHERE deleted_at IS NULL
    AND auction_id = $1
    AND plan_title = $2
`

type GetPlansByPlanTitleAndAuctionIDParams struct {
	AuctionID pgtype.Int8 `json:"auction_id"`
	PlanTitle pgtype.Int8 `json:"plan_title"`
}

func (q *Queries) GetPlansByPlanTitleAndAuctionID(ctx context.Context, arg GetPlansByPlanTitleAndAuctionIDParams) (AuctionsPlan, error) {
	row := q.db.QueryRow(ctx, getPlansByPlanTitleAndAuctionID, arg.AuctionID, arg.PlanTitle)
	var i AuctionsPlan
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.PlanTitle,
		&i.PlanUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPropertiesFactByPropertyID = `-- name: GetPropertiesFactByPropertyID :one
SELECT id, bedroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure, created_at, updated_at FROM auctions_properties_facts WHERE properties_id = $1
`

func (q *Queries) GetPropertiesFactByPropertyID(ctx context.Context, propertiesID pgtype.Int8) (AuctionsPropertiesFact, error) {
	row := q.db.QueryRow(ctx, getPropertiesFactByPropertyID, propertiesID)
	var i AuctionsPropertiesFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.PropertiesID,
		&i.Property,
		&i.IsBranch,
		&i.AvailableUnits,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.IsProjectFact,
		&i.ProjectID,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.TypeNameID,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPropertyById = `-- name: GetPropertyById :one
SELECT id, companies_id, property_title, property_title_arabic, description, description_arabic, is_verified, property_rank, addresses_id, property_types_id, status, created_at, updated_at, facilities_id, amenities_id, is_show_owner_info, property, ref_no, category, investment, contract_start_datetime, contract_end_datetime, amount, unit_types, property_name, from_xml, list_of_date, list_of_notes, list_of_agent, owner_users_id
FROM auctions_properties
WHERE id = $1
`

func (q *Queries) GetPropertyById(ctx context.Context, id int64) (AuctionsProperty, error) {
	row := q.db.QueryRow(ctx, getPropertyById, id)
	var i AuctionsProperty
	err := row.Scan(
		&i.ID,
		&i.CompaniesID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.IsVerified,
		&i.PropertyRank,
		&i.AddressesID,
		&i.PropertyTypesID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FacilitiesID,
		&i.AmenitiesID,
		&i.IsShowOwnerInfo,
		&i.Property,
		&i.RefNo,
		&i.Category,
		&i.Investment,
		&i.ContractStartDatetime,
		&i.ContractEndDatetime,
		&i.Amount,
		&i.UnitTypes,
		&i.PropertyName,
		&i.FromXml,
		&i.ListOfDate,
		&i.ListOfNotes,
		&i.ListOfAgent,
		&i.OwnerUsersID,
	)
	return i, err
}

const getUnitById = `-- name: GetUnitById :one
SELECT id, unit_no, unitno_is_public, notes, notes_arabic, notes_public, is_verified, amenities_id, property_unit_rank, properties_id, property, created_at, updated_at, ref_no, addresses_id, countries_id, property_types_id, created_by, property_name, section, type_name_id, owner_users_id
FROM auctions_units
WHERE id = $1
`

func (q *Queries) GetUnitById(ctx context.Context, id int64) (AuctionsUnit, error) {
	row := q.db.QueryRow(ctx, getUnitById, id)
	var i AuctionsUnit
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.AmenitiesID,
		&i.PropertyUnitRank,
		&i.PropertiesID,
		&i.Property,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.AddressesID,
		&i.CountriesID,
		&i.PropertyTypesID,
		&i.CreatedBy,
		&i.PropertyName,
		&i.Section,
		&i.TypeNameID,
		&i.OwnerUsersID,
	)
	return i, err
}

const getUnitFactByUnitID = `-- name: GetUnitFactByUnitID :one
SELECT id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, unit_id, category, is_branch, commercial_tax, municipality_tax, sc_currency_id, unit_of_measure, created_at, updated_at FROM auctions_unit_facts WHERE unit_id = $1
`

func (q *Queries) GetUnitFactByUnitID(ctx context.Context, unitID int64) (AuctionsUnitFact, error) {
	row := q.db.QueryRow(ctx, getUnitFactByUnitID, unitID)
	var i AuctionsUnitFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.UnitID,
		&i.Category,
		&i.IsBranch,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAddresses = `-- name: ListAddresses :many
SELECT id, country, state, city, community, sub_community, location_url, lat, lng, created_at, updated_at, deleted_at FROM auctions_addresses
`

// List all addresses
func (q *Queries) ListAddresses(ctx context.Context) ([]AuctionsAddress, error) {
	rows, err := q.db.Query(ctx, listAddresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsAddress
	for rows.Next() {
		var i AuctionsAddress
		if err := rows.Scan(
			&i.ID,
			&i.Country,
			&i.State,
			&i.City,
			&i.Community,
			&i.SubCommunity,
			&i.LocationUrl,
			&i.Lat,
			&i.Lng,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllFAQs = `-- name: ListAllFAQs :many
SELECT id, ref_no, question, answer, created_at, updated_at, deleted_at
FROM auctions_faqs
WHERE deleted_at IS NULL
    AND ($1::TEXT IS NULL OR question ILIKE '%' || $1 || '%' OR answer ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAllFAQsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListAllFAQs(ctx context.Context, arg ListAllFAQsParams) ([]AuctionsFaq, error) {
	rows, err := q.db.Query(ctx, listAllFAQs, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsFaq
	for rows.Next() {
		var i AuctionsFaq
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.Question,
			&i.Answer,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuctionPartners = `-- name: ListAuctionPartners :many
SELECT id, ref_no, auction_id, partner_name, partner_logo, website, created_at, updated_at, deleted_at
FROM auctions_partners
WHERE deleted_at IS NULL
    AND auction_id = $1
    AND ($2::TEXT IS NULL
    OR partner_name ILIKE '%' || $2 || '%'
    OR website ILIKE '%' || $2 || '%'
)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuctionPartnersParams struct {
	AuctionID int64  `json:"auction_id"`
	Column2   string `json:"column_2"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListAuctionPartners(ctx context.Context, arg ListAuctionPartnersParams) ([]AuctionsPartner, error) {
	rows, err := q.db.Query(ctx, listAuctionPartners,
		arg.AuctionID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsPartner
	for rows.Next() {
		var i AuctionsPartner
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.AuctionID,
			&i.PartnerName,
			&i.PartnerLogo,
			&i.Website,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuctions = `-- name: ListAuctions :many
SELECT
    a.id, a.ref_no, a.auction_title, a.auction_description, a.auction_category, a.companies_id, a.mobile_number, a.email_address, a.whatsapp, a.select_type, a.property_name, a.property_category, a.property_usage, a.properties_unites_id, a.plot_no, a.sector_no, a.has_tenants, a.lat, a.lng, a.prebid_start_date, a.start_date, a.end_date, a.min_bid_amount, a.min_increment_amount, a.winning_bid_amount, a.auction_url, a.auction_type, a.description, a.description_ar, a.addresses_id, a.location_url, a.ownership_id, a.auction_status, a.tags_id, a.created_at, a.updated_at, a.deleted_at,
    COUNT(DISTINCT pb.bidder_id) AS number_of_bidder,
    COALESCE(MAX(pb.amount), 0)::float8 AS current_max_bid_amount
FROM
    auctions a
LEFT JOIN
    auctions_pre_bids pb ON a.id = pb.auction_id
WHERE a.deleted_at IS NULL
AND ($1::BIGINT IS NULL OR a.auction_type = $1)  --local OR internation
AND ($2::TEXT IS NULL OR
    a.auction_title ILIKE '%' || $2 || '%' OR
    a.description ILIKE '%' || $2 || '%' OR
    a.auction_description ILIKE '%' || $2 || '%' OR
    a.auction_url ILIKE '%' || $2 || '%'
)
GROUP BY a.id
ORDER BY a.created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuctionsParams struct {
	Column1 int64  `json:"column_1"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListAuctionsRow struct {
	ID                  int64              `json:"id"`
	RefNo               pgtype.Text        `json:"ref_no"`
	AuctionTitle        pgtype.Text        `json:"auction_title"`
	AuctionDescription  pgtype.Text        `json:"auction_description"`
	AuctionCategory     pgtype.Int8        `json:"auction_category"`
	CompaniesID         pgtype.Int8        `json:"companies_id"`
	MobileNumber        pgtype.Text        `json:"mobile_number"`
	EmailAddress        pgtype.Text        `json:"email_address"`
	Whatsapp            pgtype.Text        `json:"whatsapp"`
	SelectType          int64              `json:"select_type"`
	PropertyName        pgtype.Text        `json:"property_name"`
	PropertyCategory    pgtype.Int8        `json:"property_category"`
	PropertyUsage       pgtype.Int8        `json:"property_usage"`
	PropertiesUnitesID  pgtype.Int8        `json:"properties_unites_id"`
	PlotNo              string             `json:"plot_no"`
	SectorNo            string             `json:"sector_no"`
	HasTenants          pgtype.Bool        `json:"has_tenants"`
	Lat                 pgtype.Float8      `json:"lat"`
	Lng                 pgtype.Float8      `json:"lng"`
	PrebidStartDate     pgtype.Timestamptz `json:"prebid_start_date"`
	StartDate           pgtype.Timestamptz `json:"start_date"`
	EndDate             pgtype.Timestamptz `json:"end_date"`
	MinBidAmount        pgtype.Float8      `json:"min_bid_amount"`
	MinIncrementAmount  pgtype.Float8      `json:"min_increment_amount"`
	WinningBidAmount    pgtype.Float8      `json:"winning_bid_amount"`
	AuctionUrl          pgtype.Text        `json:"auction_url"`
	AuctionType         pgtype.Int8        `json:"auction_type"`
	Description         string             `json:"description"`
	DescriptionAr       pgtype.Text        `json:"description_ar"`
	AddressesID         pgtype.Int8        `json:"addresses_id"`
	LocationUrl         pgtype.Text        `json:"location_url"`
	OwnershipID         pgtype.Int8        `json:"ownership_id"`
	AuctionStatus       pgtype.Int8        `json:"auction_status"`
	TagsID              []int64            `json:"tags_id"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DeletedAt           pgtype.Timestamptz `json:"deleted_at"`
	NumberOfBidder      int64              `json:"number_of_bidder"`
	CurrentMaxBidAmount float64            `json:"current_max_bid_amount"`
}

func (q *Queries) ListAuctions(ctx context.Context, arg ListAuctionsParams) ([]ListAuctionsRow, error) {
	rows, err := q.db.Query(ctx, listAuctions,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAuctionsRow
	for rows.Next() {
		var i ListAuctionsRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.AuctionTitle,
			&i.AuctionDescription,
			&i.AuctionCategory,
			&i.CompaniesID,
			&i.MobileNumber,
			&i.EmailAddress,
			&i.Whatsapp,
			&i.SelectType,
			&i.PropertyName,
			&i.PropertyCategory,
			&i.PropertyUsage,
			&i.PropertiesUnitesID,
			&i.PlotNo,
			&i.SectorNo,
			&i.HasTenants,
			&i.Lat,
			&i.Lng,
			&i.PrebidStartDate,
			&i.StartDate,
			&i.EndDate,
			&i.MinBidAmount,
			&i.MinIncrementAmount,
			&i.WinningBidAmount,
			&i.AuctionUrl,
			&i.AuctionType,
			&i.Description,
			&i.DescriptionAr,
			&i.AddressesID,
			&i.LocationUrl,
			&i.OwnershipID,
			&i.AuctionStatus,
			&i.TagsID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NumberOfBidder,
			&i.CurrentMaxBidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedAuctions = `-- name: ListDeletedAuctions :many
SELECT
    a.id, a.ref_no, a.auction_title, a.auction_description, a.auction_category, a.companies_id, a.mobile_number, a.email_address, a.whatsapp, a.select_type, a.property_name, a.property_category, a.property_usage, a.properties_unites_id, a.plot_no, a.sector_no, a.has_tenants, a.lat, a.lng, a.prebid_start_date, a.start_date, a.end_date, a.min_bid_amount, a.min_increment_amount, a.winning_bid_amount, a.auction_url, a.auction_type, a.description, a.description_ar, a.addresses_id, a.location_url, a.ownership_id, a.auction_status, a.tags_id, a.created_at, a.updated_at, a.deleted_at,
    COUNT(DISTINCT pb.bidder_id) AS number_of_bidder,
    COALESCE(MAX(pb.amount), 0)::float8 AS current_max_bid_amount
FROM
    auctions a
LEFT JOIN
    auctions_pre_bids pb ON a.id = pb.auction_id
WHERE a.deleted_at IS NOT NULL
AND (
    $1::TEXT IS NULL OR
    a.auction_title ILIKE '%' || $1 || '%' OR
    a.auction_description ILIKE '%' || $1 || '%' OR
    a.description ILIKE '%' || $1 || '%' OR
    a.auction_url ILIKE '%' || $1 || '%'
)
GROUP BY a.id
ORDER BY a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListDeletedAuctionsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListDeletedAuctionsRow struct {
	ID                  int64              `json:"id"`
	RefNo               pgtype.Text        `json:"ref_no"`
	AuctionTitle        pgtype.Text        `json:"auction_title"`
	AuctionDescription  pgtype.Text        `json:"auction_description"`
	AuctionCategory     pgtype.Int8        `json:"auction_category"`
	CompaniesID         pgtype.Int8        `json:"companies_id"`
	MobileNumber        pgtype.Text        `json:"mobile_number"`
	EmailAddress        pgtype.Text        `json:"email_address"`
	Whatsapp            pgtype.Text        `json:"whatsapp"`
	SelectType          int64              `json:"select_type"`
	PropertyName        pgtype.Text        `json:"property_name"`
	PropertyCategory    pgtype.Int8        `json:"property_category"`
	PropertyUsage       pgtype.Int8        `json:"property_usage"`
	PropertiesUnitesID  pgtype.Int8        `json:"properties_unites_id"`
	PlotNo              string             `json:"plot_no"`
	SectorNo            string             `json:"sector_no"`
	HasTenants          pgtype.Bool        `json:"has_tenants"`
	Lat                 pgtype.Float8      `json:"lat"`
	Lng                 pgtype.Float8      `json:"lng"`
	PrebidStartDate     pgtype.Timestamptz `json:"prebid_start_date"`
	StartDate           pgtype.Timestamptz `json:"start_date"`
	EndDate             pgtype.Timestamptz `json:"end_date"`
	MinBidAmount        pgtype.Float8      `json:"min_bid_amount"`
	MinIncrementAmount  pgtype.Float8      `json:"min_increment_amount"`
	WinningBidAmount    pgtype.Float8      `json:"winning_bid_amount"`
	AuctionUrl          pgtype.Text        `json:"auction_url"`
	AuctionType         pgtype.Int8        `json:"auction_type"`
	Description         string             `json:"description"`
	DescriptionAr       pgtype.Text        `json:"description_ar"`
	AddressesID         pgtype.Int8        `json:"addresses_id"`
	LocationUrl         pgtype.Text        `json:"location_url"`
	OwnershipID         pgtype.Int8        `json:"ownership_id"`
	AuctionStatus       pgtype.Int8        `json:"auction_status"`
	TagsID              []int64            `json:"tags_id"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DeletedAt           pgtype.Timestamptz `json:"deleted_at"`
	NumberOfBidder      int64              `json:"number_of_bidder"`
	CurrentMaxBidAmount float64            `json:"current_max_bid_amount"`
}

func (q *Queries) ListDeletedAuctions(ctx context.Context, arg ListDeletedAuctionsParams) ([]ListDeletedAuctionsRow, error) {
	rows, err := q.db.Query(ctx, listDeletedAuctions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeletedAuctionsRow
	for rows.Next() {
		var i ListDeletedAuctionsRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.AuctionTitle,
			&i.AuctionDescription,
			&i.AuctionCategory,
			&i.CompaniesID,
			&i.MobileNumber,
			&i.EmailAddress,
			&i.Whatsapp,
			&i.SelectType,
			&i.PropertyName,
			&i.PropertyCategory,
			&i.PropertyUsage,
			&i.PropertiesUnitesID,
			&i.PlotNo,
			&i.SectorNo,
			&i.HasTenants,
			&i.Lat,
			&i.Lng,
			&i.PrebidStartDate,
			&i.StartDate,
			&i.EndDate,
			&i.MinBidAmount,
			&i.MinIncrementAmount,
			&i.WinningBidAmount,
			&i.AuctionUrl,
			&i.AuctionType,
			&i.Description,
			&i.DescriptionAr,
			&i.AddressesID,
			&i.LocationUrl,
			&i.OwnershipID,
			&i.AuctionStatus,
			&i.TagsID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.NumberOfBidder,
			&i.CurrentMaxBidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedPartners = `-- name: ListDeletedPartners :many
SELECT id, ref_no, auction_id, partner_name, partner_logo, website, created_at, updated_at, deleted_at
FROM auctions_partners
WHERE deleted_at IS NOT NULL
    AND ($1::TEXT IS NULL
    OR partner_name ILIKE '%' || $1 || '%'
    OR website ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDeletedPartnersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListDeletedPartners(ctx context.Context, arg ListDeletedPartnersParams) ([]AuctionsPartner, error) {
	rows, err := q.db.Query(ctx, listDeletedPartners, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionsPartner
	for rows.Next() {
		var i AuctionsPartner
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.AuctionID,
			&i.PartnerName,
			&i.PartnerLogo,
			&i.Website,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAuctionById = `-- name: RestoreAuctionById :exec
UPDATE auctions SET
    auction_status = $2,
    updated_at = now(),
    deleted_at = NULL
WHERE id = $1 AND deleted_at IS NOT NULL
`

type RestoreAuctionByIdParams struct {
	ID            int64       `json:"id"`
	AuctionStatus pgtype.Int8 `json:"auction_status"`
}

func (q *Queries) RestoreAuctionById(ctx context.Context, arg RestoreAuctionByIdParams) error {
	_, err := q.db.Exec(ctx, restoreAuctionById, arg.ID, arg.AuctionStatus)
	return err
}

const restoreAuctionPartner = `-- name: RestoreAuctionPartner :exec
UPDATE auctions_partners
SET deleted_at = NULL
WHERE id = $1
`

func (q *Queries) RestoreAuctionPartner(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, restoreAuctionPartner, id)
	return err
}

const restoreFAQ = `-- name: RestoreFAQ :exec
UPDATE auctions_faqs
SET deleted_at = NULL
WHERE id = $1 AND deleted_at IS NOT NULL
`

func (q *Queries) RestoreFAQ(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, restoreFAQ, id)
	return err
}

const softDeleteAuction = `-- name: SoftDeleteAuction :exec
UPDATE auctions SET
    auction_status = $2, -- DELETED
    updated_at = now(),
    deleted_at = now()
WHERE id = $1
`

type SoftDeleteAuctionParams struct {
	ID            int64       `json:"id"`
	AuctionStatus pgtype.Int8 `json:"auction_status"`
}

func (q *Queries) SoftDeleteAuction(ctx context.Context, arg SoftDeleteAuctionParams) error {
	_, err := q.db.Exec(ctx, softDeleteAuction, arg.ID, arg.AuctionStatus)
	return err
}

const softDeleteAuctionPartner = `-- name: SoftDeleteAuctionPartner :exec
UPDATE auctions_partners
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteAuctionPartner(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, softDeleteAuctionPartner, id)
	return err
}

const softDeleteFAQ = `-- name: SoftDeleteFAQ :exec
UPDATE auctions_faqs
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteFAQ(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, softDeleteFAQ, id)
	return err
}

const updateAuction = `-- name: UpdateAuction :one
UPDATE auctions SET
    auction_title = $2, auction_description = $3, auction_category = $4,select_type = $5, property_name = $6, property_category = $7,
    property_usage = $8, properties_unites_id = $9, plot_no = $10, sector_no = $11, has_tenants = $12, lat = $13, lng = $14,
    prebid_start_date = $15, start_date = $16, end_date = $17, min_bid_amount = $18, min_increment_amount = $19,
    auction_url = $20, auction_type = $21, description = $22, description_ar = $23,
    addresses_id = $24, location_url = $25, ownership_id = $26, updated_at = now(), auction_status = $27, tags_id = $28
WHERE id = $1
RETURNING id, ref_no, auction_title, auction_description, auction_category, companies_id, mobile_number, email_address, whatsapp, select_type, property_name, property_category, property_usage, properties_unites_id, plot_no, sector_no, has_tenants, lat, lng, prebid_start_date, start_date, end_date, min_bid_amount, min_increment_amount, winning_bid_amount, auction_url, auction_type, description, description_ar, addresses_id, location_url, ownership_id, auction_status, tags_id, created_at, updated_at, deleted_at
`

type UpdateAuctionParams struct {
	ID                 int64              `json:"id"`
	AuctionTitle       pgtype.Text        `json:"auction_title"`
	AuctionDescription pgtype.Text        `json:"auction_description"`
	AuctionCategory    pgtype.Int8        `json:"auction_category"`
	SelectType         int64              `json:"select_type"`
	PropertyName       pgtype.Text        `json:"property_name"`
	PropertyCategory   pgtype.Int8        `json:"property_category"`
	PropertyUsage      pgtype.Int8        `json:"property_usage"`
	PropertiesUnitesID pgtype.Int8        `json:"properties_unites_id"`
	PlotNo             string             `json:"plot_no"`
	SectorNo           string             `json:"sector_no"`
	HasTenants         pgtype.Bool        `json:"has_tenants"`
	Lat                pgtype.Float8      `json:"lat"`
	Lng                pgtype.Float8      `json:"lng"`
	PrebidStartDate    pgtype.Timestamptz `json:"prebid_start_date"`
	StartDate          pgtype.Timestamptz `json:"start_date"`
	EndDate            pgtype.Timestamptz `json:"end_date"`
	MinBidAmount       pgtype.Float8      `json:"min_bid_amount"`
	MinIncrementAmount pgtype.Float8      `json:"min_increment_amount"`
	AuctionUrl         pgtype.Text        `json:"auction_url"`
	AuctionType        pgtype.Int8        `json:"auction_type"`
	Description        string             `json:"description"`
	DescriptionAr      pgtype.Text        `json:"description_ar"`
	AddressesID        pgtype.Int8        `json:"addresses_id"`
	LocationUrl        pgtype.Text        `json:"location_url"`
	OwnershipID        pgtype.Int8        `json:"ownership_id"`
	AuctionStatus      pgtype.Int8        `json:"auction_status"`
	TagsID             []int64            `json:"tags_id"`
}

func (q *Queries) UpdateAuction(ctx context.Context, arg UpdateAuctionParams) (Auction, error) {
	row := q.db.QueryRow(ctx, updateAuction,
		arg.ID,
		arg.AuctionTitle,
		arg.AuctionDescription,
		arg.AuctionCategory,
		arg.SelectType,
		arg.PropertyName,
		arg.PropertyCategory,
		arg.PropertyUsage,
		arg.PropertiesUnitesID,
		arg.PlotNo,
		arg.SectorNo,
		arg.HasTenants,
		arg.Lat,
		arg.Lng,
		arg.PrebidStartDate,
		arg.StartDate,
		arg.EndDate,
		arg.MinBidAmount,
		arg.MinIncrementAmount,
		arg.AuctionUrl,
		arg.AuctionType,
		arg.Description,
		arg.DescriptionAr,
		arg.AddressesID,
		arg.LocationUrl,
		arg.OwnershipID,
		arg.AuctionStatus,
		arg.TagsID,
	)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.AuctionTitle,
		&i.AuctionDescription,
		&i.AuctionCategory,
		&i.CompaniesID,
		&i.MobileNumber,
		&i.EmailAddress,
		&i.Whatsapp,
		&i.SelectType,
		&i.PropertyName,
		&i.PropertyCategory,
		&i.PropertyUsage,
		&i.PropertiesUnitesID,
		&i.PlotNo,
		&i.SectorNo,
		&i.HasTenants,
		&i.Lat,
		&i.Lng,
		&i.PrebidStartDate,
		&i.StartDate,
		&i.EndDate,
		&i.MinBidAmount,
		&i.MinIncrementAmount,
		&i.WinningBidAmount,
		&i.AuctionUrl,
		&i.AuctionType,
		&i.Description,
		&i.DescriptionAr,
		&i.AddressesID,
		&i.LocationUrl,
		&i.OwnershipID,
		&i.AuctionStatus,
		&i.TagsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateAuctionMediaUrls = `-- name: UpdateAuctionMediaUrls :one
UPDATE auctions_media
SET media_url = $2,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, auction_id, gallery_type, media_type, media_url, created_at, updated_at, deleted_at
`

type UpdateAuctionMediaUrlsParams struct {
	ID       int64    `json:"id"`
	MediaUrl []string `json:"media_url"`
}

func (q *Queries) UpdateAuctionMediaUrls(ctx context.Context, arg UpdateAuctionMediaUrlsParams) (AuctionsMedium, error) {
	row := q.db.QueryRow(ctx, updateAuctionMediaUrls, arg.ID, arg.MediaUrl)
	var i AuctionsMedium
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.GalleryType,
		&i.MediaType,
		&i.MediaUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateAuctionPartner = `-- name: UpdateAuctionPartner :one
UPDATE auctions_partners
SET partner_logo = $2,
    partner_name = $3,
    website = $4,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, ref_no, auction_id, partner_name, partner_logo, website, created_at, updated_at, deleted_at
`

type UpdateAuctionPartnerParams struct {
	ID          int64       `json:"id"`
	PartnerLogo string      `json:"partner_logo"`
	PartnerName string      `json:"partner_name"`
	Website     pgtype.Text `json:"website"`
}

func (q *Queries) UpdateAuctionPartner(ctx context.Context, arg UpdateAuctionPartnerParams) (AuctionsPartner, error) {
	row := q.db.QueryRow(ctx, updateAuctionPartner,
		arg.ID,
		arg.PartnerLogo,
		arg.PartnerName,
		arg.Website,
	)
	var i AuctionsPartner
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.AuctionID,
		&i.PartnerName,
		&i.PartnerLogo,
		&i.Website,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateAuctionsAddress = `-- name: UpdateAuctionsAddress :one
 UPDATE auctions_addresses
SET
    country = $1,
    state = $2,
    city = $3,
    community = $4,
    sub_community = $5,
    location_url = $6,
    lat = $7,
    lng = $8,
    updated_at = NOW()  -- Assuming you want to track the update timestamp
WHERE id = $9  -- Use the actual address ID
RETURNING id, country, state, city, community, sub_community, location_url, lat, lng, created_at, updated_at, deleted_at
`

type UpdateAuctionsAddressParams struct {
	Country      int64         `json:"country"`
	State        int64         `json:"state"`
	City         int64         `json:"city"`
	Community    pgtype.Int8   `json:"community"`
	SubCommunity pgtype.Int8   `json:"sub_community"`
	LocationUrl  pgtype.Text   `json:"location_url"`
	Lat          pgtype.Float8 `json:"lat"`
	Lng          pgtype.Float8 `json:"lng"`
	ID           int64         `json:"id"`
}

func (q *Queries) UpdateAuctionsAddress(ctx context.Context, arg UpdateAuctionsAddressParams) (AuctionsAddress, error) {
	row := q.db.QueryRow(ctx, updateAuctionsAddress,
		arg.Country,
		arg.State,
		arg.City,
		arg.Community,
		arg.SubCommunity,
		arg.LocationUrl,
		arg.Lat,
		arg.Lng,
		arg.ID,
	)
	var i AuctionsAddress
	err := row.Scan(
		&i.ID,
		&i.Country,
		&i.State,
		&i.City,
		&i.Community,
		&i.SubCommunity,
		&i.LocationUrl,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateAuctionsUnitFacts = `-- name: UpdateAuctionsUnitFacts :one
UPDATE auctions_unit_facts
SET
    bathroom = $2,
    plot_area = $3,
    built_up_area = $4,
    view = $5,
    furnished = $6,
    ownership = $7,
    completion_status = $8,
    start_date = $9,
    completion_date = $10,
    handover_date = $11,
    no_of_floor = $12,
    no_of_units = $13,
    min_area = $14,
    max_area = $15,
    service_charge = $16,
    parking = $17,
    ask_price = $18,
    price = $19,
    rent_type = $20,
    no_of_payment = $21,
    no_of_retail = $22,
    no_of_pool = $23,
    elevator = $24,
    starting_price = $25,
    life_style = $26,
    bedroom = $27,
    category = $28,
    is_branch = $29,
    commercial_tax = $30,
    municipality_tax = $31,
    sc_currency_id = $32,
    unit_of_measure = $33,
    updated_at = NOW()
WHERE id = $1
RETURNING id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, unit_id, category, is_branch, commercial_tax, municipality_tax, sc_currency_id, unit_of_measure, created_at, updated_at
`

type UpdateAuctionsUnitFactsParams struct {
	ID               int64              `json:"id"`
	Bathroom         pgtype.Int8        `json:"bathroom"`
	PlotArea         pgtype.Float8      `json:"plot_area"`
	BuiltUpArea      pgtype.Float8      `json:"built_up_area"`
	View             []int64            `json:"view"`
	Furnished        pgtype.Int8        `json:"furnished"`
	Ownership        pgtype.Int8        `json:"ownership"`
	CompletionStatus pgtype.Int8        `json:"completion_status"`
	StartDate        pgtype.Timestamptz `json:"start_date"`
	CompletionDate   pgtype.Timestamptz `json:"completion_date"`
	HandoverDate     pgtype.Timestamptz `json:"handover_date"`
	NoOfFloor        pgtype.Int8        `json:"no_of_floor"`
	NoOfUnits        pgtype.Int8        `json:"no_of_units"`
	MinArea          pgtype.Float8      `json:"min_area"`
	MaxArea          pgtype.Float8      `json:"max_area"`
	ServiceCharge    pgtype.Int8        `json:"service_charge"`
	Parking          pgtype.Int8        `json:"parking"`
	AskPrice         pgtype.Bool        `json:"ask_price"`
	Price            pgtype.Float8      `json:"price"`
	RentType         pgtype.Int8        `json:"rent_type"`
	NoOfPayment      pgtype.Int8        `json:"no_of_payment"`
	NoOfRetail       pgtype.Int8        `json:"no_of_retail"`
	NoOfPool         pgtype.Int8        `json:"no_of_pool"`
	Elevator         pgtype.Int8        `json:"elevator"`
	StartingPrice    pgtype.Int8        `json:"starting_price"`
	LifeStyle        pgtype.Int8        `json:"life_style"`
	Bedroom          pgtype.Text        `json:"bedroom"`
	Category         string             `json:"category"`
	IsBranch         pgtype.Bool        `json:"is_branch"`
	CommercialTax    pgtype.Float8      `json:"commercial_tax"`
	MunicipalityTax  pgtype.Float8      `json:"municipality_tax"`
	ScCurrencyID     pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure    pgtype.Text        `json:"unit_of_measure"`
}

func (q *Queries) UpdateAuctionsUnitFacts(ctx context.Context, arg UpdateAuctionsUnitFactsParams) (AuctionsUnitFact, error) {
	row := q.db.QueryRow(ctx, updateAuctionsUnitFacts,
		arg.ID,
		arg.Bathroom,
		arg.PlotArea,
		arg.BuiltUpArea,
		arg.View,
		arg.Furnished,
		arg.Ownership,
		arg.CompletionStatus,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.NoOfFloor,
		arg.NoOfUnits,
		arg.MinArea,
		arg.MaxArea,
		arg.ServiceCharge,
		arg.Parking,
		arg.AskPrice,
		arg.Price,
		arg.RentType,
		arg.NoOfPayment,
		arg.NoOfRetail,
		arg.NoOfPool,
		arg.Elevator,
		arg.StartingPrice,
		arg.LifeStyle,
		arg.Bedroom,
		arg.Category,
		arg.IsBranch,
		arg.CommercialTax,
		arg.MunicipalityTax,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
	)
	var i AuctionsUnitFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.UnitID,
		&i.Category,
		&i.IsBranch,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAuctionsUnits = `-- name: UpdateAuctionsUnits :one
UPDATE auctions_units
SET
    unit_no = $2,
    unitno_is_public = $3,
    notes = $4,
    notes_arabic = $5,
    notes_public = $6,
    is_verified = $7,
    amenities_id = $8,
    property_unit_rank = $9,
    properties_id = $10,
    property = $11,
    addresses_id = $12,
    countries_id = $13,
    property_types_id = $14,
    created_by = $15,
    property_name = $16,
    section = $17,
    type_name_id = $18,
    owner_users_id = $19,
    updated_at = NOW()
WHERE id = $1
RETURNING id, unit_no, unitno_is_public, notes, notes_arabic, notes_public, is_verified, amenities_id, property_unit_rank, properties_id, property, created_at, updated_at, ref_no, addresses_id, countries_id, property_types_id, created_by, property_name, section, type_name_id, owner_users_id
`

type UpdateAuctionsUnitsParams struct {
	ID               int64       `json:"id"`
	UnitNo           pgtype.Text `json:"unit_no"`
	UnitnoIsPublic   pgtype.Bool `json:"unitno_is_public"`
	Notes            pgtype.Text `json:"notes"`
	NotesArabic      pgtype.Text `json:"notes_arabic"`
	NotesPublic      pgtype.Bool `json:"notes_public"`
	IsVerified       pgtype.Bool `json:"is_verified"`
	AmenitiesID      []int64     `json:"amenities_id"`
	PropertyUnitRank pgtype.Int8 `json:"property_unit_rank"`
	PropertiesID     pgtype.Int8 `json:"properties_id"`
	Property         pgtype.Int8 `json:"property"`
	AddressesID      int64       `json:"addresses_id"`
	CountriesID      int64       `json:"countries_id"`
	PropertyTypesID  int64       `json:"property_types_id"`
	CreatedBy        pgtype.Int8 `json:"created_by"`
	PropertyName     string      `json:"property_name"`
	Section          string      `json:"section"`
	TypeNameID       pgtype.Int8 `json:"type_name_id"`
	OwnerUsersID     pgtype.Int8 `json:"owner_users_id"`
}

func (q *Queries) UpdateAuctionsUnits(ctx context.Context, arg UpdateAuctionsUnitsParams) (AuctionsUnit, error) {
	row := q.db.QueryRow(ctx, updateAuctionsUnits,
		arg.ID,
		arg.UnitNo,
		arg.UnitnoIsPublic,
		arg.Notes,
		arg.NotesArabic,
		arg.NotesPublic,
		arg.IsVerified,
		arg.AmenitiesID,
		arg.PropertyUnitRank,
		arg.PropertiesID,
		arg.Property,
		arg.AddressesID,
		arg.CountriesID,
		arg.PropertyTypesID,
		arg.CreatedBy,
		arg.PropertyName,
		arg.Section,
		arg.TypeNameID,
		arg.OwnerUsersID,
	)
	var i AuctionsUnit
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.AmenitiesID,
		&i.PropertyUnitRank,
		&i.PropertiesID,
		&i.Property,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.AddressesID,
		&i.CountriesID,
		&i.PropertyTypesID,
		&i.CreatedBy,
		&i.PropertyName,
		&i.Section,
		&i.TypeNameID,
		&i.OwnerUsersID,
	)
	return i, err
}

const updateDocumentUrls = `-- name: UpdateDocumentUrls :one
UPDATE auctions_documents
SET document_url = $2,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, auction_id, document_type, document_url, created_at, updated_at, deleted_at
`

type UpdateDocumentUrlsParams struct {
	ID          int64    `json:"id"`
	DocumentUrl []string `json:"document_url"`
}

func (q *Queries) UpdateDocumentUrls(ctx context.Context, arg UpdateDocumentUrlsParams) (AuctionsDocument, error) {
	row := q.db.QueryRow(ctx, updateDocumentUrls, arg.ID, arg.DocumentUrl)
	var i AuctionsDocument
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateFAQ = `-- name: UpdateFAQ :one
UPDATE auctions_faqs
SET question = $3,
    answer = $2,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, ref_no, question, answer, created_at, updated_at, deleted_at
`

type UpdateFAQParams struct {
	ID       int64       `json:"id"`
	Answer   pgtype.Text `json:"answer"`
	Question pgtype.Text `json:"question"`
}

func (q *Queries) UpdateFAQ(ctx context.Context, arg UpdateFAQParams) (AuctionsFaq, error) {
	row := q.db.QueryRow(ctx, updateFAQ, arg.ID, arg.Answer, arg.Question)
	var i AuctionsFaq
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Question,
		&i.Answer,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePlanUrls = `-- name: UpdatePlanUrls :one
UPDATE auctions_plans
SET plan_url = $2,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, auction_id, plan_title, plan_url, created_at, updated_at, deleted_at
`

type UpdatePlanUrlsParams struct {
	ID      int64    `json:"id"`
	PlanUrl []string `json:"plan_url"`
}

func (q *Queries) UpdatePlanUrls(ctx context.Context, arg UpdatePlanUrlsParams) (AuctionsPlan, error) {
	row := q.db.QueryRow(ctx, updatePlanUrls, arg.ID, arg.PlanUrl)
	var i AuctionsPlan
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.PlanTitle,
		&i.PlanUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePropertiesFacts = `-- name: UpdatePropertiesFacts :one
UPDATE auctions_properties_facts
SET
    plot_area = $2,
    built_up_area = $3,
    view = $4,
    furnished = $5,
    ownership = $6,
    completion_status = $7,
    start_date = $8,
    completion_date = $9,
    handover_date = $10,
    no_of_floor = $11,
    no_of_units = $12,
    min_area = $13,
    max_area = $14,
    service_charge = $15,
    parking = $16,
    ask_price = $17,
    price = $18,
    rent_type = $19,
    no_of_payment = $20,
    no_of_retail = $21,
    no_of_pool = $22,
    elevator = $23,
    starting_price = $24,
    life_style = $25,
    property = $26,
    is_branch = $27,
    available_units = $28,
    commercial_tax = $29,
    municipality_tax = $30,
    is_project_fact = $31,
    project_id = $32,
    completion_percentage = $33,
    completion_percentage_date = $34,
    type_name_id = $35,
    sc_currency_id = $36,
    unit_of_measure = $37,
    bedroom = $38,
    updated_at = NOW()
WHERE id = $1
RETURNING id, bedroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure, created_at, updated_at
`

type UpdatePropertiesFactsParams struct {
	ID                       int64              `json:"id"`
	PlotArea                 pgtype.Float8      `json:"plot_area"`
	BuiltUpArea              pgtype.Float8      `json:"built_up_area"`
	View                     []int64            `json:"view"`
	Furnished                pgtype.Int8        `json:"furnished"`
	Ownership                pgtype.Int8        `json:"ownership"`
	CompletionStatus         pgtype.Int8        `json:"completion_status"`
	StartDate                pgtype.Timestamptz `json:"start_date"`
	CompletionDate           pgtype.Timestamptz `json:"completion_date"`
	HandoverDate             pgtype.Timestamptz `json:"handover_date"`
	NoOfFloor                pgtype.Int8        `json:"no_of_floor"`
	NoOfUnits                pgtype.Int8        `json:"no_of_units"`
	MinArea                  pgtype.Float8      `json:"min_area"`
	MaxArea                  pgtype.Float8      `json:"max_area"`
	ServiceCharge            pgtype.Int8        `json:"service_charge"`
	Parking                  pgtype.Int8        `json:"parking"`
	AskPrice                 pgtype.Bool        `json:"ask_price"`
	Price                    pgtype.Float8      `json:"price"`
	RentType                 pgtype.Int8        `json:"rent_type"`
	NoOfPayment              pgtype.Int8        `json:"no_of_payment"`
	NoOfRetail               pgtype.Int8        `json:"no_of_retail"`
	NoOfPool                 pgtype.Int8        `json:"no_of_pool"`
	Elevator                 pgtype.Int8        `json:"elevator"`
	StartingPrice            pgtype.Int8        `json:"starting_price"`
	LifeStyle                pgtype.Int8        `json:"life_style"`
	Property                 int64              `json:"property"`
	IsBranch                 pgtype.Bool        `json:"is_branch"`
	AvailableUnits           pgtype.Int8        `json:"available_units"`
	CommercialTax            pgtype.Float8      `json:"commercial_tax"`
	MunicipalityTax          pgtype.Float8      `json:"municipality_tax"`
	IsProjectFact            pgtype.Bool        `json:"is_project_fact"`
	ProjectID                pgtype.Int8        `json:"project_id"`
	CompletionPercentage     pgtype.Int8        `json:"completion_percentage"`
	CompletionPercentageDate pgtype.Timestamptz `json:"completion_percentage_date"`
	TypeNameID               pgtype.Int8        `json:"type_name_id"`
	ScCurrencyID             pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure            pgtype.Text        `json:"unit_of_measure"`
	Bedroom                  pgtype.Text        `json:"bedroom"`
}

func (q *Queries) UpdatePropertiesFacts(ctx context.Context, arg UpdatePropertiesFactsParams) (AuctionsPropertiesFact, error) {
	row := q.db.QueryRow(ctx, updatePropertiesFacts,
		arg.ID,
		arg.PlotArea,
		arg.BuiltUpArea,
		arg.View,
		arg.Furnished,
		arg.Ownership,
		arg.CompletionStatus,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.NoOfFloor,
		arg.NoOfUnits,
		arg.MinArea,
		arg.MaxArea,
		arg.ServiceCharge,
		arg.Parking,
		arg.AskPrice,
		arg.Price,
		arg.RentType,
		arg.NoOfPayment,
		arg.NoOfRetail,
		arg.NoOfPool,
		arg.Elevator,
		arg.StartingPrice,
		arg.LifeStyle,
		arg.Property,
		arg.IsBranch,
		arg.AvailableUnits,
		arg.CommercialTax,
		arg.MunicipalityTax,
		arg.IsProjectFact,
		arg.ProjectID,
		arg.CompletionPercentage,
		arg.CompletionPercentageDate,
		arg.TypeNameID,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
		arg.Bedroom,
	)
	var i AuctionsPropertiesFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.PropertiesID,
		&i.Property,
		&i.IsBranch,
		&i.AvailableUnits,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.IsProjectFact,
		&i.ProjectID,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.TypeNameID,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProperty = `-- name: UpdateProperty :one
UPDATE auctions_properties
SET
    companies_id = $2,
    property_title = $3,
    property_title_arabic = $4,
    description = $5,
    description_arabic = $6,
    is_verified = $7,
    property_rank = $8,
    addresses_id = $9,
    property_types_id = $10,
    status = $11,
    facilities_id = $12,
    amenities_id = $13,
    is_show_owner_info = $14,
    property = $15,
    category = $16,
    investment = $17,
    contract_start_datetime = $18,
    contract_end_datetime = $19,
    amount = $20,
    unit_types = $21,
    property_name = $22,
    from_xml = $23,
    list_of_date = $24,
    list_of_notes = $25,
    list_of_agent = $26,
    owner_users_id = $27,
    updated_at = NOW()
WHERE id = $1
RETURNING id, companies_id, property_title, property_title_arabic, description, description_arabic, is_verified, property_rank, addresses_id, property_types_id, status, created_at, updated_at, facilities_id, amenities_id, is_show_owner_info, property, ref_no, category, investment, contract_start_datetime, contract_end_datetime, amount, unit_types, property_name, from_xml, list_of_date, list_of_notes, list_of_agent, owner_users_id
`

type UpdatePropertyParams struct {
	ID                    int64              `json:"id"`
	CompaniesID           int64              `json:"companies_id"`
	PropertyTitle         string             `json:"property_title"`
	PropertyTitleArabic   string             `json:"property_title_arabic"`
	Description           string             `json:"description"`
	DescriptionArabic     string             `json:"description_arabic"`
	IsVerified            pgtype.Bool        `json:"is_verified"`
	PropertyRank          pgtype.Int8        `json:"property_rank"`
	AddressesID           int64              `json:"addresses_id"`
	PropertyTypesID       int64              `json:"property_types_id"`
	Status                pgtype.Int8        `json:"status"`
	FacilitiesID          []int64            `json:"facilities_id"`
	AmenitiesID           []int64            `json:"amenities_id"`
	IsShowOwnerInfo       pgtype.Bool        `json:"is_show_owner_info"`
	Property              pgtype.Int8        `json:"property"`
	Category              int64              `json:"category"`
	Investment            pgtype.Bool        `json:"investment"`
	ContractStartDatetime pgtype.Timestamptz `json:"contract_start_datetime"`
	ContractEndDatetime   pgtype.Timestamptz `json:"contract_end_datetime"`
	Amount                pgtype.Float8      `json:"amount"`
	UnitTypes             []int64            `json:"unit_types"`
	PropertyName          string             `json:"property_name"`
	FromXml               pgtype.Bool        `json:"from_xml"`
	ListOfDate            []time.Time        `json:"list_of_date"`
	ListOfNotes           []string           `json:"list_of_notes"`
	ListOfAgent           []int64            `json:"list_of_agent"`
	OwnerUsersID          pgtype.Int8        `json:"owner_users_id"`
}

func (q *Queries) UpdateProperty(ctx context.Context, arg UpdatePropertyParams) (AuctionsProperty, error) {
	row := q.db.QueryRow(ctx, updateProperty,
		arg.ID,
		arg.CompaniesID,
		arg.PropertyTitle,
		arg.PropertyTitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.IsVerified,
		arg.PropertyRank,
		arg.AddressesID,
		arg.PropertyTypesID,
		arg.Status,
		arg.FacilitiesID,
		arg.AmenitiesID,
		arg.IsShowOwnerInfo,
		arg.Property,
		arg.Category,
		arg.Investment,
		arg.ContractStartDatetime,
		arg.ContractEndDatetime,
		arg.Amount,
		arg.UnitTypes,
		arg.PropertyName,
		arg.FromXml,
		arg.ListOfDate,
		arg.ListOfNotes,
		arg.ListOfAgent,
		arg.OwnerUsersID,
	)
	var i AuctionsProperty
	err := row.Scan(
		&i.ID,
		&i.CompaniesID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.IsVerified,
		&i.PropertyRank,
		&i.AddressesID,
		&i.PropertyTypesID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FacilitiesID,
		&i.AmenitiesID,
		&i.IsShowOwnerInfo,
		&i.Property,
		&i.RefNo,
		&i.Category,
		&i.Investment,
		&i.ContractStartDatetime,
		&i.ContractEndDatetime,
		&i.Amount,
		&i.UnitTypes,
		&i.PropertyName,
		&i.FromXml,
		&i.ListOfDate,
		&i.ListOfNotes,
		&i.ListOfAgent,
		&i.OwnerUsersID,
	)
	return i, err
}
