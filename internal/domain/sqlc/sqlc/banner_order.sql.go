// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: banner_order.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBannerOrder = `-- name: CreateBannerOrder :one
INSERT INTO
    banner_order (
        ref_no,
        company_id,
        plan_packages,
        total_price,
        start_date,
        end_date,
        created_by,
        created_at,
        updated_at, 
        status, 
        company_type, 
        country_id, 
        note
    )
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)RETURNING 1
`

type CreateBannerOrderParams struct {
	RefNo        string      `json:"ref_no"`
	CompanyID    int64       `json:"company_id"`
	PlanPackages []byte      `json:"plan_packages"`
	TotalPrice   float64     `json:"total_price"`
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	CreatedBy    int64       `json:"created_by"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Status       int64       `json:"status"`
	CompanyType  int64       `json:"company_type"`
	CountryID    int64       `json:"country_id"`
	Note         pgtype.Text `json:"note"`
}

func (q *Queries) CreateBannerOrder(ctx context.Context, arg CreateBannerOrderParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, createBannerOrder,
		arg.RefNo,
		arg.CompanyID,
		arg.PlanPackages,
		arg.TotalPrice,
		arg.StartDate,
		arg.EndDate,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.CompanyType,
		arg.CountryID,
		arg.Note,
	)
	var column_1 pgtype.Int8
	err := row.Scan(&column_1)
	return column_1, err
}

const getAllBannerOrder = `-- name: GetAllBannerOrder :many


SELECT
    banner_order.id,
    banner_order.ref_no,
    banner_order.country_id,
    banner_order.company_id,
    banner_order.plan_packages,
    banner_order.total_price,
    banner_order.start_date,
    banner_order.end_date,
    banner_order.created_by,
    banner_order.created_at,
    banner_order.updated_at,
    banner_order.status,
    companies.company_name,
    companies.company_type, 
    countries.country
FROM
    banner_order
    LEFT JOIN companies ON companies.id = banner_order.company_id
    LEFT JOIN countries ON countries.id=banner_order.country_id
WHERE
    banner_order.status = ANY($3::BIGINT[])
ORDER BY banner_order.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllBannerOrderParams struct {
	Limit        int32   `json:"limit"`
	Offset       int32   `json:"offset"`
	ActiveStatus []int64 `json:"active_status"`
}

type GetAllBannerOrderRow struct {
	ID           int64       `json:"id"`
	RefNo        string      `json:"ref_no"`
	CountryID    int64       `json:"country_id"`
	CompanyID    int64       `json:"company_id"`
	PlanPackages []byte      `json:"plan_packages"`
	TotalPrice   float64     `json:"total_price"`
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	CreatedBy    int64       `json:"created_by"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Status       int64       `json:"status"`
	CompanyName  pgtype.Text `json:"company_name"`
	CompanyType  pgtype.Int8 `json:"company_type"`
	Country      pgtype.Text `json:"country"`
}

// AND banner_order.status = @active_status::BIGINT;
func (q *Queries) GetAllBannerOrder(ctx context.Context, arg GetAllBannerOrderParams) ([]GetAllBannerOrderRow, error) {
	rows, err := q.db.Query(ctx, getAllBannerOrder, arg.Limit, arg.Offset, arg.ActiveStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBannerOrderRow
	for rows.Next() {
		var i GetAllBannerOrderRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CountryID,
			&i.CompanyID,
			&i.PlanPackages,
			&i.TotalPrice,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.CompanyName,
			&i.CompanyType,
			&i.Country,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannerOrderByID = `-- name: GetBannerOrderByID :one
SELECT
    banner_order.id,
    banner_order.ref_no,
    banner_order.company_id,
    banner_order.country_id,
    banner_order.plan_packages,
    banner_order.total_price,
    banner_order.start_date,
    banner_order.end_date,
    banner_order.created_by,
    banner_order.created_at,
    banner_order.updated_at, 
    banner_order.status,
    banner_order.note,
    companies.company_name, 
    companies.company_type, 
    countries.country
FROM
    banner_order
INNER JOIN companies ON companies.id=banner_order.company_id
INNER JOIN countries ON countries.id=banner_order.country_id
WHERE
    banner_order.id = $1::BIGINT
`

type GetBannerOrderByIDRow struct {
	ID           int64       `json:"id"`
	RefNo        string      `json:"ref_no"`
	CompanyID    int64       `json:"company_id"`
	CountryID    int64       `json:"country_id"`
	PlanPackages []byte      `json:"plan_packages"`
	TotalPrice   float64     `json:"total_price"`
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	CreatedBy    int64       `json:"created_by"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Status       int64       `json:"status"`
	Note         pgtype.Text `json:"note"`
	CompanyName  string      `json:"company_name"`
	CompanyType  int64       `json:"company_type"`
	Country      string      `json:"country"`
}

func (q *Queries) GetBannerOrderByID(ctx context.Context, dollar_1 int64) (GetBannerOrderByIDRow, error) {
	row := q.db.QueryRow(ctx, getBannerOrderByID, dollar_1)
	var i GetBannerOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyID,
		&i.CountryID,
		&i.PlanPackages,
		&i.TotalPrice,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Note,
		&i.CompanyName,
		&i.CompanyType,
		&i.Country,
	)
	return i, err
}

const getBannerOrderDetailsForUpdate = `-- name: GetBannerOrderDetailsForUpdate :one
SELECt company_id,company_type,country_id,plan_packages,note,start_date,end_date,total_price
FROM 
	banner_order
WHERE 
	id=$1 AND status= $2::BIGINT
`

type GetBannerOrderDetailsForUpdateParams struct {
	ID           int64 `json:"id"`
	UnpaidStatus int64 `json:"unpaid_status"`
}

type GetBannerOrderDetailsForUpdateRow struct {
	CompanyID    int64       `json:"company_id"`
	CompanyType  int64       `json:"company_type"`
	CountryID    int64       `json:"country_id"`
	PlanPackages []byte      `json:"plan_packages"`
	Note         pgtype.Text `json:"note"`
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	TotalPrice   float64     `json:"total_price"`
}

func (q *Queries) GetBannerOrderDetailsForUpdate(ctx context.Context, arg GetBannerOrderDetailsForUpdateParams) (GetBannerOrderDetailsForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getBannerOrderDetailsForUpdate, arg.ID, arg.UnpaidStatus)
	var i GetBannerOrderDetailsForUpdateRow
	err := row.Scan(
		&i.CompanyID,
		&i.CompanyType,
		&i.CountryID,
		&i.PlanPackages,
		&i.Note,
		&i.StartDate,
		&i.EndDate,
		&i.TotalPrice,
	)
	return i, err
}

const getBannerPlanPackagesByFilters = `-- name: GetBannerPlanPackagesByFilters :many
SELECT
    banner_plan_package.id,
    banner_plan_package.plan_type,
    banner_plan_cost.id AS "banner_plan_cost_id",
    banner_plan_package.plan_package_name,
    banner_plan_cost.price, 
    banner_plan_cost.platform, 
    banner_plan_package.quantity, 
    banner_plan_package.counts_per_banner
FROM
    banner_plan_cost
    INNER JOIN banner_plan_package ON banner_plan_package.id = banner_plan_cost.plan_package_id
    AND banner_plan_cost.status = $1::BIGINT
    AND banner_plan_package.status = $1::BIGINT
    AND banner_plan_cost.country_id = $2::BIGINT
    AND banner_plan_cost.company_type = (SELECT companies.company_type FROM companies WHERE companies.id= $3::BIGINT AND companies.status!=6)
    AND ($4::BIGINT IS NULL OR  banner_plan_cost.platform = $4::BIGINT)
    AND (CASE WHEN  ARRAY_LENGTH($5::BIGINT [],1) IS NULL THEN TRUE ELSE banner_plan_cost.plan_package_id= ANY($5::BIGINT []) END)
`

type GetBannerPlanPackagesByFiltersParams struct {
	ActiveStatus   int64       `json:"active_status"`
	CountryID      int64       `json:"country_id"`
	CompanyID      int64       `json:"company_id"`
	Platform       pgtype.Int8 `json:"platform"`
	PlanPackageIds []int64     `json:"plan_package_ids"`
}

type GetBannerPlanPackagesByFiltersRow struct {
	ID               int64   `json:"id"`
	PlanType         int64   `json:"plan_type"`
	BannerPlanCostID int64   `json:"banner_plan_cost_id"`
	PlanPackageName  string  `json:"plan_package_name"`
	Price            float64 `json:"price"`
	Platform         int64   `json:"platform"`
	Quantity         int64   `json:"quantity"`
	CountsPerBanner  int64   `json:"counts_per_banner"`
}

func (q *Queries) GetBannerPlanPackagesByFilters(ctx context.Context, arg GetBannerPlanPackagesByFiltersParams) ([]GetBannerPlanPackagesByFiltersRow, error) {
	rows, err := q.db.Query(ctx, getBannerPlanPackagesByFilters,
		arg.ActiveStatus,
		arg.CountryID,
		arg.CompanyID,
		arg.Platform,
		arg.PlanPackageIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBannerPlanPackagesByFiltersRow
	for rows.Next() {
		var i GetBannerPlanPackagesByFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.PlanType,
			&i.BannerPlanCostID,
			&i.PlanPackageName,
			&i.Price,
			&i.Platform,
			&i.Quantity,
			&i.CountsPerBanner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannerPlanPkgByID = `-- name: GetBannerPlanPkgByID :one
SELECT bp.id, package_name, plan_type, plan_package_name, quantity, counts_per_banner, icon, description, bp.status, bp.created_at, bp.updated_at, bc.id, country_id, company_type, plan_package_id, platform, price, bc.status, bc.created_at, bc.updated_at from banner_plan_package bp
inner join banner_plan_cost bc on bc.plan_package_id = bp.id
where bp.id = $1
`

type GetBannerPlanPkgByIDRow struct {
	ID              int64       `json:"id"`
	PackageName     int64       `json:"package_name"`
	PlanType        int64       `json:"plan_type"`
	PlanPackageName string      `json:"plan_package_name"`
	Quantity        int64       `json:"quantity"`
	CountsPerBanner int64       `json:"counts_per_banner"`
	Icon            string      `json:"icon"`
	Description     pgtype.Text `json:"description"`
	Status          int64       `json:"status"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	ID_2            int64       `json:"id_2"`
	CountryID       int64       `json:"country_id"`
	CompanyType     int64       `json:"company_type"`
	PlanPackageID   int64       `json:"plan_package_id"`
	Platform        int64       `json:"platform"`
	Price           float64     `json:"price"`
	Status_2        int64       `json:"status_2"`
	CreatedAt_2     time.Time   `json:"created_at_2"`
	UpdatedAt_2     time.Time   `json:"updated_at_2"`
}

func (q *Queries) GetBannerPlanPkgByID(ctx context.Context, id int64) (GetBannerPlanPkgByIDRow, error) {
	row := q.db.QueryRow(ctx, getBannerPlanPkgByID, id)
	var i GetBannerPlanPkgByIDRow
	err := row.Scan(
		&i.ID,
		&i.PackageName,
		&i.PlanType,
		&i.PlanPackageName,
		&i.Quantity,
		&i.CountsPerBanner,
		&i.Icon,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.CountryID,
		&i.CompanyType,
		&i.PlanPackageID,
		&i.Platform,
		&i.Price,
		&i.Status_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getBannersDetail = `-- name: GetBannersDetail :one
SELECT b.id, b.company_id, banner_order_id, banner_name, b.status, target_url, plan_package_id, duration, banner_direction, banner_position, media_type, file_url, b.description, b.created_by, b.updated_by, b.created_at, b.updated_at, banner_cost_id, no_of_impressions, bo.id, bo.ref_no, bo.company_id, plan_packages, total_price, start_date, end_date, bo.created_by, bo.updated_by, bo.created_at, bo.updated_at, bo.status, bo.company_type, country_id, note, bp.id, package_name, plan_type, plan_package_name, quantity, counts_per_banner, icon, bp.description, bp.status, bp.created_at, bp.updated_at, companies.id, companies.ref_no, company_name, company_activities_id, company_parent_id, tag_line, companies.description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, companies.status, companies.company_type, addresses_id, users_id, companies.created_by, companies.created_at, companies.updated_at, companies.updated_by, location_url, vat_no, vat_status, vat_file_url from banners b
INNER JOIN banner_order bo on bo.id = b.banner_order_id
INNER JOIN banner_plan_package bp ON bp.id = b.plan_package_id
INNER JOIN companies ON companies.id=bo.company_id
where b.id = $1
`

type GetBannersDetailRow struct {
	ID                  int64       `json:"id"`
	CompanyID           int64       `json:"company_id"`
	BannerOrderID       int64       `json:"banner_order_id"`
	BannerName          string      `json:"banner_name"`
	Status              int64       `json:"status"`
	TargetUrl           string      `json:"target_url"`
	PlanPackageID       int64       `json:"plan_package_id"`
	Duration            int64       `json:"duration"`
	BannerDirection     int64       `json:"banner_direction"`
	BannerPosition      int64       `json:"banner_position"`
	MediaType           int64       `json:"media_type"`
	FileUrl             string      `json:"file_url"`
	Description         pgtype.Text `json:"description"`
	CreatedBy           int64       `json:"created_by"`
	UpdatedBy           pgtype.Int8 `json:"updated_by"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	BannerCostID        int64       `json:"banner_cost_id"`
	NoOfImpressions     pgtype.Int8 `json:"no_of_impressions"`
	ID_2                int64       `json:"id_2"`
	RefNo               string      `json:"ref_no"`
	CompanyID_2         int64       `json:"company_id_2"`
	PlanPackages        []byte      `json:"plan_packages"`
	TotalPrice          float64     `json:"total_price"`
	StartDate           time.Time   `json:"start_date"`
	EndDate             time.Time   `json:"end_date"`
	CreatedBy_2         int64       `json:"created_by_2"`
	UpdatedBy_2         pgtype.Int8 `json:"updated_by_2"`
	CreatedAt_2         time.Time   `json:"created_at_2"`
	UpdatedAt_2         time.Time   `json:"updated_at_2"`
	Status_2            int64       `json:"status_2"`
	CompanyType         int64       `json:"company_type"`
	CountryID           int64       `json:"country_id"`
	Note                pgtype.Text `json:"note"`
	ID_3                int64       `json:"id_3"`
	PackageName         int64       `json:"package_name"`
	PlanType            int64       `json:"plan_type"`
	PlanPackageName     string      `json:"plan_package_name"`
	Quantity            int64       `json:"quantity"`
	CountsPerBanner     int64       `json:"counts_per_banner"`
	Icon                string      `json:"icon"`
	Description_2       pgtype.Text `json:"description_2"`
	Status_3            int64       `json:"status_3"`
	CreatedAt_3         time.Time   `json:"created_at_3"`
	UpdatedAt_3         time.Time   `json:"updated_at_3"`
	ID_4                int64       `json:"id_4"`
	RefNo_2             string      `json:"ref_no_2"`
	CompanyName         string      `json:"company_name"`
	CompanyActivitiesID []int64     `json:"company_activities_id"`
	CompanyParentID     pgtype.Int8 `json:"company_parent_id"`
	TagLine             pgtype.Text `json:"tag_line"`
	Description_3       string      `json:"description_3"`
	DescriptionAr       pgtype.Text `json:"description_ar"`
	LogoUrl             string      `json:"logo_url"`
	Email               string      `json:"email"`
	PhoneNumber         string      `json:"phone_number"`
	WhatsappNumber      pgtype.Text `json:"whatsapp_number"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	WebsiteUrl          pgtype.Text `json:"website_url"`
	CoverImageUrl       string      `json:"cover_image_url"`
	NoOfEmployees       pgtype.Int8 `json:"no_of_employees"`
	CompanyRank         int64       `json:"company_rank"`
	Status_4            int64       `json:"status_4"`
	CompanyType_2       int64       `json:"company_type_2"`
	AddressesID         int64       `json:"addresses_id"`
	UsersID             int64       `json:"users_id"`
	CreatedBy_3         int64       `json:"created_by_3"`
	CreatedAt_4         time.Time   `json:"created_at_4"`
	UpdatedAt_4         time.Time   `json:"updated_at_4"`
	UpdatedBy_3         pgtype.Int8 `json:"updated_by_3"`
	LocationUrl         pgtype.Text `json:"location_url"`
	VatNo               pgtype.Text `json:"vat_no"`
	VatStatus           pgtype.Int8 `json:"vat_status"`
	VatFileUrl          pgtype.Text `json:"vat_file_url"`
}

func (q *Queries) GetBannersDetail(ctx context.Context, id int64) (GetBannersDetailRow, error) {
	row := q.db.QueryRow(ctx, getBannersDetail, id)
	var i GetBannersDetailRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.BannerOrderID,
		&i.BannerName,
		&i.Status,
		&i.TargetUrl,
		&i.PlanPackageID,
		&i.Duration,
		&i.BannerDirection,
		&i.BannerPosition,
		&i.MediaType,
		&i.FileUrl,
		&i.Description,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BannerCostID,
		&i.NoOfImpressions,
		&i.ID_2,
		&i.RefNo,
		&i.CompanyID_2,
		&i.PlanPackages,
		&i.TotalPrice,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy_2,
		&i.UpdatedBy_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.Status_2,
		&i.CompanyType,
		&i.CountryID,
		&i.Note,
		&i.ID_3,
		&i.PackageName,
		&i.PlanType,
		&i.PlanPackageName,
		&i.Quantity,
		&i.CountsPerBanner,
		&i.Icon,
		&i.Description_2,
		&i.Status_3,
		&i.CreatedAt_3,
		&i.UpdatedAt_3,
		&i.ID_4,
		&i.RefNo_2,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description_3,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status_4,
		&i.CompanyType_2,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy_3,
		&i.CreatedAt_4,
		&i.UpdatedAt_4,
		&i.UpdatedBy_3,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const getBannersOrderPlanPkgs = `-- name: GetBannersOrderPlanPkgs :many
SELECT bp.id, bp.package_name, bp.plan_type, bp.plan_package_name, bp.quantity, bp.counts_per_banner, bp.icon, bp.description, bp.status, bp.created_at, bp.updated_at, bo.id as banner_order_id, bo.plan_packages
FROM banner_order bo
JOIN LATERAL jsonb_array_elements(bo.plan_packages) AS plan_package ON true
JOIN banner_plan_package bp ON bp.id = (plan_package->>'plan_package_id')::INTEGER
JOIN banner_plan_cost bc ON bc.id = (plan_package->>'plan_package_cost_id')::INTEGER
JOIN companies ON companies.id = bo.company_id
WHERE bo.id = $1
`

type GetBannersOrderPlanPkgsRow struct {
	ID              int64       `json:"id"`
	PackageName     int64       `json:"package_name"`
	PlanType        int64       `json:"plan_type"`
	PlanPackageName string      `json:"plan_package_name"`
	Quantity        int64       `json:"quantity"`
	CountsPerBanner int64       `json:"counts_per_banner"`
	Icon            string      `json:"icon"`
	Description     pgtype.Text `json:"description"`
	Status          int64       `json:"status"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	BannerOrderID   int64       `json:"banner_order_id"`
	PlanPackages    []byte      `json:"plan_packages"`
}

func (q *Queries) GetBannersOrderPlanPkgs(ctx context.Context, id int64) ([]GetBannersOrderPlanPkgsRow, error) {
	rows, err := q.db.Query(ctx, getBannersOrderPlanPkgs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBannersOrderPlanPkgsRow
	for rows.Next() {
		var i GetBannersOrderPlanPkgsRow
		if err := rows.Scan(
			&i.ID,
			&i.PackageName,
			&i.PlanType,
			&i.PlanPackageName,
			&i.Quantity,
			&i.CountsPerBanner,
			&i.Icon,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BannerOrderID,
			&i.PlanPackages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompaniesById = `-- name: GetCompaniesById :one
SELECT id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url FROM companies
WHERE id = $1
`

func (q *Queries) GetCompaniesById(ctx context.Context, id int64) (Company, error) {
	row := q.db.QueryRow(ctx, getCompaniesById, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const getConsumedPlanPkgs = `-- name: GetConsumedPlanPkgs :many
SELECT DISTINCT bp.id, bp.package_name, bp.plan_type, bp.plan_package_name, bp.quantity, bp.counts_per_banner, bp.icon, bp.description, bp.status, bp.created_at, bp.updated_at, bo.id as banner_order_id, bo.plan_packages from banners b
INNER JOIN banner_order bo on bo.id = b.banner_order_id
INNER JOIN banner_plan_package bp on bp.id = b.plan_package_id
INNER JOIN banner_plan_cost bc ON bc.id = b.banner_cost_id
WHERE bo.id = $1 and b.status = $2
`

type GetConsumedPlanPkgsParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

type GetConsumedPlanPkgsRow struct {
	ID              int64       `json:"id"`
	PackageName     int64       `json:"package_name"`
	PlanType        int64       `json:"plan_type"`
	PlanPackageName string      `json:"plan_package_name"`
	Quantity        int64       `json:"quantity"`
	CountsPerBanner int64       `json:"counts_per_banner"`
	Icon            string      `json:"icon"`
	Description     pgtype.Text `json:"description"`
	Status          int64       `json:"status"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	BannerOrderID   int64       `json:"banner_order_id"`
	PlanPackages    []byte      `json:"plan_packages"`
}

func (q *Queries) GetConsumedPlanPkgs(ctx context.Context, arg GetConsumedPlanPkgsParams) ([]GetConsumedPlanPkgsRow, error) {
	rows, err := q.db.Query(ctx, getConsumedPlanPkgs, arg.ID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConsumedPlanPkgsRow
	for rows.Next() {
		var i GetConsumedPlanPkgsRow
		if err := rows.Scan(
			&i.ID,
			&i.PackageName,
			&i.PlanType,
			&i.PlanPackageName,
			&i.Quantity,
			&i.CountsPerBanner,
			&i.Icon,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BannerOrderID,
			&i.PlanPackages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllBannerOrder = `-- name: GetCountAllBannerOrder :one
SELECT COUNT(*) AS count
FROM
    banner_order
    INNER JOIN companies ON companies.id = banner_order.company_id
WHERE
    banner_order.status = ANY($1::BIGINT[])
`

func (q *Queries) GetCountAllBannerOrder(ctx context.Context, activeStatus []int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllBannerOrder, activeStatus)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountryById = `-- name: GetCountryById :one
SELECT id, country, flag, created_at, updated_at, alpha2_code, alpha3_code, country_code, lat, lng, name, numcode, default_settings, status, deleted_at, updated_by, country_ar FROM countries
WHERE id = $1
`

func (q *Queries) GetCountryById(ctx context.Context, id int64) (Country, error) {
	row := q.db.QueryRow(ctx, getCountryById, id)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Country,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Alpha2Code,
		&i.Alpha3Code,
		&i.CountryCode,
		&i.Lat,
		&i.Lng,
		&i.Name,
		&i.Numcode,
		&i.DefaultSettings,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CountryAr,
	)
	return i, err
}

const updateBannerOrder = `-- name: UpdateBannerOrder :one
UPDATE banner_order
SET 
	plan_packages=$2, 
	note=$3,
	total_price=$4,
	start_date=$5, 
	end_date=$6, 
	updated_by=$7, 
	updated_at=$8 
WHERE 
	id=$1
RETURNING id
`

type UpdateBannerOrderParams struct {
	ID           int64       `json:"id"`
	PlanPackages []byte      `json:"plan_packages"`
	Note         pgtype.Text `json:"note"`
	TotalPrice   float64     `json:"total_price"`
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	UpdatedBy    pgtype.Int8 `json:"updated_by"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateBannerOrder(ctx context.Context, arg UpdateBannerOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateBannerOrder,
		arg.ID,
		arg.PlanPackages,
		arg.Note,
		arg.TotalPrice,
		arg.StartDate,
		arg.EndDate,
		arg.UpdatedBy,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateBannerOrderPlanPackageBannersQuantity = `-- name: UpdateBannerOrderPlanPackageBannersQuantity :one
WITH updated AS (
  UPDATE banner_order
  SET plan_packages = (
    SELECT jsonb_agg(
      CASE
        WHEN pkg->>'plan_package_id' = $2::text THEN
          jsonb_set(
            pkg,
            '{number_of_banners}',
            to_jsonb(GREATEST((pkg->>'number_of_banners')::int - 1, 0))
          )
        ELSE pkg
      END
    )
    FROM jsonb_array_elements(plan_packages) AS pkg
  )
  WHERE company_id = $1
    AND jsonb_path_exists(
      plan_packages,
      '$[*] ? (@.plan_package_id == $target_id)',
      jsonb_build_object('target_id', $2::bigint)
    )
    AND jsonb_path_exists(
      plan_packages,
      '$[*] ? (@.plan_package_cost_id == $target_id)',
      jsonb_build_object('target_id', $3::bigint)
    )
  RETURNING plan_packages
)
SELECT (elem->>'original_counts_per_banner')::BIGINT AS pkg
FROM updated,
     jsonb_array_elements(plan_packages) AS elem
`

type UpdateBannerOrderPlanPackageBannersQuantityParams struct {
	CompanyID int64  `json:"company_id"`
	Column2   string `json:"column_2"`
	Column3   int64  `json:"column_3"`
}

func (q *Queries) UpdateBannerOrderPlanPackageBannersQuantity(ctx context.Context, arg UpdateBannerOrderPlanPackageBannersQuantityParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateBannerOrderPlanPackageBannersQuantity, arg.CompanyID, arg.Column2, arg.Column3)
	var pkg int64
	err := row.Scan(&pkg)
	return pkg, err
}
