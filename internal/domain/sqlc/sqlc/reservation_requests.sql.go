// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: reservation_requests.sql

package sqlc

import (
	"context"
)

const createReservationRequest = `-- name: CreateReservationRequest :one
INSERT INTO reservation_requests (
    name, email, phone, nic_document, payment_proof,
    entity_type, entity_id, status, created_by, ref_no
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10
)
RETURNING id, ref_no, name, email, phone, nic_document, payment_proof, entity_type, entity_id, status, created_by, created_at, updated_at
`

type CreateReservationRequestParams struct {
	Name         string `json:"name"`
	Email        string `json:"email"`
	Phone        string `json:"phone"`
	NicDocument  string `json:"nic_document"`
	PaymentProof string `json:"payment_proof"`
	EntityType   int64  `json:"entity_type"`
	EntityID     int64  `json:"entity_id"`
	Status       int64  `json:"status"`
	CreatedBy    int64  `json:"created_by"`
	RefNo        string `json:"ref_no"`
}

func (q *Queries) CreateReservationRequest(ctx context.Context, arg CreateReservationRequestParams) (ReservationRequest, error) {
	row := q.db.QueryRow(ctx, createReservationRequest,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.NicDocument,
		arg.PaymentProof,
		arg.EntityType,
		arg.EntityID,
		arg.Status,
		arg.CreatedBy,
		arg.RefNo,
	)
	var i ReservationRequest
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.NicDocument,
		&i.PaymentProof,
		&i.EntityType,
		&i.EntityID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReservationRequest = `-- name: DeleteReservationRequest :exec
DELETE FROM reservation_requests
WHERE id = $1
`

func (q *Queries) DeleteReservationRequest(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteReservationRequest, id)
	return err
}

const getReservationRequestByEmail = `-- name: GetReservationRequestByEmail :one
SELECT id, ref_no, name, email, phone, nic_document, payment_proof, entity_type, entity_id, status, created_by, created_at, updated_at FROM reservation_requests
WHERE email = $1
`

func (q *Queries) GetReservationRequestByEmail(ctx context.Context, email string) (ReservationRequest, error) {
	row := q.db.QueryRow(ctx, getReservationRequestByEmail, email)
	var i ReservationRequest
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.NicDocument,
		&i.PaymentProof,
		&i.EntityType,
		&i.EntityID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReservationRequestByID = `-- name: GetReservationRequestByID :one
SELECT id, ref_no, name, email, phone, nic_document, payment_proof, entity_type, entity_id, status, created_by, created_at, updated_at FROM reservation_requests
WHERE id = $1
`

func (q *Queries) GetReservationRequestByID(ctx context.Context, id int32) (ReservationRequest, error) {
	row := q.db.QueryRow(ctx, getReservationRequestByID, id)
	var i ReservationRequest
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.NicDocument,
		&i.PaymentProof,
		&i.EntityType,
		&i.EntityID,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCountReservationRequests = `-- name: ListCountReservationRequests :one
SELECT count(*) FROM reservation_requests
`

func (q *Queries) ListCountReservationRequests(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, listCountReservationRequests)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listCountReservationRequestsByEntityIDAndEntityType = `-- name: ListCountReservationRequestsByEntityIDAndEntityType :one
SELECT count(*) FROM reservation_requests
WHERE
entity_type = $1 AND entity_id = $2
`

type ListCountReservationRequestsByEntityIDAndEntityTypeParams struct {
	EntityType int64 `json:"entity_type"`
	EntityID   int64 `json:"entity_id"`
}

func (q *Queries) ListCountReservationRequestsByEntityIDAndEntityType(ctx context.Context, arg ListCountReservationRequestsByEntityIDAndEntityTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, listCountReservationRequestsByEntityIDAndEntityType, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listReservationRequests = `-- name: ListReservationRequests :many
SELECT
  id, ref_no, name, email, phone, nic_document, payment_proof, entity_type, entity_id, status, created_by, created_at, updated_at
FROM reservation_requests
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListReservationRequestsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListReservationRequests(ctx context.Context, arg ListReservationRequestsParams) ([]ReservationRequest, error) {
	rows, err := q.db.Query(ctx, listReservationRequests, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReservationRequest
	for rows.Next() {
		var i ReservationRequest
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.NicDocument,
			&i.PaymentProof,
			&i.EntityType,
			&i.EntityID,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationRequestsByEntityIDAndEntityType = `-- name: ListReservationRequestsByEntityIDAndEntityType :many
SELECT  
  id, ref_no, name, email, phone, nic_document, payment_proof, entity_type, entity_id, status, created_by, created_at, updated_at
FROM reservation_requests
WHERE
entity_type = $3 AND entity_id = $4
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListReservationRequestsByEntityIDAndEntityTypeParams struct {
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	EntityType int64 `json:"entity_type"`
	EntityID   int64 `json:"entity_id"`
}

func (q *Queries) ListReservationRequestsByEntityIDAndEntityType(ctx context.Context, arg ListReservationRequestsByEntityIDAndEntityTypeParams) ([]ReservationRequest, error) {
	rows, err := q.db.Query(ctx, listReservationRequestsByEntityIDAndEntityType,
		arg.Limit,
		arg.Offset,
		arg.EntityType,
		arg.EntityID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReservationRequest
	for rows.Next() {
		var i ReservationRequest
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.NicDocument,
			&i.PaymentProof,
			&i.EntityType,
			&i.EntityID,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReservationRequest = `-- name: UpdateReservationRequest :exec
UPDATE reservation_requests
SET
    name = $2,
    email = $3,
    phone = $4,
    nic_document = $5,
    payment_proof = $6,
    entity_type = $7,
    entity_id = $8,
    created_by = $9,
    updated_at = now()
WHERE id = $1
`

type UpdateReservationRequestParams struct {
	ID           int32  `json:"id"`
	Name         string `json:"name"`
	Email        string `json:"email"`
	Phone        string `json:"phone"`
	NicDocument  string `json:"nic_document"`
	PaymentProof string `json:"payment_proof"`
	EntityType   int64  `json:"entity_type"`
	EntityID     int64  `json:"entity_id"`
	CreatedBy    int64  `json:"created_by"`
}

func (q *Queries) UpdateReservationRequest(ctx context.Context, arg UpdateReservationRequestParams) error {
	_, err := q.db.Exec(ctx, updateReservationRequest,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.NicDocument,
		arg.PaymentProof,
		arg.EntityType,
		arg.EntityID,
		arg.CreatedBy,
	)
	return err
}

const updateReservationRequestsStatus = `-- name: UpdateReservationRequestsStatus :exec
UPDATE reservation_requests
SET status = $2, updated_at = now()
WHERE id = $1
`

type UpdateReservationRequestsStatusParams struct {
	ID     int32 `json:"id"`
	Status int64 `json:"status"`
}

func (q *Queries) UpdateReservationRequestsStatus(ctx context.Context, arg UpdateReservationRequestsStatusParams) error {
	_, err := q.db.Exec(ctx, updateReservationRequestsStatus, arg.ID, arg.Status)
	return err
}
