// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: exclusive.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeEntitiesPropertiesExclusivity = `-- name: ChangeEntitiesPropertiesExclusivity :many
UPDATE 
	property
SET
	exclusive=$1, 
	start_date=$2, 
	end_date=$3 
WHERE 
	entity_type_id= $4::BIGINT AND entity_id= ANY( $5::BIGINT[]) AND status!=6 
RETURNING id
`

type ChangeEntitiesPropertiesExclusivityParams struct {
	Exclusive   bool        `json:"exclusive"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	EntityType  int64       `json:"entity_type"`
	EntitiesIds []int64     `json:"entities_ids"`
}

func (q *Queries) ChangeEntitiesPropertiesExclusivity(ctx context.Context, arg ChangeEntitiesPropertiesExclusivityParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, changeEntitiesPropertiesExclusivity,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.EntityType,
		arg.EntitiesIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changePhaseExclusivity = `-- name: ChangePhaseExclusivity :exec
UPDATE 
	phases
SET 
	exclusive=$1,
	start_date=$2, 
	end_date=$3
WHERE 
	id=$4 AND status!=6
`

type ChangePhaseExclusivityParams struct {
	Exclusive bool        `json:"exclusive"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	ID        int64       `json:"id"`
}

func (q *Queries) ChangePhaseExclusivity(ctx context.Context, arg ChangePhaseExclusivityParams) error {
	_, err := q.db.Exec(ctx, changePhaseExclusivity,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.ID,
	)
	return err
}

const changeProjectExclusivity = `-- name: ChangeProjectExclusivity :exec
UPDATE 
	projects 
SET 
	exclusive=$2, 
	start_date=$3, 
	end_date=$4
WHERE 
	id=$1 AND status!=6
`

type ChangeProjectExclusivityParams struct {
	ID        int64       `json:"id"`
	Exclusive bool        `json:"exclusive"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) ChangeProjectExclusivity(ctx context.Context, arg ChangeProjectExclusivityParams) error {
	_, err := q.db.Exec(ctx, changeProjectExclusivity,
		arg.ID,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
	)
	return err
}

const changeProjectPhasesExclusivity = `-- name: ChangeProjectPhasesExclusivity :many
UPDATE 
	phases
SET 
	exclusive=$1, 
	start_date=$2, 
	end_date=$3
WHERE 
	projects_id= $4::BIGINT AND status!=6
RETURNING id
`

type ChangeProjectPhasesExclusivityParams struct {
	Exclusive bool        `json:"exclusive"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	ProjectID int64       `json:"project_id"`
}

func (q *Queries) ChangeProjectPhasesExclusivity(ctx context.Context, arg ChangeProjectPhasesExclusivityParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, changeProjectPhasesExclusivity,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.ProjectID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changePropertiesUnitsExclusivity = `-- name: ChangePropertiesUnitsExclusivity :exec
UPDATE 
	units
SET 
	exclusive=$1,
	start_date=$2, 
	end_date=$3
WHERE 
	entity_type_id= $4::BIGINT AND entity_id= ANY( $5::BIGINT[]) AND status!=6 
RETURNING id
`

type ChangePropertiesUnitsExclusivityParams struct {
	Exclusive          bool        `json:"exclusive"`
	StartDate          pgtype.Date `json:"start_date"`
	EndDate            pgtype.Date `json:"end_date"`
	PropertyEntityType int64       `json:"property_entity_type"`
	EntitiesIds        []int64     `json:"entities_ids"`
}

func (q *Queries) ChangePropertiesUnitsExclusivity(ctx context.Context, arg ChangePropertiesUnitsExclusivityParams) error {
	_, err := q.db.Exec(ctx, changePropertiesUnitsExclusivity,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.PropertyEntityType,
		arg.EntitiesIds,
	)
	return err
}

const changePropertyExclusivity = `-- name: ChangePropertyExclusivity :exec
UPDATE 
	property
SET 
	exclusive=$1,
	start_date=$2, 
	end_date=$3
WHERE 
	id=$4 AND status!=6
`

type ChangePropertyExclusivityParams struct {
	Exclusive bool        `json:"exclusive"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	ID        int64       `json:"id"`
}

func (q *Queries) ChangePropertyExclusivity(ctx context.Context, arg ChangePropertyExclusivityParams) error {
	_, err := q.db.Exec(ctx, changePropertyExclusivity,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.ID,
	)
	return err
}

const changeUnitExclusivity = `-- name: ChangeUnitExclusivity :exec
UPDATE 
	units
SET 
	exclusive=$1,
	start_date=$2, 
	end_date=$3
WHERE 
	id=$4 AND status!=6
`

type ChangeUnitExclusivityParams struct {
	Exclusive bool        `json:"exclusive"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	ID        int64       `json:"id"`
}

func (q *Queries) ChangeUnitExclusivity(ctx context.Context, arg ChangeUnitExclusivityParams) error {
	_, err := q.db.Exec(ctx, changeUnitExclusivity,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.ID,
	)
	return err
}
