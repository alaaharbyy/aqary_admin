// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sharing_entities.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSharingEntity = `-- name: CreateSharingEntity :exec
INSERT INTO sharing_entities(
    sharing_id,
    entity_type,
    entity_id,
    property_id,
    phase_id,
    status,
    created_at,
    updated_at,
    updated_by,
    exclusive_start_date,
    exclusive_expire_date,
    is_exclusive
)VALUES(
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
`

type CreateSharingEntityParams struct {
	SharingID           int64              `json:"sharing_id"`
	EntityType          int64              `json:"entity_type"`
	EntityID            int64              `json:"entity_id"`
	PropertyID          pgtype.Int8        `json:"property_id"`
	PhaseID             pgtype.Int8        `json:"phase_id"`
	Status              int64              `json:"status"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy           pgtype.Int8        `json:"updated_by"`
	ExclusiveStartDate  pgtype.Date        `json:"exclusive_start_date"`
	ExclusiveExpireDate pgtype.Date        `json:"exclusive_expire_date"`
	IsExclusive         bool               `json:"is_exclusive"`
}

func (q *Queries) CreateSharingEntity(ctx context.Context, arg CreateSharingEntityParams) error {
	_, err := q.db.Exec(ctx, createSharingEntity,
		arg.SharingID,
		arg.EntityType,
		arg.EntityID,
		arg.PropertyID,
		arg.PhaseID,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.ExclusiveStartDate,
		arg.ExclusiveExpireDate,
		arg.IsExclusive,
	)
	return err
}

const getSharingEntityById = `-- name: GetSharingEntityById :one
SELECT id, sharing_id, entity_type, entity_id, property_id, phase_id, status, created_at, updated_at, updated_by, exclusive_start_date, exclusive_expire_date, is_exclusive FROM sharing_entities
WHERE id = $1
`

func (q *Queries) GetSharingEntityById(ctx context.Context, id int64) (SharingEntity, error) {
	row := q.db.QueryRow(ctx, getSharingEntityById, id)
	var i SharingEntity
	err := row.Scan(
		&i.ID,
		&i.SharingID,
		&i.EntityType,
		&i.EntityID,
		&i.PropertyID,
		&i.PhaseID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.ExclusiveStartDate,
		&i.ExclusiveExpireDate,
		&i.IsExclusive,
	)
	return i, err
}

const publishProperty = `-- name: PublishProperty :one
INSERT INTO property_versions(title, title_arabic, description, description_arabic, 
property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category,
exclusive, start_date, end_date, refreshed_at
)SELECT  
    $1 AS title, 
    $2 AS title_arabic,
    $3 AS description,
    $4 AS description_arabic, 
    property_versions.property_id,
    property_versions.facts,
    $5 AS created_at, 
    $6 AS updated_at,
    $7 AS updated_by,
    $8 AS status,
    $9 AS agent_id, 
    $10 AS ref_no, 
    property_versions.category,
    CASE WHEN sharing_entities.is_exclusive IS TRUE AND sharing_entities.exclusive_expire_date > now() THEN TRUE ELSE FALSE END,
    CASE WHEN sharing_entities.is_exclusive IS TRUE AND sharing_entities.exclusive_expire_date > now() THEN sharing_entities.exclusive_start_date ELSE NULL END,
    CASE WHEN sharing_entities.is_exclusive IS TRUE AND sharing_entities.exclusive_expire_date > now() THEN sharing_entities.exclusive_expire_date ELSE NULL END,
    $11 AS refreshed_at
FROM property_versions
INNER JOIN property ON property.id = property_versions.property_id
INNER JOIN sharing_entities ON sharing_entities.entity_id = property_versions.id
WHERE sharing_entities.id = $12::bigint
RETURNING id, title, views_count, title_arabic, description, description_arabic, property_rank, property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type PublishPropertyParams struct {
	Title             string             `json:"title"`
	TitleArabic       pgtype.Text        `json:"title_arabic"`
	Description       string             `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	UpdatedBy         int64              `json:"updated_by"`
	Status            int64              `json:"status"`
	AgentID           int64              `json:"agent_id"`
	RefNo             string             `json:"ref_no"`
	RefreshedAt       pgtype.Timestamptz `json:"refreshed_at"`
	SharingID         int64              `json:"sharing_id"`
}

func (q *Queries) PublishProperty(ctx context.Context, arg PublishPropertyParams) (PropertyVersion, error) {
	row := q.db.QueryRow(ctx, publishProperty,
		arg.Title,
		arg.TitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
		arg.AgentID,
		arg.RefNo,
		arg.RefreshedAt,
		arg.SharingID,
	)
	var i PropertyVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const publishUnit = `-- name: PublishUnit :one
INSERT INTO unit_versions (title,title_arabic, description,  description_arabic, 
 unit_id,  ref_no, status, type, unit_rank,  created_at,  created_by,updated_by, 
  facts, listed_by, exclusive, start_date, end_date, refreshed_at)
SELECT 
    $1 AS title,
    $2 AS title_arabic, 
    $3 AS description, 
    $4 AS description_arabic,
    unit_versions.unit_id,
    $5 AS ref_no,
    $6 AS status,
    unit_versions.type,
    unit_versions.unit_rank,
    $7 AS created_at,
    $8 AS created_by,
    $8 AS updated_by,
    unit_versions.facts,
    $9 AS listed_by,
    CASE WHEN sharing_entities.is_exclusive IS TRUE AND sharing_entities.exclusive_expire_date > now() THEN TRUE ELSE FALSE END,
    CASE WHEN sharing_entities.is_exclusive IS TRUE AND sharing_entities.exclusive_expire_date > now() THEN sharing_entities.exclusive_start_date ELSE NULL END,
    CASE WHEN sharing_entities.is_exclusive IS TRUE AND sharing_entities.exclusive_expire_date > now() THEN sharing_entities.exclusive_expire_date ELSE NULL END,
    $10 AS refreshed_at
FROM unit_versions
INNER JOIN units ON units.id = unit_versions.unit_id
INNER JOIN sharing_entities ON sharing_entities.entity_id = unit_versions.id
WHERE sharing_entities.id = $11::bigint
RETURNING id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type PublishUnitParams struct {
	Title             string             `json:"title"`
	TitleArabic       pgtype.Text        `json:"title_arabic"`
	Description       string             `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	RefNo             string             `json:"ref_no"`
	Status            int64              `json:"status"`
	CreatedAt         time.Time          `json:"created_at"`
	CreatedBy         int64              `json:"created_by"`
	ListedBy          int64              `json:"listed_by"`
	RefreshedAt       pgtype.Timestamptz `json:"refreshed_at"`
	SharingID         int64              `json:"sharing_id"`
}

func (q *Queries) PublishUnit(ctx context.Context, arg PublishUnitParams) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, publishUnit,
		arg.Title,
		arg.TitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.RefNo,
		arg.Status,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.ListedBy,
		arg.RefreshedAt,
		arg.SharingID,
	)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const updatePropertyVersionGalleryAndPlanStatus = `-- name: UpdatePropertyVersionGalleryAndPlanStatus :exec
UPDATE property_versions
SET has_gallery = $1,
has_plans = $2
WHERE id = $3
`

type UpdatePropertyVersionGalleryAndPlanStatusParams struct {
	HasGallery pgtype.Bool `json:"has_gallery"`
	HasPlans   pgtype.Bool `json:"has_plans"`
	ID         int64       `json:"id"`
}

func (q *Queries) UpdatePropertyVersionGalleryAndPlanStatus(ctx context.Context, arg UpdatePropertyVersionGalleryAndPlanStatusParams) error {
	_, err := q.db.Exec(ctx, updatePropertyVersionGalleryAndPlanStatus, arg.HasGallery, arg.HasPlans, arg.ID)
	return err
}

const updateSharingEntitiesStatus = `-- name: UpdateSharingEntitiesStatus :one
UPDATE sharing_entities
SET status = $1,
updated_at = $2,
updated_by = $3
WHERE id = $4
RETURNING id, sharing_id, entity_type, entity_id, property_id, phase_id, status, created_at, updated_at, updated_by, exclusive_start_date, exclusive_expire_date, is_exclusive
`

type UpdateSharingEntitiesStatusParams struct {
	Status    int64              `json:"status"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy pgtype.Int8        `json:"updated_by"`
	ID        int64              `json:"id"`
}

func (q *Queries) UpdateSharingEntitiesStatus(ctx context.Context, arg UpdateSharingEntitiesStatusParams) (SharingEntity, error) {
	row := q.db.QueryRow(ctx, updateSharingEntitiesStatus,
		arg.Status,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.ID,
	)
	var i SharingEntity
	err := row.Scan(
		&i.ID,
		&i.SharingID,
		&i.EntityType,
		&i.EntityID,
		&i.PropertyID,
		&i.PhaseID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.ExclusiveStartDate,
		&i.ExclusiveExpireDate,
		&i.IsExclusive,
	)
	return i, err
}

const updateUnitVersionGalleryAndPlanStatus = `-- name: UpdateUnitVersionGalleryAndPlanStatus :exec
UPDATE unit_versions
SET has_gallery = $1,
has_plans = $2
WHERE id = $3
`

type UpdateUnitVersionGalleryAndPlanStatusParams struct {
	HasGallery pgtype.Bool `json:"has_gallery"`
	HasPlans   pgtype.Bool `json:"has_plans"`
	ID         int64       `json:"id"`
}

func (q *Queries) UpdateUnitVersionGalleryAndPlanStatus(ctx context.Context, arg UpdateUnitVersionGalleryAndPlanStatusParams) error {
	_, err := q.db.Exec(ctx, updateUnitVersionGalleryAndPlanStatus, arg.HasGallery, arg.HasPlans, arg.ID)
	return err
}
