// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: currency.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCurrency = `-- name: CreateCurrency :one
INSERT INTO currency (
    currency,
    code,
    flag
)VALUES (
    $1, $2, $3
) RETURNING id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by
`

type CreateCurrencyParams struct {
	Currency string `json:"currency"`
	Code     string `json:"code"`
	Flag     string `json:"flag"`
}

func (q *Queries) CreateCurrency(ctx context.Context, arg CreateCurrencyParams) (Currency, error) {
	row := q.db.QueryRow(ctx, createCurrency, arg.Currency, arg.Code, arg.Flag)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const createCurrencyNew = `-- name: CreateCurrencyNew :one
INSERT INTO currency (
    currency,
    code,
    flag,
    currency_rate,
    updated_at,
    updated_by,
    created_at,
    status
)VALUES (
    $1, $2, $3, $4, $5, $6, $7,$8
) RETURNING id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by
`

type CreateCurrencyNewParams struct {
	Currency     string    `json:"currency"`
	Code         string    `json:"code"`
	Flag         string    `json:"flag"`
	CurrencyRate float64   `json:"currency_rate"`
	UpdatedAt    time.Time `json:"updated_at"`
	UpdatedBy    int64     `json:"updated_by"`
	CreatedAt    time.Time `json:"created_at"`
	Status       int64     `json:"status"`
}

func (q *Queries) CreateCurrencyNew(ctx context.Context, arg CreateCurrencyNewParams) (Currency, error) {
	row := q.db.QueryRow(ctx, createCurrencyNew,
		arg.Currency,
		arg.Code,
		arg.Flag,
		arg.CurrencyRate,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.CreatedAt,
		arg.Status,
	)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteCurrency = `-- name: DeleteCurrency :exec
DELETE FROM currency
Where id = $1
`

func (q *Queries) DeleteCurrency(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCurrency, id)
	return err
}

const getAllCurrency = `-- name: GetAllCurrency :many
SELECT id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by FROM currency
WHERE status = 2
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllCurrencyParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllCurrency(ctx context.Context, arg GetAllCurrencyParams) ([]Currency, error) {
	rows, err := q.db.Query(ctx, getAllCurrency, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Currency,
			&i.Code,
			&i.Flag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrencyRate,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCurrencyNew = `-- name: GetAllCurrencyNew :many
SELECT id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by FROM currency
where status!=6
ORDER BY updated_at desc
LIMIT $2
OFFSET $1
`

type GetAllCurrencyNewParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

func (q *Queries) GetAllCurrencyNew(ctx context.Context, arg GetAllCurrencyNewParams) ([]Currency, error) {
	rows, err := q.db.Query(ctx, getAllCurrencyNew, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Currency,
			&i.Code,
			&i.Flag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrencyRate,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCurrencyNewCount = `-- name: GetAllCurrencyNewCount :one
SELECT count(*) FROM currency
where status!=6
`

func (q *Queries) GetAllCurrencyNewCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAllCurrencyNewCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCurrency = `-- name: GetCurrency :one
SELECT id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by FROM currency 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetCurrency(ctx context.Context, limit int32) (Currency, error) {
	row := q.db.QueryRow(ctx, getCurrency, limit)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getCurrencyByCode = `-- name: GetCurrencyByCode :one
SELECT id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by FROM currency 
WHERE LOWER(TRIM(code)) = LOWER(TRIM($1::text)) AND status !=6
`

func (q *Queries) GetCurrencyByCode(ctx context.Context, code string) (Currency, error) {
	row := q.db.QueryRow(ctx, getCurrencyByCode, code)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getCurrencyByCurrency = `-- name: GetCurrencyByCurrency :one
SELECT id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by FROM currency 
WHERE currency = $2 LIMIT $1
`

type GetCurrencyByCurrencyParams struct {
	Limit    int32  `json:"limit"`
	Currency string `json:"currency"`
}

func (q *Queries) GetCurrencyByCurrency(ctx context.Context, arg GetCurrencyByCurrencyParams) (Currency, error) {
	row := q.db.QueryRow(ctx, getCurrencyByCurrency, arg.Limit, arg.Currency)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getCurrencyByCurrencyNew = `-- name: GetCurrencyByCurrencyNew :one
SELECT id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by FROM currency 
WHERE currency = $1 AND status !=6
LIMIT 1
`

func (q *Queries) GetCurrencyByCurrencyNew(ctx context.Context, currency string) (Currency, error) {
	row := q.db.QueryRow(ctx, getCurrencyByCurrencyNew, currency)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getCurrencyNew = `-- name: GetCurrencyNew :one
SELECT id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by FROM currency 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCurrencyNew(ctx context.Context, id int64) (Currency, error) {
	row := q.db.QueryRow(ctx, getCurrencyNew, id)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getDeletedCurrencies = `-- name: GetDeletedCurrencies :many
SELECT id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by FROM currency
where status=6
ORDER BY updated_at desc
LIMIT $2
OFFSET $1
`

type GetDeletedCurrenciesParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

func (q *Queries) GetDeletedCurrencies(ctx context.Context, arg GetDeletedCurrenciesParams) ([]Currency, error) {
	rows, err := q.db.Query(ctx, getDeletedCurrencies, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Currency,
			&i.Code,
			&i.Flag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrencyRate,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedCurrenciesCount = `-- name: GetDeletedCurrenciesCount :one
SELECT count(*) FROM currency
where status=6
`

func (q *Queries) GetDeletedCurrenciesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getDeletedCurrenciesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateCurrency = `-- name: UpdateCurrency :one
UPDATE currency
SET currency = $2,
    code = $3,
    flag = $4,
    status=$5,
    updated_by=$6,
    updated_at = now()

Where id = $1
RETURNING id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by
`

type UpdateCurrencyParams struct {
	ID        int64  `json:"id"`
	Currency  string `json:"currency"`
	Code      string `json:"code"`
	Flag      string `json:"flag"`
	Status    int64  `json:"status"`
	UpdatedBy int64  `json:"updated_by"`
}

func (q *Queries) UpdateCurrency(ctx context.Context, arg UpdateCurrencyParams) (Currency, error) {
	row := q.db.QueryRow(ctx, updateCurrency,
		arg.ID,
		arg.Currency,
		arg.Code,
		arg.Flag,
		arg.Status,
		arg.UpdatedBy,
	)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateCurrencyRateByCode = `-- name: UpdateCurrencyRateByCode :exec
UPDATE currency
SET currency_rate = $1,
updated_at = now()
WHERE code = $2
`

type UpdateCurrencyRateByCodeParams struct {
	CurrencyRate float64 `json:"currency_rate"`
	Code         string  `json:"code"`
}

func (q *Queries) UpdateCurrencyRateByCode(ctx context.Context, arg UpdateCurrencyRateByCodeParams) error {
	_, err := q.db.Exec(ctx, updateCurrencyRateByCode, arg.CurrencyRate, arg.Code)
	return err
}

const updateCurrencyStatus = `-- name: UpdateCurrencyStatus :one
UPDATE currency
SET status = $1,
    updated_by=$3,
    deleted_at=$4,
    updated_at = now()
WHERE id = $2
RETURNING id, currency, code, flag, created_at, updated_at, currency_rate, status, deleted_at, updated_by
`

type UpdateCurrencyStatusParams struct {
	Status    int64              `json:"status"`
	ID        int64              `json:"id"`
	UpdatedBy int64              `json:"updated_by"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) UpdateCurrencyStatus(ctx context.Context, arg UpdateCurrencyStatusParams) (Currency, error) {
	row := q.db.QueryRow(ctx, updateCurrencyStatus,
		arg.Status,
		arg.ID,
		arg.UpdatedBy,
		arg.DeletedAt,
	)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Code,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyRate,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
	)
	return i, err
}
