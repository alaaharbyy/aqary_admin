// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: slug_unit_properties.sql

package sqlc

import (
	"context"
)

const getSlugByRefNo = `-- name: GetSlugByRefNo :one
SELECT cu.company_id, 
	unit_versions."type" AS category, 
	unit_versions.ref_no, unit_versions.slug, 
	ut."usage",
	'unit' AS table_name 
FROM unit_versions 
JOIN company_users cu ON cu.users_id = unit_versions.listed_by 
JOIN units ON units.id=unit_versions.unit_id
JOIN unit_type ut ON ut.id=units.unit_type_id
WHERE ref_no = $1::varchar AND unit_versions.status = $2::BIGINT

UNION ALL

SELECT cu.company_id, 
	property_versions.category AS category, 
	property_versions.ref_no, 
	property_versions.slug, 
	gpt."usage",
	'property' AS table_name 
FROM property_versions 
JOIN company_users cu ON cu.users_id = property_versions.agent_id 
JOIN property on property.id=property_versions.property_id
JOIn global_property_type gpt on gpt.id=property.property_type_id 
WHERE property_versions.ref_no = $1::varchar AND property_versions.status = $2::BIGINT
`

type GetSlugByRefNoParams struct {
	RefNo        string `json:"ref_no"`
	ActiveStatus int64  `json:"active_status"`
}

type GetSlugByRefNoRow struct {
	CompanyID int64  `json:"company_id"`
	Category  int64  `json:"category"`
	RefNo     string `json:"ref_no"`
	Slug      string `json:"slug"`
	Usage     int64  `json:"usage"`
	TableName string `json:"table_name"`
}

func (q *Queries) GetSlugByRefNo(ctx context.Context, arg GetSlugByRefNoParams) (GetSlugByRefNoRow, error) {
	row := q.db.QueryRow(ctx, getSlugByRefNo, arg.RefNo, arg.ActiveStatus)
	var i GetSlugByRefNoRow
	err := row.Scan(
		&i.CompanyID,
		&i.Category,
		&i.RefNo,
		&i.Slug,
		&i.Usage,
		&i.TableName,
	)
	return i, err
}
