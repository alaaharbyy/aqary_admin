// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sharing.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkIsValidToShare = `-- name: CheckIsValidToShare :one
SELECT CASE 
    WHEN $1::bigint = 1 THEN EXISTS( 
        SELECT 1
        FROM projects
        WHERE id = $2::bigint AND status NOT IN (5, 6)
        AND (
        	SELECT NOT EXISTS (
                SELECT 1 FROM sharing
                WHERE entity_id = $2::bigint 
                AND entity_type_id = 1
                AND shared_to = $3::bigint
              )
          ) 
    )
    WHEN $1::bigint = 2 THEN EXISTS( 
        SELECT 1
        FROM phases
        WHERE id = $2::bigint AND status NOT IN (5, 6)
        AND (
        	SELECT NOT EXISTS (
                SELECT 1 FROM sharing
                WHERE entity_id = $2::bigint 
                AND entity_type_id = 2
                AND shared_to = $3::bigint
              )
          ) 
    )
    WHEN $1::bigint = 14 THEN EXISTS(
        SELECT 1
        FROM unit_versions
        INNER JOIN units ON unit_versions.unit_id = units.id
        WHERE unit_versions.id = $2::bigint 
        AND unit_versions.status NOT IN (5, 6)
        AND units.status NOT IN (5, 6)
        AND (
        	SELECT 
              NOT EXISTS ( -- if directly share
                SELECT 1 FROM sharing
                WHERE entity_id = $2::bigint 
                AND entity_type_id = 14
                AND shared_to = $3::bigint
                AND CASE WHEN $4::bigint = 0::bigint THEN TRUE ELSE id != $4::bigint END
              ) 
              AND
              NOT EXISTS (
                SELECT 1 FROM sharing_entities
                INNER JOIN sharing ON sharing.id = sharing_entities.sharing_id
                WHERE sharing_entities.entity_id = $2::bigint 
                AND sharing_entities.entity_type = 14
                AND sharing.shared_to = $3::bigint
              ) 
        	)
    )
    WHEN $1::bigint = 15 THEN EXISTS(
        SELECT 1
        FROM property_versions
        INNER JOIN property ON property_versions.property_id = property.id
        WHERE property_versions.id = $2::bigint 
        AND property_versions.status NOT IN (5, 6)
        AND property.status NOT IN (5, 6)
        AND (
        	SELECT 
        		  NOT EXISTS ( -- if directly share
                SELECT 1 FROM sharing
                WHERE entity_id = $2::bigint 
                AND entity_type_id = 15
                AND shared_to = $3::bigint 
                AND CASE WHEN $4::bigint = 0::bigint THEN TRUE ELSE id != $4::bigint END
              ) 
              AND    			
              NOT EXISTS (
                SELECT 1 FROM sharing_entities
                INNER JOIN sharing ON sharing.id = sharing_entities.sharing_id
                WHERE sharing_entities.entity_id = $2::bigint 
                AND sharing_entities.entity_type = 15
                AND sharing.shared_to = $3::bigint
              )  
        	)
    )
END::boolean AS is_valid_to_share
`

type CheckIsValidToShareParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
	SharedTo     int64 `json:"shared_to"`
	ExcludeID    int64 `json:"exclude_id"`
}

func (q *Queries) CheckIsValidToShare(ctx context.Context, arg CheckIsValidToShareParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkIsValidToShare,
		arg.EntityTypeID,
		arg.EntityID,
		arg.SharedTo,
		arg.ExcludeID,
	)
	var is_valid_to_share bool
	err := row.Scan(&is_valid_to_share)
	return is_valid_to_share, err
}

const countAllProjectPhaseSharing = `-- name: CountAllProjectPhaseSharing :one
WITH x AS (
    SELECT 
        external_sharing.project_id as project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id
    FROM external_sharing
    INNER JOIN users ON users.id = external_sharing.created_by
    WHERE 
        external_sharing.is_project = true
        AND external_sharing.phase_id IS NOT NULL
        AND (external_sharing.is_property IS NULL OR  external_sharing.is_property IS FALSE)
        AND (external_sharing.is_unit IS NULL OR external_sharing.is_unit IS FALSE)  
        -- AND CASE WHEN @company_id::bigint = 0 THEN true ELSE @company_id::bigint = ANY(external_company_id) END
        -- AND CASE WHEN @is_branch_id::bigint = 0 THEN true ELSE @is_branch::bool = ANY(external_is_branch) END
        -- AND CASE WHEN @company_type::bigint = 0 THEN true ELSE @company_type::bigint = ANY(external_company_type) END
        AND CASE WHEN $2::bigint = 0 THEN true ELSE  $2::bigint =  created_by  END
    UNION ALL
    SELECT
        internal_sharing.project_id as project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id
    FROM internal_sharing
    INNER JOIN users u ON u.id = internal_sharing.created_by
    WHERE 
        internal_sharing.is_project = true
        AND internal_sharing.phase_id IS NOT NULL
        AND (internal_sharing.is_property IS NULL OR  internal_sharing.is_property IS FALSE)
        AND (internal_sharing.is_unit IS NULL OR internal_sharing.is_unit IS FALSE)  
        -- AND CASE WHEN @user_id::bigint = 0 THEN true ELSE @user_id::bigint = ANY(shared_to) END
        AND CASE WHEN $2::bigint = 0 THEN true ELSE  $2::bigint =  created_by  END
)
SELECT
    COUNT(DISTINCT x.project_id) AS total_count
FROM 
    x
  INNER JOIN projects p ON x.project_id = p.id
    -- other joins 
  INNER JOIN phases ON p.id = phases.projects_id
  INNER JOIN phases_facts ON phases.id = phases_facts.phases_id
  INNER JOIN companies ON p.developer_companies_id = companies.id
WHERE   
     (
        $1 = '%%'
      OR phases.ref_no ILIKE $1
      OR p.project_name ILIKE $1
      OR companies.company_name ILIKE $1
      OR phases.phase_name ILIKE $1
       OR (CASE 
        WHEN 'ready' ILIKE $1 THEN phases_facts.completion_status = 5
        WHEN 'off plan'ILIKE $1  THEN phases_facts.completion_status = 4
        WHEN '^[0-9]+$' ~ $1  THEN phases_facts.completion_percentage::TEXT % $1
        ELSE FALSE
      END)
     )   
  ---------------------     
AND  p.status NOT IN (5, 6)
`

type CountAllProjectPhaseSharingParams struct {
	Search interface{} `json:"search"`
	UserID int64       `json:"user_id"`
}

func (q *Queries) CountAllProjectPhaseSharing(ctx context.Context, arg CountAllProjectPhaseSharingParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProjectPhaseSharing, arg.Search, arg.UserID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countAllProjectSharing = `-- name: CountAllProjectSharing :one
WITH x AS (
    SELECT
        external_sharing.id as share_id,
        external_sharing.external_company_id as company_ids,
        external_sharing.project_id AS project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.external_is_enabled AS is_enabled,
        external_sharing.id AS external_id
    FROM
        external_sharing
        INNER JOIN users ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = TRUE
        AND external_sharing.phase_id IS NULL
        AND (external_sharing.is_property IS NULL OR external_sharing.is_property IS FALSE)
        AND (external_sharing.is_unit IS NULL OR external_sharing.is_unit IS FALSE)
        AND CASE WHEN $2::bigint = 0 THEN true ELSE  $2::bigint =  created_by  END
    UNION ALL
    SELECT
        internal_sharing.id as share_id,
        internal_sharing.shared_to as company_ids,
        internal_sharing.project_id AS project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        internal_sharing.is_enabled AS is_enabled,
        0 AS external_id
    FROM
        internal_sharing
        INNER JOIN users u ON u.id = internal_sharing.created_by
    WHERE
        internal_sharing.is_project = TRUE
        AND internal_sharing.phase_id IS NULL
        AND (internal_sharing.is_property IS NULL OR internal_sharing.is_property IS FALSE)
        AND (internal_sharing.is_unit IS NULL OR internal_sharing.is_unit IS FALSE)
        AND CASE WHEN $2::bigint = 0 THEN true ELSE  $2::bigint =  created_by  END
)
SELECT
    COUNT(DISTINCT x.project_id) AS total_count
FROM
    x
    INNER JOIN projects p ON x.project_id = p.id
    INNER JOIN addresses ON p.addresses_id = addresses.id 
    INNER JOIN countries ON addresses.countries_id = countries.id  
    INNER JOIN states ON addresses.states_id = states.id   
    INNER JOIN cities ON addresses.cities_id = cities.id    
    INNER JOIN companies ON p.developer_companies_id = companies.id    
    INNER JOIN properties_facts ON p.id = properties_facts.project_id AND properties_facts.is_project_fact = true  
WHERE
 -- Search criteria
    ($1 = '%%' OR 
     p.project_name % $1 OR 
     p.ref_number % $1 OR
     countries.country % $1 OR 
     states."state" % $1 OR 
     cities.city % $1 OR 
     companies.company_name % $1  
      OR (CASE 
        WHEN 'ready' ILIKE $1 THEN properties_facts.completion_status = 5
        WHEN 'off plan' ILIKE $1  THEN properties_facts.completion_status = 4
        WHEN '^[0-9]+$' ~ $1  THEN properties_facts.completion_percentage::TEXT % $1
        WHEN 'draft' ILIKE $1  THEN p.status = 1
        WHEN 'available' ILIKE $1  THEN p.status = 2
        WHEN 'block' ILIKE $1  THEN p.status = 5
        WHEN 'single' ILIKE $1  THEN p.is_multiphase = false
        WHEN 'multiple' ILIKE $1  THEN p.is_multiphase = true 
        ELSE FALSE
      END)
      )
AND 
    p.status NOT IN (5, 6)
`

type CountAllProjectSharingParams struct {
	Search interface{} `json:"search"`
	UserID int64       `json:"user_id"`
}

func (q *Queries) CountAllProjectSharing(ctx context.Context, arg CountAllProjectSharingParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProjectSharing, arg.Search, arg.UserID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countAllSharedPhases = `-- name: CountAllSharedPhases :one
SELECT COUNT(*) FROM(
    SELECT
        project_id,phase_id,
        MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
        MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
        CASE WHEN $1::bigint = created_by THEN true ELSE false END AS unshared_available
        FROM(
            SELECT project_id,phase_id, 'external' as source, created_at,created_by FROM external_sharing
            Where is_project = true AND phase_id IS NOT NULL 
            AND CASE WHEN $2::bigint = 0 THEN true ELSE $2::bigint = ANY(external_company_id) END 
            AND CASE WHEN $3::bigint = 0 THEN true ELSE  $4::bool = ANY(external_is_branch)  END
            AND CASE WHEN $5::bigint = 0 THEN true ELSE $5::bigint = ANY(external_company_type) END  
            UNION ALL
            SELECT project_id,phase_id, 'internal' as source, created_at,created_by FROM internal_sharing
            Where is_project = true AND phase_id IS NOT NULL AND CASE WHEN $1::bigint = 0 THEN true ELSE $1::bigint = ANY(shared_to) END 
        ) AS derived_table 
    GROUP BY project_id,phase_id,created_by
) AS count
`

type CountAllSharedPhasesParams struct {
	UserID      int64       `json:"user_id"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
}

func (q *Queries) CountAllSharedPhases(ctx context.Context, arg CountAllSharedPhasesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllSharedPhases,
		arg.UserID,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSharingEntityIDsByEntityType = `-- name: CountSharingEntityIDsByEntityType :one
SELECT COUNT(*)
FROM sharing s
LEFT JOIN projects p ON (
    s.entity_id = p.id 
    AND s.entity_type_id = $1
)
LEFT JOIN companies c ON (
    p.developer_companies_id = c.id 
    AND s.entity_type_id = $1
)
LEFT JOIN phases ph ON (
    s.entity_id = ph.id 
    AND s.entity_type_id = $1
)

LEFT JOIN property_versions pv ON (
    s.entity_id = pv.id 
    AND s.entity_type_id = $1
)

LEFT JOIN property ON pv.property_id = property.id

LEFT JOIN unit_versions uv ON (
    s.entity_id = uv.id 
    AND s.entity_type_id = $1
)
WHERE 
   ((s.entity_type_id = $1 AND p.id IS NOT NULL)
    OR 
    (s.entity_type_id = $1 AND ph.id IS NOT NULL)
    OR
    (s.entity_type_id = $1 AND pv.id IS NOT NULL))
    AND (
        ($2 = '%%')
        OR p.project_name ILIKE $2
        OR p.ref_number ILIKE $2
        OR c.company_name ILIKE $2
        OR (p.facts->>'completion_percentage')::TEXT ILIKE $2
        OR ph.phase_name ILIKE $2
        OR property.property_name ILIKE $2
        OR uv.title ILIKE $2
    )
    AND CASE 
        WHEN $3::bigint = 0 THEN true 
        ELSE s.created_by = $3::bigint 
    END
    AND CASE 
        WHEN $4::bigint = 0 THEN true 
        ELSE s.shared_to = $4::bigint 
    END
AND s.entity_type_id = $1
`

type CountSharingEntityIDsByEntityTypeParams struct {
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	Search       interface{} `json:"search"`
	CreatedBy    int64       `json:"created_by"`
	UserID       int64       `json:"user_id"`
}

func (q *Queries) CountSharingEntityIDsByEntityType(ctx context.Context, arg CountSharingEntityIDsByEntityTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSharingEntityIDsByEntityType,
		arg.EntityTypeID,
		arg.Search,
		arg.CreatedBy,
		arg.UserID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExternalSharing = `-- name: CreateExternalSharing :one
INSERT INTO external_sharing (
 company_types_id,
 companies_id, 
 is_branch,  
 is_project,  
 project_id ,
 is_property, 
 is_property_branch,
 property_id,
 is_unit, 
 unit_id,
 unit_category,
 price, 
 external_company_type,
 external_is_branch,
 external_company_id,
 created_at, 
 created_by,
 phase_id,
 external_is_enabled,
 property_key
 )VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18 , $19, $20
 ) RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id
`

type CreateExternalSharingParams struct {
	CompanyTypesID      int64         `json:"company_types_id"`
	CompaniesID         int64         `json:"companies_id"`
	IsBranch            pgtype.Bool   `json:"is_branch"`
	IsProject           pgtype.Bool   `json:"is_project"`
	ProjectID           pgtype.Int8   `json:"project_id"`
	IsProperty          pgtype.Bool   `json:"is_property"`
	IsPropertyBranch    pgtype.Bool   `json:"is_property_branch"`
	PropertyID          pgtype.Int8   `json:"property_id"`
	IsUnit              pgtype.Bool   `json:"is_unit"`
	UnitID              pgtype.Int8   `json:"unit_id"`
	UnitCategory        pgtype.Text   `json:"unit_category"`
	Price               pgtype.Bool   `json:"price"`
	ExternalCompanyType []int64       `json:"external_company_type"`
	ExternalIsBranch    []pgtype.Bool `json:"external_is_branch"`
	ExternalCompanyID   []int64       `json:"external_company_id"`
	CreatedAt           time.Time     `json:"created_at"`
	CreatedBy           int64         `json:"created_by"`
	PhaseID             pgtype.Int8   `json:"phase_id"`
	ExternalIsEnabled   []pgtype.Bool `json:"external_is_enabled"`
	PropertyKey         pgtype.Int8   `json:"property_key"`
}

func (q *Queries) CreateExternalSharing(ctx context.Context, arg CreateExternalSharingParams) (ExternalSharing, error) {
	row := q.db.QueryRow(ctx, createExternalSharing,
		arg.CompanyTypesID,
		arg.CompaniesID,
		arg.IsBranch,
		arg.IsProject,
		arg.ProjectID,
		arg.IsProperty,
		arg.IsPropertyBranch,
		arg.PropertyID,
		arg.IsUnit,
		arg.UnitID,
		arg.UnitCategory,
		arg.Price,
		arg.ExternalCompanyType,
		arg.ExternalIsBranch,
		arg.ExternalCompanyID,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.PhaseID,
		arg.ExternalIsEnabled,
		arg.PropertyKey,
	)
	var i ExternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.ExternalCompanyType,
		&i.ExternalIsBranch,
		&i.ExternalCompanyID,
		&i.ExternalIsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const createInternalSharing = `-- name: CreateInternalSharing :one
INSERT INTO internal_sharing (
     company_types_id,
     companies_id, 
     is_branch, 
     is_project, 
     project_id,   
     is_property, 
     is_property_branch,
     property_id,  
     is_unit, 
     unit_id,
     unit_category,
     price, 
     shared_to, 
     created_at, 
     created_by,
     phase_id,
     is_enabled,
     property_key
 )VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
 ) RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id
`

type CreateInternalSharingParams struct {
	CompanyTypesID   pgtype.Int8   `json:"company_types_id"`
	CompaniesID      pgtype.Int8   `json:"companies_id"`
	IsBranch         pgtype.Bool   `json:"is_branch"`
	IsProject        pgtype.Bool   `json:"is_project"`
	ProjectID        pgtype.Int8   `json:"project_id"`
	IsProperty       pgtype.Bool   `json:"is_property"`
	IsPropertyBranch pgtype.Bool   `json:"is_property_branch"`
	PropertyID       pgtype.Int8   `json:"property_id"`
	IsUnit           pgtype.Bool   `json:"is_unit"`
	UnitID           pgtype.Int8   `json:"unit_id"`
	UnitCategory     pgtype.Text   `json:"unit_category"`
	Price            pgtype.Bool   `json:"price"`
	SharedTo         []int64       `json:"shared_to"`
	CreatedAt        time.Time     `json:"created_at"`
	CreatedBy        int64         `json:"created_by"`
	PhaseID          pgtype.Int8   `json:"phase_id"`
	IsEnabled        []pgtype.Bool `json:"is_enabled"`
	PropertyKey      pgtype.Int8   `json:"property_key"`
}

func (q *Queries) CreateInternalSharing(ctx context.Context, arg CreateInternalSharingParams) (InternalSharing, error) {
	row := q.db.QueryRow(ctx, createInternalSharing,
		arg.CompanyTypesID,
		arg.CompaniesID,
		arg.IsBranch,
		arg.IsProject,
		arg.ProjectID,
		arg.IsProperty,
		arg.IsPropertyBranch,
		arg.PropertyID,
		arg.IsUnit,
		arg.UnitID,
		arg.UnitCategory,
		arg.Price,
		arg.SharedTo,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.PhaseID,
		arg.IsEnabled,
		arg.PropertyKey,
	)
	var i InternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const createShareDoc = `-- name: CreateShareDoc :one
INSERT INTO shared_doc (
 sharing_id,
 is_internal,
 single_share_docs,
 created_at, 
 updated_at,
 is_project,
 project_id,
 is_property,
 is_property_branch,
 property_id,
 property_key,
 is_unit,
 unit_id,
 unit_category,
 status,
 shared_to,
 is_branch,
 phase_id
)VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,  $15, $16, $17, $18
 ) RETURNING id, sharing_id, is_internal, single_share_docs, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, status, shared_to, is_branch, phase_id, created_at, updated_at
`

type CreateShareDocParams struct {
	SharingID        int64       `json:"sharing_id"`
	IsInternal       pgtype.Bool `json:"is_internal"`
	SingleShareDocs  []int64     `json:"single_share_docs"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	IsProject        pgtype.Bool `json:"is_project"`
	ProjectID        pgtype.Int8 `json:"project_id"`
	IsProperty       pgtype.Bool `json:"is_property"`
	IsPropertyBranch pgtype.Bool `json:"is_property_branch"`
	PropertyID       pgtype.Int8 `json:"property_id"`
	PropertyKey      pgtype.Int8 `json:"property_key"`
	IsUnit           pgtype.Bool `json:"is_unit"`
	UnitID           pgtype.Int8 `json:"unit_id"`
	UnitCategory     pgtype.Text `json:"unit_category"`
	Status           int64       `json:"status"`
	SharedTo         int64       `json:"shared_to"`
	IsBranch         pgtype.Bool `json:"is_branch"`
	PhaseID          pgtype.Int8 `json:"phase_id"`
}

func (q *Queries) CreateShareDoc(ctx context.Context, arg CreateShareDocParams) (SharedDoc, error) {
	row := q.db.QueryRow(ctx, createShareDoc,
		arg.SharingID,
		arg.IsInternal,
		arg.SingleShareDocs,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsProject,
		arg.ProjectID,
		arg.IsProperty,
		arg.IsPropertyBranch,
		arg.PropertyID,
		arg.PropertyKey,
		arg.IsUnit,
		arg.UnitID,
		arg.UnitCategory,
		arg.Status,
		arg.SharedTo,
		arg.IsBranch,
		arg.PhaseID,
	)
	var i SharedDoc
	err := row.Scan(
		&i.ID,
		&i.SharingID,
		&i.IsInternal,
		&i.SingleShareDocs,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Status,
		&i.SharedTo,
		&i.IsBranch,
		&i.PhaseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createShareRequest = `-- name: CreateShareRequest :one
INSERT INTO share_requests (
 document_id,
 request_status,
 requester_id,
 owner_id,
 created_by,
 created_at,
 updated_at

 
) VALUES($1, $2, $3, $4, $5, $6, $7) RETURNING id, document_id, request_status, requester_id, owner_id, created_by, created_at, updated_at
`

type CreateShareRequestParams struct {
	DocumentID    pgtype.Int8        `json:"document_id"`
	RequestStatus int32              `json:"request_status"`
	RequesterID   pgtype.Int8        `json:"requester_id"`
	OwnerID       pgtype.Int8        `json:"owner_id"`
	CreatedBy     pgtype.Int8        `json:"created_by"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateShareRequest(ctx context.Context, arg CreateShareRequestParams) (ShareRequest, error) {
	row := q.db.QueryRow(ctx, createShareRequest,
		arg.DocumentID,
		arg.RequestStatus,
		arg.RequesterID,
		arg.OwnerID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ShareRequest
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.RequestStatus,
		&i.RequesterID,
		&i.OwnerID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSharing = `-- name: CreateSharing :one

INSERT INTO sharing(
  sharing_type,
  entity_type_id,
  entity_id,
  shared_to,
  is_enabled,
  country_id,
  created_at,
  created_by
)VALUES (
   $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, sharing_type, entity_type_id, entity_id, shared_to, is_enabled, country_id, created_at, created_by
`

type CreateSharingParams struct {
	SharingType  int32              `json:"sharing_type"`
	EntityTypeID pgtype.Int8        `json:"entity_type_id"`
	EntityID     int64              `json:"entity_id"`
	SharedTo     int64              `json:"shared_to"`
	IsEnabled    pgtype.Bool        `json:"is_enabled"`
	CountryID    pgtype.Int8        `json:"country_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CreatedBy    pgtype.Int8        `json:"created_by"`
}

// ------------------------------------- Start Sharing  -------------------------------------------------------
func (q *Queries) CreateSharing(ctx context.Context, arg CreateSharingParams) (Sharing, error) {
	row := q.db.QueryRow(ctx, createSharing,
		arg.SharingType,
		arg.EntityTypeID,
		arg.EntityID,
		arg.SharedTo,
		arg.IsEnabled,
		arg.CountryID,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	var i Sharing
	err := row.Scan(
		&i.ID,
		&i.SharingType,
		&i.EntityTypeID,
		&i.EntityID,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CountryID,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createSingleShareDoc = `-- name: CreateSingleShareDoc :one
 INSERT INTO single_share_doc (
 documents_category_id,
 documents_subcategory_id,
 file_url,
 is_allowed
 ) 
 VALUES ($1, $2, $3, $4)
 RETURNING id, documents_category_id, documents_subcategory_id, file_url, is_allowed
`

type CreateSingleShareDocParams struct {
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                string      `json:"file_url"`
	IsAllowed              pgtype.Bool `json:"is_allowed"`
}

func (q *Queries) CreateSingleShareDoc(ctx context.Context, arg CreateSingleShareDocParams) (SingleShareDoc, error) {
	row := q.db.QueryRow(ctx, createSingleShareDoc,
		arg.DocumentsCategoryID,
		arg.DocumentsSubcategoryID,
		arg.FileUrl,
		arg.IsAllowed,
	)
	var i SingleShareDoc
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.IsAllowed,
	)
	return i, err
}

const deleteASharing = `-- name: DeleteASharing :one
WITH sharing_to_delete AS (
    -- First identify the sharing records we want to delete
    SELECT id FROM sharing 
    WHERE sharing.entity_id = $1 AND sharing.entity_type_id = $2
),
documents_to_delete AS (
    -- Find related shared_documents
    SELECT id FROM shared_documents 
    WHERE sharing_id IN (SELECT id FROM sharing_to_delete)
),
delete_requests AS (
    DELETE FROM share_requests
    WHERE document_id IN (SELECT id FROM documents_to_delete)
),
delete_documents AS (
    DELETE FROM shared_documents
    WHERE sharing_id IN (SELECT id FROM sharing_to_delete)
)
DELETE FROM sharing 
WHERE id IN (SELECT id FROM sharing_to_delete)
RETURNING id, sharing_type, entity_type_id, entity_id, shared_to, is_enabled, country_id, created_at, created_by
`

type DeleteASharingParams struct {
	EntityID     int64       `json:"entity_id"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
}

// First delete the share_requests
// Then delete the shared_documents
// Finally delete the sharing record
func (q *Queries) DeleteASharing(ctx context.Context, arg DeleteASharingParams) (Sharing, error) {
	row := q.db.QueryRow(ctx, deleteASharing, arg.EntityID, arg.EntityTypeID)
	var i Sharing
	err := row.Scan(
		&i.ID,
		&i.SharingType,
		&i.EntityTypeID,
		&i.EntityID,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CountryID,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteExternalSharing = `-- name: DeleteExternalSharing :exec
DELETE FROM external_sharing
WHERE
    CASE
        WHEN $1 = 'unit' THEN
            CASE
                WHEN is_unit = $2 AND unit_id = $3 AND created_by = $4 AND unit_category = $5 THEN TRUE
                ELSE FALSE
            END
        WHEN $1 = 'property' THEN
            CASE
                WHEN is_property = $6 AND property_key = $7 AND property_id = $8 AND created_by = $4                 
               
                AND (is_unit IS NULL OR is_unit IS FALSE)
                 THEN TRUE
                ELSE FALSE
            END
        WHEN $1 = 'project_with_phase' THEN
            CASE
                WHEN is_project = $9 AND phase_id = $10 AND project_id = $11 AND created_by = $4
                  AND (is_property IS NULL OR is_property IS FALSE)
                  AND (is_unit IS NULL OR is_unit IS FALSE)
                 THEN TRUE
                ELSE FALSE
            END
        WHEN $1 = 'project_without_phase' THEN
            CASE
                WHEN is_project = $9 AND phase_id IS NULL AND project_id = $11 AND created_by = $4
                  AND (is_property IS NULL OR is_property IS FALSE)
                  AND (is_unit IS NULL OR is_unit IS FALSE)
                 THEN TRUE
                ELSE FALSE
            END
        ELSE FALSE 
  END
`

type DeleteExternalSharingParams struct {
	CheckFor     interface{} `json:"check_for"`
	IsUnit       pgtype.Bool `json:"is_unit"`
	UnitID       pgtype.Int8 `json:"unit_id"`
	UserID       int64       `json:"user_id"`
	UnitCategory pgtype.Text `json:"unit_category"`
	IsProperty   pgtype.Bool `json:"is_property"`
	PropertyKey  pgtype.Int8 `json:"property_key"`
	PropertyID   pgtype.Int8 `json:"property_id"`
	IsProject    pgtype.Bool `json:"is_project"`
	PhaseID      pgtype.Int8 `json:"phase_id"`
	ProjectID    pgtype.Int8 `json:"project_id"`
}

func (q *Queries) DeleteExternalSharing(ctx context.Context, arg DeleteExternalSharingParams) error {
	_, err := q.db.Exec(ctx, deleteExternalSharing,
		arg.CheckFor,
		arg.IsUnit,
		arg.UnitID,
		arg.UserID,
		arg.UnitCategory,
		arg.IsProperty,
		arg.PropertyKey,
		arg.PropertyID,
		arg.IsProject,
		arg.PhaseID,
		arg.ProjectID,
	)
	return err
}

const deleteInternalSharing = `-- name: DeleteInternalSharing :exec
DELETE FROM internal_sharing
WHERE
    CASE
        WHEN $1 = 'unit' THEN
            CASE
                WHEN is_unit = $2 AND unit_id = $3 AND created_by = $4  AND unit_category = $5  THEN TRUE
                ELSE FALSE
            END
        WHEN $1 = 'property' THEN
            CASE
                WHEN is_property = $6 AND property_key = $7 AND property_id = $8 AND created_by = $4 
                  AND (is_unit IS NULL OR is_unit IS FALSE)
                 THEN TRUE
                ELSE FALSE
            END
        WHEN $1 = 'project_with_phase' THEN
            CASE
                WHEN is_project = $9 AND phase_id = $10 AND project_id = $11 AND created_by = $4
                AND (is_property IS NULL OR is_property IS FALSE)
                  AND (is_unit IS NULL OR is_unit IS FALSE)
                 THEN TRUE
                ELSE FALSE
            END
        WHEN $1 = 'project_without_phase' THEN
            CASE
                WHEN is_project = $9 AND phase_id IS NULL AND project_id = $11 AND created_by = $4 
                  AND (is_property IS NULL OR is_property IS FALSE)
                  AND (is_unit IS NULL OR is_unit IS FALSE)
                   THEN TRUE
                ELSE FALSE
            END
        ELSE FALSE
    END
`

type DeleteInternalSharingParams struct {
	CheckFor     interface{} `json:"check_for"`
	IsUnit       pgtype.Bool `json:"is_unit"`
	UnitID       pgtype.Int8 `json:"unit_id"`
	UserID       int64       `json:"user_id"`
	UnitCategory pgtype.Text `json:"unit_category"`
	IsProperty   pgtype.Bool `json:"is_property"`
	PropertyKey  pgtype.Int8 `json:"property_key"`
	PropertyID   pgtype.Int8 `json:"property_id"`
	IsProject    pgtype.Bool `json:"is_project"`
	PhaseID      pgtype.Int8 `json:"phase_id"`
	ProjectID    pgtype.Int8 `json:"project_id"`
}

func (q *Queries) DeleteInternalSharing(ctx context.Context, arg DeleteInternalSharingParams) error {
	_, err := q.db.Exec(ctx, deleteInternalSharing,
		arg.CheckFor,
		arg.IsUnit,
		arg.UnitID,
		arg.UserID,
		arg.UnitCategory,
		arg.IsProperty,
		arg.PropertyKey,
		arg.PropertyID,
		arg.IsProject,
		arg.PhaseID,
		arg.ProjectID,
	)
	return err
}

const deleteProjectPhaseRelatedData = `-- name: DeleteProjectPhaseRelatedData :execrows
WITH deleted_internal_sharing AS (
    DELETE FROM internal_sharing
    WHERE internal_sharing.phase_id = $1
    RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id
),
deleted_shared_doc AS (
    DELETE FROM shared_doc
    WHERE shared_doc.phase_id = $1
    RETURNING id, sharing_id, is_internal, single_share_docs, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, status, shared_to, is_branch, phase_id, created_at, updated_at
),
deleted_external_sharing AS (
    DELETE FROM external_sharing
    WHERE external_sharing.phase_id = $1
    RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id
),
deleted_publish_plan AS (
    DELETE FROM publish_plan
    WHERE publish_plan.publish_listing_id IN (
        SELECT publish_listing.id FROM publish_listing WHERE publish_listing.phase_id = $1
    )
    RETURNING id, publish_listing_id, title, plan_url, updated_at, created_at
),
deleted_publish_gallery AS (
    DELETE FROM publish_gallery
    WHERE publish_gallery.publish_listing_id IN (
        SELECT publish_listing.id FROM publish_listing WHERE publish_listing.phase_id = $1
    )
    RETURNING id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at
),
deleted_publish_listing AS (
    DELETE FROM publish_listing
    WHERE publish_listing.phase_id = $1
    RETURNING id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id
)
SELECT
    (SELECT count(*) FROM deleted_internal_sharing) +
    (SELECT count(*) FROM deleted_shared_doc) +
    (SELECT count(*) FROM deleted_external_sharing) +
    (SELECT count(*) FROM deleted_publish_plan) +
    (SELECT count(*) FROM deleted_publish_gallery) +
    (SELECT count(*) FROM deleted_publish_listing) AS total_deleted
`

func (q *Queries) DeleteProjectPhaseRelatedData(ctx context.Context, phaseID pgtype.Int8) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProjectPhaseRelatedData, phaseID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProjectPropertyRelatedData = `-- name: DeleteProjectPropertyRelatedData :execrows
WITH deleted_internal_sharing AS (
    DELETE FROM internal_sharing
    WHERE 
         internal_sharing.is_property = TRUE   AND
         internal_sharing.project_id = (SELECT MAX(project_id) FROM internal_sharing WHERE internal_sharing.property_id = $1)
    RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id 
),
deleted_shared_doc AS (
    DELETE FROM shared_doc
    WHERE 
       shared_doc.is_property = TRUE AND 
       shared_doc.project_id  = (SELECT MAX(project_id) FROM shared_doc WHERE shared_doc.property_id = $1) 
  RETURNING id, sharing_id, is_internal, single_share_docs, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, status, shared_to, is_branch, phase_id, created_at, updated_at
),
deleted_external_sharing AS (
    DELETE FROM external_sharing
    WHERE 
        external_sharing.is_property = TRUE AND
        external_sharing.project_id = (SELECT MAX(project_id) FROM external_sharing WHERE external_sharing.property_id = $1)
    RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id
),
deleted_publish_plan AS (
    DELETE FROM publish_plan
    WHERE  
    publish_plan.publish_listing_id IN (
        SELECT publish_listing.id FROM publish_listing 
        WHERE 
            publish_listing.is_property = TRUE AND 
            publish_listing.project_id = (SELECT MAX(project_id) FROM publish_listing WHERE  publish_listing.property_id = $1)
    )
    RETURNING id, publish_listing_id, title, plan_url, updated_at, created_at
),
deleted_publish_gallery AS (
    DELETE FROM publish_gallery
    WHERE publish_gallery.publish_listing_id IN (
        SELECT publish_listing.id FROM publish_listing 
        WHERE 
           publish_listing.is_property = TRUE AND
           publish_listing.project_id = (SELECT MAX(project_id) FROM publish_listing WHERE publish_listing.property_id = $1)
    )
    RETURNING id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at
),
deleted_publish_listing AS (
    DELETE FROM publish_listing
    WHERE 
    publish_listing.is_property = TRUE AND 
    publish_listing.project_id = (SELECT MAX(project_id) FROM publish_listing WHERE publish_listing.property_id = $1)
    RETURNING id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id
)
SELECT
    (SELECT count(*) FROM deleted_internal_sharing) +
    (SELECT count(*) FROM deleted_shared_doc) +
    (SELECT count(*) FROM deleted_external_sharing) +
    (SELECT count(*) FROM deleted_publish_plan) +
    (SELECT count(*) FROM deleted_publish_gallery) +
    (SELECT count(*) FROM deleted_publish_listing) AS total_deleted
`

func (q *Queries) DeleteProjectPropertyRelatedData(ctx context.Context, propertyID pgtype.Int8) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProjectPropertyRelatedData, propertyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProjectPropertyUnitRelatedData = `-- name: DeleteProjectPropertyUnitRelatedData :execrows


WITH deleted_internal_sharing AS (
    DELETE FROM internal_sharing
    WHERE internal_sharing.unit_id = $1 AND  internal_sharing.is_unit = TRUE AND internal_sharing.unit_category = $2
    RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id 
),
deleted_shared_doc AS (
    DELETE FROM shared_doc
    WHERE shared_doc.unit_id = $1  AND shared_doc.is_unit = TRUE AND shared_doc.unit_category = $2
    RETURNING id, sharing_id, is_internal, single_share_docs, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, status, shared_to, is_branch, phase_id, created_at, updated_at
),
deleted_external_sharing AS (
    DELETE FROM external_sharing
    WHERE external_sharing.unit_id = $1 AND  external_sharing.is_unit = TRUE AND external_sharing.unit_category = $2
    RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id
),
deleted_publish_plan AS (
    DELETE FROM publish_plan
    WHERE publish_plan.publish_listing_id IN (
        SELECT publish_listing.id FROM publish_listing WHERE publish_listing.unit_id = $1  AND publish_listing.is_unit = TRUE AND publish_listing.unit_category  = $2
    )
    RETURNING id, publish_listing_id, title, plan_url, updated_at, created_at
),
deleted_publish_gallery AS (
    DELETE FROM publish_gallery
    WHERE publish_gallery.publish_listing_id IN (
        SELECT publish_listing.id FROM publish_listing WHERE publish_listing.unit_id = $1 AND publish_listing.is_unit = TRUE AND publish_listing.unit_category  = $2
    )
    RETURNING id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at
),
deleted_publish_listing AS (
    DELETE FROM publish_listing
    WHERE publish_listing.unit_id = $1 AND  publish_listing.is_unit = TRUE AND publish_listing.unit_category = $2
    RETURNING id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id
)
SELECT
    (SELECT count(*) FROM deleted_internal_sharing) +
    (SELECT count(*) FROM deleted_shared_doc) +
    (SELECT count(*) FROM deleted_external_sharing) +
    (SELECT count(*) FROM deleted_publish_plan) +
    (SELECT count(*) FROM deleted_publish_gallery) +
    (SELECT count(*) FROM deleted_publish_listing) AS total_deleted
`

type DeleteProjectPropertyUnitRelatedDataParams struct {
	UnitID       pgtype.Int8 `json:"unit_id"`
	UnitCategory pgtype.Text `json:"unit_category"`
}

// WITH deleted_internal_sharing AS (
//
//	DELETE FROM internal_sharing
//	WHERE
//	     internal_sharing.is_property = TRUE   AND
//	     internal_sharing.project_id = (SELECT project_id FROM internal_sharing WHERE internal_sharing.property_id = $1)
//	RETURNING *
//
// ),
// deleted_shared_doc AS (
//
//	  DELETE FROM shared_doc
//	  WHERE
//	     shared_doc.is_property = TRUE AND
//	     shared_doc.project_id  = (SELECT project_id FROM shared_doc WHERE shared_doc.property_id = $1)
//	RETURNING *
//
// ),
// deleted_external_sharing AS (
//
//	DELETE FROM external_sharing
//	WHERE
//	    external_sharing.is_property = TRUE AND
//	    external_sharing.project_id = (SELECT project_id FROM external_sharing WHERE external_sharing.property_id = $1)
//	RETURNING *
//
// ),
// deleted_publish_plan AS (
//
//	DELETE FROM publish_plan
//	WHERE
//	publish_plan.publish_listing_id IN (
//	    SELECT publish_listing.id FROM publish_listing
//	    WHERE
//	        publish_listing.is_property = TRUE AND
//	        publish_listing.project_id = (SELECT project_id FROM publish_listing WHERE  publish_listing.property_id = $1)
//	)
//	RETURNING *
//
// ),
// deleted_publish_gallery AS (
//
//	DELETE FROM publish_gallery
//	WHERE publish_gallery.publish_listing_id IN (
//	    SELECT publish_listing.id FROM publish_listing
//	    WHERE
//	       publish_listing.is_property = TRUE AND
//	       publish_listing.project_id = (SELECT project_id FROM publish_listing WHERE publish_listing.property_id = $1)
//	)
//	RETURNING *
//
// ),
// deleted_publish_listing AS (
//
//	DELETE FROM publish_listing
//	WHERE
//	publish_listing.is_property = TRUE AND
//	publish_listing.project_id = (SELECT project_id FROM publish_listing WHERE publish_listing.property_id = $1)
//	RETURNING *
//
// )
// SELECT
//
//	(SELECT count(*) FROM deleted_internal_sharing) +
//	(SELECT count(*) FROM deleted_shared_doc) +
//	(SELECT count(*) FROM deleted_external_sharing) +
//	(SELECT count(*) FROM deleted_publish_plan) +
//	(SELECT count(*) FROM deleted_publish_gallery) +
//	(SELECT count(*) FROM deleted_publish_listing) AS total_deleted;
func (q *Queries) DeleteProjectPropertyUnitRelatedData(ctx context.Context, arg DeleteProjectPropertyUnitRelatedDataParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProjectPropertyUnitRelatedData, arg.UnitID, arg.UnitCategory)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProjectRelatedData = `-- name: DeleteProjectRelatedData :execrows
WITH deleted_internal_sharing AS (
    DELETE FROM internal_sharing
    WHERE internal_sharing.project_id = $1
    RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id
),
deleted_shared_doc AS (
    DELETE FROM shared_doc
    WHERE shared_doc.project_id = $1
    RETURNING id, sharing_id, is_internal, single_share_docs, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, status, shared_to, is_branch, phase_id, created_at, updated_at
),
deleted_external_sharing AS (
    DELETE FROM external_sharing
    WHERE external_sharing.project_id = $1
    RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id
),
deleted_publish_plan AS (
    DELETE FROM publish_plan
    WHERE publish_plan.publish_listing_id IN (
        SELECT publish_listing.id FROM publish_listing WHERE publish_listing.project_id = $1
    )
    RETURNING id, publish_listing_id, title, plan_url, updated_at, created_at
),
deleted_publish_gallery AS (
    DELETE FROM publish_gallery
    WHERE publish_gallery.publish_listing_id IN (
        SELECT publish_listing.id FROM publish_listing WHERE publish_listing.project_id = $1
    )
    RETURNING id, publish_listing_id, image_url, image360_url, video_url, panaroma_url, main_media_section, updated_at, created_at
),
deleted_publish_listing AS (
    DELETE FROM publish_listing
    WHERE publish_listing.entity_id = $1 AND publish_listing.entity_type_id= $2::BIGINT
    RETURNING id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id
)
SELECT
    (SELECT count(*) FROM deleted_internal_sharing) +
    (SELECT count(*) FROM deleted_shared_doc) +
    (SELECT count(*) FROM deleted_external_sharing) +
    (SELECT count(*) FROM deleted_publish_plan) +
    (SELECT count(*) FROM deleted_publish_gallery) +
    (SELECT count(*) FROM deleted_publish_listing) AS total_deleted
`

type DeleteProjectRelatedDataParams struct {
	ProjectID           pgtype.Int8 `json:"project_id"`
	ProjectEntityTypeID int64       `json:"project_entity_type_id"`
}

func (q *Queries) DeleteProjectRelatedData(ctx context.Context, arg DeleteProjectRelatedDataParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProjectRelatedData, arg.ProjectID, arg.ProjectEntityTypeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProjectSharedDoc = `-- name: DeleteProjectSharedDoc :exec
DELETE FROM shared_doc
WHERE project_id = $1
`

func (q *Queries) DeleteProjectSharedDoc(ctx context.Context, projectID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteProjectSharedDoc, projectID)
	return err
}

const getASharing = `-- name: GetASharing :one


SELECT id, sharing_type, entity_type_id, entity_id, shared_to, is_enabled, country_id, created_at, created_by FROM sharing 
WHERE sharing.entity_type_id = $1 AND sharing.entity_id = $2 LIMIT 1
`

type GetASharingParams struct {
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	EntityID     int64       `json:"entity_id"`
}

// SELECT * FROM sharing
// WHERE
//
//	CASE WHEN @created_by::bigint=0 THEN true ELSE sharing.created_by = @created_by::bigint END
//	AND CASE WHEN @user_id::bigint=0 THEN true ELSE sharing.shared_to = @user_id::bigint END
//
// AND sharing.entity_type_id = @entity_type_id LIMIT $1 OFFSET $2;
func (q *Queries) GetASharing(ctx context.Context, arg GetASharingParams) (Sharing, error) {
	row := q.db.QueryRow(ctx, getASharing, arg.EntityTypeID, arg.EntityID)
	var i Sharing
	err := row.Scan(
		&i.ID,
		&i.SharingType,
		&i.EntityTypeID,
		&i.EntityID,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CountryID,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getAddressByUser = `-- name: GetAddressByUser :one
SELECT addresses.id, addresses.countries_id, addresses.states_id, addresses.cities_id, addresses.communities_id, addresses.sub_communities_id, addresses.locations_id, addresses.created_at, addresses.updated_at, addresses.property_map_location_id, addresses.full_address, addresses.full_address_ar FROM addresses
LEFT JOIN profiles ON profiles.addresses_id = addresses.id
LEFT JOIN users ON users.id = profiles.users_id
WHERE users.id = $1
`

func (q *Queries) GetAddressByUser(ctx context.Context, id int64) (Address, error) {
	row := q.db.QueryRow(ctx, getAddressByUser, id)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunitiesID,
		&i.SubCommunitiesID,
		&i.LocationsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyMapLocationID,
		&i.FullAddress,
		&i.FullAddressAr,
	)
	return i, err
}

const getAll = `-- name: GetAll :many
SELECT id, ref_no, unit_category_id, is_branch, project_id, phase_id, properties_id, is_verified, property_unit_rank, broker_company_agents_id, sale_title, sale_title_ar, rent_title, rent_title_ar, booking_title, booking_title_ar, description, description_ar, notes, notes_ar, notes_public, countries_id, addresses_id, property_types_id, property_type_name, unit_no, unitno_is_public, amenities_id, facilities_id, available_for, completion_status, service_charge, investment, contract_start_date, contract_end_date, rent_type, no_of_payments, is_request_video, from_xml, users_id, owners_user_id, created_at, updated_at, status, tags_id FROM project_property_units LIMIT $1 OFFSET $2
`

type GetAllParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAll(ctx context.Context, arg GetAllParams) ([]ProjectPropertyUnit, error) {
	rows, err := q.db.Query(ctx, getAll, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectPropertyUnit
	for rows.Next() {
		var i ProjectPropertyUnit
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.UnitCategoryID,
			&i.IsBranch,
			&i.ProjectID,
			&i.PhaseID,
			&i.PropertiesID,
			&i.IsVerified,
			&i.PropertyUnitRank,
			&i.BrokerCompanyAgentsID,
			&i.SaleTitle,
			&i.SaleTitleAr,
			&i.RentTitle,
			&i.RentTitleAr,
			&i.BookingTitle,
			&i.BookingTitleAr,
			&i.Description,
			&i.DescriptionAr,
			&i.Notes,
			&i.NotesAr,
			&i.NotesPublic,
			&i.CountriesID,
			&i.AddressesID,
			&i.PropertyTypesID,
			&i.PropertyTypeName,
			&i.UnitNo,
			&i.UnitnoIsPublic,
			&i.AmenitiesID,
			&i.FacilitiesID,
			&i.AvailableFor,
			&i.CompletionStatus,
			&i.ServiceCharge,
			&i.Investment,
			&i.ContractStartDate,
			&i.ContractEndDate,
			&i.RentType,
			&i.NoOfPayments,
			&i.IsRequestVideo,
			&i.FromXml,
			&i.UsersID,
			&i.OwnersUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.TagsID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyFromSharing = `-- name: GetAllCompanyFromSharing :many
SELECT DISTINCT ON  (companies.id) sharing.shared_to, sharing.country_id, sharing.is_enabled, sharing.sharing_type,
	companies.company_name, companies.logo_url, countries.country, countries."flag"
FROM sharing
INNER JOIN companies ON sharing.shared_to = companies.id
LEFT JOIN countries ON sharing.country_id = countries.id
Where sharing.sharing_type = 2 AND sharing.entity_id = $1
`

type GetAllCompanyFromSharingRow struct {
	SharedTo    int64       `json:"shared_to"`
	CountryID   pgtype.Int8 `json:"country_id"`
	IsEnabled   pgtype.Bool `json:"is_enabled"`
	SharingType int32       `json:"sharing_type"`
	CompanyName string      `json:"company_name"`
	LogoUrl     string      `json:"logo_url"`
	Country     pgtype.Text `json:"country"`
	Flag        pgtype.Text `json:"flag"`
}

func (q *Queries) GetAllCompanyFromSharing(ctx context.Context, entityID int64) ([]GetAllCompanyFromSharingRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyFromSharing, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyFromSharingRow
	for rows.Next() {
		var i GetAllCompanyFromSharingRow
		if err := rows.Scan(
			&i.SharedTo,
			&i.CountryID,
			&i.IsEnabled,
			&i.SharingType,
			&i.CompanyName,
			&i.LogoUrl,
			&i.Country,
			&i.Flag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllInternalSharing = `-- name: GetAllInternalSharing :many




SELECT project_id,'internal' AS internal, CASE WHEN $3::bigint = created_by THEN true ELSE false END AS unshared_available FROM internal_sharing 
Where is_project = true AND phase_id IS NULL AND CASE WHEN $3::bigint = 0 THEN true ELSE $3::bigint  =  ANY(shared_to) END
ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type GetAllInternalSharingParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	UserID int64 `json:"user_id"`
}

type GetAllInternalSharingRow struct {
	ProjectID         pgtype.Int8 `json:"project_id"`
	Internal          string      `json:"internal"`
	UnsharedAvailable pgtype.Bool `json:"unshared_available"`
}

// SELECT * FROM external_sharing
// WHERE
// CASE
// WHEN is_project = TRUE AND phase_id IS NULL AND project_id = $1
// THEN TRUE
// ELSE is_project = TRUE AND phase_id = $2 AND project_id = $1
// END;
func (q *Queries) GetAllInternalSharing(ctx context.Context, arg GetAllInternalSharingParams) ([]GetAllInternalSharingRow, error) {
	rows, err := q.db.Query(ctx, getAllInternalSharing, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllInternalSharingRow
	for rows.Next() {
		var i GetAllInternalSharingRow
		if err := rows.Scan(&i.ProjectID, &i.Internal, &i.UnsharedAvailable); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPhaseSharing = `-- name: GetAllProjectPhaseSharing :many

WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        phase_id
    FROM
        external_sharing
    INNER JOIN
        users  ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = true
          AND external_sharing.phase_id IS NOT NULL
          AND (external_sharing.is_property IS NULL OR  external_sharing.is_property IS FALSE)
         AND (external_sharing.is_unit IS NULL OR external_sharing.is_unit IS FALSE) 
         AND CASE WHEN $3::bigint = 0 THEN true ELSE  $3::bigint =  created_by  END     
    UNION ALL
        
  SELECT
        internal_sharing.project_id as project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        phase_id
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
    Where internal_sharing.is_project = true 
    AND internal_sharing.phase_id IS NOT NULL
    AND (internal_sharing.is_property IS NULL OR  internal_sharing.is_property IS FALSE)
    AND (internal_sharing.is_unit IS NULL OR internal_sharing.is_unit IS FALSE) 
    -- AND CASE WHEN @user_id::bigint = 0 THEN true ELSE @user_id::bigint = ANY(shared_to) END
    AND CASE WHEN $3::bigint = 0 THEN true ELSE  $3::bigint =  created_by  END 
)
SELECT
    x.external_id,
    x.project_id,
    x.created_by,
    MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = x.created_by THEN true ELSE false END AS unshared_available,
    x.phase_id,
    x.created_at
FROM 
    x
  INNER JOIN projects p ON x.project_id = p.id
    -- other joins 
  INNER JOIN phases ON p.id = phases.projects_id
  INNER JOIN phases_facts ON phases.id = phases_facts.phases_id
  INNER JOIN companies ON p.developer_companies_id = companies.id
  
WHERE   
     (
      $4 = '%%'
      OR  phases.ref_no ILIKE $4
      OR p.project_name ILIKE $4
      OR companies.company_name ILIKE $4
      OR phases.phase_name ILIKE $4
       OR (CASE 
        WHEN 'ready' ILIKE $4 THEN phases_facts.completion_status = 5
        WHEN 'off plan'ILIKE $4  THEN phases_facts.completion_status = 4
        WHEN '^[0-9]+$' ~ $4  THEN phases_facts.completion_percentage::TEXT % $4
        ELSE FALSE
      END)
     )   
   ---------------------     
   AND  p.status NOT IN (5, 6)
GROUP BY
    x.project_id,
    x.created_by,
    x.external_id,
    x.created_at,
    x.phase_id
    ORDER BY created_at DESC
    LIMIT $1 OFFSET $2
`

type GetAllProjectPhaseSharingParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	UserID int64       `json:"user_id"`
	Search interface{} `json:"search"`
}

type GetAllProjectPhaseSharingRow struct {
	ExternalID        int64       `json:"external_id"`
	ProjectID         pgtype.Int8 `json:"project_id"`
	CreatedBy         int64       `json:"created_by"`
	Internal          string      `json:"internal"`
	External          string      `json:"external"`
	UnsharedAvailable pgtype.Bool `json:"unshared_available"`
	PhaseID           pgtype.Int8 `json:"phase_id"`
	CreatedAt         time.Time   `json:"created_at"`
}

// ------------------------------------------------
//
//	AND CASE WHEN @company_id::bigint = 0 THEN true ELSE @company_id::bigint = ANY(external_company_id) END
//	AND CASE WHEN @is_branch_id::bigint = 0 THEN true ELSE  @is_branch::bool = ANY(external_is_branch)  END
//	AND CASE WHEN @company_type::bigint = 0 THEN true ELSE @company_type::bigint = ANY(external_company_type) END
func (q *Queries) GetAllProjectPhaseSharing(ctx context.Context, arg GetAllProjectPhaseSharingParams) ([]GetAllProjectPhaseSharingRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPhaseSharing,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPhaseSharingRow
	for rows.Next() {
		var i GetAllProjectPhaseSharingRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.ProjectID,
			&i.CreatedBy,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
			&i.PhaseID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectSharing = `-- name: GetAllProjectSharing :many
WITH x AS (
    SELECT
        external_sharing.id as share_id,
        external_sharing.external_company_id as company_ids,
        external_sharing.project_id AS project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.external_is_enabled AS is_enabled,
        external_sharing.id AS external_id
    FROM
        external_sharing
        INNER JOIN users ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = TRUE
        AND external_sharing.phase_id IS NULL
        AND (external_sharing.is_property IS NULL OR external_sharing.is_property IS FALSE)
        AND (external_sharing.is_unit IS NULL OR external_sharing.is_unit IS FALSE)
        -- AND CASE WHEN @company_id::bigint = 0 THEN TRUE ELSE @company_id::bigint = ANY (external_company_id) END
        -- AND CASE WHEN @is_branch_id::bigint = 0 THEN TRUE ELSE @is_branch::bool = ANY (external_is_branch) END
        -- AND CASE WHEN @company_type::bigint = 0 THEN TRUE ELSE @company_type::bigint = ANY(external_company_type) END
        AND CASE WHEN $3::bigint = 0 THEN true ELSE  $3::bigint =  created_by  END
    UNION ALL
    SELECT
        internal_sharing.id as share_id,
        internal_sharing.shared_to as company_ids,
        internal_sharing.project_id AS project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        internal_sharing.is_enabled AS is_enabled,
        0 AS external_id
    FROM
        internal_sharing
        INNER JOIN users u ON u.id = internal_sharing.created_by
    WHERE
        internal_sharing.is_project = TRUE
        AND internal_sharing.phase_id IS NULL
        AND (internal_sharing.is_property IS NULL OR internal_sharing.is_property IS FALSE)
        AND (internal_sharing.is_unit IS NULL OR internal_sharing.is_unit IS FALSE)
        -- AND CASE WHEN @user_id::bigint = 0 THEN TRUE ELSE @user_id::bigint = ANY (shared_to) END
        AND CASE WHEN $3::bigint = 0 THEN true ELSE  $3::bigint =  created_by  END
)
SELECT
    x.share_id,
    x.company_ids,
    x.external_id,
    x.project_id,
    x.created_by,
    MAX(CASE WHEN x.source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN x.source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = x.created_by THEN TRUE ELSE FALSE END AS unshared_available,
    x.created_at,
    x.is_enabled
FROM
    x
    LEFT JOIN projects p ON x.project_id = p.id
    LEFT JOIN addresses ON p.addresses_id = addresses.id 
    LEFT JOIN countries ON addresses.countries_id = countries.id  
    LEFT JOIN states ON addresses.states_id = states.id   
    LEFT JOIN cities ON addresses.cities_id = cities.id    
    LEFT JOIN companies ON p.developer_companies_id = companies.id    
    LEFT JOIN properties_facts ON p.id = properties_facts.project_id AND properties_facts.is_project_fact = true  
WHERE
 -- Search criteria
    ($4 = '%%' OR 
     p.project_name % $4 OR 
     p.ref_number % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     companies.company_name % $4  
      OR (CASE 
        WHEN 'ready' ILIKE $4 THEN properties_facts.completion_status = 5
        WHEN 'off plan' ILIKE $4  THEN properties_facts.completion_status = 4
        WHEN '^[0-9]+$' ~ $4  THEN properties_facts.completion_percentage::TEXT % $4
        WHEN 'draft' ILIKE $4  THEN p.status = 1
        WHEN 'available' ILIKE $4  THEN p.status = 2
        WHEN 'block' ILIKE $4  THEN p.status = 5
        WHEN 'single' ILIKE $4  THEN p.is_multiphase = false
        WHEN 'multiple' ILIKE $4  THEN p.is_multiphase = true 
        ELSE FALSE
      END)
      )
AND 
    p.status NOT IN (5, 6)
GROUP BY
    x.share_id,
    x.company_ids,
    x.project_id,
    x.created_by,
    x.external_id,
    x.created_at,
    x.is_enabled
ORDER BY
    x.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllProjectSharingParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	UserID int64       `json:"user_id"`
	Search interface{} `json:"search"`
}

type GetAllProjectSharingRow struct {
	ShareID           int64         `json:"share_id"`
	CompanyIds        []int64       `json:"company_ids"`
	ExternalID        int64         `json:"external_id"`
	ProjectID         pgtype.Int8   `json:"project_id"`
	CreatedBy         int64         `json:"created_by"`
	Internal          string        `json:"internal"`
	External          string        `json:"external"`
	UnsharedAvailable pgtype.Bool   `json:"unshared_available"`
	CreatedAt         time.Time     `json:"created_at"`
	IsEnabled         []pgtype.Bool `json:"is_enabled"`
}

func (q *Queries) GetAllProjectSharing(ctx context.Context, arg GetAllProjectSharingParams) ([]GetAllProjectSharingRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectSharing,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectSharingRow
	for rows.Next() {
		var i GetAllProjectSharingRow
		if err := rows.Scan(
			&i.ShareID,
			&i.CompanyIds,
			&i.ExternalID,
			&i.ProjectID,
			&i.CreatedBy,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
			&i.CreatedAt,
			&i.IsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllShareDocuments = `-- name: GetAllShareDocuments :many
SELECT 
    jsonb_agg(
      subcategory.*
    ) AS subcategorized_documents
FROM (
    SELECT 
   	documents_category.id AS category_id,
    documents_category.category AS category,
    documents_category.category_ar AS category_ar,
        documents_subcategory.id AS subcategory_id,
        documents_subcategory.sub_category,
        documents_subcategory.sub_category_ar,
        jsonb_agg(
          shared_documents.*
        ) AS documents
    FROM shared_documents
    INNER JOIN sharing ON sharing.id = shared_documents.sharing_id
    INNER JOIN documents_category ON documents_category.id = shared_documents.category_id
    INNER JOIN documents_subcategory ON documents_subcategory.id = shared_documents.subcategory_id
    WHERE shared_documents.sharing_id = $1
    GROUP BY documents_subcategory.id, documents_category.id
) subcategory
`

func (q *Queries) GetAllShareDocuments(ctx context.Context, sharingID pgtype.Int8) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getAllShareDocuments, sharingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var subcategorized_documents []byte
		if err := rows.Scan(&subcategorized_documents); err != nil {
			return nil, err
		}
		items = append(items, subcategorized_documents)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedDocsBySharingId = `-- name: GetAllSharedDocsBySharingId :many
SELECT shared_documents.id, shared_documents.sharing_id, shared_documents.category_id, shared_documents.subcategory_id, shared_documents.file_url, shared_documents.status, shared_documents.is_allowed, shared_documents.created_at, shared_documents.updated_at  FROM shared_documents
INNER JOIN sharing ON sharing.id = shared_documents.sharing_id
WHERE sharing.id = $1
`

func (q *Queries) GetAllSharedDocsBySharingId(ctx context.Context, id int64) ([]SharedDocument, error) {
	rows, err := q.db.Query(ctx, getAllSharedDocsBySharingId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SharedDocument
	for rows.Next() {
		var i SharedDocument
		if err := rows.Scan(
			&i.ID,
			&i.SharingID,
			&i.CategoryID,
			&i.SubcategoryID,
			&i.FileUrl,
			&i.Status,
			&i.IsAllowed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedDocuments = `-- name: GetAllSharedDocuments :many


SELECT
    shared_doc.id, shared_doc.sharing_id, shared_doc.is_internal, shared_doc.single_share_docs, shared_doc.is_project, shared_doc.project_id, shared_doc.is_property, shared_doc.is_property_branch, shared_doc.property_id, shared_doc.property_key, shared_doc.is_unit, shared_doc.unit_id, shared_doc.unit_category, shared_doc.status, shared_doc.shared_to, shared_doc.is_branch, shared_doc.phase_id, shared_doc.created_at, shared_doc.updated_at,
    documents_category.category,
    documents_category.category_ar,
    documents_subcategory.sub_category,
    documents_subcategory.sub_category_ar,
    single_share_doc.file_url,
    CASE WHEN $1 = 'unit' THEN
        CASE WHEN shared_doc.is_unit = $2
            AND shared_doc.unit_id = $3 AND shared_doc.unit_category = $4 THEN
            'Unit query executed'
        ELSE
            'No matching condition'
        END
    WHEN $1 = 'property' THEN
        CASE WHEN shared_doc.is_property = $5
            AND shared_doc.property_key = $6 
            AND (shared_doc.is_unit IS NULL OR shared_doc.is_unit IS FALSE) THEN 
            'Property query executed'
        ELSE
            'No matching condition'
        END
    WHEN $1 = 'project_with_phase' THEN
        CASE WHEN shared_doc.project_id = $7
            AND shared_doc.phase_id = $8 THEN
            'Project with phase query executed'
        ELSE
            'No matching condition'
        END
    WHEN $1 = 'project_without_phase' THEN
        CASE WHEN shared_doc.project_id = $7
            AND shared_doc.phase_id IS NULL THEN
            'Project without phase query executed'
        ELSE
            'No matching condition'
        END
    ELSE
        'Invalid check_for parameter'
    END AS query_executed
FROM
    shared_doc
LEFT JOIN LATERAL unnest(shared_doc.single_share_docs) AS unnested_id ON TRUE
LEFT JOIN single_share_doc ON single_share_doc.id = unnested_id
LEFT JOIN documents_category ON documents_category.id = single_share_doc.documents_category_id
LEFT JOIN documents_subcategory ON documents_subcategory.id = single_share_doc.documents_subcategory_id
WHERE
    shared_doc.is_internal = $9
    AND shared_doc.is_branch = $10
    AND shared_doc.shared_to = $11
    AND single_share_doc.is_allowed IS TRUE
    AND (
        CASE WHEN $1 = 'unit' THEN
            CASE WHEN shared_doc.is_unit = $2
                AND shared_doc.unit_id = $3 AND shared_doc.unit_category = $4 THEN
                TRUE
            ELSE
                FALSE
            END
        WHEN $1 = 'property' THEN
            CASE WHEN shared_doc.is_property = $5
                AND shared_doc.property_id = $12 
                AND shared_doc.property_key = $6 AND (shared_doc.is_unit IS NULL OR shared_doc.is_unit IS FALSE) THEN
                TRUE
            ELSE
                FALSE
            END
        WHEN $1 = 'project_with_phase' THEN
            CASE WHEN shared_doc.project_id = $7
                AND shared_doc.phase_id = $8 THEN
                TRUE
            ELSE
                FALSE
            END
        WHEN $1 = 'project_without_phase' THEN
            CASE WHEN shared_doc.project_id = $7
                AND shared_doc.phase_id IS NULL THEN
                TRUE
            ELSE
                FALSE
            END
        ELSE
            FALSE
        END
)
`

type GetAllSharedDocumentsParams struct {
	CheckFor     interface{} `json:"check_for"`
	IsUnit       pgtype.Bool `json:"is_unit"`
	UnitID       pgtype.Int8 `json:"unit_id"`
	UnitCategory pgtype.Text `json:"unit_category"`
	IsProperty   pgtype.Bool `json:"is_property"`
	PropertyKey  pgtype.Int8 `json:"property_key"`
	ProjectID    pgtype.Int8 `json:"project_id"`
	PhaseID      pgtype.Int8 `json:"phase_id"`
	IsInternal   pgtype.Bool `json:"is_internal"`
	IsBranch     pgtype.Bool `json:"is_branch"`
	SharedTo     int64       `json:"shared_to"`
	PropertyID   pgtype.Int8 `json:"property_id"`
}

type GetAllSharedDocumentsRow struct {
	ID               int64       `json:"id"`
	SharingID        int64       `json:"sharing_id"`
	IsInternal       pgtype.Bool `json:"is_internal"`
	SingleShareDocs  []int64     `json:"single_share_docs"`
	IsProject        pgtype.Bool `json:"is_project"`
	ProjectID        pgtype.Int8 `json:"project_id"`
	IsProperty       pgtype.Bool `json:"is_property"`
	IsPropertyBranch pgtype.Bool `json:"is_property_branch"`
	PropertyID       pgtype.Int8 `json:"property_id"`
	PropertyKey      pgtype.Int8 `json:"property_key"`
	IsUnit           pgtype.Bool `json:"is_unit"`
	UnitID           pgtype.Int8 `json:"unit_id"`
	UnitCategory     pgtype.Text `json:"unit_category"`
	Status           int64       `json:"status"`
	SharedTo         int64       `json:"shared_to"`
	IsBranch         pgtype.Bool `json:"is_branch"`
	PhaseID          pgtype.Int8 `json:"phase_id"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Category         pgtype.Text `json:"category"`
	CategoryAr       pgtype.Text `json:"category_ar"`
	SubCategory      pgtype.Text `json:"sub_category"`
	SubCategoryAr    pgtype.Text `json:"sub_category_ar"`
	FileUrl          pgtype.Text `json:"file_url"`
	QueryExecuted    string      `json:"query_executed"`
}

// -- name: GetAllSharedDocuments :many
// SELECT
//
//		shared_doc.*,
//		documents_category.category,
//		documents_subcategory.sub_category,
//		CASE WHEN @check_for = 'unit' THEN
//			CASE WHEN is_unit = @is_unit
//				AND unit_id = @unit_id  AND unit_category = @unit_category THEN
//				'Unit query executed'
//			ELSE
//				'No matching condition'
//			END
//		WHEN @check_for = 'property' THEN
//			CASE WHEN is_property = @is_property
//				AND property_key = @property_key
//	      AND (is_unit IS NULL  OR is_unit IS FALSE) THEN
//				'Property query executed'
//			ELSE
//				'No matching condition'
//			END
//		WHEN @check_for = 'project_with_phase' THEN
//			CASE WHEN project_id = @project_id
//				AND phase_id = @phase_id THEN
//				'Project with phase query executed'
//			ELSE
//				'No matching condition'
//			END
//		WHEN @check_for = 'project_without_phase' THEN
//			CASE WHEN project_id = @project_id
//				AND phase_id IS NULL THEN
//				'Project without phase query executed'
//			ELSE
//				'No matching condition'
//			END
//		ELSE
//			'Invalid check_for parameter'
//		END AS query_executed
//
// FROM
//
//		shared_doc
//	  LEFT JOIN single_share_doc ON shared_doc.single_share_docs = ANY(single_share_doc.id)
//		LEFT JOIN documents_category ON documents_category.id = single_share_doc.documents_category_id
//		LEFT JOIN documents_subcategory ON documents_subcategory.id = single_share_doc.documents_subcategory_id
//
// WHERE
//
//		is_internal = @is_internal
//		AND is_branch = @is_branch
//		AND shared_to = @shared_to
//		AND(
//			CASE WHEN @check_for = 'unit' THEN
//				CASE WHEN is_unit = @is_unit
//					AND unit_id = @unit_id AND unit_category  = @unit_category THEN
//					TRUE
//				ELSE
//					FALSE
//				END
//			WHEN @check_for = 'property' THEN
//	 			CASE WHEN is_property = @is_property
//	         AND property_id = @property_id
//					AND property_key = @property_key   AND (is_unit IS NULL  OR is_unit IS FALSE) THEN
//					TRUE
//				ELSE
//					FALSE
//				END
//			WHEN @check_for = 'project_with_phase' THEN
//				CASE WHEN project_id = @project_id
//					AND phase_id = @phase_id THEN
//					TRUE
//				ELSE
//					FALSE
//				END
//			WHEN @check_for = 'project_without_phase' THEN
//				CASE WHEN project_id = @project_id
//					AND phase_id IS NULL THEN
//					TRUE
//				ELSE
//					FALSE
//				END
//			ELSE
//				FALSE
//			END
//
// );
func (q *Queries) GetAllSharedDocuments(ctx context.Context, arg GetAllSharedDocumentsParams) ([]GetAllSharedDocumentsRow, error) {
	rows, err := q.db.Query(ctx, getAllSharedDocuments,
		arg.CheckFor,
		arg.IsUnit,
		arg.UnitID,
		arg.UnitCategory,
		arg.IsProperty,
		arg.PropertyKey,
		arg.ProjectID,
		arg.PhaseID,
		arg.IsInternal,
		arg.IsBranch,
		arg.SharedTo,
		arg.PropertyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSharedDocumentsRow
	for rows.Next() {
		var i GetAllSharedDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.SharingID,
			&i.IsInternal,
			&i.SingleShareDocs,
			&i.IsProject,
			&i.ProjectID,
			&i.IsProperty,
			&i.IsPropertyBranch,
			&i.PropertyID,
			&i.PropertyKey,
			&i.IsUnit,
			&i.UnitID,
			&i.UnitCategory,
			&i.Status,
			&i.SharedTo,
			&i.IsBranch,
			&i.PhaseID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Category,
			&i.CategoryAr,
			&i.SubCategory,
			&i.SubCategoryAr,
			&i.FileUrl,
			&i.QueryExecuted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedDocumentsByEntityTypeAndEntityID = `-- name: GetAllSharedDocumentsByEntityTypeAndEntityID :many
SELECT shared_documents.id, sharing_id, category_id, subcategory_id, file_url, status, is_allowed, shared_documents.created_at, updated_at, sharing.id, sharing_type, entity_type_id, entity_id, shared_to, is_enabled, country_id, sharing.created_at, created_by  FROM shared_documents
INNER JOIN sharing ON sharing.id = shared_documents.sharing_id
WHERE 
   CASE WHEN $1=0 THEN true ELSE sharing.created_by = $1 END
   AND CASE WHEN $2=0 THEN true ELSE sharing.shared_to = $2 END 
AND sharing.entity_type_id = $3 AND sharing.entity_id = $4
`

type GetAllSharedDocumentsByEntityTypeAndEntityIDParams struct {
	CreatedBy    interface{} `json:"created_by"`
	SharedTo     interface{} `json:"shared_to"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	EntityID     int64       `json:"entity_id"`
}

type GetAllSharedDocumentsByEntityTypeAndEntityIDRow struct {
	ID            int64              `json:"id"`
	SharingID     pgtype.Int8        `json:"sharing_id"`
	CategoryID    pgtype.Int8        `json:"category_id"`
	SubcategoryID pgtype.Int8        `json:"subcategory_id"`
	FileUrl       string             `json:"file_url"`
	Status        pgtype.Int4        `json:"status"`
	IsAllowed     pgtype.Bool        `json:"is_allowed"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ID_2          int64              `json:"id_2"`
	SharingType   int32              `json:"sharing_type"`
	EntityTypeID  pgtype.Int8        `json:"entity_type_id"`
	EntityID      int64              `json:"entity_id"`
	SharedTo      int64              `json:"shared_to"`
	IsEnabled     pgtype.Bool        `json:"is_enabled"`
	CountryID     pgtype.Int8        `json:"country_id"`
	CreatedAt_2   pgtype.Timestamptz `json:"created_at_2"`
	CreatedBy     pgtype.Int8        `json:"created_by"`
}

func (q *Queries) GetAllSharedDocumentsByEntityTypeAndEntityID(ctx context.Context, arg GetAllSharedDocumentsByEntityTypeAndEntityIDParams) ([]GetAllSharedDocumentsByEntityTypeAndEntityIDRow, error) {
	rows, err := q.db.Query(ctx, getAllSharedDocumentsByEntityTypeAndEntityID,
		arg.CreatedBy,
		arg.SharedTo,
		arg.EntityTypeID,
		arg.EntityID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSharedDocumentsByEntityTypeAndEntityIDRow
	for rows.Next() {
		var i GetAllSharedDocumentsByEntityTypeAndEntityIDRow
		if err := rows.Scan(
			&i.ID,
			&i.SharingID,
			&i.CategoryID,
			&i.SubcategoryID,
			&i.FileUrl,
			&i.Status,
			&i.IsAllowed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.SharingType,
			&i.EntityTypeID,
			&i.EntityID,
			&i.SharedTo,
			&i.IsEnabled,
			&i.CountryID,
			&i.CreatedAt_2,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedPhases = `-- name: GetAllSharedPhases :many
WITH x AS (
    SELECT project_id,phase_id, 'external' as source, created_at,created_by FROM external_sharing
    Where is_project = true AND phase_id IS NOT NULL 
    AND CASE WHEN $4::bigint = 0 THEN true ELSE $4::bigint = ANY(external_company_id) END 
    AND CASE WHEN $5::bigint = 0 THEN true ELSE  $6::bool = ANY(external_is_branch)  END
    AND CASE WHEN $7::bigint = 0 THEN true ELSE $7::bigint = ANY(external_company_type) END  
    UNION ALL
    SELECT project_id,phase_id, 'internal' as source, created_at,created_by FROM internal_sharing
    Where is_project = true AND phase_id IS NOT NULL AND CASE WHEN $3::bigint = 0 THEN true ELSE $3::bigint = ANY(shared_to) END 
)
SELECT
    project_id,phase_id,
    MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = created_by THEN true ELSE false END AS unshared_available
FROM x
GROUP BY project_id,phase_id,created_by
LIMIT $1 OFFSET $2
`

type GetAllSharedPhasesParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	UserID      int64       `json:"user_id"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
}

type GetAllSharedPhasesRow struct {
	ProjectID         pgtype.Int8 `json:"project_id"`
	PhaseID           pgtype.Int8 `json:"phase_id"`
	Internal          string      `json:"internal"`
	External          string      `json:"external"`
	UnsharedAvailable pgtype.Bool `json:"unshared_available"`
}

func (q *Queries) GetAllSharedPhases(ctx context.Context, arg GetAllSharedPhasesParams) ([]GetAllSharedPhasesRow, error) {
	rows, err := q.db.Query(ctx, getAllSharedPhases,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSharedPhasesRow
	for rows.Next() {
		var i GetAllSharedPhasesRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.PhaseID,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedWithCompany = `-- name: GetAllSharedWithCompany :many
SELECT id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url FROM companies 
Where id = ANY($1::bigint[])
`

func (q *Queries) GetAllSharedWithCompany(ctx context.Context, userOrCompaniesID []int64) ([]Company, error) {
	rows, err := q.db.Query(ctx, getAllSharedWithCompany, userOrCompaniesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CompanyName,
			&i.CompanyActivitiesID,
			&i.CompanyParentID,
			&i.TagLine,
			&i.Description,
			&i.DescriptionAr,
			&i.LogoUrl,
			&i.Email,
			&i.PhoneNumber,
			&i.WhatsappNumber,
			&i.IsVerified,
			&i.WebsiteUrl,
			&i.CoverImageUrl,
			&i.NoOfEmployees,
			&i.CompanyRank,
			&i.Status,
			&i.CompanyType,
			&i.AddressesID,
			&i.UsersID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.LocationUrl,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedWithUsers = `-- name: GetAllSharedWithUsers :many
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users Where id = ANY($1::bigint[])
`

func (q *Queries) GetAllSharedWithUsers(ctx context.Context, userOrCompaniesID []int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllSharedWithUsers, userOrCompaniesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharingByEntityIDAndType = `-- name: GetAllSharingByEntityIDAndType :many
SELECT id, sharing_type, entity_type_id, entity_id, shared_to, is_enabled, country_id, created_at, created_by FROM sharing 
WHERE sharing.entity_type_id = $1 AND sharing.entity_id = $2
`

type GetAllSharingByEntityIDAndTypeParams struct {
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	EntityID     int64       `json:"entity_id"`
}

func (q *Queries) GetAllSharingByEntityIDAndType(ctx context.Context, arg GetAllSharingByEntityIDAndTypeParams) ([]Sharing, error) {
	rows, err := q.db.Query(ctx, getAllSharingByEntityIDAndType, arg.EntityTypeID, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sharing
	for rows.Next() {
		var i Sharing
		if err := rows.Scan(
			&i.ID,
			&i.SharingType,
			&i.EntityTypeID,
			&i.EntityID,
			&i.SharedTo,
			&i.IsEnabled,
			&i.CountryID,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSingleShareDoc = `-- name: GetAllSingleShareDoc :many
SELECT single_share_doc.id, single_share_doc.documents_category_id, single_share_doc.documents_subcategory_id, single_share_doc.file_url, single_share_doc.is_allowed FROM shared_doc
INNER JOIN single_share_doc ON single_share_doc.id = ANY(shared_doc.single_share_docs)
WHERE shared_doc.id = $1
`

func (q *Queries) GetAllSingleShareDoc(ctx context.Context, id int64) ([]SingleShareDoc, error) {
	rows, err := q.db.Query(ctx, getAllSingleShareDoc, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SingleShareDoc
	for rows.Next() {
		var i SingleShareDoc
		if err := rows.Scan(
			&i.ID,
			&i.DocumentsCategoryID,
			&i.DocumentsSubcategoryID,
			&i.FileUrl,
			&i.IsAllowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserFromSharing = `-- name: GetAllUserFromSharing :many
SELECT DISTINCT ON  (users.id) sharing.shared_to, sharing.country_id, sharing.is_enabled, sharing.sharing_type,
 profiles.first_name ,profiles.last_name, profiles.profile_image_url
 FROM sharing
INNER JOIN users ON sharing.shared_to = users.id
INNER JOIN profiles ON users.id = profiles.users_id
Where sharing.sharing_type = 1 AND sharing.entity_id = $1
`

type GetAllUserFromSharingRow struct {
	SharedTo        int64       `json:"shared_to"`
	CountryID       pgtype.Int8 `json:"country_id"`
	IsEnabled       pgtype.Bool `json:"is_enabled"`
	SharingType     int32       `json:"sharing_type"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
}

func (q *Queries) GetAllUserFromSharing(ctx context.Context, entityID int64) ([]GetAllUserFromSharingRow, error) {
	rows, err := q.db.Query(ctx, getAllUserFromSharing, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserFromSharingRow
	for rows.Next() {
		var i GetAllUserFromSharingRow
		if err := rows.Scan(
			&i.SharedTo,
			&i.CountryID,
			&i.IsEnabled,
			&i.SharingType,
			&i.FirstName,
			&i.LastName,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyNameByEqualCountry = `-- name: GetCompanyNameByEqualCountry :one
SELECT companies.id, companies.company_name, companies.status, companies.logo_url FROM companies
INNER JOIN addresses ON addresses.id = companies.addresses_id
INNER JOIN  countries ON countries.id = addresses.countries_id
WHERE companies.id = $1 AND company_type = $2 
AND  countries.id != $3
`

type GetCompanyNameByEqualCountryParams struct {
	CompanyID   int64 `json:"company_id"`
	CompanyType int64 `json:"company_type"`
	CountryID   int64 `json:"country_id"`
}

type GetCompanyNameByEqualCountryRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
	Status      int64  `json:"status"`
	LogoUrl     string `json:"logo_url"`
}

func (q *Queries) GetCompanyNameByEqualCountry(ctx context.Context, arg GetCompanyNameByEqualCountryParams) (GetCompanyNameByEqualCountryRow, error) {
	row := q.db.QueryRow(ctx, getCompanyNameByEqualCountry, arg.CompanyID, arg.CompanyType, arg.CountryID)
	var i GetCompanyNameByEqualCountryRow
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.Status,
		&i.LogoUrl,
	)
	return i, err
}

const getCompanyNameByNotEqualCountry = `-- name: GetCompanyNameByNotEqualCountry :one
SELECT companies.id, companies.company_name, companies.status, companies.logo_url, countries.country as country_name, countries.flag as country_flag  FROM companies
INNER JOIN addresses ON addresses.id = companies.addresses_id
INNER JOIN  countries ON countries.id = addresses.countries_id
WHERE companies.id = $1 AND company_type = $2 
AND ($3 = 0 AND countries.id != $4) OR ($3 = 1 AND countries.id = $4)
`

type GetCompanyNameByNotEqualCountryParams struct {
	CompanyID       int64       `json:"company_id"`
	CompanyType     int64       `json:"company_type"`
	Isinternational interface{} `json:"isinternational"`
	CountryID       int64       `json:"country_id"`
}

type GetCompanyNameByNotEqualCountryRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
	Status      int64  `json:"status"`
	LogoUrl     string `json:"logo_url"`
	CountryName string `json:"country_name"`
	CountryFlag string `json:"country_flag"`
}

func (q *Queries) GetCompanyNameByNotEqualCountry(ctx context.Context, arg GetCompanyNameByNotEqualCountryParams) (GetCompanyNameByNotEqualCountryRow, error) {
	row := q.db.QueryRow(ctx, getCompanyNameByNotEqualCountry,
		arg.CompanyID,
		arg.CompanyType,
		arg.Isinternational,
		arg.CountryID,
	)
	var i GetCompanyNameByNotEqualCountryRow
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.Status,
		&i.LogoUrl,
		&i.CountryName,
		&i.CountryFlag,
	)
	return i, err
}

const getCountAllInternalSharing = `-- name: GetCountAllInternalSharing :one
SELECT COUNT(project_id) FROM internal_sharing 
Where is_project = true AND phase_id IS NULL AND CASE WHEN $1::bigint = 0 THEN true ELSE $1::bigint  =  ANY(shared_to) END
`

func (q *Queries) GetCountAllInternalSharing(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllInternalSharing, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getExternalSharing = `-- name: GetExternalSharing :one
SELECT id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id,
  CASE
    WHEN $1 = 'unit' THEN
      CASE
        WHEN   is_unit = $2 AND unit_id = $3 AND unit_category = $4  THEN 'Unit query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'property' THEN
      CASE
        WHEN  is_property = $5 AND property_key = $6 AND property_id = $7  
         AND (is_unit IS NULL  OR is_unit IS FALSE)  THEN 'Property query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'project_with_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id = $9 AND project_id = $10 
         AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false) 
         THEN 'Project with phase query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'project_without_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id IS NULL AND project_id = $10
         AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false)          
         THEN 'Project without phase query executed'
        ELSE 'No matching condition'
      END
    ELSE 'Invalid check_for parameter'
  END AS query_executed
FROM external_sharing
WHERE
  CASE
    WHEN $1 = 'unit' THEN
      CASE
        WHEN  is_unit = $2 AND unit_id = $3  AND unit_category = $4 THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'property' THEN
      CASE
        WHEN   is_property = $5 AND property_key = $6 AND property_id = $7  AND (is_unit IS NULL  OR is_unit IS FALSE)  THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'project_with_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id = $9 AND project_id = $10 THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'project_without_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id IS NULL AND project_id = $10 THEN TRUE
        ELSE FALSE
      END
    ELSE FALSE
  END
`

type GetExternalSharingParams struct {
	CheckFor     interface{} `json:"check_for"`
	IsUnit       pgtype.Bool `json:"is_unit"`
	UnitID       pgtype.Int8 `json:"unit_id"`
	UnitCategory pgtype.Text `json:"unit_category"`
	IsProperty   pgtype.Bool `json:"is_property"`
	PropertyKey  pgtype.Int8 `json:"property_key"`
	PropertyID   pgtype.Int8 `json:"property_id"`
	IsProject    pgtype.Bool `json:"is_project"`
	PhaseID      pgtype.Int8 `json:"phase_id"`
	ProjectID    pgtype.Int8 `json:"project_id"`
}

type GetExternalSharingRow struct {
	ID                  int64         `json:"id"`
	CompanyTypesID      int64         `json:"company_types_id"`
	CompaniesID         int64         `json:"companies_id"`
	IsBranch            pgtype.Bool   `json:"is_branch"`
	IsProject           pgtype.Bool   `json:"is_project"`
	ProjectID           pgtype.Int8   `json:"project_id"`
	IsProperty          pgtype.Bool   `json:"is_property"`
	IsPropertyBranch    pgtype.Bool   `json:"is_property_branch"`
	PropertyID          pgtype.Int8   `json:"property_id"`
	PropertyKey         pgtype.Int8   `json:"property_key"`
	IsUnit              pgtype.Bool   `json:"is_unit"`
	UnitID              pgtype.Int8   `json:"unit_id"`
	UnitCategory        pgtype.Text   `json:"unit_category"`
	Price               pgtype.Bool   `json:"price"`
	ExternalCompanyType []int64       `json:"external_company_type"`
	ExternalIsBranch    []pgtype.Bool `json:"external_is_branch"`
	ExternalCompanyID   []int64       `json:"external_company_id"`
	ExternalIsEnabled   []pgtype.Bool `json:"external_is_enabled"`
	CreatedAt           time.Time     `json:"created_at"`
	CreatedBy           int64         `json:"created_by"`
	PhaseID             pgtype.Int8   `json:"phase_id"`
	QueryExecuted       string        `json:"query_executed"`
}

func (q *Queries) GetExternalSharing(ctx context.Context, arg GetExternalSharingParams) (GetExternalSharingRow, error) {
	row := q.db.QueryRow(ctx, getExternalSharing,
		arg.CheckFor,
		arg.IsUnit,
		arg.UnitID,
		arg.UnitCategory,
		arg.IsProperty,
		arg.PropertyKey,
		arg.PropertyID,
		arg.IsProject,
		arg.PhaseID,
		arg.ProjectID,
	)
	var i GetExternalSharingRow
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.ExternalCompanyType,
		&i.ExternalIsBranch,
		&i.ExternalCompanyID,
		&i.ExternalIsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
		&i.QueryExecuted,
	)
	return i, err
}

const getExternalSharingByMe = `-- name: GetExternalSharingByMe :one
SELECT id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id,
  CASE
    WHEN $1 = 'unit' THEN
      CASE
        WHEN is_unit = $2 AND unit_id = $3  AND unit_category =  $4 THEN 'Unit query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'property' THEN
      CASE
        WHEN  is_property = $5 AND property_key = $6 AND property_id = $7 
         AND (is_unit IS NULL  OR is_unit IS FALSE) THEN 'Property query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'project_with_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id = $9 AND project_id = $10
         AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false)          
         THEN 'Project with phase query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'project_without_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id IS NULL AND project_id = $10 
         AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false)          
        THEN 'Project without phase query executed'
        ELSE 'No matching condition'
      END
    ELSE 'Invalid check_for parameter'
  END AS query_executed
FROM external_sharing
WHERE
  CASE
    WHEN $1 = 'unit' THEN
      CASE
        WHEN is_unit = $2 AND unit_id = $3  AND created_by = $11 
         AND unit_category =  $4  THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'property' THEN
      CASE
        WHEN is_property = $5 AND property_key = $6 AND property_id = $7 
         AND created_by = $11  AND (is_unit IS NULL  OR is_unit IS FALSE) THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'project_with_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id = $9 AND project_id = $10  AND created_by = $11
         AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false)  
         THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'project_without_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id IS NULL AND project_id = $10  AND created_by = $11
         AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false)          
         THEN TRUE
        ELSE FALSE
      END
    ELSE FALSE
  END
`

type GetExternalSharingByMeParams struct {
	CheckFor     interface{} `json:"check_for"`
	IsUnit       pgtype.Bool `json:"is_unit"`
	UnitID       pgtype.Int8 `json:"unit_id"`
	UnitCategory pgtype.Text `json:"unit_category"`
	IsProperty   pgtype.Bool `json:"is_property"`
	PropertyKey  pgtype.Int8 `json:"property_key"`
	PropertyID   pgtype.Int8 `json:"property_id"`
	IsProject    pgtype.Bool `json:"is_project"`
	PhaseID      pgtype.Int8 `json:"phase_id"`
	ProjectID    pgtype.Int8 `json:"project_id"`
	UserID       int64       `json:"user_id"`
}

type GetExternalSharingByMeRow struct {
	ID                  int64         `json:"id"`
	CompanyTypesID      int64         `json:"company_types_id"`
	CompaniesID         int64         `json:"companies_id"`
	IsBranch            pgtype.Bool   `json:"is_branch"`
	IsProject           pgtype.Bool   `json:"is_project"`
	ProjectID           pgtype.Int8   `json:"project_id"`
	IsProperty          pgtype.Bool   `json:"is_property"`
	IsPropertyBranch    pgtype.Bool   `json:"is_property_branch"`
	PropertyID          pgtype.Int8   `json:"property_id"`
	PropertyKey         pgtype.Int8   `json:"property_key"`
	IsUnit              pgtype.Bool   `json:"is_unit"`
	UnitID              pgtype.Int8   `json:"unit_id"`
	UnitCategory        pgtype.Text   `json:"unit_category"`
	Price               pgtype.Bool   `json:"price"`
	ExternalCompanyType []int64       `json:"external_company_type"`
	ExternalIsBranch    []pgtype.Bool `json:"external_is_branch"`
	ExternalCompanyID   []int64       `json:"external_company_id"`
	ExternalIsEnabled   []pgtype.Bool `json:"external_is_enabled"`
	CreatedAt           time.Time     `json:"created_at"`
	CreatedBy           int64         `json:"created_by"`
	PhaseID             pgtype.Int8   `json:"phase_id"`
	QueryExecuted       string        `json:"query_executed"`
}

func (q *Queries) GetExternalSharingByMe(ctx context.Context, arg GetExternalSharingByMeParams) (GetExternalSharingByMeRow, error) {
	row := q.db.QueryRow(ctx, getExternalSharingByMe,
		arg.CheckFor,
		arg.IsUnit,
		arg.UnitID,
		arg.UnitCategory,
		arg.IsProperty,
		arg.PropertyKey,
		arg.PropertyID,
		arg.IsProject,
		arg.PhaseID,
		arg.ProjectID,
		arg.UserID,
	)
	var i GetExternalSharingByMeRow
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.ExternalCompanyType,
		&i.ExternalIsBranch,
		&i.ExternalCompanyID,
		&i.ExternalIsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
		&i.QueryExecuted,
	)
	return i, err
}

const getExternalSharingByProjectID = `-- name: GetExternalSharingByProjectID :one
SELECT id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id FROM external_sharing 
WHERE is_project = TRUE AND project_id = $1
`

func (q *Queries) GetExternalSharingByProjectID(ctx context.Context, projectID pgtype.Int8) (ExternalSharing, error) {
	row := q.db.QueryRow(ctx, getExternalSharingByProjectID, projectID)
	var i ExternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.ExternalCompanyType,
		&i.ExternalIsBranch,
		&i.ExternalCompanyID,
		&i.ExternalIsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const getInternalSharing = `-- name: GetInternalSharing :one
SELECT id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id,
  CASE
    WHEN $1 = 'unit' THEN
      CASE
        WHEN  is_unit = $2 AND unit_id = $3   AND unit_category = $4    THEN 'Unit query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'property' THEN
      CASE
        WHEN  is_property = $5 AND property_key = $6 AND  property_id = $7  
        AND (is_unit IS NULL  OR is_unit IS FALSE) 
         THEN 'Property query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'project_with_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id = $9 AND project_id = $10 
        
        THEN 'Project with phase query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'project_without_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id IS NULL AND project_id = $10 THEN 'Project without phase query executed'
        ELSE 'No matching condition'
      END
    ELSE 'Invalid check_for parameter'
  END AS query_executed
FROM internal_sharing
WHERE
  CASE
    WHEN $1 = 'unit' THEN
      CASE
        WHEN   is_unit = $2 AND unit_id = $3  AND unit_category = $4   THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'property' THEN
      CASE
        WHEN   is_property = $5 AND property_key = $6 AND property_id = $7 
         AND (is_unit IS NULL  OR is_unit IS FALSE) THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'project_with_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id = $9 AND project_id = $10
             AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false)  
                 THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'project_without_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id IS NULL AND project_id = $10
             AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false)          
         THEN TRUE
        ELSE FALSE
      END
    ELSE FALSE
END
`

type GetInternalSharingParams struct {
	CheckFor     interface{} `json:"check_for"`
	IsUnit       pgtype.Bool `json:"is_unit"`
	UnitID       pgtype.Int8 `json:"unit_id"`
	UnitCategory pgtype.Text `json:"unit_category"`
	IsProperty   pgtype.Bool `json:"is_property"`
	PropertyKey  pgtype.Int8 `json:"property_key"`
	PropertyID   pgtype.Int8 `json:"property_id"`
	IsProject    pgtype.Bool `json:"is_project"`
	PhaseID      pgtype.Int8 `json:"phase_id"`
	ProjectID    pgtype.Int8 `json:"project_id"`
}

type GetInternalSharingRow struct {
	ID               int64         `json:"id"`
	CompanyTypesID   pgtype.Int8   `json:"company_types_id"`
	CompaniesID      pgtype.Int8   `json:"companies_id"`
	IsBranch         pgtype.Bool   `json:"is_branch"`
	IsProject        pgtype.Bool   `json:"is_project"`
	ProjectID        pgtype.Int8   `json:"project_id"`
	IsProperty       pgtype.Bool   `json:"is_property"`
	IsPropertyBranch pgtype.Bool   `json:"is_property_branch"`
	PropertyID       pgtype.Int8   `json:"property_id"`
	PropertyKey      pgtype.Int8   `json:"property_key"`
	IsUnit           pgtype.Bool   `json:"is_unit"`
	UnitID           pgtype.Int8   `json:"unit_id"`
	UnitCategory     pgtype.Text   `json:"unit_category"`
	Price            pgtype.Bool   `json:"price"`
	SharedTo         []int64       `json:"shared_to"`
	IsEnabled        []pgtype.Bool `json:"is_enabled"`
	CreatedAt        time.Time     `json:"created_at"`
	CreatedBy        int64         `json:"created_by"`
	PhaseID          pgtype.Int8   `json:"phase_id"`
	QueryExecuted    string        `json:"query_executed"`
}

func (q *Queries) GetInternalSharing(ctx context.Context, arg GetInternalSharingParams) (GetInternalSharingRow, error) {
	row := q.db.QueryRow(ctx, getInternalSharing,
		arg.CheckFor,
		arg.IsUnit,
		arg.UnitID,
		arg.UnitCategory,
		arg.IsProperty,
		arg.PropertyKey,
		arg.PropertyID,
		arg.IsProject,
		arg.PhaseID,
		arg.ProjectID,
	)
	var i GetInternalSharingRow
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
		&i.QueryExecuted,
	)
	return i, err
}

const getInternalSharingByMe = `-- name: GetInternalSharingByMe :one
SELECT id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id,
  CASE
    WHEN $1 = 'unit' THEN
      CASE
        WHEN  is_unit = $2 AND unit_id = $3  AND unit_category = $4  THEN 'Unit query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'property' THEN
      CASE
        WHEN  is_property = $5 AND property_key = $6 AND property_id = $7  AND (is_unit IS NULL  OR is_unit IS FALSE)  THEN 'Property query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'project_with_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id = $9 AND project_id = $10 THEN 'Project with phase query executed'
        ELSE 'No matching condition'
      END
    WHEN $1 = 'project_without_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id IS NULL AND project_id = $10 THEN 'Project without phase query executed'
        ELSE 'No matching condition'
      END
    ELSE 'Invalid check_for parameter'
  END AS query_executed
FROM internal_sharing
WHERE
  CASE
    WHEN $1 = 'unit' THEN
      CASE
        WHEN  is_unit = $2 AND unit_id = $3  AND created_by = $11  AND unit_category = $4   THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'property' THEN
      CASE
        WHEN is_property = $5 AND property_key = $6 AND property_id = $7  AND created_by = $11  
         AND (is_unit IS NULL  OR is_unit IS FALSE)  THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'project_with_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id = $9 AND project_id = $10 
             AND (is_property IS NULL OR is_property IS false) 
            AND (is_unit IS NULL OR is_unit IS false)  
         AND created_by = $11 THEN TRUE
        ELSE FALSE
      END
    WHEN $1 = 'project_without_phase' THEN
      CASE
        WHEN is_project = $8 AND phase_id IS NULL AND project_id = $10   
        AND (is_property IS NULL OR is_property IS false) 
        AND (is_unit IS NULL OR is_unit IS false)   
        AND created_by = $11    THEN TRUE
        ELSE FALSE
      END
    ELSE FALSE
  END
`

type GetInternalSharingByMeParams struct {
	CheckFor     interface{} `json:"check_for"`
	IsUnit       pgtype.Bool `json:"is_unit"`
	UnitID       pgtype.Int8 `json:"unit_id"`
	UnitCategory pgtype.Text `json:"unit_category"`
	IsProperty   pgtype.Bool `json:"is_property"`
	PropertyKey  pgtype.Int8 `json:"property_key"`
	PropertyID   pgtype.Int8 `json:"property_id"`
	IsProject    pgtype.Bool `json:"is_project"`
	PhaseID      pgtype.Int8 `json:"phase_id"`
	ProjectID    pgtype.Int8 `json:"project_id"`
	UserID       int64       `json:"user_id"`
}

type GetInternalSharingByMeRow struct {
	ID               int64         `json:"id"`
	CompanyTypesID   pgtype.Int8   `json:"company_types_id"`
	CompaniesID      pgtype.Int8   `json:"companies_id"`
	IsBranch         pgtype.Bool   `json:"is_branch"`
	IsProject        pgtype.Bool   `json:"is_project"`
	ProjectID        pgtype.Int8   `json:"project_id"`
	IsProperty       pgtype.Bool   `json:"is_property"`
	IsPropertyBranch pgtype.Bool   `json:"is_property_branch"`
	PropertyID       pgtype.Int8   `json:"property_id"`
	PropertyKey      pgtype.Int8   `json:"property_key"`
	IsUnit           pgtype.Bool   `json:"is_unit"`
	UnitID           pgtype.Int8   `json:"unit_id"`
	UnitCategory     pgtype.Text   `json:"unit_category"`
	Price            pgtype.Bool   `json:"price"`
	SharedTo         []int64       `json:"shared_to"`
	IsEnabled        []pgtype.Bool `json:"is_enabled"`
	CreatedAt        time.Time     `json:"created_at"`
	CreatedBy        int64         `json:"created_by"`
	PhaseID          pgtype.Int8   `json:"phase_id"`
	QueryExecuted    string        `json:"query_executed"`
}

func (q *Queries) GetInternalSharingByMe(ctx context.Context, arg GetInternalSharingByMeParams) (GetInternalSharingByMeRow, error) {
	row := q.db.QueryRow(ctx, getInternalSharingByMe,
		arg.CheckFor,
		arg.IsUnit,
		arg.UnitID,
		arg.UnitCategory,
		arg.IsProperty,
		arg.PropertyKey,
		arg.PropertyID,
		arg.IsProject,
		arg.PhaseID,
		arg.ProjectID,
		arg.UserID,
	)
	var i GetInternalSharingByMeRow
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
		&i.QueryExecuted,
	)
	return i, err
}

const getInternalSharingByProjectID = `-- name: GetInternalSharingByProjectID :one
SELECT id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id FROM internal_sharing 
WHERE is_project = TRUE AND project_id = $1
`

func (q *Queries) GetInternalSharingByProjectID(ctx context.Context, projectID pgtype.Int8) (InternalSharing, error) {
	row := q.db.QueryRow(ctx, getInternalSharingByProjectID, projectID)
	var i InternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const getOwnerUserFromPhasesByID = `-- name: GetOwnerUserFromPhasesByID :one
SELECT  companies.users_id FROM phases
INNER JOIN projects ON phases.projects_id =  projects.id
INNER JOIN companies ON projects.developer_companies_id = companies.id
WHERE phases.id = $1
`

func (q *Queries) GetOwnerUserFromPhasesByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getOwnerUserFromPhasesByID, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getOwnerUserFromProjectByID = `-- name: GetOwnerUserFromProjectByID :one
SELECT companies.users_id FROM projects
INNER JOIN companies ON projects.developer_companies_id = companies.id
WHERE projects.id = $1
`

func (q *Queries) GetOwnerUserFromProjectByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getOwnerUserFromProjectByID, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getOwnerUserFromProjectPropertyByID = `-- name: GetOwnerUserFromProjectPropertyByID :one
SELECT companies.users_id from project_properties
INNER JOIN projects ON project_properties.projects_id =  projects.id
INNER JOIN companies ON projects.developer_companies_id = companies.id
WHERE project_properties.id = $1
`

func (q *Queries) GetOwnerUserFromProjectPropertyByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getOwnerUserFromProjectPropertyByID, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getOwnerUserFromUnitByID = `-- name: GetOwnerUserFromUnitByID :one

SELECT units.owner_users_id from units
WHERE id = $1
`

// TODO: need todo it for other properties also
func (q *Queries) GetOwnerUserFromUnitByID(ctx context.Context, id int64) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, getOwnerUserFromUnitByID, id)
	var owner_users_id pgtype.Int8
	err := row.Scan(&owner_users_id)
	return owner_users_id, err
}

const getShareDocById = `-- name: GetShareDocById :one
SELECT id, sharing_id, is_internal, single_share_docs, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, status, shared_to, is_branch, phase_id, created_at, updated_at FROM shared_doc 
WHERE id =  $1 LIMIT 1
`

func (q *Queries) GetShareDocById(ctx context.Context, id int64) (SharedDoc, error) {
	row := q.db.QueryRow(ctx, getShareDocById, id)
	var i SharedDoc
	err := row.Scan(
		&i.ID,
		&i.SharingID,
		&i.IsInternal,
		&i.SingleShareDocs,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Status,
		&i.SharedTo,
		&i.IsBranch,
		&i.PhaseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShareRequestByRequestorAndDocID = `-- name: GetShareRequestByRequestorAndDocID :one
SELECT id, document_id, request_status, requester_id, owner_id, created_by, created_at, updated_at FROM share_requests
WHERE document_id = $1 AND requester_id = $2
`

type GetShareRequestByRequestorAndDocIDParams struct {
	DocumentID  pgtype.Int8 `json:"document_id"`
	RequesterID pgtype.Int8 `json:"requester_id"`
}

func (q *Queries) GetShareRequestByRequestorAndDocID(ctx context.Context, arg GetShareRequestByRequestorAndDocIDParams) (ShareRequest, error) {
	row := q.db.QueryRow(ctx, getShareRequestByRequestorAndDocID, arg.DocumentID, arg.RequesterID)
	var i ShareRequest
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.RequestStatus,
		&i.RequesterID,
		&i.OwnerID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSharedPhases = `-- name: GetSharedPhases :many
WITH phase_reviews AS (
    SELECT 
        er.entity_id as phase_id,
        COALESCE(rt.review_term, '') as review_term,
        -- COALESCE(rt.review_term_ar, '') as review_term_ar,
        COALESCE(r.review_value, 0) as review_value
    FROM entity_review er
    LEFT JOIN reviews_table r ON r.entity_review_id = er.id
    LEFT JOIN review_terms rt ON rt.id = r.review_term_id
    WHERE er.entity_type_id = (SELECT id FROM entity_type WHERE name = 'phase')
)
SELECT 
    p.id as phase_id,
    p.projects_id,
    p.phase_name,
    COALESCE(MAX(CASE WHEN pr.review_term = 'items' THEN pr.review_value END), 0)::FLOAT as phase_clean,
    COALESCE(MAX(CASE WHEN pr.review_term = 'location' THEN pr.review_value END), 0)::FLOAT as phase_location,
    COALESCE(MAX(CASE WHEN pr.review_term = 'facilities' THEN pr.review_value END), 0)::FLOAT as phase_facilities,
    COALESCE(MAX(CASE WHEN pr.review_term = 'securities' THEN pr.review_value END), 0)::FLOAT as phase_securities,
    COALESCE((p.facts->>'completion_percentage')::int, 0)::bigint as completion_percentage,
    COALESCE((p.facts->>'completion_status')::int, 0)::bigint as completion_status
FROM phases p
LEFT JOIN phase_reviews pr ON pr.phase_id = p.id
WHERE p.id = ANY($1::bigint[])
GROUP BY 
    p.id,
    p.projects_id,
    p.phase_name
ORDER BY p.projects_id
`

type GetSharedPhasesRow struct {
	PhaseID              int64   `json:"phase_id"`
	ProjectsID           int64   `json:"projects_id"`
	PhaseName            string  `json:"phase_name"`
	PhaseClean           float64 `json:"phase_clean"`
	PhaseLocation        float64 `json:"phase_location"`
	PhaseFacilities      float64 `json:"phase_facilities"`
	PhaseSecurities      float64 `json:"phase_securities"`
	CompletionPercentage int64   `json:"completion_percentage"`
	CompletionStatus     int64   `json:"completion_status"`
}

func (q *Queries) GetSharedPhases(ctx context.Context, phaseID []int64) ([]GetSharedPhasesRow, error) {
	rows, err := q.db.Query(ctx, getSharedPhases, phaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharedPhasesRow
	for rows.Next() {
		var i GetSharedPhasesRow
		if err := rows.Scan(
			&i.PhaseID,
			&i.ProjectsID,
			&i.PhaseName,
			&i.PhaseClean,
			&i.PhaseLocation,
			&i.PhaseFacilities,
			&i.PhaseSecurities,
			&i.CompletionPercentage,
			&i.CompletionStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedProject = `-- name: GetSharedProject :many
WITH project_ids AS (
    SELECT unnest($1::bigint[]) AS id, row_number() OVER () AS rn
),
project_reviews AS (
    SELECT 
        er.entity_id,
        COALESCE(rt.review_term, '') as review_term,
        -- COALESCE(rt.review_term_ar, '') as review_term_ar,
        COALESCE(r.review_value, 0) as review_value
    FROM entity_review er
    LEFT JOIN reviews_table r ON r.entity_review_id = er.id
    LEFT JOIN review_terms rt ON rt.id = r.review_term_id
    WHERE er.entity_type_id = (SELECT id FROM entity_type WHERE name = 'project')
)
SELECT 
    p.id,
    p.ref_number,
    p.project_name,
    p.is_multiphase,
    p.description,
    p.addresses_id,
    c.company_name,
    COALESCE(MAX(CASE WHEN pr.review_term = 'items' THEN pr.review_value END), 0)::FLOAT as project_clean,
    COALESCE(MAX(CASE WHEN pr.review_term = 'location' THEN pr.review_value END), 0)::FLOAT as project_location,
    COALESCE(MAX(CASE WHEN pr.review_term = 'facilities' THEN pr.review_value END), 0)::FLOAT as project_facilities,
    COALESCE(MAX(CASE WHEN pr.review_term = 'securities' THEN pr.review_value END), 0)::FLOAT as project_securities,
    COALESCE((p.facts->>'completion_percentage')::int, 0)::bigint as completion_percentage,
    COALESCE((p.facts->>'completion_status')::int, 0)::bigint as completion_status,
    (SELECT COUNT(*) FROM phases ph WHERE ph.projects_id = p.id) AS no_of_phases
FROM projects p
CROSS JOIN project_ids pi
LEFT JOIN companies c ON p.developer_companies_id = c.id
LEFT JOIN project_reviews pr ON pr.entity_id = p.id
WHERE p.id = pi.id
GROUP BY 
    p.id,
    p.ref_number,
    p.project_name,
    p.is_multiphase,
    p.description,
    p.addresses_id,
    c.company_name,
    pi.rn
ORDER BY pi.rn
`

type GetSharedProjectRow struct {
	ID                   int64       `json:"id"`
	RefNumber            string      `json:"ref_number"`
	ProjectName          string      `json:"project_name"`
	IsMultiphase         pgtype.Bool `json:"is_multiphase"`
	Description          string      `json:"description"`
	AddressesID          int64       `json:"addresses_id"`
	CompanyName          pgtype.Text `json:"company_name"`
	ProjectClean         float64     `json:"project_clean"`
	ProjectLocation      float64     `json:"project_location"`
	ProjectFacilities    float64     `json:"project_facilities"`
	ProjectSecurities    float64     `json:"project_securities"`
	CompletionPercentage int64       `json:"completion_percentage"`
	CompletionStatus     int64       `json:"completion_status"`
	NoOfPhases           int64       `json:"no_of_phases"`
}

func (q *Queries) GetSharedProject(ctx context.Context, projectID []int64) ([]GetSharedProjectRow, error) {
	rows, err := q.db.Query(ctx, getSharedProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharedProjectRow
	for rows.Next() {
		var i GetSharedProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNumber,
			&i.ProjectName,
			&i.IsMultiphase,
			&i.Description,
			&i.AddressesID,
			&i.CompanyName,
			&i.ProjectClean,
			&i.ProjectLocation,
			&i.ProjectFacilities,
			&i.ProjectSecurities,
			&i.CompletionPercentage,
			&i.CompletionStatus,
			&i.NoOfPhases,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedProperty = `-- name: GetSharedProperty :many
SELECT property_versions.id, title, views_count, title_arabic, property_versions.description, property_versions.description_arabic, property_rank, property_id, property_versions.facts, property_versions.created_at, property_versions.updated_at, property_versions.updated_by, property_versions.status, agent_id, ref_no, category, has_gallery, has_plans, is_main, property_versions.is_verified, property_versions.exclusive, property_versions.start_date, property_versions.end_date, slug, is_hotdeal, refreshed_at, property.id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, property.is_verified, addresses_id, entity_type_id, entity_id, property.status, is_show_owner_info, property_name, property.description, property.description_arabic, owner_users_id, user_id, property.updated_by, from_xml, property.facts, notes, property.created_at, property.updated_at, notes_ar, is_public_note, is_project_property, property.exclusive, property.start_date, property.end_date FROM property_versions
INNER JOIN property ON property_versions.property_id = property.id
WHERE property_versions.id = ANY($1::bigint[])
`

type GetSharedPropertyRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts               []byte             `json:"facts"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	UpdatedBy           int64              `json:"updated_by"`
	Status              int64              `json:"status"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status_2            int64              `json:"status_2"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts_2             []byte             `json:"facts_2"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

// WHERE property.id = ANY(@property_id::bigint[]);
func (q *Queries) GetSharedProperty(ctx context.Context, propertyVersionsID []int64) ([]GetSharedPropertyRow, error) {
	rows, err := q.db.Query(ctx, getSharedProperty, propertyVersionsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharedPropertyRow
	for rows.Next() {
		var i GetSharedPropertyRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified_2,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status_2,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy_2,
			&i.FromXml,
			&i.Facts_2,
			&i.Notes,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedUnit = `-- name: GetSharedUnit :many
SELECT unit_versions.id, title, views_count, title_arabic, unit_versions.description, unit_versions.description_arabic, unit_id, ref_no, unit_versions.status, type, unit_rank, unit_versions.created_at, unit_versions.updated_at, unit_versions.created_by, unit_versions.updated_by, unit_versions.facts, listed_by, has_gallery, has_plans, is_main, unit_versions.is_verified, unit_versions.exclusive, unit_versions.start_date, unit_versions.end_date, slug, is_hotdeal, refreshed_at, units.id, unit_no, unitno_is_public, notes, unit_title, units.description, units.description_arabic, unit_title_arabic, notes_arabic, notes_public, units.is_verified, entity_type_id, entity_id, units.created_at, units.updated_at, addresses_id, unit_type_id, units.created_by, units.updated_by, type_name_id, owner_users_id, from_xml, company_id, units.status, units.facts, is_project_unit, units.exclusive, units.start_date, units.end_date FROM unit_versions 
INNER JOIN  units ON unit_versions.unit_id = units.id
WHERE unit_versions.id = ANY($1::bigint[])
`

type GetSharedUnitRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	UnitID              int64              `json:"unit_id"`
	RefNo               string             `json:"ref_no"`
	Status              int64              `json:"status"`
	Type                int64              `json:"type"`
	UnitRank            int64              `json:"unit_rank"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	CreatedBy           int64              `json:"created_by"`
	UpdatedBy           int64              `json:"updated_by"`
	Facts               []byte             `json:"facts"`
	ListedBy            int64              `json:"listed_by"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	UnitNo              string             `json:"unit_no"`
	UnitnoIsPublic      pgtype.Bool        `json:"unitno_is_public"`
	Notes               string             `json:"notes"`
	UnitTitle           string             `json:"unit_title"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 string             `json:"description_arabic_2"`
	UnitTitleArabic     string             `json:"unit_title_arabic"`
	NotesArabic         string             `json:"notes_arabic"`
	NotesPublic         pgtype.Bool        `json:"notes_public"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	EntityTypeID        pgtype.Int8        `json:"entity_type_id"`
	EntityID            pgtype.Int8        `json:"entity_id"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	AddressesID         int64              `json:"addresses_id"`
	UnitTypeID          int64              `json:"unit_type_id"`
	CreatedBy_2         int64              `json:"created_by_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	TypeNameID          pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	Status_2            int64              `json:"status_2"`
	Facts_2             []byte             `json:"facts_2"`
	IsProjectUnit       pgtype.Bool        `json:"is_project_unit"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

func (q *Queries) GetSharedUnit(ctx context.Context, unitsID []int64) ([]GetSharedUnitRow, error) {
	rows, err := q.db.Query(ctx, getSharedUnit, unitsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharedUnitRow
	for rows.Next() {
		var i GetSharedUnitRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.UnitID,
			&i.RefNo,
			&i.Status,
			&i.Type,
			&i.UnitRank,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.Facts,
			&i.ListedBy,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.UnitNo,
			&i.UnitnoIsPublic,
			&i.Notes,
			&i.UnitTitle,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.UnitTitleArabic,
			&i.NotesArabic,
			&i.NotesPublic,
			&i.IsVerified_2,
			&i.EntityTypeID,
			&i.EntityID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.AddressesID,
			&i.UnitTypeID,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
			&i.TypeNameID,
			&i.OwnerUsersID,
			&i.FromXml,
			&i.CompanyID,
			&i.Status_2,
			&i.Facts_2,
			&i.IsProjectUnit,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharing = `-- name: GetSharing :one
SELECT id, sharing_type, entity_type_id, entity_id, shared_to, is_enabled, country_id, created_at, created_by FROM sharing
WHERE sharing_type = $1 AnD entity_type_id = $2 
AnD entity_id = $3 AnD 
 CASE WHEN $4=0 THEN true ELSE country_id = $4 END
AND shared_to = $5
`

type GetSharingParams struct {
	SharingType  int32       `json:"sharing_type"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	EntityID     int64       `json:"entity_id"`
	CountryID    interface{} `json:"country_id"`
	SharedTo     int64       `json:"shared_to"`
}

func (q *Queries) GetSharing(ctx context.Context, arg GetSharingParams) (Sharing, error) {
	row := q.db.QueryRow(ctx, getSharing,
		arg.SharingType,
		arg.EntityTypeID,
		arg.EntityID,
		arg.CountryID,
		arg.SharedTo,
	)
	var i Sharing
	err := row.Scan(
		&i.ID,
		&i.SharingType,
		&i.EntityTypeID,
		&i.EntityID,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CountryID,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getSharingEntityIDsByEntityType = `-- name: GetSharingEntityIDsByEntityType :many



SELECT s.id, sharing_type, s.entity_type_id, s.entity_id, shared_to, is_enabled, country_id, s.created_at, s.created_by, p.id, project_name, ref_number, no_of_views, p.is_verified, project_rank, p.addresses_id, p.status, developer_companies_id, developer_company_branches_id, countries_id, p.created_at, p.updated_at, is_multiphase, p.live_status, project_no, license_no, p.users_id, p.description, p.description_arabic, p.rating, p.polygon_coords, p.facts, p.exclusive, p.start_date, p.end_date, p.slug, deleted_at, p.bank_name, p.registration_date, p.escrow_number, p.refreshed_at, c.id, c.ref_no, company_name, company_activities_id, company_parent_id, tag_line, c.description, c.description_ar, logo_url, email, phone_number, whatsapp_number, c.is_verified, website_url, cover_image_url, no_of_employees, company_rank, c.status, company_type, c.addresses_id, c.users_id, c.created_by, c.created_at, c.updated_at, c.updated_by, location_url, vat_no, vat_status, vat_file_url, ph.id, phase_name, ph.addresses_id, ph.created_at, ph.updated_at, ph.status, ph.live_status, ph.ref_no, projects_id, ph.rating, ph.description, ph.description_ar, ph.polygon_coords, ph.facts, ph.exclusive, ph.start_date, ph.end_date, ph.bank_name, ph.registration_date, ph.escrow_number, pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, property_rank, property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, agent_id, pv.ref_no, category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at, property.id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, property.is_verified, property.addresses_id, property.entity_type_id, property.entity_id, property.status, is_show_owner_info, property_name, property.description, property.description_arabic, owner_users_id, user_id, property.updated_by, from_xml, property.facts, notes, property.created_at, property.updated_at, notes_ar, is_public_note, is_project_property, property.exclusive, property.start_date, property.end_date, uv.id, uv.title, uv.views_count, uv.title_arabic, uv.description, uv.description_arabic, unit_id, uv.ref_no, uv.status, type, unit_rank, uv.created_at, uv.updated_at, uv.created_by, uv.updated_by, uv.facts, listed_by, uv.has_gallery, uv.has_plans, uv.is_main, uv.is_verified, uv.exclusive, uv.start_date, uv.end_date, uv.slug, uv.is_hotdeal, uv.refreshed_at
FROM sharing s
LEFT JOIN projects p ON (
    s.entity_id = p.id 
    AND s.entity_type_id = $3
)
LEFT JOIN companies c ON (
    p.developer_companies_id = c.id 
    AND s.entity_type_id = $3
)
LEFT JOIN phases ph ON (
    s.entity_id = ph.id 
    AND s.entity_type_id = $3
)

LEFT JOIN property_versions pv ON (
    s.entity_id = pv.id 
    AND s.entity_type_id = $3
)
LEFT JOIN property ON pv.property_id = property.id
LEFT JOIN unit_versions uv ON (
    s.entity_id = uv.id 
    AND s.entity_type_id = $3
)
WHERE 
((s.entity_type_id = $3 AND p.id IS NOT NULL)
    OR 
    (s.entity_type_id = $3 AND ph.id IS NOT NULL)
    OR
    (s.entity_type_id = $3 AND pv.id IS NOT NULL))
    AND (
        ($4 = '%%')
        OR p.project_name ILIKE $4
        OR p.ref_number ILIKE $4
        OR c.company_name ILIKE $4
        OR (p.facts->>'completion_percentage')::TEXT ILIKE $4
        OR ph.phase_name ILIKE $4
        OR property.property_name ILIKE $4
        OR uv.title ILIKE $4
    )
    AND CASE 
        WHEN $5::bigint = 0 THEN true 
        ELSE s.created_by = $5::bigint 
    END
    AND CASE 
        WHEN $6::bigint = 0 THEN true 
        ELSE s.shared_to = $6::bigint 
    END
    AND s.entity_type_id = $3
LIMIT $1 OFFSET $2
`

type GetSharingEntityIDsByEntityTypeParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	Search       interface{} `json:"search"`
	CreatedBy    int64       `json:"created_by"`
	UserID       int64       `json:"user_id"`
}

type GetSharingEntityIDsByEntityTypeRow struct {
	ID                         int64              `json:"id"`
	SharingType                int32              `json:"sharing_type"`
	EntityTypeID               pgtype.Int8        `json:"entity_type_id"`
	EntityID                   int64              `json:"entity_id"`
	SharedTo                   int64              `json:"shared_to"`
	IsEnabled                  pgtype.Bool        `json:"is_enabled"`
	CountryID                  pgtype.Int8        `json:"country_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	CreatedBy                  pgtype.Int8        `json:"created_by"`
	ID_2                       pgtype.Int8        `json:"id_2"`
	ProjectName                pgtype.Text        `json:"project_name"`
	RefNumber                  pgtype.Text        `json:"ref_number"`
	NoOfViews                  pgtype.Int8        `json:"no_of_views"`
	IsVerified                 pgtype.Bool        `json:"is_verified"`
	ProjectRank                pgtype.Int8        `json:"project_rank"`
	AddressesID                pgtype.Int8        `json:"addresses_id"`
	Status                     pgtype.Int8        `json:"status"`
	DeveloperCompaniesID       pgtype.Int8        `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8        `json:"developer_company_branches_id"`
	CountriesID                pgtype.Int8        `json:"countries_id"`
	CreatedAt_2                pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	IsMultiphase               pgtype.Bool        `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool        `json:"live_status"`
	ProjectNo                  pgtype.Text        `json:"project_no"`
	LicenseNo                  pgtype.Text        `json:"license_no"`
	UsersID                    pgtype.Int8        `json:"users_id"`
	Description                pgtype.Text        `json:"description"`
	DescriptionArabic          pgtype.Text        `json:"description_arabic"`
	Rating                     pgtype.Float8      `json:"rating"`
	PolygonCoords              []byte             `json:"polygon_coords"`
	Facts                      []byte             `json:"facts"`
	Exclusive                  pgtype.Bool        `json:"exclusive"`
	StartDate                  pgtype.Date        `json:"start_date"`
	EndDate                    pgtype.Date        `json:"end_date"`
	Slug                       pgtype.Text        `json:"slug"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
	BankName                   pgtype.Text        `json:"bank_name"`
	RegistrationDate           pgtype.Date        `json:"registration_date"`
	EscrowNumber               pgtype.Text        `json:"escrow_number"`
	RefreshedAt                pgtype.Timestamptz `json:"refreshed_at"`
	ID_3                       pgtype.Int8        `json:"id_3"`
	RefNo                      pgtype.Text        `json:"ref_no"`
	CompanyName                pgtype.Text        `json:"company_name"`
	CompanyActivitiesID        []int64            `json:"company_activities_id"`
	CompanyParentID            pgtype.Int8        `json:"company_parent_id"`
	TagLine                    pgtype.Text        `json:"tag_line"`
	Description_2              pgtype.Text        `json:"description_2"`
	DescriptionAr              pgtype.Text        `json:"description_ar"`
	LogoUrl                    pgtype.Text        `json:"logo_url"`
	Email                      pgtype.Text        `json:"email"`
	PhoneNumber                pgtype.Text        `json:"phone_number"`
	WhatsappNumber             pgtype.Text        `json:"whatsapp_number"`
	IsVerified_2               pgtype.Bool        `json:"is_verified_2"`
	WebsiteUrl                 pgtype.Text        `json:"website_url"`
	CoverImageUrl              pgtype.Text        `json:"cover_image_url"`
	NoOfEmployees              pgtype.Int8        `json:"no_of_employees"`
	CompanyRank                pgtype.Int8        `json:"company_rank"`
	Status_2                   pgtype.Int8        `json:"status_2"`
	CompanyType                pgtype.Int8        `json:"company_type"`
	AddressesID_2              pgtype.Int8        `json:"addresses_id_2"`
	UsersID_2                  pgtype.Int8        `json:"users_id_2"`
	CreatedBy_2                pgtype.Int8        `json:"created_by_2"`
	CreatedAt_3                pgtype.Timestamptz `json:"created_at_3"`
	UpdatedAt_2                pgtype.Timestamptz `json:"updated_at_2"`
	UpdatedBy                  pgtype.Int8        `json:"updated_by"`
	LocationUrl                pgtype.Text        `json:"location_url"`
	VatNo                      pgtype.Text        `json:"vat_no"`
	VatStatus                  pgtype.Int8        `json:"vat_status"`
	VatFileUrl                 pgtype.Text        `json:"vat_file_url"`
	ID_4                       pgtype.Int8        `json:"id_4"`
	PhaseName                  pgtype.Text        `json:"phase_name"`
	AddressesID_3              pgtype.Int8        `json:"addresses_id_3"`
	CreatedAt_4                pgtype.Timestamptz `json:"created_at_4"`
	UpdatedAt_3                pgtype.Timestamptz `json:"updated_at_3"`
	Status_3                   pgtype.Int8        `json:"status_3"`
	LiveStatus_2               pgtype.Bool        `json:"live_status_2"`
	RefNo_2                    pgtype.Text        `json:"ref_no_2"`
	ProjectsID                 pgtype.Int8        `json:"projects_id"`
	Rating_2                   pgtype.Float8      `json:"rating_2"`
	Description_3              pgtype.Text        `json:"description_3"`
	DescriptionAr_2            pgtype.Text        `json:"description_ar_2"`
	PolygonCoords_2            []byte             `json:"polygon_coords_2"`
	Facts_2                    []byte             `json:"facts_2"`
	Exclusive_2                pgtype.Bool        `json:"exclusive_2"`
	StartDate_2                pgtype.Date        `json:"start_date_2"`
	EndDate_2                  pgtype.Date        `json:"end_date_2"`
	BankName_2                 pgtype.Text        `json:"bank_name_2"`
	RegistrationDate_2         pgtype.Date        `json:"registration_date_2"`
	EscrowNumber_2             pgtype.Text        `json:"escrow_number_2"`
	ID_5                       pgtype.Int8        `json:"id_5"`
	Title                      pgtype.Text        `json:"title"`
	ViewsCount                 pgtype.Int8        `json:"views_count"`
	TitleArabic                pgtype.Text        `json:"title_arabic"`
	Description_4              pgtype.Text        `json:"description_4"`
	DescriptionArabic_2        pgtype.Text        `json:"description_arabic_2"`
	PropertyRank               pgtype.Int8        `json:"property_rank"`
	PropertyID                 pgtype.Int8        `json:"property_id"`
	Facts_3                    []byte             `json:"facts_3"`
	CreatedAt_5                pgtype.Timestamptz `json:"created_at_5"`
	UpdatedAt_4                pgtype.Timestamptz `json:"updated_at_4"`
	UpdatedBy_2                pgtype.Int8        `json:"updated_by_2"`
	Status_4                   pgtype.Int8        `json:"status_4"`
	AgentID                    pgtype.Int8        `json:"agent_id"`
	RefNo_3                    pgtype.Text        `json:"ref_no_3"`
	Category                   pgtype.Int8        `json:"category"`
	HasGallery                 pgtype.Bool        `json:"has_gallery"`
	HasPlans                   pgtype.Bool        `json:"has_plans"`
	IsMain                     pgtype.Bool        `json:"is_main"`
	IsVerified_3               pgtype.Bool        `json:"is_verified_3"`
	Exclusive_3                pgtype.Bool        `json:"exclusive_3"`
	StartDate_3                pgtype.Date        `json:"start_date_3"`
	EndDate_3                  pgtype.Date        `json:"end_date_3"`
	Slug_2                     pgtype.Text        `json:"slug_2"`
	IsHotdeal                  pgtype.Bool        `json:"is_hotdeal"`
	RefreshedAt_2              pgtype.Timestamptz `json:"refreshed_at_2"`
	ID_6                       pgtype.Int8        `json:"id_6"`
	CompanyID                  pgtype.Int8        `json:"company_id"`
	PropertyTypeID             pgtype.Int8        `json:"property_type_id"`
	UnitTypeID                 []int64            `json:"unit_type_id"`
	PropertyTitle              pgtype.Text        `json:"property_title"`
	PropertyTitleArabic        pgtype.Text        `json:"property_title_arabic"`
	IsVerified_4               pgtype.Bool        `json:"is_verified_4"`
	AddressesID_4              pgtype.Int8        `json:"addresses_id_4"`
	EntityTypeID_2             pgtype.Int8        `json:"entity_type_id_2"`
	EntityID_2                 pgtype.Int8        `json:"entity_id_2"`
	Status_5                   pgtype.Int8        `json:"status_5"`
	IsShowOwnerInfo            pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName               pgtype.Text        `json:"property_name"`
	Description_5              pgtype.Text        `json:"description_5"`
	DescriptionArabic_3        pgtype.Text        `json:"description_arabic_3"`
	OwnerUsersID               pgtype.Int8        `json:"owner_users_id"`
	UserID                     pgtype.Int8        `json:"user_id"`
	UpdatedBy_3                pgtype.Int8        `json:"updated_by_3"`
	FromXml                    pgtype.Bool        `json:"from_xml"`
	Facts_4                    []byte             `json:"facts_4"`
	Notes                      pgtype.Text        `json:"notes"`
	CreatedAt_6                pgtype.Timestamptz `json:"created_at_6"`
	UpdatedAt_5                pgtype.Timestamptz `json:"updated_at_5"`
	NotesAr                    pgtype.Text        `json:"notes_ar"`
	IsPublicNote               pgtype.Bool        `json:"is_public_note"`
	IsProjectProperty          pgtype.Bool        `json:"is_project_property"`
	Exclusive_4                pgtype.Bool        `json:"exclusive_4"`
	StartDate_4                pgtype.Date        `json:"start_date_4"`
	EndDate_4                  pgtype.Date        `json:"end_date_4"`
	ID_7                       pgtype.Int8        `json:"id_7"`
	Title_2                    pgtype.Text        `json:"title_2"`
	ViewsCount_2               pgtype.Int8        `json:"views_count_2"`
	TitleArabic_2              pgtype.Text        `json:"title_arabic_2"`
	Description_6              pgtype.Text        `json:"description_6"`
	DescriptionArabic_4        pgtype.Text        `json:"description_arabic_4"`
	UnitID                     pgtype.Int8        `json:"unit_id"`
	RefNo_4                    pgtype.Text        `json:"ref_no_4"`
	Status_6                   pgtype.Int8        `json:"status_6"`
	Type                       pgtype.Int8        `json:"type"`
	UnitRank                   pgtype.Int8        `json:"unit_rank"`
	CreatedAt_7                pgtype.Timestamptz `json:"created_at_7"`
	UpdatedAt_6                pgtype.Timestamptz `json:"updated_at_6"`
	CreatedBy_3                pgtype.Int8        `json:"created_by_3"`
	UpdatedBy_4                pgtype.Int8        `json:"updated_by_4"`
	Facts_5                    []byte             `json:"facts_5"`
	ListedBy                   pgtype.Int8        `json:"listed_by"`
	HasGallery_2               pgtype.Bool        `json:"has_gallery_2"`
	HasPlans_2                 pgtype.Bool        `json:"has_plans_2"`
	IsMain_2                   pgtype.Bool        `json:"is_main_2"`
	IsVerified_5               pgtype.Bool        `json:"is_verified_5"`
	Exclusive_5                pgtype.Bool        `json:"exclusive_5"`
	StartDate_5                pgtype.Date        `json:"start_date_5"`
	EndDate_5                  pgtype.Date        `json:"end_date_5"`
	Slug_3                     pgtype.Text        `json:"slug_3"`
	IsHotdeal_2                pgtype.Bool        `json:"is_hotdeal_2"`
	RefreshedAt_3              pgtype.Timestamptz `json:"refreshed_at_3"`
}

// ------------------------------------- End Sharing  -------------------------------------------------------
// ------------------------------------- New Sharing  Queries -----------------------------------------------
func (q *Queries) GetSharingEntityIDsByEntityType(ctx context.Context, arg GetSharingEntityIDsByEntityTypeParams) ([]GetSharingEntityIDsByEntityTypeRow, error) {
	rows, err := q.db.Query(ctx, getSharingEntityIDsByEntityType,
		arg.Limit,
		arg.Offset,
		arg.EntityTypeID,
		arg.Search,
		arg.CreatedBy,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharingEntityIDsByEntityTypeRow
	for rows.Next() {
		var i GetSharingEntityIDsByEntityTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.SharingType,
			&i.EntityTypeID,
			&i.EntityID,
			&i.SharedTo,
			&i.IsEnabled,
			&i.CountryID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.ID_2,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt_2,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
			&i.ID_3,
			&i.RefNo,
			&i.CompanyName,
			&i.CompanyActivitiesID,
			&i.CompanyParentID,
			&i.TagLine,
			&i.Description_2,
			&i.DescriptionAr,
			&i.LogoUrl,
			&i.Email,
			&i.PhoneNumber,
			&i.WhatsappNumber,
			&i.IsVerified_2,
			&i.WebsiteUrl,
			&i.CoverImageUrl,
			&i.NoOfEmployees,
			&i.CompanyRank,
			&i.Status_2,
			&i.CompanyType,
			&i.AddressesID_2,
			&i.UsersID_2,
			&i.CreatedBy_2,
			&i.CreatedAt_3,
			&i.UpdatedAt_2,
			&i.UpdatedBy,
			&i.LocationUrl,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
			&i.ID_4,
			&i.PhaseName,
			&i.AddressesID_3,
			&i.CreatedAt_4,
			&i.UpdatedAt_3,
			&i.Status_3,
			&i.LiveStatus_2,
			&i.RefNo_2,
			&i.ProjectsID,
			&i.Rating_2,
			&i.Description_3,
			&i.DescriptionAr_2,
			&i.PolygonCoords_2,
			&i.Facts_2,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
			&i.BankName_2,
			&i.RegistrationDate_2,
			&i.EscrowNumber_2,
			&i.ID_5,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description_4,
			&i.DescriptionArabic_2,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts_3,
			&i.CreatedAt_5,
			&i.UpdatedAt_4,
			&i.UpdatedBy_2,
			&i.Status_4,
			&i.AgentID,
			&i.RefNo_3,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified_3,
			&i.Exclusive_3,
			&i.StartDate_3,
			&i.EndDate_3,
			&i.Slug_2,
			&i.IsHotdeal,
			&i.RefreshedAt_2,
			&i.ID_6,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified_4,
			&i.AddressesID_4,
			&i.EntityTypeID_2,
			&i.EntityID_2,
			&i.Status_5,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description_5,
			&i.DescriptionArabic_3,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy_3,
			&i.FromXml,
			&i.Facts_4,
			&i.Notes,
			&i.CreatedAt_6,
			&i.UpdatedAt_5,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive_4,
			&i.StartDate_4,
			&i.EndDate_4,
			&i.ID_7,
			&i.Title_2,
			&i.ViewsCount_2,
			&i.TitleArabic_2,
			&i.Description_6,
			&i.DescriptionArabic_4,
			&i.UnitID,
			&i.RefNo_4,
			&i.Status_6,
			&i.Type,
			&i.UnitRank,
			&i.CreatedAt_7,
			&i.UpdatedAt_6,
			&i.CreatedBy_3,
			&i.UpdatedBy_4,
			&i.Facts_5,
			&i.ListedBy,
			&i.HasGallery_2,
			&i.HasPlans_2,
			&i.IsMain_2,
			&i.IsVerified_5,
			&i.Exclusive_5,
			&i.StartDate_5,
			&i.EndDate_5,
			&i.Slug_3,
			&i.IsHotdeal_2,
			&i.RefreshedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleShareDoc = `-- name: GetSingleShareDoc :one
SELECT id, documents_category_id, documents_subcategory_id, file_url, is_allowed FROM single_share_doc
WHERE id =  $1
LIMIT 1
`

func (q *Queries) GetSingleShareDoc(ctx context.Context, id int64) (SingleShareDoc, error) {
	row := q.db.QueryRow(ctx, getSingleShareDoc, id)
	var i SingleShareDoc
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.IsAllowed,
	)
	return i, err
}

const updateAllShareDoc = `-- name: UpdateAllShareDoc :many
Update shared_documents
SET is_allowed = $1
WHERE id = ANY($2::bigint[])
RETURNING id, sharing_id, category_id, subcategory_id, file_url, status, is_allowed, created_at, updated_at
`

type UpdateAllShareDocParams struct {
	IsAllowed pgtype.Bool `json:"is_allowed"`
	DocsID    []int64     `json:"docs_id"`
}

func (q *Queries) UpdateAllShareDoc(ctx context.Context, arg UpdateAllShareDocParams) ([]SharedDocument, error) {
	rows, err := q.db.Query(ctx, updateAllShareDoc, arg.IsAllowed, arg.DocsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SharedDocument
	for rows.Next() {
		var i SharedDocument
		if err := rows.Scan(
			&i.ID,
			&i.SharingID,
			&i.CategoryID,
			&i.SubcategoryID,
			&i.FileUrl,
			&i.Status,
			&i.IsAllowed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExternalIsEnableCheck = `-- name: UpdateExternalIsEnableCheck :one
UPDATE external_sharing 
SET external_is_enabled = $2 
WHERE id = $1
RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id
`

type UpdateExternalIsEnableCheckParams struct {
	ID                int64         `json:"id"`
	ExternalIsEnabled []pgtype.Bool `json:"external_is_enabled"`
}

func (q *Queries) UpdateExternalIsEnableCheck(ctx context.Context, arg UpdateExternalIsEnableCheckParams) (ExternalSharing, error) {
	row := q.db.QueryRow(ctx, updateExternalIsEnableCheck, arg.ID, arg.ExternalIsEnabled)
	var i ExternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.ExternalCompanyType,
		&i.ExternalIsBranch,
		&i.ExternalCompanyID,
		&i.ExternalIsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const updateExternalSharing = `-- name: UpdateExternalSharing :one
UPDATE external_sharing
SET company_types_id =$2,
 companies_id =$3, 
 is_branch=$4,  
 is_project=$5,  
 project_id=$6,
 is_property=$7, 
 is_property_branch=$8,
 property_id = $9,
 is_unit = $10, 
 price = $11, 
 external_company_type = $12,
 external_is_branch = $13,
 external_company_id = $14,
 created_at = $15, 
 created_by = $16,
 phase_id = $17,
 external_is_enabled = $18,
 property_key = $19,
 unit_category =  $20,  
 unit_id =  $21
Where id=$1
RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, external_company_type, external_is_branch, external_company_id, external_is_enabled, created_at, created_by, phase_id
`

type UpdateExternalSharingParams struct {
	ID                  int64         `json:"id"`
	CompanyTypesID      int64         `json:"company_types_id"`
	CompaniesID         int64         `json:"companies_id"`
	IsBranch            pgtype.Bool   `json:"is_branch"`
	IsProject           pgtype.Bool   `json:"is_project"`
	ProjectID           pgtype.Int8   `json:"project_id"`
	IsProperty          pgtype.Bool   `json:"is_property"`
	IsPropertyBranch    pgtype.Bool   `json:"is_property_branch"`
	PropertyID          pgtype.Int8   `json:"property_id"`
	IsUnit              pgtype.Bool   `json:"is_unit"`
	Price               pgtype.Bool   `json:"price"`
	ExternalCompanyType []int64       `json:"external_company_type"`
	ExternalIsBranch    []pgtype.Bool `json:"external_is_branch"`
	ExternalCompanyID   []int64       `json:"external_company_id"`
	CreatedAt           time.Time     `json:"created_at"`
	CreatedBy           int64         `json:"created_by"`
	PhaseID             pgtype.Int8   `json:"phase_id"`
	ExternalIsEnabled   []pgtype.Bool `json:"external_is_enabled"`
	PropertyKey         pgtype.Int8   `json:"property_key"`
	UnitCategory        pgtype.Text   `json:"unit_category"`
	UnitID              pgtype.Int8   `json:"unit_id"`
}

func (q *Queries) UpdateExternalSharing(ctx context.Context, arg UpdateExternalSharingParams) (ExternalSharing, error) {
	row := q.db.QueryRow(ctx, updateExternalSharing,
		arg.ID,
		arg.CompanyTypesID,
		arg.CompaniesID,
		arg.IsBranch,
		arg.IsProject,
		arg.ProjectID,
		arg.IsProperty,
		arg.IsPropertyBranch,
		arg.PropertyID,
		arg.IsUnit,
		arg.Price,
		arg.ExternalCompanyType,
		arg.ExternalIsBranch,
		arg.ExternalCompanyID,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.PhaseID,
		arg.ExternalIsEnabled,
		arg.PropertyKey,
		arg.UnitCategory,
		arg.UnitID,
	)
	var i ExternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.ExternalCompanyType,
		&i.ExternalIsBranch,
		&i.ExternalCompanyID,
		&i.ExternalIsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const updateInternalIsEnableCheck = `-- name: UpdateInternalIsEnableCheck :one
UPDATE internal_sharing 
SET is_enabled = $2 
WHERE id = $1
RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id
`

type UpdateInternalIsEnableCheckParams struct {
	ID        int64         `json:"id"`
	IsEnabled []pgtype.Bool `json:"is_enabled"`
}

func (q *Queries) UpdateInternalIsEnableCheck(ctx context.Context, arg UpdateInternalIsEnableCheckParams) (InternalSharing, error) {
	row := q.db.QueryRow(ctx, updateInternalIsEnableCheck, arg.ID, arg.IsEnabled)
	var i InternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const updateInternalShare = `-- name: UpdateInternalShare :one
UPDATE internal_sharing
SET  company_types_id = $2,
     companies_id = $3, 
     is_branch = $4, 
     is_project = $5, 
     project_id = $6,   
     is_property = $7, 
     is_property_branch = $8,
     property_id = $9,  
     is_unit = $10,
     unit_category = $11, 
     price = $12,  
     shared_to = $13, 
     created_at = $14, 
     created_by = $15,
     phase_id = $16,
     is_enabled = $17,
     property_key = $18,
     unit_id =  $19 
Where id = $1
RETURNING id, company_types_id, companies_id, is_branch, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, price, shared_to, is_enabled, created_at, created_by, phase_id
`

type UpdateInternalShareParams struct {
	ID               int64         `json:"id"`
	CompanyTypesID   pgtype.Int8   `json:"company_types_id"`
	CompaniesID      pgtype.Int8   `json:"companies_id"`
	IsBranch         pgtype.Bool   `json:"is_branch"`
	IsProject        pgtype.Bool   `json:"is_project"`
	ProjectID        pgtype.Int8   `json:"project_id"`
	IsProperty       pgtype.Bool   `json:"is_property"`
	IsPropertyBranch pgtype.Bool   `json:"is_property_branch"`
	PropertyID       pgtype.Int8   `json:"property_id"`
	IsUnit           pgtype.Bool   `json:"is_unit"`
	UnitCategory     pgtype.Text   `json:"unit_category"`
	Price            pgtype.Bool   `json:"price"`
	SharedTo         []int64       `json:"shared_to"`
	CreatedAt        time.Time     `json:"created_at"`
	CreatedBy        int64         `json:"created_by"`
	PhaseID          pgtype.Int8   `json:"phase_id"`
	IsEnabled        []pgtype.Bool `json:"is_enabled"`
	PropertyKey      pgtype.Int8   `json:"property_key"`
	UnitID           pgtype.Int8   `json:"unit_id"`
}

func (q *Queries) UpdateInternalShare(ctx context.Context, arg UpdateInternalShareParams) (InternalSharing, error) {
	row := q.db.QueryRow(ctx, updateInternalShare,
		arg.ID,
		arg.CompanyTypesID,
		arg.CompaniesID,
		arg.IsBranch,
		arg.IsProject,
		arg.ProjectID,
		arg.IsProperty,
		arg.IsPropertyBranch,
		arg.PropertyID,
		arg.IsUnit,
		arg.UnitCategory,
		arg.Price,
		arg.SharedTo,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.PhaseID,
		arg.IsEnabled,
		arg.PropertyKey,
		arg.UnitID,
	)
	var i InternalSharing
	err := row.Scan(
		&i.ID,
		&i.CompanyTypesID,
		&i.CompaniesID,
		&i.IsBranch,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Price,
		&i.SharedTo,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.PhaseID,
	)
	return i, err
}

const updateShareDoc = `-- name: UpdateShareDoc :one
UPDATE shared_doc
SET  sharing_id = $2,
  is_internal = $3,
  updated_at = $4,
   is_project = $5,
  project_id = $6,
  is_property = $7,
  is_property_branch = $8,
  property_id = $9,
  property_key = $10,
  is_unit = $11,
  status = $12,
  shared_to = $13,
  is_branch =  $14,
  phase_id =  $15,
  unit_id =  $16,
  unit_category = $17,
  single_share_docs =  $18
 Where id = $1
 Returning id, sharing_id, is_internal, single_share_docs, is_project, project_id, is_property, is_property_branch, property_id, property_key, is_unit, unit_id, unit_category, status, shared_to, is_branch, phase_id, created_at, updated_at
`

type UpdateShareDocParams struct {
	ID               int64       `json:"id"`
	SharingID        int64       `json:"sharing_id"`
	IsInternal       pgtype.Bool `json:"is_internal"`
	UpdatedAt        time.Time   `json:"updated_at"`
	IsProject        pgtype.Bool `json:"is_project"`
	ProjectID        pgtype.Int8 `json:"project_id"`
	IsProperty       pgtype.Bool `json:"is_property"`
	IsPropertyBranch pgtype.Bool `json:"is_property_branch"`
	PropertyID       pgtype.Int8 `json:"property_id"`
	PropertyKey      pgtype.Int8 `json:"property_key"`
	IsUnit           pgtype.Bool `json:"is_unit"`
	Status           int64       `json:"status"`
	SharedTo         int64       `json:"shared_to"`
	IsBranch         pgtype.Bool `json:"is_branch"`
	PhaseID          pgtype.Int8 `json:"phase_id"`
	UnitID           pgtype.Int8 `json:"unit_id"`
	UnitCategory     pgtype.Text `json:"unit_category"`
	SingleShareDocs  []int64     `json:"single_share_docs"`
}

func (q *Queries) UpdateShareDoc(ctx context.Context, arg UpdateShareDocParams) (SharedDoc, error) {
	row := q.db.QueryRow(ctx, updateShareDoc,
		arg.ID,
		arg.SharingID,
		arg.IsInternal,
		arg.UpdatedAt,
		arg.IsProject,
		arg.ProjectID,
		arg.IsProperty,
		arg.IsPropertyBranch,
		arg.PropertyID,
		arg.PropertyKey,
		arg.IsUnit,
		arg.Status,
		arg.SharedTo,
		arg.IsBranch,
		arg.PhaseID,
		arg.UnitID,
		arg.UnitCategory,
		arg.SingleShareDocs,
	)
	var i SharedDoc
	err := row.Scan(
		&i.ID,
		&i.SharingID,
		&i.IsInternal,
		&i.SingleShareDocs,
		&i.IsProject,
		&i.ProjectID,
		&i.IsProperty,
		&i.IsPropertyBranch,
		&i.PropertyID,
		&i.PropertyKey,
		&i.IsUnit,
		&i.UnitID,
		&i.UnitCategory,
		&i.Status,
		&i.SharedTo,
		&i.IsBranch,
		&i.PhaseID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSharingEnables = `-- name: UpdateSharingEnables :many
UPDATE sharing 
SET 
    is_enabled = $1::BOOLEAN
WHERE 
    CASE 
        WHEN $2::BIGINT > 0 THEN 
            sharing.entity_id = $2::BIGINT
        ELSE  (
                entity_type_id = $3
                AND shared_to = $4
                AND sharing.id = $5

        )            
    END
RETURNING id, sharing_type, entity_type_id, entity_id, shared_to, is_enabled, country_id, created_at, created_by
`

type UpdateSharingEnablesParams struct {
	Enable       bool        `json:"enable"`
	EntityID     int64       `json:"entity_id"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	UserID       int64       `json:"user_id"`
	SharingID    int64       `json:"sharing_id"`
}

func (q *Queries) UpdateSharingEnables(ctx context.Context, arg UpdateSharingEnablesParams) ([]Sharing, error) {
	rows, err := q.db.Query(ctx, updateSharingEnables,
		arg.Enable,
		arg.EntityID,
		arg.EntityTypeID,
		arg.UserID,
		arg.SharingID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sharing
	for rows.Next() {
		var i Sharing
		if err := rows.Scan(
			&i.ID,
			&i.SharingType,
			&i.EntityTypeID,
			&i.EntityID,
			&i.SharedTo,
			&i.IsEnabled,
			&i.CountryID,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSingleShareDoc = `-- name: UpdateSingleShareDoc :one
Update shared_documents
SET is_allowed = $2
WHERE id = $1
RETURNING id, sharing_id, category_id, subcategory_id, file_url, status, is_allowed, created_at, updated_at
`

type UpdateSingleShareDocParams struct {
	ID        int64       `json:"id"`
	IsAllowed pgtype.Bool `json:"is_allowed"`
}

// Update single_share_doc
func (q *Queries) UpdateSingleShareDoc(ctx context.Context, arg UpdateSingleShareDocParams) (SharedDocument, error) {
	row := q.db.QueryRow(ctx, updateSingleShareDoc, arg.ID, arg.IsAllowed)
	var i SharedDocument
	err := row.Scan(
		&i.ID,
		&i.SharingID,
		&i.CategoryID,
		&i.SubcategoryID,
		&i.FileUrl,
		&i.Status,
		&i.IsAllowed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
