// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: units_documents.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUnitsDocuments = `-- name: CreateUnitsDocuments :one
INSERT INTO units_documents (
    documents_category_id,
    documents_subcategory_id,
    file_url,
    created_at, 
    updated_at,
    units_id, 
    status
)VALUES (
    $1 ,$2, $3, $4, $5, $6, $7
) RETURNING id, documents_category_id, documents_subcategory_id, file_url, units_id, status, created_at, updated_at
`

type CreateUnitsDocumentsParams struct {
	DocumentsCategoryID    int64     `json:"documents_category_id"`
	DocumentsSubcategoryID int64     `json:"documents_subcategory_id"`
	FileUrl                []string  `json:"file_url"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
	UnitsID                int64     `json:"units_id"`
	Status                 int64     `json:"status"`
}

func (q *Queries) CreateUnitsDocuments(ctx context.Context, arg CreateUnitsDocumentsParams) (UnitsDocument, error) {
	row := q.db.QueryRow(ctx, createUnitsDocuments,
		arg.DocumentsCategoryID,
		arg.DocumentsSubcategoryID,
		arg.FileUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UnitsID,
		arg.Status,
	)
	var i UnitsDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.UnitsID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOneUnitDocByIdAndFile = `-- name: DeleteOneUnitDocByIdAndFile :one
UPDATE units_documents
SET file_url = array_remove(file_url, $2)
WHERE id = $1
RETURNING id, documents_category_id, documents_subcategory_id, file_url, units_id, status, created_at, updated_at
`

type DeleteOneUnitDocByIdAndFileParams struct {
	ID          int64       `json:"id"`
	ArrayRemove interface{} `json:"array_remove"`
}

func (q *Queries) DeleteOneUnitDocByIdAndFile(ctx context.Context, arg DeleteOneUnitDocByIdAndFileParams) (UnitsDocument, error) {
	row := q.db.QueryRow(ctx, deleteOneUnitDocByIdAndFile, arg.ID, arg.ArrayRemove)
	var i UnitsDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.UnitsID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUnitsDocuments = `-- name: DeleteUnitsDocuments :exec
DELETE FROM units_documents
WHERE id = $1
`

func (q *Queries) DeleteUnitsDocuments(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUnitsDocuments, id)
	return err
}

const getAllUnitDocsByUnitId = `-- name: GetAllUnitDocsByUnitId :many
SELECT units_documents.id, units_documents.documents_category_id, units_documents.documents_subcategory_id, units_documents.file_url, units_documents.units_id, units_documents.status, units_documents.created_at, units_documents.updated_at,documents_category.category AS documents_category, documents_category.category_ar AS documents_category_ar,documents_subcategory.sub_category AS documents_subcategory
FROM units_documents 
INNER JOIN documents_category ON units_documents.documents_category_id = documents_category.id
INNER JOIN documents_subcategory ON units_documents.documents_subcategory_id = documents_subcategory.id
WHERE units_id = $3 AND (units_documents.status != 5 AND units_documents.status != 6)
LIMIT $1 OFFSET $2
`

type GetAllUnitDocsByUnitIdParams struct {
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
	UnitsID int64 `json:"units_id"`
}

type GetAllUnitDocsByUnitIdRow struct {
	ID                     int64       `json:"id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                []string    `json:"file_url"`
	UnitsID                int64       `json:"units_id"`
	Status                 int64       `json:"status"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	DocumentsCategory      string      `json:"documents_category"`
	DocumentsCategoryAr    pgtype.Text `json:"documents_category_ar"`
	DocumentsSubcategory   string      `json:"documents_subcategory"`
}

func (q *Queries) GetAllUnitDocsByUnitId(ctx context.Context, arg GetAllUnitDocsByUnitIdParams) ([]GetAllUnitDocsByUnitIdRow, error) {
	rows, err := q.db.Query(ctx, getAllUnitDocsByUnitId, arg.Limit, arg.Offset, arg.UnitsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUnitDocsByUnitIdRow
	for rows.Next() {
		var i GetAllUnitDocsByUnitIdRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentsCategoryID,
			&i.DocumentsSubcategoryID,
			&i.FileUrl,
			&i.UnitsID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DocumentsCategory,
			&i.DocumentsCategoryAr,
			&i.DocumentsSubcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllUnitDocsByUnitId = `-- name: GetCountAllUnitDocsByUnitId :one
SELECT COUNT(*) 
FROM units_documents 
INNER JOIN documents_category ON units_documents.documents_category_id = documents_category.id
INNER JOIN documents_subcategory ON units_documents.documents_subcategory_id = documents_subcategory.id
WHERE units_id = $1 AND (units_documents.status != 5 AND units_documents.status != 6)
`

func (q *Queries) GetCountAllUnitDocsByUnitId(ctx context.Context, unitsID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllUnitDocsByUnitId, unitsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnitsDocuments = `-- name: GetUnitsDocuments :one
SELECT units_documents.id, units_documents.documents_category_id, units_documents.documents_subcategory_id, units_documents.file_url, units_documents.units_id, units_documents.status, units_documents.created_at, units_documents.updated_at,documents_category.category AS documents_category, documents_category.category_ar AS documents_category_ar, documents_subcategory.sub_category AS documents_subcategory
FROM units_documents 
INNER JOIN documents_category ON units_documents.documents_category_id = documents_category.id
INNER JOIN documents_subcategory ON units_documents.documents_subcategory_id = documents_subcategory.id 
WHERE units_documents.id = $1
`

type GetUnitsDocumentsRow struct {
	ID                     int64       `json:"id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                []string    `json:"file_url"`
	UnitsID                int64       `json:"units_id"`
	Status                 int64       `json:"status"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	DocumentsCategory      string      `json:"documents_category"`
	DocumentsCategoryAr    pgtype.Text `json:"documents_category_ar"`
	DocumentsSubcategory   string      `json:"documents_subcategory"`
}

func (q *Queries) GetUnitsDocuments(ctx context.Context, id int64) (GetUnitsDocumentsRow, error) {
	row := q.db.QueryRow(ctx, getUnitsDocuments, id)
	var i GetUnitsDocumentsRow
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.UnitsID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DocumentsCategory,
		&i.DocumentsCategoryAr,
		&i.DocumentsSubcategory,
	)
	return i, err
}

const getUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatId = `-- name: GetUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatId :one
SELECT id, documents_category_id, documents_subcategory_id, 
file_url, created_at, updated_at, units_id, status 
FROM units_documents 
WHERE units_id = $1 AND documents_category_id = $2 AND documents_subcategory_id = $3
`

type GetUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatIdParams struct {
	UnitsID                int64 `json:"units_id"`
	DocumentsCategoryID    int64 `json:"documents_category_id"`
	DocumentsSubcategoryID int64 `json:"documents_subcategory_id"`
}

type GetUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatIdRow struct {
	ID                     int64     `json:"id"`
	DocumentsCategoryID    int64     `json:"documents_category_id"`
	DocumentsSubcategoryID int64     `json:"documents_subcategory_id"`
	FileUrl                []string  `json:"file_url"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
	UnitsID                int64     `json:"units_id"`
	Status                 int64     `json:"status"`
}

func (q *Queries) GetUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatId(ctx context.Context, arg GetUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatIdParams) (GetUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatIdRow, error) {
	row := q.db.QueryRow(ctx, getUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatId, arg.UnitsID, arg.DocumentsCategoryID, arg.DocumentsSubcategoryID)
	var i GetUnitsDocumentsByUnitIdAndDocCatIdAndSubDocCatIdRow
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnitsID,
		&i.Status,
	)
	return i, err
}

const updateUnitDocFileUrls = `-- name: UpdateUnitDocFileUrls :one
UPDATE units_documents
SET file_url = $2,
  updated_at = $3
Where id = $1
RETURNING id, documents_category_id, documents_subcategory_id, file_url, units_id, status, created_at, updated_at
`

type UpdateUnitDocFileUrlsParams struct {
	ID        int64     `json:"id"`
	FileUrl   []string  `json:"file_url"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateUnitDocFileUrls(ctx context.Context, arg UpdateUnitDocFileUrlsParams) (UnitsDocument, error) {
	row := q.db.QueryRow(ctx, updateUnitDocFileUrls, arg.ID, arg.FileUrl, arg.UpdatedAt)
	var i UnitsDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.UnitsID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
