// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: other_users.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllFreelanceUsers = `-- name: CountAllFreelanceUsers :one
SELECT
  	COUNT(*)
FROM
	users 
	LEFT JOIN profiles ON profiles.users_id = users.id
    LEFT JOIN roles ON users.roles_id = roles.id
	LEFT JOIN department ON roles.department_id = department.id
	LEFT JOIN license l1 ON  users.id = l1.entity_id  AND l1.license_type_id = 5 -- brn
	LEFT JOIN license l2 ON  users.id = l2.entity_id  AND l2.license_type_id = 6 -- noc 
	------------------------------------------------------------@search---------------------
WHERE
    ($1 = $1
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $1 
      OR users.phone_number ILIKE $1
      OR users.email ILIKE $1
    )
	AND users.status NOT IN (5,6)
`

func (q *Queries) CountAllFreelanceUsers(ctx context.Context, search interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, countAllFreelanceUsers, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllOwnerUsers = `-- name: CountAllOwnerUsers :one
SELECT
  COUNT(*)
FROM
	users 
	LEFT JOIN profiles ON profiles.users_id = users.id
    LEFT JOIN roles ON users.roles_id = roles.id
	LEFT JOIN department ON roles.department_id = department.id
 	------------------------------------------------------------@search---------------------
WHERE
    ($1 = $1
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $1 
      OR users.phone_number ILIKE $1
      OR users.email ILIKE $1
    )
	AND users.status NOT IN (5,6)
`

func (q *Queries) CountAllOwnerUsers(ctx context.Context, search interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, countAllOwnerUsers, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllFreelanceUsers = `-- name: GetAllFreelanceUsers :many
SELECT
  	users.id,
  	profiles.profile_image_url,
	profiles.first_name,
	profiles.last_name,
	l1.license_no as brn,
	l2.license_no as noc,
	users.phone_number,
	users.email, 
	department.department,
	roles."role",
	users.is_verified, 
	users.status
FROM
	users 
	LEFT JOIN profiles ON profiles.users_id = users.id
    LEFT JOIN roles ON users.roles_id = roles.id
	LEFT JOIN department ON roles.department_id = department.id
	LEFT JOIN license l1 ON  users.id = l1.entity_id  AND l1.license_type_id = 5 -- brn
	LEFT JOIN license l2 ON  users.id = l2.entity_id  AND l2.license_type_id = 6 -- noc 
	------------------------------------------------------------@search---------------------
WHERE
    ($3 = $3
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $3 
      OR users.phone_number ILIKE $3
      OR users.email ILIKE $3
    )
	AND users.status NOT IN (5,6)
ORDER BY
	users.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAllFreelanceUsersParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Search interface{} `json:"search"`
}

type GetAllFreelanceUsersRow struct {
	ID              int64       `json:"id"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
	FirstName       pgtype.Text `json:"first_name"`
	LastName        pgtype.Text `json:"last_name"`
	Brn             pgtype.Text `json:"brn"`
	Noc             pgtype.Text `json:"noc"`
	PhoneNumber     pgtype.Text `json:"phone_number"`
	Email           string      `json:"email"`
	Department      pgtype.Text `json:"department"`
	Role            pgtype.Text `json:"role"`
	IsVerified      pgtype.Bool `json:"is_verified"`
	Status          int64       `json:"status"`
}

func (q *Queries) GetAllFreelanceUsers(ctx context.Context, arg GetAllFreelanceUsersParams) ([]GetAllFreelanceUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllFreelanceUsers, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFreelanceUsersRow
	for rows.Next() {
		var i GetAllFreelanceUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileImageUrl,
			&i.FirstName,
			&i.LastName,
			&i.Brn,
			&i.Noc,
			&i.PhoneNumber,
			&i.Email,
			&i.Department,
			&i.Role,
			&i.IsVerified,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOwnerUsers = `-- name: GetAllOwnerUsers :many
SELECT
  	users.id,
  	profiles.profile_image_url,
	profiles.first_name,
	profiles.last_name, 
	users.phone_number,
	users.is_verified, 
	users.email,
	users.status
FROM
	users 
	LEFT JOIN profiles ON profiles.users_id = users.id
    LEFT JOIN roles ON users.roles_id = roles.id
	LEFT JOIN department ON roles.department_id = department.id
 	------------------------------------------------------------@search---------------------
WHERE
    ($3 = $3
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $3 
      OR users.phone_number ILIKE $3
      OR users.email ILIKE $3
    )
	AND users.status NOT IN (5,6)
ORDER BY
	users.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAllOwnerUsersParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Search interface{} `json:"search"`
}

type GetAllOwnerUsersRow struct {
	ID              int64       `json:"id"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
	FirstName       pgtype.Text `json:"first_name"`
	LastName        pgtype.Text `json:"last_name"`
	PhoneNumber     pgtype.Text `json:"phone_number"`
	IsVerified      pgtype.Bool `json:"is_verified"`
	Email           string      `json:"email"`
	Status          int64       `json:"status"`
}

func (q *Queries) GetAllOwnerUsers(ctx context.Context, arg GetAllOwnerUsersParams) ([]GetAllOwnerUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllOwnerUsers, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOwnerUsersRow
	for rows.Next() {
		var i GetAllOwnerUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileImageUrl,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.IsVerified,
			&i.Email,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
