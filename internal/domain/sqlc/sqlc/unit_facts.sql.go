// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: unit_facts.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUnitFact = `-- name: CreateUnitFact :one
INSERT INTO unit_facts (
bedroom,
bathroom,
plot_area,
built_up_area, 
view, 
furnished, 
ownership,  
completion_status, 
start_date, 
completion_date,  
handover_date,  
no_of_floor,  
no_of_units, 
min_area,  
max_area,  
service_charge,  
parking,  
ask_price,  
price , 
rent_type,  
no_of_payment,  
no_of_retail, 
no_of_pool, 
elevator, 
starting_price ,
life_style,  
unit_id,
category,  
is_branch ,
created_at,  
updated_at,
commercial_tax,
municipality_tax,
sc_currency_id,
unit_of_measure
)VALUES (
     $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,$21,$22,$23,$24,$25,$26,$27,$28, $29, $30, $31, $32, $33, $34, $35
) RETURNING id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, unit_id, category, is_branch, created_at, updated_at, commercial_tax, municipality_tax, sc_currency_id, unit_of_measure
`

type CreateUnitFactParams struct {
	Bedroom          pgtype.Text        `json:"bedroom"`
	Bathroom         pgtype.Int8        `json:"bathroom"`
	PlotArea         pgtype.Float8      `json:"plot_area"`
	BuiltUpArea      pgtype.Float8      `json:"built_up_area"`
	View             []int64            `json:"view"`
	Furnished        pgtype.Int8        `json:"furnished"`
	Ownership        pgtype.Int8        `json:"ownership"`
	CompletionStatus pgtype.Int8        `json:"completion_status"`
	StartDate        pgtype.Timestamptz `json:"start_date"`
	CompletionDate   pgtype.Timestamptz `json:"completion_date"`
	HandoverDate     pgtype.Timestamptz `json:"handover_date"`
	NoOfFloor        pgtype.Int8        `json:"no_of_floor"`
	NoOfUnits        pgtype.Int8        `json:"no_of_units"`
	MinArea          pgtype.Float8      `json:"min_area"`
	MaxArea          pgtype.Float8      `json:"max_area"`
	ServiceCharge    pgtype.Int8        `json:"service_charge"`
	Parking          pgtype.Int8        `json:"parking"`
	AskPrice         pgtype.Bool        `json:"ask_price"`
	Price            pgtype.Float8      `json:"price"`
	RentType         pgtype.Int8        `json:"rent_type"`
	NoOfPayment      pgtype.Int8        `json:"no_of_payment"`
	NoOfRetail       pgtype.Int8        `json:"no_of_retail"`
	NoOfPool         pgtype.Int8        `json:"no_of_pool"`
	Elevator         pgtype.Int8        `json:"elevator"`
	StartingPrice    pgtype.Int8        `json:"starting_price"`
	LifeStyle        pgtype.Int8        `json:"life_style"`
	UnitID           int64              `json:"unit_id"`
	Category         string             `json:"category"`
	IsBranch         pgtype.Bool        `json:"is_branch"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	CommercialTax    pgtype.Float8      `json:"commercial_tax"`
	MunicipalityTax  pgtype.Float8      `json:"municipality_tax"`
	ScCurrencyID     pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure    pgtype.Text        `json:"unit_of_measure"`
}

func (q *Queries) CreateUnitFact(ctx context.Context, arg CreateUnitFactParams) (UnitFact, error) {
	row := q.db.QueryRow(ctx, createUnitFact,
		arg.Bedroom,
		arg.Bathroom,
		arg.PlotArea,
		arg.BuiltUpArea,
		arg.View,
		arg.Furnished,
		arg.Ownership,
		arg.CompletionStatus,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.NoOfFloor,
		arg.NoOfUnits,
		arg.MinArea,
		arg.MaxArea,
		arg.ServiceCharge,
		arg.Parking,
		arg.AskPrice,
		arg.Price,
		arg.RentType,
		arg.NoOfPayment,
		arg.NoOfRetail,
		arg.NoOfPool,
		arg.Elevator,
		arg.StartingPrice,
		arg.LifeStyle,
		arg.UnitID,
		arg.Category,
		arg.IsBranch,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CommercialTax,
		arg.MunicipalityTax,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
	)
	var i UnitFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.UnitID,
		&i.Category,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}

const deleteUnitFact = `-- name: DeleteUnitFact :exec
DELETE FROM unit_facts
Where id = $1
`

func (q *Queries) DeleteUnitFact(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUnitFact, id)
	return err
}

const getAllUnitFact = `-- name: GetAllUnitFact :many
SELECT id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, unit_id, category, is_branch, created_at, updated_at, commercial_tax, municipality_tax, sc_currency_id, unit_of_measure FROM unit_facts
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllUnitFactParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllUnitFact(ctx context.Context, arg GetAllUnitFactParams) ([]UnitFact, error) {
	rows, err := q.db.Query(ctx, getAllUnitFact, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitFact
	for rows.Next() {
		var i UnitFact
		if err := rows.Scan(
			&i.ID,
			&i.Bedroom,
			&i.Bathroom,
			&i.PlotArea,
			&i.BuiltUpArea,
			&i.View,
			&i.Furnished,
			&i.Ownership,
			&i.CompletionStatus,
			&i.StartDate,
			&i.CompletionDate,
			&i.HandoverDate,
			&i.NoOfFloor,
			&i.NoOfUnits,
			&i.MinArea,
			&i.MaxArea,
			&i.ServiceCharge,
			&i.Parking,
			&i.AskPrice,
			&i.Price,
			&i.RentType,
			&i.NoOfPayment,
			&i.NoOfRetail,
			&i.NoOfPool,
			&i.Elevator,
			&i.StartingPrice,
			&i.LifeStyle,
			&i.UnitID,
			&i.Category,
			&i.IsBranch,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CommercialTax,
			&i.MunicipalityTax,
			&i.ScCurrencyID,
			&i.UnitOfMeasure,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitFact = `-- name: GetUnitFact :one
SELECT id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, unit_id, category, is_branch, created_at, updated_at, commercial_tax, municipality_tax, sc_currency_id, unit_of_measure FROM unit_facts 
WHERE id = $1
`

func (q *Queries) GetUnitFact(ctx context.Context, id int64) (UnitFact, error) {
	row := q.db.QueryRow(ctx, getUnitFact, id)
	var i UnitFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.UnitID,
		&i.Category,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}

const getUnitFactsByUnit = `-- name: GetUnitFactsByUnit :one
SELECT id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, unit_id, category, is_branch, created_at, updated_at, commercial_tax, municipality_tax, sc_currency_id, unit_of_measure FROM unit_facts
WHERE unit_facts.unit_id = $1 AND unit_facts.category = $2 AND unit_facts.is_branch = $3
`

type GetUnitFactsByUnitParams struct {
	UnitID   int64       `json:"unit_id"`
	Category string      `json:"category"`
	IsBranch pgtype.Bool `json:"is_branch"`
}

func (q *Queries) GetUnitFactsByUnit(ctx context.Context, arg GetUnitFactsByUnitParams) (UnitFact, error) {
	row := q.db.QueryRow(ctx, getUnitFactsByUnit, arg.UnitID, arg.Category, arg.IsBranch)
	var i UnitFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.UnitID,
		&i.Category,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}

const updateUnitFact = `-- name: UpdateUnitFact :one
UPDATE unit_facts
SET  bedroom = $2,  
bathroom = $3, 
plot_area = $4,  
built_up_area = $5, 
view = $6, 
furnished = $7, 
ownership = $8,  
completion_status = $9, 
start_date = $10, 
completion_date = $11,  
handover_date = $12,  
no_of_floor = $13,  
no_of_units = $14, 
min_area = $15,  
max_area = $16,  
service_charge = $17,  
parking = $18,  
ask_price = $19,  
price = $20, 
rent_type = $21,  
no_of_payment = $22,  
no_of_retail = $23, 
no_of_pool = $24, 
elevator = $25, 
starting_price = $26,
life_style = $27,  
unit_id = $28,  
category = $29,
is_branch = $30,
created_at = $31,  
updated_at = $32,
commercial_tax = $33,
municipality_tax = $34,
sc_currency_id = $35,
unit_of_measure = $36
Where id = $1
RETURNING id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, unit_id, category, is_branch, created_at, updated_at, commercial_tax, municipality_tax, sc_currency_id, unit_of_measure
`

type UpdateUnitFactParams struct {
	ID               int64              `json:"id"`
	Bedroom          pgtype.Text        `json:"bedroom"`
	Bathroom         pgtype.Int8        `json:"bathroom"`
	PlotArea         pgtype.Float8      `json:"plot_area"`
	BuiltUpArea      pgtype.Float8      `json:"built_up_area"`
	View             []int64            `json:"view"`
	Furnished        pgtype.Int8        `json:"furnished"`
	Ownership        pgtype.Int8        `json:"ownership"`
	CompletionStatus pgtype.Int8        `json:"completion_status"`
	StartDate        pgtype.Timestamptz `json:"start_date"`
	CompletionDate   pgtype.Timestamptz `json:"completion_date"`
	HandoverDate     pgtype.Timestamptz `json:"handover_date"`
	NoOfFloor        pgtype.Int8        `json:"no_of_floor"`
	NoOfUnits        pgtype.Int8        `json:"no_of_units"`
	MinArea          pgtype.Float8      `json:"min_area"`
	MaxArea          pgtype.Float8      `json:"max_area"`
	ServiceCharge    pgtype.Int8        `json:"service_charge"`
	Parking          pgtype.Int8        `json:"parking"`
	AskPrice         pgtype.Bool        `json:"ask_price"`
	Price            pgtype.Float8      `json:"price"`
	RentType         pgtype.Int8        `json:"rent_type"`
	NoOfPayment      pgtype.Int8        `json:"no_of_payment"`
	NoOfRetail       pgtype.Int8        `json:"no_of_retail"`
	NoOfPool         pgtype.Int8        `json:"no_of_pool"`
	Elevator         pgtype.Int8        `json:"elevator"`
	StartingPrice    pgtype.Int8        `json:"starting_price"`
	LifeStyle        pgtype.Int8        `json:"life_style"`
	UnitID           int64              `json:"unit_id"`
	Category         string             `json:"category"`
	IsBranch         pgtype.Bool        `json:"is_branch"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	CommercialTax    pgtype.Float8      `json:"commercial_tax"`
	MunicipalityTax  pgtype.Float8      `json:"municipality_tax"`
	ScCurrencyID     pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure    pgtype.Text        `json:"unit_of_measure"`
}

func (q *Queries) UpdateUnitFact(ctx context.Context, arg UpdateUnitFactParams) (UnitFact, error) {
	row := q.db.QueryRow(ctx, updateUnitFact,
		arg.ID,
		arg.Bedroom,
		arg.Bathroom,
		arg.PlotArea,
		arg.BuiltUpArea,
		arg.View,
		arg.Furnished,
		arg.Ownership,
		arg.CompletionStatus,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.NoOfFloor,
		arg.NoOfUnits,
		arg.MinArea,
		arg.MaxArea,
		arg.ServiceCharge,
		arg.Parking,
		arg.AskPrice,
		arg.Price,
		arg.RentType,
		arg.NoOfPayment,
		arg.NoOfRetail,
		arg.NoOfPool,
		arg.Elevator,
		arg.StartingPrice,
		arg.LifeStyle,
		arg.UnitID,
		arg.Category,
		arg.IsBranch,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CommercialTax,
		arg.MunicipalityTax,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
	)
	var i UnitFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.UnitID,
		&i.Category,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}
