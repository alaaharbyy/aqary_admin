// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: company_profiles.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkIfXMLCompanyProfilePhaseExist = `-- name: CheckIfXMLCompanyProfilePhaseExist :one
SELECT EXISTS(
    SELECT id FROM company_profiles_phases
    WHERE ref_number = $1
)::boolean
`

func (q *Queries) CheckIfXMLCompanyProfilePhaseExist(ctx context.Context, refNumber string) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfXMLCompanyProfilePhaseExist, refNumber)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkIfXMLCompanyProfileProjectExist = `-- name: CheckIfXMLCompanyProfileProjectExist :one
SELECT EXISTS(
    SELECT id FROM company_profiles_projects
    WHERE ref_number = $1
)::boolean
`

func (q *Queries) CheckIfXMLCompanyProfileProjectExist(ctx context.Context, refNumber string) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfXMLCompanyProfileProjectExist, refNumber)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createCompanyProfilePhase = `-- name: CreateCompanyProfilePhase :one
INSERT INTO company_profiles_phases(
    ref_number,
    company_profiles_projects_id,
    phase_name,
    registration_date,
    bank_name,
    escrow_number,
    facts,
    properties_ref_nos,
    promotions,
    status
)VALUES(
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)RETURNING id, ref_number, company_profiles_projects_id, phase_name, registration_date, bank_name, escrow_number, facts, properties_ref_nos, promotions, status
`

type CreateCompanyProfilePhaseParams struct {
	RefNumber                 string      `json:"ref_number"`
	CompanyProfilesProjectsID int64       `json:"company_profiles_projects_id"`
	PhaseName                 string      `json:"phase_name"`
	RegistrationDate          pgtype.Date `json:"registration_date"`
	BankName                  pgtype.Text `json:"bank_name"`
	EscrowNumber              pgtype.Text `json:"escrow_number"`
	Facts                     []byte      `json:"facts"`
	PropertiesRefNos          []string    `json:"properties_ref_nos"`
	Promotions                []byte      `json:"promotions"`
	Status                    int64       `json:"status"`
}

func (q *Queries) CreateCompanyProfilePhase(ctx context.Context, arg CreateCompanyProfilePhaseParams) (CompanyProfilesPhase, error) {
	row := q.db.QueryRow(ctx, createCompanyProfilePhase,
		arg.RefNumber,
		arg.CompanyProfilesProjectsID,
		arg.PhaseName,
		arg.RegistrationDate,
		arg.BankName,
		arg.EscrowNumber,
		arg.Facts,
		arg.PropertiesRefNos,
		arg.Promotions,
		arg.Status,
	)
	var i CompanyProfilesPhase
	err := row.Scan(
		&i.ID,
		&i.RefNumber,
		&i.CompanyProfilesProjectsID,
		&i.PhaseName,
		&i.RegistrationDate,
		&i.BankName,
		&i.EscrowNumber,
		&i.Facts,
		&i.PropertiesRefNos,
		&i.Promotions,
		&i.Status,
	)
	return i, err
}

const createCompanyProfiles = `-- name: CreateCompanyProfiles :one
INSERT INTO company_profiles (
    ref_no,
    company_type,
    company_name,
    company_name_ar,
    company_category_id,
    company_activities_id, 
    website_url,
    company_email,
    phone_number,
    logo_url,
    cover_image_url, 
    internal_cover_image,
    description,
    description_ar,
    status,
    addresses_id,
    created_by,
    created_at, 
    updated_at,
    updated_by, 
    sort_order
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18,$19,$20, $21
) RETURNING id, ref_no, company_type, company_name, company_name_ar, company_category_id, company_activities_id, website_url, company_email, phone_number, logo_url, cover_image_url, internal_cover_image, description, description_ar, status, addresses_id, created_by, sort_order, created_at, updated_at, updated_by
`

type CreateCompanyProfilesParams struct {
	RefNo               string      `json:"ref_no"`
	CompanyType         int64       `json:"company_type"`
	CompanyName         string      `json:"company_name"`
	CompanyNameAr       pgtype.Text `json:"company_name_ar"`
	CompanyCategoryID   int64       `json:"company_category_id"`
	CompanyActivitiesID []int64     `json:"company_activities_id"`
	WebsiteUrl          pgtype.Text `json:"website_url"`
	CompanyEmail        string      `json:"company_email"`
	PhoneNumber         string      `json:"phone_number"`
	LogoUrl             string      `json:"logo_url"`
	CoverImageUrl       string      `json:"cover_image_url"`
	InternalCoverImage  string      `json:"internal_cover_image"`
	Description         string      `json:"description"`
	DescriptionAr       pgtype.Text `json:"description_ar"`
	Status              int64       `json:"status"`
	AddressesID         int64       `json:"addresses_id"`
	CreatedBy           int64       `json:"created_by"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	UpdatedBy           pgtype.Int8 `json:"updated_by"`
	SortOrder           pgtype.Int8 `json:"sort_order"`
}

func (q *Queries) CreateCompanyProfiles(ctx context.Context, arg CreateCompanyProfilesParams) (CompanyProfile, error) {
	row := q.db.QueryRow(ctx, createCompanyProfiles,
		arg.RefNo,
		arg.CompanyType,
		arg.CompanyName,
		arg.CompanyNameAr,
		arg.CompanyCategoryID,
		arg.CompanyActivitiesID,
		arg.WebsiteUrl,
		arg.CompanyEmail,
		arg.PhoneNumber,
		arg.LogoUrl,
		arg.CoverImageUrl,
		arg.InternalCoverImage,
		arg.Description,
		arg.DescriptionAr,
		arg.Status,
		arg.AddressesID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.SortOrder,
	)
	var i CompanyProfile
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyType,
		&i.CompanyName,
		&i.CompanyNameAr,
		&i.CompanyCategoryID,
		&i.CompanyActivitiesID,
		&i.WebsiteUrl,
		&i.CompanyEmail,
		&i.PhoneNumber,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.InternalCoverImage,
		&i.Description,
		&i.DescriptionAr,
		&i.Status,
		&i.AddressesID,
		&i.CreatedBy,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const createCompanyProfilesProjects = `-- name: CreateCompanyProfilesProjects :one
INSERT INTO company_profiles_projects(
    ref_number,
	project_no ,
    project_name ,
    company_profiles_id,
    is_verified,
	is_multiphase ,
    license_no,
    addresses_id,
	bank_name,    
    escrow_number,
	registration_date,
	status,
	description,
    description_arabic,
    properties_ref_nos,
    facts,
    created_at,
    updated_at,
    promotions
)VALUES(
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19
)RETURNING id, ref_number, project_no, project_name, company_profiles_id, is_verified, is_multiphase, license_no, addresses_id, bank_name, escrow_number, registration_date, status, description, description_arabic, properties_ref_nos, facts, promotions, created_at, updated_at, slug
`

type CreateCompanyProfilesProjectsParams struct {
	RefNumber         string      `json:"ref_number"`
	ProjectNo         string      `json:"project_no"`
	ProjectName       string      `json:"project_name"`
	CompanyProfilesID int64       `json:"company_profiles_id"`
	IsVerified        bool        `json:"is_verified"`
	IsMultiphase      bool        `json:"is_multiphase"`
	LicenseNo         string      `json:"license_no"`
	AddressesID       int64       `json:"addresses_id"`
	BankName          pgtype.Text `json:"bank_name"`
	EscrowNumber      pgtype.Text `json:"escrow_number"`
	RegistrationDate  pgtype.Date `json:"registration_date"`
	Status            int64       `json:"status"`
	Description       string      `json:"description"`
	DescriptionArabic pgtype.Text `json:"description_arabic"`
	PropertiesRefNos  []string    `json:"properties_ref_nos"`
	Facts             []byte      `json:"facts"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	Promotions        []byte      `json:"promotions"`
}

func (q *Queries) CreateCompanyProfilesProjects(ctx context.Context, arg CreateCompanyProfilesProjectsParams) (CompanyProfilesProject, error) {
	row := q.db.QueryRow(ctx, createCompanyProfilesProjects,
		arg.RefNumber,
		arg.ProjectNo,
		arg.ProjectName,
		arg.CompanyProfilesID,
		arg.IsVerified,
		arg.IsMultiphase,
		arg.LicenseNo,
		arg.AddressesID,
		arg.BankName,
		arg.EscrowNumber,
		arg.RegistrationDate,
		arg.Status,
		arg.Description,
		arg.DescriptionArabic,
		arg.PropertiesRefNos,
		arg.Facts,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Promotions,
	)
	var i CompanyProfilesProject
	err := row.Scan(
		&i.ID,
		&i.RefNumber,
		&i.ProjectNo,
		&i.ProjectName,
		&i.CompanyProfilesID,
		&i.IsVerified,
		&i.IsMultiphase,
		&i.LicenseNo,
		&i.AddressesID,
		&i.BankName,
		&i.EscrowNumber,
		&i.RegistrationDate,
		&i.Status,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertiesRefNos,
		&i.Facts,
		&i.Promotions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
	)
	return i, err
}

const createXMLPlans = `-- name: CreateXMLPlans :exec

INSERT INTO plans(
	entity_type_id, entity_id, title, file_urls, created_at, updated_at, uploaded_by, updated_by
)VALUES (
	$1, $2, $3, $4, $5, $6, $7, $8
)
`

type CreateXMLPlansParams struct {
	EntityTypeID int64     `json:"entity_type_id"`
	EntityID     int64     `json:"entity_id"`
	Title        string    `json:"title"`
	FileUrls     []string  `json:"file_urls"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	UploadedBy   int64     `json:"uploaded_by"`
	UpdatedBy    int64     `json:"updated_by"`
}

// approve companies profiles
func (q *Queries) CreateXMLPlans(ctx context.Context, arg CreateXMLPlansParams) error {
	_, err := q.db.Exec(ctx, createXMLPlans,
		arg.EntityTypeID,
		arg.EntityID,
		arg.Title,
		arg.FileUrls,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UploadedBy,
		arg.UpdatedBy,
	)
	return err
}

const deleteCompanyProfileByID = `-- name: DeleteCompanyProfileByID :exec
DELETE FROM company_profiles WHERE id = $1
`

func (q *Queries) DeleteCompanyProfileByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCompanyProfileByID, id)
	return err
}

const deleteCompanyProfileProject = `-- name: DeleteCompanyProfileProject :exec
DELETE FROM company_profiles_projects WHERE id = $1
`

func (q *Queries) DeleteCompanyProfileProject(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCompanyProfileProject, id)
	return err
}

const deleteXMLBulkCompanyProfilePhases = `-- name: DeleteXMLBulkCompanyProfilePhases :exec
DELETE FROM company_profiles_phases
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteXMLBulkCompanyProfilePhases(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, deleteXMLBulkCompanyProfilePhases, ids)
	return err
}

const deleteXMLPlansByEntity = `-- name: DeleteXMLPlansByEntity :exec
DELETE FROM plans
WHERE entity_type_id = $1 AND entity_id = ANY($2::bigint[])
`

type DeleteXMLPlansByEntityParams struct {
	EntityTypeID int64   `json:"entity_type_id"`
	EntityIds    []int64 `json:"entity_ids"`
}

func (q *Queries) DeleteXMLPlansByEntity(ctx context.Context, arg DeleteXMLPlansByEntityParams) error {
	_, err := q.db.Exec(ctx, deleteXMLPlansByEntity, arg.EntityTypeID, arg.EntityIds)
	return err
}

const getAllCompanyProfilePhaseRefNosToDelete = `-- name: GetAllCompanyProfilePhaseRefNosToDelete :many
SELECT id, ref_number
FROM company_profiles_phases
WHERE ref_number != ALL($1::varchar[])
`

type GetAllCompanyProfilePhaseRefNosToDeleteRow struct {
	ID        int64  `json:"id"`
	RefNumber string `json:"ref_number"`
}

func (q *Queries) GetAllCompanyProfilePhaseRefNosToDelete(ctx context.Context, ignorePhaseRefnos []string) ([]GetAllCompanyProfilePhaseRefNosToDeleteRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyProfilePhaseRefNosToDelete, ignorePhaseRefnos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyProfilePhaseRefNosToDeleteRow
	for rows.Next() {
		var i GetAllCompanyProfilePhaseRefNosToDeleteRow
		if err := rows.Scan(&i.ID, &i.RefNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyProfilePhasesByProject = `-- name: GetAllCompanyProfilePhasesByProject :many
SELECT
	company_profiles_phases.id, company_profiles_phases.ref_number, company_profiles_phases.company_profiles_projects_id, company_profiles_phases.phase_name, company_profiles_phases.registration_date, company_profiles_phases.bank_name, company_profiles_phases.escrow_number, company_profiles_phases.facts, company_profiles_phases.properties_ref_nos, company_profiles_phases.promotions, company_profiles_phases.status
FROM
	company_profiles_phases
    LEFT JOIN company_profiles_projects ON company_profiles_projects.id = company_profiles_phases.company_profiles_projects_id
	LEFT JOIN addresses ON addresses.id = company_profiles_phases.addresses_id
    LEFT JOIN countries ON countries.id = addresses.countries_id
    LEFT JOIN states ON states.id = addresses.states_id
    LEFT JOIN cities ON cities.id = addresses.cities_id
    LEFT JOIN communities ON communities.id = addresses.communities_id
    LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
WHERE
    -- Search criteria
    ($4 = '%%' OR 
     company_profiles_projects.project_name % $4 OR 
      company_profiles_phases.phase_name % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     communities.community % $4 OR 
     sub_communities.sub_community % $4  
       OR (CASE 
         WHEN 'ready' ILIKE $4 THEN (company_profiles_phases.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $4  THEN (company_profiles_phases.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $4  THEN (company_profiles_phases.facts->>'completion_percentage')::TEXT % $4
        WHEN 'draft'ILIKE $4  THEN company_profiles_projects.status = 1
        WHEN 'available'ILIKE $4  THEN company_profiles_projects.status = 2
        WHEN 'block'ILIKE $4  THEN company_profiles_projects.status = 5
        WHEN 'single'ILIKE $4  THEN company_profiles_projects.is_multiphase = false
        WHEN 'multiple'ILIKE $4  THEN company_profiles_projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
     -- Company and branch permissions
     AND (
        $5::BOOLEAN != true
        OR (
            ($6 != false OR company_profiles_projects.developer_companies_id = $7::bigint)
            AND ($6 != true OR company_profiles_projects.developer_company_branches_id = $7::bigint)
        )
    )
    -- Location filters
    AND ($8::bigint = 0 OR addresses.countries_id = $8::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    -- AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
    -- AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
    -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
	AND company_profiles_projects.id = $3 AND (company_profiles_phases.status != 5 AND company_profiles_phases.status != 6)
ORDER BY
	company_profiles_phases.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllCompanyProfilePhasesByProjectParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	ID            int64       `json:"id"`
	Search        interface{} `json:"search"`
	IsCompanyUser bool        `json:"is_company_user"`
	CompanyBranch interface{} `json:"company_branch"`
	CompanyID     int64       `json:"company_id"`
	CountryID     int64       `json:"country_id"`
}

func (q *Queries) GetAllCompanyProfilePhasesByProject(ctx context.Context, arg GetAllCompanyProfilePhasesByProjectParams) ([]CompanyProfilesPhase, error) {
	rows, err := q.db.Query(ctx, getAllCompanyProfilePhasesByProject,
		arg.Limit,
		arg.Offset,
		arg.ID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyBranch,
		arg.CompanyID,
		arg.CountryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyProfilesPhase
	for rows.Next() {
		var i CompanyProfilesPhase
		if err := rows.Scan(
			&i.ID,
			&i.RefNumber,
			&i.CompanyProfilesProjectsID,
			&i.PhaseName,
			&i.RegistrationDate,
			&i.BankName,
			&i.EscrowNumber,
			&i.Facts,
			&i.PropertiesRefNos,
			&i.Promotions,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyProfilePhasesByStatus = `-- name: GetAllCompanyProfilePhasesByStatus :many
SELECT company_profiles_phases.id, company_profiles_phases.ref_number, company_profiles_phases.company_profiles_projects_id, company_profiles_phases.phase_name, company_profiles_phases.registration_date, company_profiles_phases.bank_name, company_profiles_phases.escrow_number, company_profiles_phases.facts, company_profiles_phases.properties_ref_nos, company_profiles_phases.promotions, company_profiles_phases.status,company_profiles_projects.project_name, addresses.full_address,coalesce(company_profiles.company_name, '')::VARCHAR as "company_name"
FROM company_profiles_phases
    LEFT JOIN company_profiles_projects ON company_profiles_projects.id = company_profiles_phases.company_profiles_projects_id
    INNER JOIN company_profiles ON company_profiles_projects.company_profiles_id = company_profiles.id
	LEFT JOIN addresses ON addresses.id = company_profiles_phases.addresses_id
    LEFT JOIN countries ON countries.id = addresses.countries_id
    LEFT JOIN states ON states.id = addresses.states_id
    LEFT JOIN cities ON cities.id = addresses.cities_id
    LEFT JOIN communities ON communities.id = addresses.communities_id
    LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
WHERE 
    -- Search criteria
    ($3 = '%%' OR 
     company_profiles_projects.project_name % $3 OR 
      company_profiles_phases.phase_name % $3 OR
     countries.country % $3 OR 
     states."state" % $3 OR 
     cities.city % $3 OR 
     communities.community % $3 OR 
     sub_communities.sub_community % $3  
       OR (CASE 
        WHEN 'ready' ILIKE $3 THEN (company_profiles_phases.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $3  THEN (company_profiles_phases.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $3  THEN (company_profiles_phases.facts->>'completion_percentage')::TEXT % $3
        WHEN 'draft'ILIKE $3  THEN company_profiles_projects.status = 1
        WHEN 'available'ILIKE $3  THEN company_profiles_projects.status = 2
        WHEN 'block'ILIKE $3  THEN company_profiles_projects.status = 5
        WHEN 'single'ILIKE $3  THEN company_profiles_projects.is_multiphase = false
        WHEN 'multiple'ILIKE $3  THEN company_profiles_projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
     -- Company and branch permissions
    --  AND (
    --     @is_company_user != true
    --     OR (
    --         (@company_branch != false OR company_profiles_projects.developer_companies_id = @company_id::bigint)
    --         AND (@company_branch != true OR company_profiles_projects.developer_company_branches_id = @company_id::bigint)
    --     )
    -- )

    -- Location filters
    AND ($4::bigint = 0 OR addresses.countries_id = $4::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    AND ($5::bigint = 0 OR addresses.cities_id = $5::bigint)
    AND ($6::bigint = 0 OR addresses.communities_id = $6::bigint)
    AND ($7::bigint = 0 OR addresses.sub_communities_id = $7::bigint)
    
ORDER BY company_profiles_phases.created_at DESC 
LIMIT $1 OFFSET $2
`

type GetAllCompanyProfilePhasesByStatusParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	Search         interface{} `json:"search"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
}

type GetAllCompanyProfilePhasesByStatusRow struct {
	ID                        int64       `json:"id"`
	RefNumber                 string      `json:"ref_number"`
	CompanyProfilesProjectsID int64       `json:"company_profiles_projects_id"`
	PhaseName                 string      `json:"phase_name"`
	RegistrationDate          pgtype.Date `json:"registration_date"`
	BankName                  pgtype.Text `json:"bank_name"`
	EscrowNumber              pgtype.Text `json:"escrow_number"`
	Facts                     []byte      `json:"facts"`
	PropertiesRefNos          []string    `json:"properties_ref_nos"`
	Promotions                []byte      `json:"promotions"`
	Status                    int64       `json:"status"`
	ProjectName               pgtype.Text `json:"project_name"`
	FullAddress               pgtype.Text `json:"full_address"`
	CompanyName               string      `json:"company_name"`
}

// AND company_profiles_phases.status = $3 //TODO: status
func (q *Queries) GetAllCompanyProfilePhasesByStatus(ctx context.Context, arg GetAllCompanyProfilePhasesByStatusParams) ([]GetAllCompanyProfilePhasesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyProfilePhasesByStatus,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyProfilePhasesByStatusRow
	for rows.Next() {
		var i GetAllCompanyProfilePhasesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNumber,
			&i.CompanyProfilesProjectsID,
			&i.PhaseName,
			&i.RegistrationDate,
			&i.BankName,
			&i.EscrowNumber,
			&i.Facts,
			&i.PropertiesRefNos,
			&i.Promotions,
			&i.Status,
			&i.ProjectName,
			&i.FullAddress,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyProfileProjectIdToDelete = `-- name: GetAllCompanyProfileProjectIdToDelete :many
SELECT 
    company_profiles_projects.id AS project_id,
    company_profiles_projects.is_multiphase,
    locations.id AS location_id,
    addresses.id AS addresses_id,
    ARRAY_AGG(DISTINCT company_profiles_phases.id) FILTER (WHERE company_profiles_phases.id IS NOT NULL)::BIGINT[] AS phase_ids,
    ARRAY_AGG(DISTINCT company_profiles_phases.ref_number) FILTER (WHERE company_profiles_phases.id IS NOT NULL)::VARCHAR[] AS phase_refnos
FROM company_profiles_projects
LEFT JOIN addresses ON company_profiles_projects.addresses_id = addresses.id
LEFT JOIN locations ON locations.id = addresses.locations_id
LEFT JOIN company_profiles_phases ON company_profiles_phases.company_profiles_projects_id = company_profiles_projects.id
WHERE company_profiles_projects.ref_number != ALL($1::varchar[])
GROUP BY company_profiles_projects.id, locations.id, addresses.id
`

type GetAllCompanyProfileProjectIdToDeleteRow struct {
	ProjectID    int64       `json:"project_id"`
	IsMultiphase bool        `json:"is_multiphase"`
	LocationID   pgtype.Int8 `json:"location_id"`
	AddressesID  pgtype.Int8 `json:"addresses_id"`
	PhaseIds     []int64     `json:"phase_ids"`
	PhaseRefnos  []string    `json:"phase_refnos"`
}

func (q *Queries) GetAllCompanyProfileProjectIdToDelete(ctx context.Context, ignoreProjectRefNos []string) ([]GetAllCompanyProfileProjectIdToDeleteRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyProfileProjectIdToDelete, ignoreProjectRefNos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyProfileProjectIdToDeleteRow
	for rows.Next() {
		var i GetAllCompanyProfileProjectIdToDeleteRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.IsMultiphase,
			&i.LocationID,
			&i.AddressesID,
			&i.PhaseIds,
			&i.PhaseRefnos,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyProfiles = `-- name: GetAllCompanyProfiles :many
SELECT id, ref_no, company_type, company_name, company_name_ar, company_category_id, company_activities_id, website_url, company_email, phone_number, logo_url, cover_image_url, internal_cover_image, description, description_ar, status, addresses_id, created_by, sort_order, created_at, updated_at, updated_by FROM company_profiles
`

func (q *Queries) GetAllCompanyProfiles(ctx context.Context) ([]CompanyProfile, error) {
	rows, err := q.db.Query(ctx, getAllCompanyProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyProfile
	for rows.Next() {
		var i CompanyProfile
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CompanyType,
			&i.CompanyName,
			&i.CompanyNameAr,
			&i.CompanyCategoryID,
			&i.CompanyActivitiesID,
			&i.WebsiteUrl,
			&i.CompanyEmail,
			&i.PhoneNumber,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.InternalCoverImage,
			&i.Description,
			&i.DescriptionAr,
			&i.Status,
			&i.AddressesID,
			&i.CreatedBy,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyProfilesByStatus = `-- name: GetAllCompanyProfilesByStatus :many
SELECT cp.id, ref_no, company_type, company_name, company_name_ar, company_category_id, company_activities_id, website_url, company_email, phone_number, logo_url, cover_image_url, internal_cover_image, description, description_ar, status, addresses_id, created_by, sort_order, cp.created_at, cp.updated_at, updated_by, a.id, countries_id, states_id, cities_id, communities_id, sub_communities_id, locations_id, a.created_at, a.updated_at, property_map_location_id, full_address, full_address_ar FROM company_profiles cp
INNER JOIN addresses a on a.id = cp.addresses_id 
WHERE cp.status = ANY($1::int[])
ORDER BY cp.created_at DESC
LIMIT $2
OFFSET $3
`

type GetAllCompanyProfilesByStatusParams struct {
	Column1 []int32 `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

type GetAllCompanyProfilesByStatusRow struct {
	ID                    int64       `json:"id"`
	RefNo                 string      `json:"ref_no"`
	CompanyType           int64       `json:"company_type"`
	CompanyName           string      `json:"company_name"`
	CompanyNameAr         pgtype.Text `json:"company_name_ar"`
	CompanyCategoryID     int64       `json:"company_category_id"`
	CompanyActivitiesID   []int64     `json:"company_activities_id"`
	WebsiteUrl            pgtype.Text `json:"website_url"`
	CompanyEmail          string      `json:"company_email"`
	PhoneNumber           string      `json:"phone_number"`
	LogoUrl               string      `json:"logo_url"`
	CoverImageUrl         string      `json:"cover_image_url"`
	InternalCoverImage    string      `json:"internal_cover_image"`
	Description           string      `json:"description"`
	DescriptionAr         pgtype.Text `json:"description_ar"`
	Status                int64       `json:"status"`
	AddressesID           int64       `json:"addresses_id"`
	CreatedBy             int64       `json:"created_by"`
	SortOrder             pgtype.Int8 `json:"sort_order"`
	CreatedAt             time.Time   `json:"created_at"`
	UpdatedAt             time.Time   `json:"updated_at"`
	UpdatedBy             pgtype.Int8 `json:"updated_by"`
	ID_2                  int64       `json:"id_2"`
	CountriesID           pgtype.Int8 `json:"countries_id"`
	StatesID              pgtype.Int8 `json:"states_id"`
	CitiesID              pgtype.Int8 `json:"cities_id"`
	CommunitiesID         pgtype.Int8 `json:"communities_id"`
	SubCommunitiesID      pgtype.Int8 `json:"sub_communities_id"`
	LocationsID           pgtype.Int8 `json:"locations_id"`
	CreatedAt_2           time.Time   `json:"created_at_2"`
	UpdatedAt_2           time.Time   `json:"updated_at_2"`
	PropertyMapLocationID pgtype.Int8 `json:"property_map_location_id"`
	FullAddress           pgtype.Text `json:"full_address"`
	FullAddressAr         pgtype.Text `json:"full_address_ar"`
}

func (q *Queries) GetAllCompanyProfilesByStatus(ctx context.Context, arg GetAllCompanyProfilesByStatusParams) ([]GetAllCompanyProfilesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyProfilesByStatus, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyProfilesByStatusRow
	for rows.Next() {
		var i GetAllCompanyProfilesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CompanyType,
			&i.CompanyName,
			&i.CompanyNameAr,
			&i.CompanyCategoryID,
			&i.CompanyActivitiesID,
			&i.WebsiteUrl,
			&i.CompanyEmail,
			&i.PhoneNumber,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.InternalCoverImage,
			&i.Description,
			&i.DescriptionAr,
			&i.Status,
			&i.AddressesID,
			&i.CreatedBy,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.ID_2,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunitiesID,
			&i.SubCommunitiesID,
			&i.LocationsID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.PropertyMapLocationID,
			&i.FullAddress,
			&i.FullAddressAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyProfilesByStatusInternational = `-- name: GetAllCompanyProfilesByStatusInternational :many
SELECT cp.id, ref_no, company_type, company_name, company_name_ar, company_category_id, company_activities_id, website_url, company_email, phone_number, logo_url, cover_image_url, internal_cover_image, description, description_ar, status, addresses_id, created_by, sort_order, cp.created_at, cp.updated_at, updated_by, a.id, countries_id, states_id, cities_id, communities_id, sub_communities_id, locations_id, a.created_at, a.updated_at, property_map_location_id, full_address, full_address_ar FROM company_profiles cp
INNER JOIN addresses a on a.id = cp.addresses_id 
where cp.status = $1 and a.countries_id != 1
LIMIT $2
OFFSET $3
`

type GetAllCompanyProfilesByStatusInternationalParams struct {
	Status int64 `json:"status"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllCompanyProfilesByStatusInternationalRow struct {
	ID                    int64       `json:"id"`
	RefNo                 string      `json:"ref_no"`
	CompanyType           int64       `json:"company_type"`
	CompanyName           string      `json:"company_name"`
	CompanyNameAr         pgtype.Text `json:"company_name_ar"`
	CompanyCategoryID     int64       `json:"company_category_id"`
	CompanyActivitiesID   []int64     `json:"company_activities_id"`
	WebsiteUrl            pgtype.Text `json:"website_url"`
	CompanyEmail          string      `json:"company_email"`
	PhoneNumber           string      `json:"phone_number"`
	LogoUrl               string      `json:"logo_url"`
	CoverImageUrl         string      `json:"cover_image_url"`
	InternalCoverImage    string      `json:"internal_cover_image"`
	Description           string      `json:"description"`
	DescriptionAr         pgtype.Text `json:"description_ar"`
	Status                int64       `json:"status"`
	AddressesID           int64       `json:"addresses_id"`
	CreatedBy             int64       `json:"created_by"`
	SortOrder             pgtype.Int8 `json:"sort_order"`
	CreatedAt             time.Time   `json:"created_at"`
	UpdatedAt             time.Time   `json:"updated_at"`
	UpdatedBy             pgtype.Int8 `json:"updated_by"`
	ID_2                  int64       `json:"id_2"`
	CountriesID           pgtype.Int8 `json:"countries_id"`
	StatesID              pgtype.Int8 `json:"states_id"`
	CitiesID              pgtype.Int8 `json:"cities_id"`
	CommunitiesID         pgtype.Int8 `json:"communities_id"`
	SubCommunitiesID      pgtype.Int8 `json:"sub_communities_id"`
	LocationsID           pgtype.Int8 `json:"locations_id"`
	CreatedAt_2           time.Time   `json:"created_at_2"`
	UpdatedAt_2           time.Time   `json:"updated_at_2"`
	PropertyMapLocationID pgtype.Int8 `json:"property_map_location_id"`
	FullAddress           pgtype.Text `json:"full_address"`
	FullAddressAr         pgtype.Text `json:"full_address_ar"`
}

func (q *Queries) GetAllCompanyProfilesByStatusInternational(ctx context.Context, arg GetAllCompanyProfilesByStatusInternationalParams) ([]GetAllCompanyProfilesByStatusInternationalRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyProfilesByStatusInternational, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyProfilesByStatusInternationalRow
	for rows.Next() {
		var i GetAllCompanyProfilesByStatusInternationalRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CompanyType,
			&i.CompanyName,
			&i.CompanyNameAr,
			&i.CompanyCategoryID,
			&i.CompanyActivitiesID,
			&i.WebsiteUrl,
			&i.CompanyEmail,
			&i.PhoneNumber,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.InternalCoverImage,
			&i.Description,
			&i.DescriptionAr,
			&i.Status,
			&i.AddressesID,
			&i.CreatedBy,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.ID_2,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunitiesID,
			&i.SubCommunitiesID,
			&i.LocationsID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.PropertyMapLocationID,
			&i.FullAddress,
			&i.FullAddressAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyProfilesByStatusLocal = `-- name: GetAllCompanyProfilesByStatusLocal :many
SELECT cp.id, ref_no, company_type, company_name, company_name_ar, company_category_id, company_activities_id, website_url, company_email, phone_number, logo_url, cover_image_url, internal_cover_image, description, description_ar, status, addresses_id, created_by, sort_order, cp.created_at, cp.updated_at, updated_by, a.id, countries_id, states_id, cities_id, communities_id, sub_communities_id, locations_id, a.created_at, a.updated_at, property_map_location_id, full_address, full_address_ar FROM company_profiles cp
INNER JOIN addresses a on a.id = cp.addresses_id 
where cp.status = $1 and a.countries_id = 1
LIMIT $2
OFFSET $3
`

type GetAllCompanyProfilesByStatusLocalParams struct {
	Status int64 `json:"status"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllCompanyProfilesByStatusLocalRow struct {
	ID                    int64       `json:"id"`
	RefNo                 string      `json:"ref_no"`
	CompanyType           int64       `json:"company_type"`
	CompanyName           string      `json:"company_name"`
	CompanyNameAr         pgtype.Text `json:"company_name_ar"`
	CompanyCategoryID     int64       `json:"company_category_id"`
	CompanyActivitiesID   []int64     `json:"company_activities_id"`
	WebsiteUrl            pgtype.Text `json:"website_url"`
	CompanyEmail          string      `json:"company_email"`
	PhoneNumber           string      `json:"phone_number"`
	LogoUrl               string      `json:"logo_url"`
	CoverImageUrl         string      `json:"cover_image_url"`
	InternalCoverImage    string      `json:"internal_cover_image"`
	Description           string      `json:"description"`
	DescriptionAr         pgtype.Text `json:"description_ar"`
	Status                int64       `json:"status"`
	AddressesID           int64       `json:"addresses_id"`
	CreatedBy             int64       `json:"created_by"`
	SortOrder             pgtype.Int8 `json:"sort_order"`
	CreatedAt             time.Time   `json:"created_at"`
	UpdatedAt             time.Time   `json:"updated_at"`
	UpdatedBy             pgtype.Int8 `json:"updated_by"`
	ID_2                  int64       `json:"id_2"`
	CountriesID           pgtype.Int8 `json:"countries_id"`
	StatesID              pgtype.Int8 `json:"states_id"`
	CitiesID              pgtype.Int8 `json:"cities_id"`
	CommunitiesID         pgtype.Int8 `json:"communities_id"`
	SubCommunitiesID      pgtype.Int8 `json:"sub_communities_id"`
	LocationsID           pgtype.Int8 `json:"locations_id"`
	CreatedAt_2           time.Time   `json:"created_at_2"`
	UpdatedAt_2           time.Time   `json:"updated_at_2"`
	PropertyMapLocationID pgtype.Int8 `json:"property_map_location_id"`
	FullAddress           pgtype.Text `json:"full_address"`
	FullAddressAr         pgtype.Text `json:"full_address_ar"`
}

func (q *Queries) GetAllCompanyProfilesByStatusLocal(ctx context.Context, arg GetAllCompanyProfilesByStatusLocalParams) ([]GetAllCompanyProfilesByStatusLocalRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyProfilesByStatusLocal, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyProfilesByStatusLocalRow
	for rows.Next() {
		var i GetAllCompanyProfilesByStatusLocalRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CompanyType,
			&i.CompanyName,
			&i.CompanyNameAr,
			&i.CompanyCategoryID,
			&i.CompanyActivitiesID,
			&i.WebsiteUrl,
			&i.CompanyEmail,
			&i.PhoneNumber,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.InternalCoverImage,
			&i.Description,
			&i.DescriptionAr,
			&i.Status,
			&i.AddressesID,
			&i.CreatedBy,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.ID_2,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunitiesID,
			&i.SubCommunitiesID,
			&i.LocationsID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.PropertyMapLocationID,
			&i.FullAddress,
			&i.FullAddressAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyActivitiesByCompanyCategory = `-- name: GetCompanyActivitiesByCompanyCategory :many
SELECT id, company_category_id, activity_name, icon_url, tags, created_by, created_at, updated_at, updated_by, description, description_ar, status, activity_name_ar FROM company_activities where company_category_id = $1
`

func (q *Queries) GetCompanyActivitiesByCompanyCategory(ctx context.Context, companyCategoryID int64) ([]CompanyActivity, error) {
	rows, err := q.db.Query(ctx, getCompanyActivitiesByCompanyCategory, companyCategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyActivity
	for rows.Next() {
		var i CompanyActivity
		if err := rows.Scan(
			&i.ID,
			&i.CompanyCategoryID,
			&i.ActivityName,
			&i.IconUrl,
			&i.Tags,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Description,
			&i.DescriptionAr,
			&i.Status,
			&i.ActivityNameAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyProfileByID = `-- name: GetCompanyProfileByID :one
SELECT id, ref_no, company_type, company_name, company_name_ar, company_category_id, company_activities_id, website_url, company_email, phone_number, logo_url, cover_image_url, internal_cover_image, description, description_ar, status, addresses_id, created_by, sort_order, created_at, updated_at, updated_by FROM company_profiles WHERE id = $1
`

func (q *Queries) GetCompanyProfileByID(ctx context.Context, id int64) (CompanyProfile, error) {
	row := q.db.QueryRow(ctx, getCompanyProfileByID, id)
	var i CompanyProfile
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyType,
		&i.CompanyName,
		&i.CompanyNameAr,
		&i.CompanyCategoryID,
		&i.CompanyActivitiesID,
		&i.WebsiteUrl,
		&i.CompanyEmail,
		&i.PhoneNumber,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.InternalCoverImage,
		&i.Description,
		&i.DescriptionAr,
		&i.Status,
		&i.AddressesID,
		&i.CreatedBy,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getCompanyProfilePhase = `-- name: GetCompanyProfilePhase :one
SELECT id, ref_number, company_profiles_projects_id, phase_name, registration_date, bank_name, escrow_number, facts, properties_ref_nos, promotions, status FROM company_profiles_phases 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetCompanyProfilePhase(ctx context.Context, limit int32) (CompanyProfilesPhase, error) {
	row := q.db.QueryRow(ctx, getCompanyProfilePhase, limit)
	var i CompanyProfilesPhase
	err := row.Scan(
		&i.ID,
		&i.RefNumber,
		&i.CompanyProfilesProjectsID,
		&i.PhaseName,
		&i.RegistrationDate,
		&i.BankName,
		&i.EscrowNumber,
		&i.Facts,
		&i.PropertiesRefNos,
		&i.Promotions,
		&i.Status,
	)
	return i, err
}

const getCompanyProfilePhaseByRefNo = `-- name: GetCompanyProfilePhaseByRefNo :one
SELECT id, ref_number, company_profiles_projects_id, phase_name, registration_date, bank_name, escrow_number, facts, properties_ref_nos, promotions, status FROM company_profiles_phases 
WHERE ref_number = $1 LIMIT 1
`

func (q *Queries) GetCompanyProfilePhaseByRefNo(ctx context.Context, refNumber string) (CompanyProfilesPhase, error) {
	row := q.db.QueryRow(ctx, getCompanyProfilePhaseByRefNo, refNumber)
	var i CompanyProfilesPhase
	err := row.Scan(
		&i.ID,
		&i.RefNumber,
		&i.CompanyProfilesProjectsID,
		&i.PhaseName,
		&i.RegistrationDate,
		&i.BankName,
		&i.EscrowNumber,
		&i.Facts,
		&i.PropertiesRefNos,
		&i.Promotions,
		&i.Status,
	)
	return i, err
}

const getCompanyProfileProject = `-- name: GetCompanyProfileProject :one
SELECT id, ref_number, project_no, project_name, company_profiles_id, is_verified, is_multiphase, license_no, addresses_id, bank_name, escrow_number, registration_date, status, description, description_arabic, properties_ref_nos, facts, promotions, created_at, updated_at, slug FROM company_profiles_projects 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCompanyProfileProject(ctx context.Context, id int64) (CompanyProfilesProject, error) {
	row := q.db.QueryRow(ctx, getCompanyProfileProject, id)
	var i CompanyProfilesProject
	err := row.Scan(
		&i.ID,
		&i.RefNumber,
		&i.ProjectNo,
		&i.ProjectName,
		&i.CompanyProfilesID,
		&i.IsVerified,
		&i.IsMultiphase,
		&i.LicenseNo,
		&i.AddressesID,
		&i.BankName,
		&i.EscrowNumber,
		&i.RegistrationDate,
		&i.Status,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertiesRefNos,
		&i.Facts,
		&i.Promotions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
	)
	return i, err
}

const getCompanyProfileProjectByRefNo = `-- name: GetCompanyProfileProjectByRefNo :one
SELECT id, ref_number, project_no, project_name, company_profiles_id, is_verified, is_multiphase, license_no, addresses_id, bank_name, escrow_number, registration_date, status, description, description_arabic, properties_ref_nos, facts, promotions, created_at, updated_at, slug FROM company_profiles_projects 
WHERE ref_number = $1
`

func (q *Queries) GetCompanyProfileProjectByRefNo(ctx context.Context, refNumber string) (CompanyProfilesProject, error) {
	row := q.db.QueryRow(ctx, getCompanyProfileProjectByRefNo, refNumber)
	var i CompanyProfilesProject
	err := row.Scan(
		&i.ID,
		&i.RefNumber,
		&i.ProjectNo,
		&i.ProjectName,
		&i.CompanyProfilesID,
		&i.IsVerified,
		&i.IsMultiphase,
		&i.LicenseNo,
		&i.AddressesID,
		&i.BankName,
		&i.EscrowNumber,
		&i.RegistrationDate,
		&i.Status,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertiesRefNos,
		&i.Facts,
		&i.Promotions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
	)
	return i, err
}

const getCompanyProfileProjectNotEqualToCountryId = `-- name: GetCompanyProfileProjectNotEqualToCountryId :many
SELECT DISTINCT 
    company_profiles_projects.id, company_profiles_projects.ref_number, company_profiles_projects.project_no, company_profiles_projects.project_name, company_profiles_projects.company_profiles_id, company_profiles_projects.is_verified, company_profiles_projects.is_multiphase, company_profiles_projects.license_no, company_profiles_projects.addresses_id, company_profiles_projects.bank_name, company_profiles_projects.escrow_number, company_profiles_projects.registration_date, company_profiles_projects.status, company_profiles_projects.description, company_profiles_projects.description_arabic, company_profiles_projects.properties_ref_nos, company_profiles_projects.facts, company_profiles_projects.promotions, company_profiles_projects.created_at, company_profiles_projects.updated_at, company_profiles_projects.slug, addresses.full_address, company_profiles.company_name
FROM company_profiles_projects
INNER JOIN addresses ON company_profiles_projects.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
INNER JOIN company_profiles ON company_profiles_projects.company_profiles_id = company_profiles.id    
WHERE
	(CASE WHEN $3::bigint=0 then true else company_profiles.id= $3::bigint END)
	AND 
    -- Search criteria
    ($4 = '%%' OR 
     company_profiles_projects.project_name % $4 OR 
     company_profiles_projects.ref_number % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     communities.community % $4 OR 
     sub_communities.sub_community % $4 OR
     (company_profiles_projects.facts->>'starting_price')::TEXT % $4 OR
     company_profiles.company_name % $4  
       OR (CASE 
        WHEN 'ready' ILIKE $4 THEN (company_profiles_projects.facts->>'completion_status')::BIGINT  = 5
        WHEN 'off plan'ILIKE $4  THEN (company_profiles_projects.facts->>'completion_status')::BIGINT= 4
        WHEN '^[0-9]+$' ~ $4  THEN (company_profiles_projects.facts->>'completion_percentage')::TEXT % $4
        WHEN 'draft'ILIKE $4  THEN company_profiles_projects.status = 1
        WHEN 'available'ILIKE $4  THEN company_profiles_projects.status = 2
        WHEN 'block'ILIKE $4  THEN company_profiles_projects.status = 5
        WHEN 'single'ILIKE $4  THEN company_profiles_projects.is_multiphase = false
        WHEN 'multiple'ILIKE $4  THEN company_profiles_projects.is_multiphase = true 
        ELSE FALSE
      END)
      )

    -- Location filters
    -- AND (@country_id::bigint = 0 OR addresses.countries_id != @country_id::bigint)

    -- Status filter
    AND company_profiles_projects.status NOT IN (5,6)  
ORDER BY company_profiles_projects.created_at DESC
LIMIT $1 OFFSET $2
`

type GetCompanyProfileProjectNotEqualToCountryIdParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
}

type GetCompanyProfileProjectNotEqualToCountryIdRow struct {
	ID                int64       `json:"id"`
	RefNumber         string      `json:"ref_number"`
	ProjectNo         string      `json:"project_no"`
	ProjectName       string      `json:"project_name"`
	CompanyProfilesID int64       `json:"company_profiles_id"`
	IsVerified        bool        `json:"is_verified"`
	IsMultiphase      bool        `json:"is_multiphase"`
	LicenseNo         string      `json:"license_no"`
	AddressesID       int64       `json:"addresses_id"`
	BankName          pgtype.Text `json:"bank_name"`
	EscrowNumber      pgtype.Text `json:"escrow_number"`
	RegistrationDate  pgtype.Date `json:"registration_date"`
	Status            int64       `json:"status"`
	Description       string      `json:"description"`
	DescriptionArabic pgtype.Text `json:"description_arabic"`
	PropertiesRefNos  []string    `json:"properties_ref_nos"`
	Facts             []byte      `json:"facts"`
	Promotions        []byte      `json:"promotions"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	Slug              string      `json:"slug"`
	FullAddress       pgtype.Text `json:"full_address"`
	CompanyName       string      `json:"company_name"`
}

// INNER JOIN properties_facts ON projects.id = properties_facts.project_id AND properties_facts.is_project_fact = true
//
//	 -- Company and branch permissions
//	 AND (
//	    @is_company_user != true
//	    OR (
//	        (@company_branch != false OR projects.developer_companies_id = @company_id::bigint)
//	        AND (@company_branch != true OR projects.developer_company_branches_id = @company_id::bigint)
//	    )
//	)
//	-- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
//	AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
//	AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
//	AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
func (q *Queries) GetCompanyProfileProjectNotEqualToCountryId(ctx context.Context, arg GetCompanyProfileProjectNotEqualToCountryIdParams) ([]GetCompanyProfileProjectNotEqualToCountryIdRow, error) {
	rows, err := q.db.Query(ctx, getCompanyProfileProjectNotEqualToCountryId,
		arg.Limit,
		arg.Offset,
		arg.CompanyID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyProfileProjectNotEqualToCountryIdRow
	for rows.Next() {
		var i GetCompanyProfileProjectNotEqualToCountryIdRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNumber,
			&i.ProjectNo,
			&i.ProjectName,
			&i.CompanyProfilesID,
			&i.IsVerified,
			&i.IsMultiphase,
			&i.LicenseNo,
			&i.AddressesID,
			&i.BankName,
			&i.EscrowNumber,
			&i.RegistrationDate,
			&i.Status,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertiesRefNos,
			&i.Facts,
			&i.Promotions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Slug,
			&i.FullAddress,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllCompanyProfilePhasesByProject = `-- name: GetCountAllCompanyProfilePhasesByProject :one
SELECT
	COUNT(company_profiles_phases.id)
FROM
	company_profiles_phases
   LEFT JOIN company_profiles_projects ON company_profiles_projects.id = company_profiles_phases.company_profiles_projects_id
	--INNER JOIN phases_facts ON phases.id = phases_facts.phases_id
	LEFT JOIN addresses ON addresses.id = company_profiles_phases.addresses_id
    LEFT JOIN countries ON countries.id = addresses.countries_id
    LEFT JOIN states ON states.id = addresses.states_id
    LEFT JOIN cities ON cities.id = addresses.cities_id
    LEFT JOIN communities ON communities.id = addresses.communities_id
    LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
WHERE
    -- Search criteria
    ($2 = '%%' OR 
     company_profiles_projects.project_name % $2 OR 
      company_profiles_phases.phase_name % $2 OR
     countries.country % $2 OR 
     states."state" % $2 OR 
     cities.city % $2 OR 
     communities.community % $2 OR 
     sub_communities.sub_community % $2  
       OR (CASE 
        WHEN 'ready' ILIKE $2 THEN (company_profiles_phases.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $2  THEN (company_profiles_phases.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $2  THEN (company_profiles_phases.facts->>'completion_percentage')::TEXT % $2
        WHEN 'draft'ILIKE $2  THEN company_profiles_projects.status = 1
        WHEN 'available'ILIKE $2  THEN company_profiles_projects.status = 2
        WHEN 'block'ILIKE $2  THEN company_profiles_projects.status = 5
        WHEN 'single'ILIKE $2  THEN company_profiles_projects.is_multiphase = false
        WHEN 'multiple'ILIKE $2  THEN company_profiles_projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
     -- Company and branch permissions
     AND (
        $3::BOOLEAN != true
        OR (
            ($4 != false OR company_profiles_projects.developer_companies_id = $5::bigint)
            AND ($4 != true OR company_profiles_projects.developer_company_branches_id = $5::bigint)
        )
    )
    -- Location filters
    AND ($6::bigint = 0 OR addresses.countries_id = $6::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
  --  AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
  --  AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
   -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
 AND company_profiles_projects.id = $1 AND (company_profiles_phases.status != 5 AND company_profiles_phases.status != 6)
`

type GetCountAllCompanyProfilePhasesByProjectParams struct {
	ID            int64       `json:"id"`
	Search        interface{} `json:"search"`
	IsCompanyUser bool        `json:"is_company_user"`
	CompanyBranch interface{} `json:"company_branch"`
	CompanyID     int64       `json:"company_id"`
	CountryID     int64       `json:"country_id"`
}

func (q *Queries) GetCountAllCompanyProfilePhasesByProject(ctx context.Context, arg GetCountAllCompanyProfilePhasesByProjectParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllCompanyProfilePhasesByProject,
		arg.ID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyBranch,
		arg.CompanyID,
		arg.CountryID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllCompanyProfilesByStatus = `-- name: GetCountAllCompanyProfilesByStatus :one
SELECT count(*) FROM company_profiles cp
INNER JOIN addresses a on a.id = cp.addresses_id 
where cp.status = ANY($1::int[])
`

func (q *Queries) GetCountAllCompanyProfilesByStatus(ctx context.Context, dollar_1 []int32) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllCompanyProfilesByStatus, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountCompanyProfileProjectByCounrty = `-- name: GetCountCompanyProfileProjectByCounrty :one
SELECT COUNT(*)
FROM company_profiles_projects
INNER JOIN addresses ON company_profiles_projects.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id    
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
INNER JOIN company_profiles ON company_profiles_projects.company_profiles_id = company_profiles.id    
WHERE
	(CASE WHEN $1::bigint= 0 then true else company_profiles.id= $1::bigint END)
	AND 
    -- Search criteria
    ($2 = '%%' OR 
     company_profiles_projects.project_name % $2 OR 
     company_profiles_projects.ref_number % $2 OR
     countries.country % $2 OR 
     states."state" % $2 OR 
     cities.city % $2 OR 
      communities.community % $2 OR 
     sub_communities.sub_community % $2 OR
      (company_profiles_projects.facts->>'starting_price')::TEXT % $2 OR
     company_profiles.company_name % $2  
      OR (CASE 
        WHEN 'ready' ILIKE $2 THEN (company_profiles_projects.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $2  THEN (company_profiles_projects.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $2  THEN (company_profiles_projects.facts->>'completion_percentage')::TEXT % $2
        WHEN 'draft'ILIKE $2  THEN company_profiles_projects.status = 1
        WHEN 'available'ILIKE $2  THEN company_profiles_projects.status = 2
        WHEN 'block'ILIKE $2  THEN company_profiles_projects.status = 5
        WHEN 'single'ILIKE $2  THEN company_profiles_projects.is_multiphase = false
        WHEN 'multiple'ILIKE $2  THEN company_profiles_projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
    --  -- Company and branch permissions
    --  AND (
    --     @is_company_user != true
    --     OR (
    --         (@company_branch != false OR projects.developer_companies_id = @company_id::bigint)
    --         AND (@company_branch != true OR projects.developer_company_branches_id = @company_id::bigint)
    --     )
    -- )
    -- Location filters
    -- AND (@country_id::bigint = 0 OR addresses.countries_id = @country_id::bigint)
    -- -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    -- AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
    -- AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
    -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
    -- Status filter
AND company_profiles_projects.status NOT IN (5,6)
`

type GetCountCompanyProfileProjectByCounrtyParams struct {
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
}

func (q *Queries) GetCountCompanyProfileProjectByCounrty(ctx context.Context, arg GetCountCompanyProfileProjectByCounrtyParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountCompanyProfileProjectByCounrty, arg.CompanyID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountCompanyProfileProjectByCountryNotEqual = `-- name: GetCountCompanyProfileProjectByCountryNotEqual :one
SELECT COUNT(company_profiles_projects.*)
FROM company_profiles_projects
INNER JOIN addresses ON company_profiles_projects.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
INNER JOIN company_profiles ON company_profiles_projects.company_profiles_id = company_profiles.id      
WHERE
	(CASE WHEN $1::bigint= 0 then true else company_profiles.id= $1::bigint END)
	AND 
    -- Search criteria
    ($2 = '%%' OR 
     company_profiles_projects.project_name % $2 OR 
     company_profiles_projects.ref_number % $2 OR
     countries.country % $2 OR 
     states."state" % $2 OR 
     cities.city % $2 OR 
     communities.community % $2 OR 
     sub_communities.sub_community % $2 OR
     (company_profiles_projects.facts->>'starting_price')::TEXT % $2 OR
     company_profiles.company_name % $2  
       OR (CASE 
        WHEN 'ready' ILIKE $2 THEN (company_profiles_projects.facts->>'completion_status')::BIGINT  = 5
        WHEN 'off plan'ILIKE $2  THEN (company_profiles_projects.facts->>'completion_status')::BIGINT= 4
        WHEN '^[0-9]+$' ~ $2  THEN (company_profiles_projects.facts->>'completion_percentage')::TEXT % $2
        WHEN 'draft'ILIKE $2  THEN company_profiles_projects.status = 1
        WHEN 'available'ILIKE $2  THEN company_profiles_projects.status = 2
        WHEN 'block'ILIKE $2  THEN company_profiles_projects.status = 5
        WHEN 'single'ILIKE $2  THEN company_profiles_projects.is_multiphase = false
        WHEN 'multiple'ILIKE $2  THEN company_profiles_projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
    --  -- Company and branch permissions
    --  AND (
    --     @is_company_user != true
    --     OR (
    --         (@company_branch != false OR projects.developer_companies_id = @company_id::bigint)
    --         AND (@company_branch != true OR projects.developer_company_branches_id = @company_id::bigint)
    --     )
    -- )
    -- Location filters
    -- AND (@country_id::bigint = 0 OR addresses.countries_id != @country_id::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    -- AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
    -- AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
    -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
    -- Status filter
    AND company_profiles_projects.status NOT IN (5,6)
`

type GetCountCompanyProfileProjectByCountryNotEqualParams struct {
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
}

// INNER JOIN properties_facts ON projects.id = properties_facts.project_id AND properties_facts.is_project_fact = true
func (q *Queries) GetCountCompanyProfileProjectByCountryNotEqual(ctx context.Context, arg GetCountCompanyProfileProjectByCountryNotEqualParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountCompanyProfileProjectByCountryNotEqual, arg.CompanyID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGlobalPropertiesByID = `-- name: GetGlobalPropertiesByID :one
SELECT id, type, code, property_type_facts, listing_facts, usage, created_at, updated_at, status, icon, is_project, type_ar
FROM global_property_type
WHERE id = $1
`

func (q *Queries) GetGlobalPropertiesByID(ctx context.Context, id int64) (GlobalPropertyType, error) {
	row := q.db.QueryRow(ctx, getGlobalPropertiesByID, id)
	var i GlobalPropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.PropertyTypeFacts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.IsProject,
		&i.TypeAr,
	)
	return i, err
}

const getLocalCompanyProfileProjects = `-- name: GetLocalCompanyProfileProjects :many
SELECT DISTINCT company_profiles_projects.id, company_profiles_projects.ref_number, company_profiles_projects.project_no, company_profiles_projects.project_name, company_profiles_projects.company_profiles_id, company_profiles_projects.is_verified, company_profiles_projects.is_multiphase, company_profiles_projects.license_no, company_profiles_projects.addresses_id, company_profiles_projects.bank_name, company_profiles_projects.escrow_number, company_profiles_projects.registration_date, company_profiles_projects.status, company_profiles_projects.description, company_profiles_projects.description_arabic, company_profiles_projects.properties_ref_nos, company_profiles_projects.facts, company_profiles_projects.promotions, company_profiles_projects.created_at, company_profiles_projects.updated_at, company_profiles_projects.slug, addresses.full_address,company_profiles.company_name
FROM company_profiles_projects
INNER JOIN addresses ON company_profiles_projects.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id 
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
INNER JOIN company_profiles ON company_profiles_projects.company_profiles_id = company_profiles.id    
WHERE
	(CASE WHEN $3::bigint= 0 then true else company_profiles.id= $3::bigint END)
	AND 
    -- Search criteria
    ($4 = '%%' OR 
     company_profiles_projects.project_name % $4 OR 
     company_profiles_projects.ref_number % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     communities.community % $4 OR 
     sub_communities.sub_community % $4 OR
     (company_profiles_projects.facts->>'starting_price')::TEXT % $4 OR
     company_profiles.company_name % $4 
      OR (CASE 
        WHEN 'ready' ILIKE $4 THEN (company_profiles_projects.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $4  THEN (company_profiles_projects.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $4  THEN (company_profiles_projects.facts->>'completion_percentage')::TEXT % $4
        WHEN 'draft' ILIKE $4  THEN company_profiles_projects.status = 1
        WHEN 'available'ILIKE $4  THEN company_profiles_projects.status = 2
        WHEN 'block'ILIKE $4  THEN company_profiles_projects.status = 5
        WHEN 'single'ILIKE $4  THEN company_profiles_projects.is_multiphase = false
        WHEN 'multiple'ILIKE $4  THEN company_profiles_projects.is_multiphase = true 
        ELSE FALSE
       END)
      )
    -- --  Company and branch permissions
    --  AND (
    --     @is_company_user != true
    --     OR (
    --         (@company_branch != false OR projects.developer_companies_id = @company_id::bigint)
    --         AND (@company_branch != true OR projects.developer_company_branches_id = @company_id::bigint)
    --     )
    -- )
    -- Location filters
    -- AND (@country_id::bigint = 0 OR addresses.countries_id = @country_id::bigint)
    -- -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    -- AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
    -- AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
    -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
    
    -- Status filter
    AND company_profiles_projects.status NOT IN (5,6)  
ORDER BY company_profiles_projects.created_at DESC
LIMIT $1 OFFSET $2
`

type GetLocalCompanyProfileProjectsParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	CompanyID int64       `json:"company_id"`
	Search    interface{} `json:"search"`
}

type GetLocalCompanyProfileProjectsRow struct {
	ID                int64       `json:"id"`
	RefNumber         string      `json:"ref_number"`
	ProjectNo         string      `json:"project_no"`
	ProjectName       string      `json:"project_name"`
	CompanyProfilesID int64       `json:"company_profiles_id"`
	IsVerified        bool        `json:"is_verified"`
	IsMultiphase      bool        `json:"is_multiphase"`
	LicenseNo         string      `json:"license_no"`
	AddressesID       int64       `json:"addresses_id"`
	BankName          pgtype.Text `json:"bank_name"`
	EscrowNumber      pgtype.Text `json:"escrow_number"`
	RegistrationDate  pgtype.Date `json:"registration_date"`
	Status            int64       `json:"status"`
	Description       string      `json:"description"`
	DescriptionArabic pgtype.Text `json:"description_arabic"`
	PropertiesRefNos  []string    `json:"properties_ref_nos"`
	Facts             []byte      `json:"facts"`
	Promotions        []byte      `json:"promotions"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	Slug              string      `json:"slug"`
	FullAddress       pgtype.Text `json:"full_address"`
	CompanyName       string      `json:"company_name"`
}

func (q *Queries) GetLocalCompanyProfileProjects(ctx context.Context, arg GetLocalCompanyProfileProjectsParams) ([]GetLocalCompanyProfileProjectsRow, error) {
	rows, err := q.db.Query(ctx, getLocalCompanyProfileProjects,
		arg.Limit,
		arg.Offset,
		arg.CompanyID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocalCompanyProfileProjectsRow
	for rows.Next() {
		var i GetLocalCompanyProfileProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNumber,
			&i.ProjectNo,
			&i.ProjectName,
			&i.CompanyProfilesID,
			&i.IsVerified,
			&i.IsMultiphase,
			&i.LicenseNo,
			&i.AddressesID,
			&i.BankName,
			&i.EscrowNumber,
			&i.RegistrationDate,
			&i.Status,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertiesRefNos,
			&i.Facts,
			&i.Promotions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Slug,
			&i.FullAddress,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertiesByRefNo = `-- name: GetPropertiesByRefNo :many
select pv.id, title, views_count, title_arabic, pv.description, pv.description_arabic, property_rank, property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, agent_id, ref_no, category, has_gallery, has_plans, is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, slug, is_hotdeal, refreshed_at, p.id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, p.is_verified, addresses_id, entity_type_id, entity_id, p.status, is_show_owner_info, property_name, p.description, p.description_arabic, owner_users_id, user_id, p.updated_by, from_xml, p.facts, notes, p.created_at, p.updated_at, notes_ar, is_public_note, is_project_property, p.exclusive, p.start_date, p.end_date from property_versions pv
inner join property p  on p.id =pv.property_id
where pv.ref_no = $1
and (pv.status != 6 or pv.status !=5)
and (p.status != 6 or p.status !=5)
`

type GetPropertiesByRefNoRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts               []byte             `json:"facts"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	UpdatedBy           int64              `json:"updated_by"`
	Status              int64              `json:"status"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status_2            int64              `json:"status_2"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts_2             []byte             `json:"facts_2"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

func (q *Queries) GetPropertiesByRefNo(ctx context.Context, refNo string) ([]GetPropertiesByRefNoRow, error) {
	rows, err := q.db.Query(ctx, getPropertiesByRefNo, refNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertiesByRefNoRow
	for rows.Next() {
		var i GetPropertiesByRefNoRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified_2,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status_2,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy_2,
			&i.FromXml,
			&i.Facts_2,
			&i.Notes,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertiesByRefNos = `-- name: GetPropertiesByRefNos :many
SELECT pv.id, title, views_count, title_arabic, pv.description, pv.description_arabic, property_rank, property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, agent_id, ref_no, category, has_gallery, has_plans, is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, slug, is_hotdeal, refreshed_at, p.id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, p.is_verified, addresses_id, entity_type_id, entity_id, p.status, is_show_owner_info, property_name, p.description, p.description_arabic, owner_users_id, user_id, p.updated_by, from_xml, p.facts, notes, p.created_at, p.updated_at, notes_ar, is_public_note, is_project_property, p.exclusive, p.start_date, p.end_date 
FROM property_versions pv
INNER JOIN property p ON p.id = pv.property_id
WHERE pv.ref_no = ANY($1::text[])
AND pv.status NOT IN (5, 6) 
AND p.status NOT IN (5, 6)
`

type GetPropertiesByRefNosRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts               []byte             `json:"facts"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	UpdatedBy           int64              `json:"updated_by"`
	Status              int64              `json:"status"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status_2            int64              `json:"status_2"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts_2             []byte             `json:"facts_2"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

func (q *Queries) GetPropertiesByRefNos(ctx context.Context, dollar_1 []string) ([]GetPropertiesByRefNosRow, error) {
	rows, err := q.db.Query(ctx, getPropertiesByRefNos, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertiesByRefNosRow
	for rows.Next() {
		var i GetPropertiesByRefNosRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified_2,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status_2,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy_2,
			&i.FromXml,
			&i.Facts_2,
			&i.Notes,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getXMLActiveCompanyProfileByLicenseNo = `-- name: GetXMLActiveCompanyProfileByLicenseNo :one
SELECT company_profiles.id,company_profiles.company_name,license.license_no FROM company_profiles
INNER JOIN license ON license.entity_id = company_profiles.id AND license.entity_type_id = 18 -- company profile entity type
WHERE license_no = $1 AND company_profiles.status = 2
`

type GetXMLActiveCompanyProfileByLicenseNoRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
	LicenseNo   string `json:"license_no"`
}

func (q *Queries) GetXMLActiveCompanyProfileByLicenseNo(ctx context.Context, licenseNo string) (GetXMLActiveCompanyProfileByLicenseNoRow, error) {
	row := q.db.QueryRow(ctx, getXMLActiveCompanyProfileByLicenseNo, licenseNo)
	var i GetXMLActiveCompanyProfileByLicenseNoRow
	err := row.Scan(&i.ID, &i.CompanyName, &i.LicenseNo)
	return i, err
}

const updateCompanyProfile = `-- name: UpdateCompanyProfile :one
UPDATE company_profiles 
SET 
    company_name = $1,
    website_url = $2,
    company_email = $3,
    phone_number = $4,
    company_category_id = $5,
    company_activities_id = $6,
    logo_url = $7,
    cover_image_url = $8, 
    description = $9,
    description_ar = $10,
    updated_at = now(),
    updated_by = $11,
    addresses_id = $12,
    company_type = $13, 
    sort_order=$15,
    internal_cover_image=$16,
    company_name_ar = $17
WHERE id = $14
RETURNING id, ref_no, company_type, company_name, company_name_ar, company_category_id, company_activities_id, website_url, company_email, phone_number, logo_url, cover_image_url, internal_cover_image, description, description_ar, status, addresses_id, created_by, sort_order, created_at, updated_at, updated_by
`

type UpdateCompanyProfileParams struct {
	CompanyName         string      `json:"company_name"`
	WebsiteUrl          pgtype.Text `json:"website_url"`
	CompanyEmail        string      `json:"company_email"`
	PhoneNumber         string      `json:"phone_number"`
	CompanyCategoryID   int64       `json:"company_category_id"`
	CompanyActivitiesID []int64     `json:"company_activities_id"`
	LogoUrl             string      `json:"logo_url"`
	CoverImageUrl       string      `json:"cover_image_url"`
	Description         string      `json:"description"`
	DescriptionAr       pgtype.Text `json:"description_ar"`
	UpdatedBy           pgtype.Int8 `json:"updated_by"`
	AddressesID         int64       `json:"addresses_id"`
	CompanyType         int64       `json:"company_type"`
	ID                  int64       `json:"id"`
	SortOrder           pgtype.Int8 `json:"sort_order"`
	InternalCoverImage  string      `json:"internal_cover_image"`
	CompanyNameAr       pgtype.Text `json:"company_name_ar"`
}

func (q *Queries) UpdateCompanyProfile(ctx context.Context, arg UpdateCompanyProfileParams) (CompanyProfile, error) {
	row := q.db.QueryRow(ctx, updateCompanyProfile,
		arg.CompanyName,
		arg.WebsiteUrl,
		arg.CompanyEmail,
		arg.PhoneNumber,
		arg.CompanyCategoryID,
		arg.CompanyActivitiesID,
		arg.LogoUrl,
		arg.CoverImageUrl,
		arg.Description,
		arg.DescriptionAr,
		arg.UpdatedBy,
		arg.AddressesID,
		arg.CompanyType,
		arg.ID,
		arg.SortOrder,
		arg.InternalCoverImage,
		arg.CompanyNameAr,
	)
	var i CompanyProfile
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyType,
		&i.CompanyName,
		&i.CompanyNameAr,
		&i.CompanyCategoryID,
		&i.CompanyActivitiesID,
		&i.WebsiteUrl,
		&i.CompanyEmail,
		&i.PhoneNumber,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.InternalCoverImage,
		&i.Description,
		&i.DescriptionAr,
		&i.Status,
		&i.AddressesID,
		&i.CreatedBy,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateCompanyProfilePhase = `-- name: UpdateCompanyProfilePhase :one
UPDATE company_profiles_phases
    SET ref_number = $2,
    company_profiles_projects_id = $3,
    phase_name = $4,
    registration_date = $5,
    bank_name = $6,
    escrow_number = $7,
    facts = $8,
    properties_ref_nos = $9,
    promotions = $10,
    status = $11
WHERE id = $1 
RETURNING id, ref_number, company_profiles_projects_id, phase_name, registration_date, bank_name, escrow_number, facts, properties_ref_nos, promotions, status
`

type UpdateCompanyProfilePhaseParams struct {
	ID                        int64       `json:"id"`
	RefNumber                 string      `json:"ref_number"`
	CompanyProfilesProjectsID int64       `json:"company_profiles_projects_id"`
	PhaseName                 string      `json:"phase_name"`
	RegistrationDate          pgtype.Date `json:"registration_date"`
	BankName                  pgtype.Text `json:"bank_name"`
	EscrowNumber              pgtype.Text `json:"escrow_number"`
	Facts                     []byte      `json:"facts"`
	PropertiesRefNos          []string    `json:"properties_ref_nos"`
	Promotions                []byte      `json:"promotions"`
	Status                    int64       `json:"status"`
}

func (q *Queries) UpdateCompanyProfilePhase(ctx context.Context, arg UpdateCompanyProfilePhaseParams) (CompanyProfilesPhase, error) {
	row := q.db.QueryRow(ctx, updateCompanyProfilePhase,
		arg.ID,
		arg.RefNumber,
		arg.CompanyProfilesProjectsID,
		arg.PhaseName,
		arg.RegistrationDate,
		arg.BankName,
		arg.EscrowNumber,
		arg.Facts,
		arg.PropertiesRefNos,
		arg.Promotions,
		arg.Status,
	)
	var i CompanyProfilesPhase
	err := row.Scan(
		&i.ID,
		&i.RefNumber,
		&i.CompanyProfilesProjectsID,
		&i.PhaseName,
		&i.RegistrationDate,
		&i.BankName,
		&i.EscrowNumber,
		&i.Facts,
		&i.PropertiesRefNos,
		&i.Promotions,
		&i.Status,
	)
	return i, err
}

const updateCompanyProfileStatus = `-- name: UpdateCompanyProfileStatus :one
UPDATE company_profiles 
SET 
    status = $2,
    updated_at = now(),
    updated_by = $3
WHERE id = $1
RETURNING id, ref_no, company_type, company_name, company_name_ar, company_category_id, company_activities_id, website_url, company_email, phone_number, logo_url, cover_image_url, internal_cover_image, description, description_ar, status, addresses_id, created_by, sort_order, created_at, updated_at, updated_by
`

type UpdateCompanyProfileStatusParams struct {
	ID        int64       `json:"id"`
	Status    int64       `json:"status"`
	UpdatedBy pgtype.Int8 `json:"updated_by"`
}

func (q *Queries) UpdateCompanyProfileStatus(ctx context.Context, arg UpdateCompanyProfileStatusParams) (CompanyProfile, error) {
	row := q.db.QueryRow(ctx, updateCompanyProfileStatus, arg.ID, arg.Status, arg.UpdatedBy)
	var i CompanyProfile
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyType,
		&i.CompanyName,
		&i.CompanyNameAr,
		&i.CompanyCategoryID,
		&i.CompanyActivitiesID,
		&i.WebsiteUrl,
		&i.CompanyEmail,
		&i.PhoneNumber,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.InternalCoverImage,
		&i.Description,
		&i.DescriptionAr,
		&i.Status,
		&i.AddressesID,
		&i.CreatedBy,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateCompanyProfilesProjects = `-- name: UpdateCompanyProfilesProjects :one
UPDATE company_profiles_projects
    SET ref_number = $2,
	project_no = $3,
    project_name = $4,
    company_profiles_id = $5,
    is_verified = $6,
	is_multiphase = $7,
    license_no = $8,
    addresses_id = $9,
	bank_name = $10,    
    escrow_number = $11,
	registration_date = $12,
	status = $13,
	description = $14,
    description_arabic = $15,
    properties_ref_nos = $16,
    facts = $17,
    created_at = $18,
    updated_at = $19,
    promotions = $20
WHERE id = $1
RETURNING id, ref_number, project_no, project_name, company_profiles_id, is_verified, is_multiphase, license_no, addresses_id, bank_name, escrow_number, registration_date, status, description, description_arabic, properties_ref_nos, facts, promotions, created_at, updated_at, slug
`

type UpdateCompanyProfilesProjectsParams struct {
	ID                int64       `json:"id"`
	RefNumber         string      `json:"ref_number"`
	ProjectNo         string      `json:"project_no"`
	ProjectName       string      `json:"project_name"`
	CompanyProfilesID int64       `json:"company_profiles_id"`
	IsVerified        bool        `json:"is_verified"`
	IsMultiphase      bool        `json:"is_multiphase"`
	LicenseNo         string      `json:"license_no"`
	AddressesID       int64       `json:"addresses_id"`
	BankName          pgtype.Text `json:"bank_name"`
	EscrowNumber      pgtype.Text `json:"escrow_number"`
	RegistrationDate  pgtype.Date `json:"registration_date"`
	Status            int64       `json:"status"`
	Description       string      `json:"description"`
	DescriptionArabic pgtype.Text `json:"description_arabic"`
	PropertiesRefNos  []string    `json:"properties_ref_nos"`
	Facts             []byte      `json:"facts"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	Promotions        []byte      `json:"promotions"`
}

func (q *Queries) UpdateCompanyProfilesProjects(ctx context.Context, arg UpdateCompanyProfilesProjectsParams) (CompanyProfilesProject, error) {
	row := q.db.QueryRow(ctx, updateCompanyProfilesProjects,
		arg.ID,
		arg.RefNumber,
		arg.ProjectNo,
		arg.ProjectName,
		arg.CompanyProfilesID,
		arg.IsVerified,
		arg.IsMultiphase,
		arg.LicenseNo,
		arg.AddressesID,
		arg.BankName,
		arg.EscrowNumber,
		arg.RegistrationDate,
		arg.Status,
		arg.Description,
		arg.DescriptionArabic,
		arg.PropertiesRefNos,
		arg.Facts,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Promotions,
	)
	var i CompanyProfilesProject
	err := row.Scan(
		&i.ID,
		&i.RefNumber,
		&i.ProjectNo,
		&i.ProjectName,
		&i.CompanyProfilesID,
		&i.IsVerified,
		&i.IsMultiphase,
		&i.LicenseNo,
		&i.AddressesID,
		&i.BankName,
		&i.EscrowNumber,
		&i.RegistrationDate,
		&i.Status,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertiesRefNos,
		&i.Facts,
		&i.Promotions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
	)
	return i, err
}
