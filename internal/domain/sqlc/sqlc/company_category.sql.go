// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: company_category.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeStatusOfCompanyCategory = `-- name: ChangeStatusOfCompanyCategory :one
UPDATE company_category
SET 
	updated_at=$2,
	updated_by=$3,
    status=$4
WHERE id=$1
RETURNING id, category_name, created_by, created_at, updated_at, updated_by, status, company_type, category_name_ar
`

type ChangeStatusOfCompanyCategoryParams struct {
	ID        int64       `json:"id"`
	UpdatedAt time.Time   `json:"updated_at"`
	UpdatedBy pgtype.Int8 `json:"updated_by"`
	Status    int64       `json:"status"`
}

func (q *Queries) ChangeStatusOfCompanyCategory(ctx context.Context, arg ChangeStatusOfCompanyCategoryParams) (CompanyCategory, error) {
	row := q.db.QueryRow(ctx, changeStatusOfCompanyCategory,
		arg.ID,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
	)
	var i CompanyCategory
	err := row.Scan(
		&i.ID,
		&i.CategoryName,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.CompanyType,
		&i.CategoryNameAr,
	)
	return i, err
}

const createCompanyCategory = `-- name: CreateCompanyCategory :one
INSERT INTO company_category(
	category_name,
	created_by,
	created_at,
	updated_at,
	updated_by,
    status,
	company_type,
	category_name_ar
)VALUES($1, $2,$3,$4,$5,$6,$7,$8)
RETURNING id, category_name, created_by, created_at, updated_at, updated_by, status, company_type, category_name_ar
`

type CreateCompanyCategoryParams struct {
	CategoryName   string      `json:"category_name"`
	CreatedBy      int64       `json:"created_by"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	UpdatedBy      pgtype.Int8 `json:"updated_by"`
	Status         int64       `json:"status"`
	CompanyType    int64       `json:"company_type"`
	CategoryNameAr pgtype.Text `json:"category_name_ar"`
}

func (q *Queries) CreateCompanyCategory(ctx context.Context, arg CreateCompanyCategoryParams) (CompanyCategory, error) {
	row := q.db.QueryRow(ctx, createCompanyCategory,
		arg.CategoryName,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
		arg.CompanyType,
		arg.CategoryNameAr,
	)
	var i CompanyCategory
	err := row.Scan(
		&i.ID,
		&i.CategoryName,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.CompanyType,
		&i.CategoryNameAr,
	)
	return i, err
}

const getActiveCompanyCategoryByTypeId = `-- name: GetActiveCompanyCategoryByTypeId :many
SELECT id, category_name FROM company_category
WHERE company_type=$1 AND status = 2
ORDER BY id desc
`

type GetActiveCompanyCategoryByTypeIdRow struct {
	ID           int64  `json:"id"`
	CategoryName string `json:"category_name"`
}

func (q *Queries) GetActiveCompanyCategoryByTypeId(ctx context.Context, companyType int64) ([]GetActiveCompanyCategoryByTypeIdRow, error) {
	rows, err := q.db.Query(ctx, getActiveCompanyCategoryByTypeId, companyType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveCompanyCategoryByTypeIdRow
	for rows.Next() {
		var i GetActiveCompanyCategoryByTypeIdRow
		if err := rows.Scan(&i.ID, &i.CategoryName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyCategories = `-- name: GetAllCompanyCategories :many
SELECT id, category_name, created_by, created_at, updated_at, updated_by, status, company_type, category_name_ar FROM company_category 
WHERE CASE WHEN $1::bigint = 0 THEN status != 6 ELSE status = $1::BIGINT END
ORDER BY id desc
LIMIT $3
OFFSET $2
`

type GetAllCompanyCategoriesParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

func (q *Queries) GetAllCompanyCategories(ctx context.Context, arg GetAllCompanyCategoriesParams) ([]CompanyCategory, error) {
	rows, err := q.db.Query(ctx, getAllCompanyCategories, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyCategory
	for rows.Next() {
		var i CompanyCategory
		if err := rows.Scan(
			&i.ID,
			&i.CategoryName,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.CompanyType,
			&i.CategoryNameAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyCategoriesCount = `-- name: GetAllCompanyCategoriesCount :one
SELECT COUNT(*) FROM company_category 
WHERE CASE WHEN $1::bigint = 0 THEN status != 6 ELSE status = $1::BIGINT END
`

func (q *Queries) GetAllCompanyCategoriesCount(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAllCompanyCategoriesCount, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSingleCompanyCategory = `-- name: GetSingleCompanyCategory :one
SELECT id, category_name, created_by, created_at, updated_at, updated_by, status, company_type, category_name_ar FROM company_category
WHERE id=$1
`

func (q *Queries) GetSingleCompanyCategory(ctx context.Context, id int64) (CompanyCategory, error) {
	row := q.db.QueryRow(ctx, getSingleCompanyCategory, id)
	var i CompanyCategory
	err := row.Scan(
		&i.ID,
		&i.CategoryName,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.CompanyType,
		&i.CategoryNameAr,
	)
	return i, err
}

const updateCompanyCategory = `-- name: UpdateCompanyCategory :one
UPDATE company_category
SET 
	category_name=$1,
	updated_at=$2,
	updated_by=$3,
    status=$4,
	company_type=$5,
	category_name_ar=$7
WHERE id=$6
RETURNING id, category_name, created_by, created_at, updated_at, updated_by, status, company_type, category_name_ar
`

type UpdateCompanyCategoryParams struct {
	CategoryName   string      `json:"category_name"`
	UpdatedAt      time.Time   `json:"updated_at"`
	UpdatedBy      pgtype.Int8 `json:"updated_by"`
	Status         int64       `json:"status"`
	CompanyType    int64       `json:"company_type"`
	ID             int64       `json:"id"`
	CategoryNameAr pgtype.Text `json:"category_name_ar"`
}

func (q *Queries) UpdateCompanyCategory(ctx context.Context, arg UpdateCompanyCategoryParams) (CompanyCategory, error) {
	row := q.db.QueryRow(ctx, updateCompanyCategory,
		arg.CategoryName,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
		arg.CompanyType,
		arg.ID,
		arg.CategoryNameAr,
	)
	var i CompanyCategory
	err := row.Scan(
		&i.ID,
		&i.CategoryName,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.CompanyType,
		&i.CategoryNameAr,
	)
	return i, err
}
