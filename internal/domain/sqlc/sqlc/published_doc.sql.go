// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: published_doc.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPublishedDoc = `-- name: CreatePublishedDoc :one
INSERT INTO  published_doc(
    publish_info_id,
    documents_category_id,
    documents_subcategory_id,
    file_url,
    created_at,
    updated_at,
    projects_id,
    status,
    property_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, publish_info_id, documents_category_id, documents_subcategory_id, file_url, created_at, updated_at, projects_id, status, property_id
`

type CreatePublishedDocParams struct {
	PublishInfoID          int64       `json:"publish_info_id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                []string    `json:"file_url"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	ProjectsID             pgtype.Int8 `json:"projects_id"`
	Status                 int64       `json:"status"`
	PropertyID             pgtype.Int8 `json:"property_id"`
}

func (q *Queries) CreatePublishedDoc(ctx context.Context, arg CreatePublishedDocParams) (PublishedDoc, error) {
	row := q.db.QueryRow(ctx, createPublishedDoc,
		arg.PublishInfoID,
		arg.DocumentsCategoryID,
		arg.DocumentsSubcategoryID,
		arg.FileUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProjectsID,
		arg.Status,
		arg.PropertyID,
	)
	var i PublishedDoc
	err := row.Scan(
		&i.ID,
		&i.PublishInfoID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectsID,
		&i.Status,
		&i.PropertyID,
	)
	return i, err
}

const deletePublishedDocByProject = `-- name: DeletePublishedDocByProject :exec
DELETE FROM published_doc
WHERE projects_id = $1
`

func (q *Queries) DeletePublishedDocByProject(ctx context.Context, projectsID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deletePublishedDocByProject, projectsID)
	return err
}

const getAllPublishedDocumentsByProject = `-- name: GetAllPublishedDocumentsByProject :many
SELECT published_doc.id, published_doc.publish_info_id, published_doc.documents_category_id, published_doc.documents_subcategory_id, published_doc.file_url, published_doc.created_at, published_doc.updated_at, published_doc.projects_id, published_doc.status, published_doc.property_id,documents_category.category, documents_category.category_ar, documents_subcategory.sub_category, documents_subcategory.sub_category_ar FROM published_doc 
LEFT JOIN documents_category ON documents_category.id = published_doc.documents_category_id 
LEFT JOIN documents_subcategory ON documents_subcategory.id = published_doc.documents_subcategory_id
WHERE projects_id = $1 AND publish_info_id = $2
`

type GetAllPublishedDocumentsByProjectParams struct {
	ProjectsID    pgtype.Int8 `json:"projects_id"`
	PublishInfoID int64       `json:"publish_info_id"`
}

type GetAllPublishedDocumentsByProjectRow struct {
	ID                     int64       `json:"id"`
	PublishInfoID          int64       `json:"publish_info_id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                []string    `json:"file_url"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	ProjectsID             pgtype.Int8 `json:"projects_id"`
	Status                 int64       `json:"status"`
	PropertyID             pgtype.Int8 `json:"property_id"`
	Category               pgtype.Text `json:"category"`
	CategoryAr             pgtype.Text `json:"category_ar"`
	SubCategory            pgtype.Text `json:"sub_category"`
	SubCategoryAr          pgtype.Text `json:"sub_category_ar"`
}

func (q *Queries) GetAllPublishedDocumentsByProject(ctx context.Context, arg GetAllPublishedDocumentsByProjectParams) ([]GetAllPublishedDocumentsByProjectRow, error) {
	rows, err := q.db.Query(ctx, getAllPublishedDocumentsByProject, arg.ProjectsID, arg.PublishInfoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPublishedDocumentsByProjectRow
	for rows.Next() {
		var i GetAllPublishedDocumentsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.PublishInfoID,
			&i.DocumentsCategoryID,
			&i.DocumentsSubcategoryID,
			&i.FileUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectsID,
			&i.Status,
			&i.PropertyID,
			&i.Category,
			&i.CategoryAr,
			&i.SubCategory,
			&i.SubCategoryAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
