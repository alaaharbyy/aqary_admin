// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: cities.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCity = `-- name: CreateCity :one
INSERT INTO cities (
    city,
    states_id,
    status,
    updated_by,
    updated_at,
    city_ar,
    cover_image,
    description
)VALUES (
    $1 ,$2,$3,$4,$5,$6,$7,$8
) RETURNING id, city, states_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, city_ar, cover_image, description
`

type CreateCityParams struct {
	City        string      `json:"city"`
	StatesID    pgtype.Int8 `json:"states_id"`
	Status      int64       `json:"status"`
	UpdatedBy   int64       `json:"updated_by"`
	UpdatedAt   time.Time   `json:"updated_at"`
	CityAr      pgtype.Text `json:"city_ar"`
	CoverImage  pgtype.Text `json:"cover_image"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateCity(ctx context.Context, arg CreateCityParams) (City, error) {
	row := q.db.QueryRow(ctx, createCity,
		arg.City,
		arg.StatesID,
		arg.Status,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.CityAr,
		arg.CoverImage,
		arg.Description,
	)
	var i City
	err := row.Scan(
		&i.ID,
		&i.City,
		&i.StatesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CityAr,
		&i.CoverImage,
		&i.Description,
	)
	return i, err
}

const deleteCity = `-- name: DeleteCity :exec
DELETE FROM cities
Where id = $1
`

func (q *Queries) DeleteCity(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCity, id)
	return err
}

const getAllCitiesByCountry = `-- name: GetAllCitiesByCountry :many
select c.id, c.city, c.states_id, c.created_at, c.updated_at, c.lat, c.lng, c.status, c.deleted_at, c.updated_by, c.city_ar, c.cover_image, c.description
from cities c 
join states s on s.id=c.states_id
join countries co on co.id=s.countries_id
where co.id=$1
`

func (q *Queries) GetAllCitiesByCountry(ctx context.Context, id int64) ([]City, error) {
	rows, err := q.db.Query(ctx, getAllCitiesByCountry, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []City
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.ID,
			&i.City,
			&i.StatesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CityAr,
			&i.CoverImage,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCititesByIds = `-- name: GetAllCititesByIds :many
SELECT id, city, states_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, city_ar, cover_image, description FROM cities WHERE cities.id = ANY($1::bigint[])
`

func (q *Queries) GetAllCititesByIds(ctx context.Context, dollar_1 []int64) ([]City, error) {
	rows, err := q.db.Query(ctx, getAllCititesByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []City
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.ID,
			&i.City,
			&i.StatesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CityAr,
			&i.CoverImage,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCity = `-- name: GetAllCity :many
SELECT cities.id, cities.city, cities.states_id, cities.created_at, cities.updated_at, cities.lat, cities.lng, cities.status, cities.deleted_at, cities.updated_by, cities.city_ar, cities.cover_image, cities.description,  
coalesce(states.state::varchar,'')::varchar as state,
coalesce(states.state_ar::varchar,'')::varchar as state_ar, 

coalesce(countries.country::varchar,'')::varchar as country,
coalesce(countries.country_ar::varchar,'')::varchar as country_ar,
coalesce(countries.id::bigint,0)::bigint as country_id  
FROM cities
left JOIN states on states.id=cities.states_id
left JOIN countries on countries.id=states.countries_id
where cities.status!=6
ORDER BY cities.updated_at desc
LIMIT $2
OFFSET $1
`

type GetAllCityParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllCityRow struct {
	ID          int64              `json:"id"`
	City        string             `json:"city"`
	StatesID    pgtype.Int8        `json:"states_id"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Lat         pgtype.Float8      `json:"lat"`
	Lng         pgtype.Float8      `json:"lng"`
	Status      int64              `json:"status"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy   int64              `json:"updated_by"`
	CityAr      pgtype.Text        `json:"city_ar"`
	CoverImage  pgtype.Text        `json:"cover_image"`
	Description pgtype.Text        `json:"description"`
	State       string             `json:"state"`
	StateAr     string             `json:"state_ar"`
	Country     string             `json:"country"`
	CountryAr   string             `json:"country_ar"`
	CountryID   int64              `json:"country_id"`
}

func (q *Queries) GetAllCity(ctx context.Context, arg GetAllCityParams) ([]GetAllCityRow, error) {
	rows, err := q.db.Query(ctx, getAllCity, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCityRow
	for rows.Next() {
		var i GetAllCityRow
		if err := rows.Scan(
			&i.ID,
			&i.City,
			&i.StatesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CityAr,
			&i.CoverImage,
			&i.Description,
			&i.State,
			&i.StateAr,
			&i.Country,
			&i.CountryAr,
			&i.CountryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCitiesByCountryId = `-- name: GetCitiesByCountryId :many
With x As (
    SELECT cities.id, cities.city, cities.states_id, cities.created_at, cities.updated_at, cities.lat, cities.lng, cities.status, cities.deleted_at, cities.updated_by, cities.city_ar, cities.cover_image, cities.description FROM cities
    LEFT JOIN states ON states.id = cities.states_id 
    LEFT JOIN countries ON countries.id = states.countries_id 
    WHERE $1::bigint = countries.id
) SELECT x.id, city FROM x
`

type GetCitiesByCountryIdRow struct {
	ID   int64  `json:"id"`
	City string `json:"city"`
}

func (q *Queries) GetCitiesByCountryId(ctx context.Context, dollar_1 int64) ([]GetCitiesByCountryIdRow, error) {
	rows, err := q.db.Query(ctx, getCitiesByCountryId, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCitiesByCountryIdRow
	for rows.Next() {
		var i GetCitiesByCountryIdRow
		if err := rows.Scan(&i.ID, &i.City); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCitiesCount = `-- name: GetCitiesCount :one
SELECT count(*) FROM cities
where cities.status!=6
`

func (q *Queries) GetCitiesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCitiesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCity = `-- name: GetCity :one
SELECT cities.id, cities.city, cities.states_id, cities.created_at, cities.updated_at, cities.lat, cities.lng, cities.status, cities.deleted_at, cities.updated_by, cities.city_ar, cities.cover_image, cities.description,
coalesce(states.state::varchar,'')::varchar as state,
coalesce(states.state_ar::varchar,'')::varchar as state_ar, 

coalesce(countries.country::varchar,'')::varchar as country,
coalesce(countries.country_ar::varchar,'')::varchar as country_ar,

coalesce(countries.id::bigint,0)::bigint as country_id  
FROM cities
left JOIN states on states.id=cities.states_id
left JOIN countries on countries.id=states.countries_id
WHERE cities.id = $1 LIMIT 1
`

type GetCityRow struct {
	City      City   `json:"city"`
	State     string `json:"state"`
	StateAr   string `json:"state_ar"`
	Country   string `json:"country"`
	CountryAr string `json:"country_ar"`
	CountryID int64  `json:"country_id"`
}

func (q *Queries) GetCity(ctx context.Context, id int64) (GetCityRow, error) {
	row := q.db.QueryRow(ctx, getCity, id)
	var i GetCityRow
	err := row.Scan(
		&i.City.ID,
		&i.City.City,
		&i.City.StatesID,
		&i.City.CreatedAt,
		&i.City.UpdatedAt,
		&i.City.Lat,
		&i.City.Lng,
		&i.City.Status,
		&i.City.DeletedAt,
		&i.City.UpdatedBy,
		&i.City.CityAr,
		&i.City.CoverImage,
		&i.City.Description,
		&i.State,
		&i.StateAr,
		&i.Country,
		&i.CountryAr,
		&i.CountryID,
	)
	return i, err
}

const getCityByName = `-- name: GetCityByName :one
SELECT id, city, states_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, city_ar, cover_image, description FROM cities 
WHERE city = $1  AND status!=6 LIMIT 1
`

func (q *Queries) GetCityByName(ctx context.Context, city string) (City, error) {
	row := q.db.QueryRow(ctx, getCityByName, city)
	var i City
	err := row.Scan(
		&i.ID,
		&i.City,
		&i.StatesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CityAr,
		&i.CoverImage,
		&i.Description,
	)
	return i, err
}

const getCityByStatesId = `-- name: GetCityByStatesId :many
SELECT id, city, states_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, city_ar, cover_image, description FROM cities
Where states_id = $1 AND status= $2::BIGINT ORDER BY id
`

type GetCityByStatesIdParams struct {
	StatesID     pgtype.Int8 `json:"states_id"`
	ActiveStatus int64       `json:"active_status"`
}

func (q *Queries) GetCityByStatesId(ctx context.Context, arg GetCityByStatesIdParams) ([]City, error) {
	rows, err := q.db.Query(ctx, getCityByStatesId, arg.StatesID, arg.ActiveStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []City
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.ID,
			&i.City,
			&i.StatesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CityAr,
			&i.CoverImage,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedCities = `-- name: GetDeletedCities :many
SELECT cities.id, cities.city, cities.states_id, cities.created_at, cities.updated_at, cities.lat, cities.lng, cities.status, cities.deleted_at, cities.updated_by, cities.city_ar, cities.cover_image, cities.description,  
coalesce(states.state::varchar,'')::varchar as state,
coalesce(states.state_ar::varchar,'')::varchar as state_ar, 

coalesce(countries.country::varchar,'')::varchar as country,
coalesce(countries.country_ar::varchar,'')::varchar as country_ar,

coalesce(countries.id::bigint,0)::bigint as country_id  
FROM cities
left JOIN states on states.id=cities.states_id
left JOIN countries on countries.id=states.countries_id
where cities.status=6
ORDER BY cities.deleted_at
LIMIT $2
OFFSET $1
`

type GetDeletedCitiesParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetDeletedCitiesRow struct {
	ID          int64              `json:"id"`
	City        string             `json:"city"`
	StatesID    pgtype.Int8        `json:"states_id"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Lat         pgtype.Float8      `json:"lat"`
	Lng         pgtype.Float8      `json:"lng"`
	Status      int64              `json:"status"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy   int64              `json:"updated_by"`
	CityAr      pgtype.Text        `json:"city_ar"`
	CoverImage  pgtype.Text        `json:"cover_image"`
	Description pgtype.Text        `json:"description"`
	State       string             `json:"state"`
	StateAr     string             `json:"state_ar"`
	Country     string             `json:"country"`
	CountryAr   string             `json:"country_ar"`
	CountryID   int64              `json:"country_id"`
}

func (q *Queries) GetDeletedCities(ctx context.Context, arg GetDeletedCitiesParams) ([]GetDeletedCitiesRow, error) {
	rows, err := q.db.Query(ctx, getDeletedCities, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeletedCitiesRow
	for rows.Next() {
		var i GetDeletedCitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.City,
			&i.StatesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CityAr,
			&i.CoverImage,
			&i.Description,
			&i.State,
			&i.StateAr,
			&i.Country,
			&i.CountryAr,
			&i.CountryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedCitiesCount = `-- name: GetDeletedCitiesCount :one
SELECT count(*) FROM cities
where cities.status=6
`

func (q *Queries) GetDeletedCitiesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getDeletedCitiesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateCity = `-- name: UpdateCity :one
UPDATE cities
SET city = $2,
    updated_by=$3,
    updated_at=$4,
    city_ar=$5,
    cover_image=$6,
    description=$7
Where id = $1
RETURNING id, city, states_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, city_ar, cover_image, description
`

type UpdateCityParams struct {
	ID          int64       `json:"id"`
	City        string      `json:"city"`
	UpdatedBy   int64       `json:"updated_by"`
	UpdatedAt   time.Time   `json:"updated_at"`
	CityAr      pgtype.Text `json:"city_ar"`
	CoverImage  pgtype.Text `json:"cover_image"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateCity(ctx context.Context, arg UpdateCityParams) (City, error) {
	row := q.db.QueryRow(ctx, updateCity,
		arg.ID,
		arg.City,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.CityAr,
		arg.CoverImage,
		arg.Description,
	)
	var i City
	err := row.Scan(
		&i.ID,
		&i.City,
		&i.StatesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CityAr,
		&i.CoverImage,
		&i.Description,
	)
	return i, err
}

const updateCityStatus = `-- name: UpdateCityStatus :one
UPDATE cities
SET 
status = $2,
deleted_at=$3,
updated_at=$4
Where id = $1
RETURNING id, city, states_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, city_ar, cover_image, description
`

type UpdateCityStatusParams struct {
	ID        int64              `json:"id"`
	Status    int64              `json:"status"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	UpdatedAt time.Time          `json:"updated_at"`
}

func (q *Queries) UpdateCityStatus(ctx context.Context, arg UpdateCityStatusParams) (City, error) {
	row := q.db.QueryRow(ctx, updateCityStatus,
		arg.ID,
		arg.Status,
		arg.DeletedAt,
		arg.UpdatedAt,
	)
	var i City
	err := row.Scan(
		&i.ID,
		&i.City,
		&i.StatesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CityAr,
		&i.CoverImage,
		&i.Description,
	)
	return i, err
}
