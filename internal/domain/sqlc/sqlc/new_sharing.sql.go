// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: new_sharing.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkSharingBySharedTo = `-- name: CheckSharingBySharedTo :one


SELECT sharing.id, sharing.sharing_type, sharing.entity_type_id, sharing.entity_id, sharing.shared_to, sharing.is_enabled, sharing.country_id, sharing.created_at, sharing.created_by FROM sharing 
WHERE id= $1 AND shared_to= $2
`

type CheckSharingBySharedToParams struct {
	ID       int64 `json:"id"`
	SharedTo int64 `json:"shared_to"`
}

type CheckSharingBySharedToRow struct {
	Sharing Sharing `json:"sharing"`
}

// SELECT
//
//	count(se.id)
//
// FROM sharing_entities AS se
// JOIN sharing ON sharing.id=se.sharing_id
// JOIN projects ON projects.id=sharing.entity_id and sharing.entity_type_id= @project_entity::bigint
// LEFT join phases AS ph ON
//
//		(CASE
//	            WHEN se.entity_type = @phase_entity::BIGINT AND se.phase_id is null and se.property_id is null THEN ph.id = se.entity_id
//	            WHEN se.entity_type =  @property_entity::bigint and se.property_id is null and se.phase_id is not null THEN ph.id = se.phase_id
//	        END)
//
// LEFT join property AS p ON
//
//		(CASE
//	            WHEN se.entity_type = @property_entity::BIGINT AND se.property_id is null and se.phase_id is not null THEN p.id = se.entity_id
//	            WHEN se.entity_type = @unit_entity::bigint and se.property_id is not null and se.phase_id is null THEN p.id = se.property_id
//	        END)
//
// LEFT JOIN units on units.id=se.entity_id and se.entity_type= @unit_entity::bigint
// WHERE
//
//	se.sharing_id= @sharing_id::bigint
//
// AND
//
//	se.entity_type= @entity_type_id::bigint
//
// AND
//
//	(case when @phase_id::bigint= 0 then true else se.phase_id= @phase_id end )
//
// AND
//
//	(case when @property_id::bigint= 0 then true else se.property_id= @property_id end )
//
// ;
func (q *Queries) CheckSharingBySharedTo(ctx context.Context, arg CheckSharingBySharedToParams) (CheckSharingBySharedToRow, error) {
	row := q.db.QueryRow(ctx, checkSharingBySharedTo, arg.ID, arg.SharedTo)
	var i CheckSharingBySharedToRow
	err := row.Scan(
		&i.Sharing.ID,
		&i.Sharing.SharingType,
		&i.Sharing.EntityTypeID,
		&i.Sharing.EntityID,
		&i.Sharing.SharedTo,
		&i.Sharing.IsEnabled,
		&i.Sharing.CountryID,
		&i.Sharing.CreatedAt,
		&i.Sharing.CreatedBy,
	)
	return i, err
}

const getSearchTotalCount = `-- name: GetSearchTotalCount :one
SELECT COUNT(DISTINCT s.id)
FROM sharing s
WHERE s.entity_type_id = $1::bigint
    AND (
        CASE 
            WHEN $2::bigint > 0 THEN s.created_by = $2
            WHEN $3::bigint > 0 THEN s.shared_to = $3
            ELSE true
        END
    )
`

type GetSearchTotalCountParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	CreatedBy    int64 `json:"created_by"`
	UserID       int64 `json:"user_id"`
}

// Utility query for pagination
func (q *Queries) GetSearchTotalCount(ctx context.Context, arg GetSearchTotalCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSearchTotalCount, arg.EntityTypeID, arg.CreatedBy, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSharedEntities = `-- name: GetSharedEntities :many
SELECT 
se.id AS sharing_entity_id,
projects.id AS project_id,
projects.project_name AS project_name,
phases.id AS phase_id,
phases.phase_name AS phase_name,
property.id AS property_id,
CASE WHEN $1::bigint = 15 THEN property_versions.title ELSE property.property_name END::VARCHAR AS property_name,
units.id AS unit_id,
units.unit_title AS unit_title,
unit_versions.id AS unit_version_id,
unit_versions.title AS unit_version_title
FROM sharing_entities se
INNER JOIN sharing ON sharing.id = se.sharing_id
LEFT JOIN unit_versions ON unit_versions.id = se.entity_id AND $1::bigint = 14 -- when unit version
LEFT JOIN property_versions ON property_versions.id = se.entity_id AND $1::bigint = 15 -- when property version
LEFT JOIN units ON units.id = unit_versions.unit_id AND $1::bigint = 14 -- when unit version
LEFT JOIN property ON
(CASE
	WHEN  $1::bigint = 15 THEN property.id = property_versions.property_id  -- when property version
	WHEN $1::bigint = 14 THEN property.id = units.entity_id AND units.id = unit_versions.unit_id  -- when unit version
END)
LEFT JOIN phases ON phases.id = property.entity_id AND property.entity_type_id = 2 -- if phase property
LEFT JOIN projects ON 
(CASE 
	WHEN property.entity_type_id = 1 THEN property.entity_id = projects.id 
	WHEN property.entity_type_id = 2 THEN property.entity_id = phases.id AND projects.id = phases.projects_id
END)
WHERE se.entity_type= $1::bigint AND sharing.id = $2::bigint AND 
CASE WHEN $1::bigint = 15 THEN TRUE ELSE se.property_id = $3::bigint END
LIMIT $5
OFFSET $4
`

type GetSharedEntitiesParams struct {
	EntityType int64       `json:"entity_type"`
	SharingID  int64       `json:"sharing_id"`
	PropertyID int64       `json:"property_id"`
	Offset     pgtype.Int4 `json:"offset"`
	Limit      pgtype.Int4 `json:"limit"`
}

type GetSharedEntitiesRow struct {
	SharingEntityID  int64       `json:"sharing_entity_id"`
	ProjectID        pgtype.Int8 `json:"project_id"`
	ProjectName      pgtype.Text `json:"project_name"`
	PhaseID          pgtype.Int8 `json:"phase_id"`
	PhaseName        pgtype.Text `json:"phase_name"`
	PropertyID       pgtype.Int8 `json:"property_id"`
	PropertyName     string      `json:"property_name"`
	UnitID           pgtype.Int8 `json:"unit_id"`
	UnitTitle        pgtype.Text `json:"unit_title"`
	UnitVersionID    pgtype.Int8 `json:"unit_version_id"`
	UnitVersionTitle pgtype.Text `json:"unit_version_title"`
}

func (q *Queries) GetSharedEntities(ctx context.Context, arg GetSharedEntitiesParams) ([]GetSharedEntitiesRow, error) {
	rows, err := q.db.Query(ctx, getSharedEntities,
		arg.EntityType,
		arg.SharingID,
		arg.PropertyID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharedEntitiesRow
	for rows.Next() {
		var i GetSharedEntitiesRow
		if err := rows.Scan(
			&i.SharingEntityID,
			&i.ProjectID,
			&i.ProjectName,
			&i.PhaseID,
			&i.PhaseName,
			&i.PropertyID,
			&i.PropertyName,
			&i.UnitID,
			&i.UnitTitle,
			&i.UnitVersionID,
			&i.UnitVersionTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedEntitiesCounts = `-- name: GetSharedEntitiesCounts :one






SELECT COUNT(se.id)
FROM sharing_entities se
INNER JOIN sharing ON sharing.id = se.sharing_id
LEFT JOIN unit_versions ON unit_versions.id = se.entity_id AND $1::bigint = 14 -- when unit version
LEFT JOIN property_versions ON property_versions.id = se.entity_id AND $1::bigint = 15 -- when property version
LEFT JOIN units ON units.id = unit_versions.unit_id AND $1::bigint = 14 -- when unit version
LEFT JOIN property ON
(CASE
	WHEN  $1::bigint = 15 THEN property.id = property_versions.property_id  -- when property version
	WHEN $1::bigint = 14 THEN property.id = units.entity_id AND units.id = unit_versions.unit_id  -- when unit version
END)
LEFT JOIN phases ON phases.id = property.entity_id AND property.entity_type_id = 2 -- if phase property
LEFT JOIN projects ON 
(CASE 
	WHEN property.entity_type_id = 1 THEN property.entity_id = projects.id 
	WHEN property.entity_type_id = 2 THEN property.entity_id = phases.id AND projects.id = phases.projects_id
END)
WHERE se.entity_type= $1::bigint AND sharing.id = $2::bigint AND 
CASE WHEN $1::bigint = 15 THEN TRUE ELSE se.property_id = $3::bigint END
`

type GetSharedEntitiesCountsParams struct {
	EntityType int64 `json:"entity_type"`
	SharingID  int64 `json:"sharing_id"`
	PropertyID int64 `json:"property_id"`
}

// SELECT DISTINCT
//
//	sqlc.embed(se),
//	projects.id,
//	projects.project_name,
//	COALESCE(ph.id,0)::BIGINT as phase_id,
//	COALESCE(ph.phase_name,'')::VARCHAR as phase_name,
//	COALESCE(p.id,0)::BIGINT as property_id,
//	COALESCE(p.property_name,'')::VARCHAR as property_names,
//	COALESCE(units.id,0)::BIGINT as unit_id,
//	COALESCE(units.unit_title,'')::VARCHAR as unit_title
//
// FROM sharing_entities AS se
// JOIN sharing ON sharing.id=se.sharing_id
// JOIN projects ON projects.id=sharing.entity_id and sharing.entity_type_id= @project_entity::bigint
// LEFT join phases AS ph ON
//
//		(CASE
//	            WHEN se.entity_type = @phase_entity::BIGINT AND se.phase_id is null and se.property_id is null THEN ph.id = se.entity_id
//	            WHEN se.entity_type =  @property_entity::bigint and se.property_id is null and se.phase_id is not null THEN ph.id = se.phase_id
//	        END)
//
// LEFT join property AS p ON
//
//		(CASE
//	            WHEN se.entity_type = @property_entity::BIGINT AND se.property_id is null and se.phase_id is not null THEN p.id = se.entity_id
//	            WHEN se.entity_type = @unit_entity::bigint and se.property_id is not null and se.phase_id is null THEN p.id = se.property_id
//	        END)
//
// LEFT JOIN units on units.id=se.entity_id and se.entity_type= @unit_entity::bigint
// WHERE
//
//	se.sharing_id= @sharing_id::bigint
//
// AND
//
//	se.entity_type= @entity_type_id::bigint
//
// AND
//
//	(case when @phase_id::bigint= 0 then true else se.phase_id= @phase_id end )
//
// AND
//
//	(case when @property_id::bigint= 0 then true else se.property_id= @property_id end )
//
// LIMIT sqlc.narg('limit')
// OFFSET sqlc.narg('offset');
func (q *Queries) GetSharedEntitiesCounts(ctx context.Context, arg GetSharedEntitiesCountsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSharedEntitiesCounts, arg.EntityType, arg.SharingID, arg.PropertyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchAllShared = `-- name: SearchAllShared :many
SELECT DISTINCT 
    s.id,
    s.entity_type_id,
    s.entity_id,
    s.sharing_type,
    s.country_id,
    COALESCE(p.project_name, '') as project_name,
    COALESCE(p.ref_number, '') as ref_number,
    COALESCE(ph.phase_name, '') as phase_name,
    COALESCE(prop.property_name, '') as property_name,
    COALESCE(u.unit_no, '') as unit_no,
    COALESCE(u.unit_title, '') as unit_title,
    c.company_name
FROM sharing s
LEFT JOIN projects p ON s.entity_type_id = 1 AND s.entity_id = p.id
LEFT JOIN phases ph ON s.entity_type_id = 2 AND s.entity_id = ph.id
LEFT JOIN property_versions pv ON s.entity_type_id = 3 AND s.entity_id = pv.id
LEFT JOIN property prop ON pv.property_id = prop.id
LEFT JOIN unit_versions uv ON s.entity_type_id = 5 AND s.entity_id = uv.id
LEFT JOIN units u ON uv.unit_id = u.id
LEFT JOIN companies c ON p.developer_companies_id = c.id
WHERE (
    CASE 
        WHEN $3::bigint > 0 THEN s.created_by = $3
        WHEN $4::bigint > 0 THEN s.shared_to = $4
        ELSE true
    END
)
AND (
    COALESCE(p.project_name, '') ILIKE $5
    OR COALESCE(p.ref_number, '') ILIKE $5
    OR COALESCE(ph.phase_name, '') ILIKE $5
    OR COALESCE(prop.property_name, '') ILIKE $5
    OR COALESCE(u.unit_no, '') ILIKE $5
    OR COALESCE(u.unit_title, '') ILIKE $5
    OR COALESCE(c.company_name, '') ILIKE $5
)
LIMIT $1
OFFSET $2
`

type SearchAllSharedParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CreatedBy int64  `json:"created_by"`
	UserID    int64  `json:"user_id"`
	Query     string `json:"query"`
}

type SearchAllSharedRow struct {
	ID           int64       `json:"id"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	EntityID     int64       `json:"entity_id"`
	SharingType  int32       `json:"sharing_type"`
	CountryID    pgtype.Int8 `json:"country_id"`
	ProjectName  string      `json:"project_name"`
	RefNumber    string      `json:"ref_number"`
	PhaseName    string      `json:"phase_name"`
	PropertyName string      `json:"property_name"`
	UnitNo       string      `json:"unit_no"`
	UnitTitle    string      `json:"unit_title"`
	CompanyName  pgtype.Text `json:"company_name"`
}

// Global search across all entities
func (q *Queries) SearchAllShared(ctx context.Context, arg SearchAllSharedParams) ([]SearchAllSharedRow, error) {
	rows, err := q.db.Query(ctx, searchAllShared,
		arg.Limit,
		arg.Offset,
		arg.CreatedBy,
		arg.UserID,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAllSharedRow
	for rows.Next() {
		var i SearchAllSharedRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.SharingType,
			&i.CountryID,
			&i.ProjectName,
			&i.RefNumber,
			&i.PhaseName,
			&i.PropertyName,
			&i.UnitNo,
			&i.UnitTitle,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSharedPhases = `-- name: SearchSharedPhases :many
SELECT DISTINCT 
    ph.id, ph.phase_name, ph.addresses_id, ph.created_at, ph.updated_at, ph.status, ph.live_status, ph.ref_no, ph.projects_id, ph.rating, ph.description, ph.description_ar, ph.polygon_coords, ph.facts, ph.exclusive, ph.start_date, ph.end_date, ph.bank_name, ph.registration_date, ph.escrow_number,
    p.project_name,
    p.ref_number,
    s.sharing_type,
    s.country_id,
    c.company_name
FROM sharing s
JOIN phases ph ON ph.id = s.entity_id
JOIN projects p ON ph.projects_id = p.id
LEFT JOIN companies c ON p.developer_companies_id = c.id
WHERE s.entity_type_id = 2
    AND (
        CASE 
            WHEN $3::bigint > 0 THEN s.created_by = $3
            WHEN $4::bigint > 0 THEN s.shared_to = $4
            ELSE true
        END
    )
    AND (
        ph.phase_name ILIKE $5
        OR p.project_name ILIKE $5
        OR p.ref_number ILIKE $5
        OR c.company_name ILIKE $5
    )
LIMIT $1
OFFSET $2
`

type SearchSharedPhasesParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CreatedBy int64  `json:"created_by"`
	UserID    int64  `json:"user_id"`
	Query     string `json:"query"`
}

type SearchSharedPhasesRow struct {
	ID               int64       `json:"id"`
	PhaseName        string      `json:"phase_name"`
	AddressesID      pgtype.Int8 `json:"addresses_id"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Status           int64       `json:"status"`
	LiveStatus       pgtype.Bool `json:"live_status"`
	RefNo            string      `json:"ref_no"`
	ProjectsID       int64       `json:"projects_id"`
	Rating           float64     `json:"rating"`
	Description      string      `json:"description"`
	DescriptionAr    pgtype.Text `json:"description_ar"`
	PolygonCoords    []byte      `json:"polygon_coords"`
	Facts            []byte      `json:"facts"`
	Exclusive        bool        `json:"exclusive"`
	StartDate        pgtype.Date `json:"start_date"`
	EndDate          pgtype.Date `json:"end_date"`
	BankName         string      `json:"bank_name"`
	RegistrationDate time.Time   `json:"registration_date"`
	EscrowNumber     string      `json:"escrow_number"`
	ProjectName      string      `json:"project_name"`
	RefNumber        string      `json:"ref_number"`
	SharingType      int32       `json:"sharing_type"`
	CountryID        pgtype.Int8 `json:"country_id"`
	CompanyName      pgtype.Text `json:"company_name"`
}

// Phase search queries
func (q *Queries) SearchSharedPhases(ctx context.Context, arg SearchSharedPhasesParams) ([]SearchSharedPhasesRow, error) {
	rows, err := q.db.Query(ctx, searchSharedPhases,
		arg.Limit,
		arg.Offset,
		arg.CreatedBy,
		arg.UserID,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSharedPhasesRow
	for rows.Next() {
		var i SearchSharedPhasesRow
		if err := rows.Scan(
			&i.ID,
			&i.PhaseName,
			&i.AddressesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.LiveStatus,
			&i.RefNo,
			&i.ProjectsID,
			&i.Rating,
			&i.Description,
			&i.DescriptionAr,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.ProjectName,
			&i.RefNumber,
			&i.SharingType,
			&i.CountryID,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSharedProjects = `-- name: SearchSharedProjects :many
SELECT DISTINCT 
    p.id, p.project_name, p.ref_number, p.no_of_views, p.is_verified, p.project_rank, p.addresses_id, p.status, p.developer_companies_id, p.developer_company_branches_id, p.countries_id, p.created_at, p.updated_at, p.is_multiphase, p.live_status, p.project_no, p.license_no, p.users_id, p.description, p.description_arabic, p.rating, p.polygon_coords, p.facts, p.exclusive, p.start_date, p.end_date, p.slug, p.deleted_at, p.bank_name, p.registration_date, p.escrow_number, p.refreshed_at,
    s.sharing_type,
    s.country_id,
    c.company_name
FROM sharing s
JOIN projects p ON p.id = s.entity_id
LEFT JOIN companies c ON p.developer_companies_id = c.id
WHERE s.entity_type_id = 1
    AND (
        CASE 
            WHEN $3::bigint > 0 THEN s.created_by = $3
            WHEN $4::bigint > 0 THEN s.shared_to = $4
            ELSE true
        END
    )
    AND (
        p.project_name ILIKE $5
        OR p.ref_number ILIKE $5
        OR c.company_name ILIKE $5
    )
LIMIT $1
OFFSET $2
`

type SearchSharedProjectsParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CreatedBy int64  `json:"created_by"`
	UserID    int64  `json:"user_id"`
	Query     string `json:"query"`
}

type SearchSharedProjectsRow struct {
	ID                         int64              `json:"id"`
	ProjectName                string             `json:"project_name"`
	RefNumber                  string             `json:"ref_number"`
	NoOfViews                  int64              `json:"no_of_views"`
	IsVerified                 pgtype.Bool        `json:"is_verified"`
	ProjectRank                int64              `json:"project_rank"`
	AddressesID                int64              `json:"addresses_id"`
	Status                     int64              `json:"status"`
	DeveloperCompaniesID       int64              `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8        `json:"developer_company_branches_id"`
	CountriesID                int64              `json:"countries_id"`
	CreatedAt                  time.Time          `json:"created_at"`
	UpdatedAt                  time.Time          `json:"updated_at"`
	IsMultiphase               pgtype.Bool        `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool        `json:"live_status"`
	ProjectNo                  string             `json:"project_no"`
	LicenseNo                  string             `json:"license_no"`
	UsersID                    int64              `json:"users_id"`
	Description                string             `json:"description"`
	DescriptionArabic          pgtype.Text        `json:"description_arabic"`
	Rating                     float64            `json:"rating"`
	PolygonCoords              []byte             `json:"polygon_coords"`
	Facts                      []byte             `json:"facts"`
	Exclusive                  bool               `json:"exclusive"`
	StartDate                  pgtype.Date        `json:"start_date"`
	EndDate                    pgtype.Date        `json:"end_date"`
	Slug                       string             `json:"slug"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
	BankName                   pgtype.Text        `json:"bank_name"`
	RegistrationDate           pgtype.Date        `json:"registration_date"`
	EscrowNumber               pgtype.Text        `json:"escrow_number"`
	RefreshedAt                pgtype.Timestamptz `json:"refreshed_at"`
	SharingType                int32              `json:"sharing_type"`
	CountryID                  pgtype.Int8        `json:"country_id"`
	CompanyName                pgtype.Text        `json:"company_name"`
}

// Project search queries
func (q *Queries) SearchSharedProjects(ctx context.Context, arg SearchSharedProjectsParams) ([]SearchSharedProjectsRow, error) {
	rows, err := q.db.Query(ctx, searchSharedProjects,
		arg.Limit,
		arg.Offset,
		arg.CreatedBy,
		arg.UserID,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSharedProjectsRow
	for rows.Next() {
		var i SearchSharedProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
			&i.SharingType,
			&i.CountryID,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSharedProperties = `-- name: SearchSharedProperties :many
SELECT DISTINCT 
    pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at,
    p.project_name,
    p.ref_number,
    ph.phase_name,
    s.sharing_type,
    s.country_id,
    c.company_name,
    prop.property_name,
    prop.property_title,
    prop.description
FROM sharing s
JOIN property_versions pv ON pv.id = s.entity_id
JOIN property prop ON prop.id = pv.property_id
LEFT JOIN projects p ON prop.entity_id = p.id AND prop.entity_type_id = 1
LEFT JOIN phases ph ON prop.entity_id = ph.id AND prop.entity_type_id = 2
LEFT JOIN companies c ON p.developer_companies_id = c.id
WHERE s.entity_type_id = 3
    AND (
        CASE 
            WHEN $3::bigint > 0 THEN s.created_by = $3
            WHEN $4::bigint > 0 THEN s.shared_to = $4
            ELSE true
        END
    )
    AND (
        prop.property_name ILIKE $5
        OR prop.property_title ILIKE $5
        OR p.project_name ILIKE $5
        OR p.ref_number ILIKE $5
        OR ph.phase_name ILIKE $5
        OR c.company_name ILIKE $5
    )
LIMIT $1
OFFSET $2
`

type SearchSharedPropertiesParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CreatedBy int64  `json:"created_by"`
	UserID    int64  `json:"user_id"`
	Query     string `json:"query"`
}

type SearchSharedPropertiesRow struct {
	ID                int64              `json:"id"`
	Title             string             `json:"title"`
	ViewsCount        int64              `json:"views_count"`
	TitleArabic       pgtype.Text        `json:"title_arabic"`
	Description       string             `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	PropertyRank      int64              `json:"property_rank"`
	PropertyID        int64              `json:"property_id"`
	Facts             []byte             `json:"facts"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	UpdatedBy         int64              `json:"updated_by"`
	Status            int64              `json:"status"`
	AgentID           int64              `json:"agent_id"`
	RefNo             string             `json:"ref_no"`
	Category          int64              `json:"category"`
	HasGallery        pgtype.Bool        `json:"has_gallery"`
	HasPlans          pgtype.Bool        `json:"has_plans"`
	IsMain            bool               `json:"is_main"`
	IsVerified        bool               `json:"is_verified"`
	Exclusive         bool               `json:"exclusive"`
	StartDate         pgtype.Date        `json:"start_date"`
	EndDate           pgtype.Date        `json:"end_date"`
	Slug              string             `json:"slug"`
	IsHotdeal         bool               `json:"is_hotdeal"`
	RefreshedAt       pgtype.Timestamptz `json:"refreshed_at"`
	ProjectName       pgtype.Text        `json:"project_name"`
	RefNumber         pgtype.Text        `json:"ref_number"`
	PhaseName         pgtype.Text        `json:"phase_name"`
	SharingType       int32              `json:"sharing_type"`
	CountryID         pgtype.Int8        `json:"country_id"`
	CompanyName       pgtype.Text        `json:"company_name"`
	PropertyName      string             `json:"property_name"`
	PropertyTitle     string             `json:"property_title"`
	Description_2     string             `json:"description_2"`
}

// Property search queries
func (q *Queries) SearchSharedProperties(ctx context.Context, arg SearchSharedPropertiesParams) ([]SearchSharedPropertiesRow, error) {
	rows, err := q.db.Query(ctx, searchSharedProperties,
		arg.Limit,
		arg.Offset,
		arg.CreatedBy,
		arg.UserID,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSharedPropertiesRow
	for rows.Next() {
		var i SearchSharedPropertiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ProjectName,
			&i.RefNumber,
			&i.PhaseName,
			&i.SharingType,
			&i.CountryID,
			&i.CompanyName,
			&i.PropertyName,
			&i.PropertyTitle,
			&i.Description_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSharedUnits = `-- name: SearchSharedUnits :many
SELECT DISTINCT 
    uv.id, uv.title, uv.views_count, uv.title_arabic, uv.description, uv.description_arabic, uv.unit_id, uv.ref_no, uv.status, uv.type, uv.unit_rank, uv.created_at, uv.updated_at, uv.created_by, uv.updated_by, uv.facts, uv.listed_by, uv.has_gallery, uv.has_plans, uv.is_main, uv.is_verified, uv.exclusive, uv.start_date, uv.end_date, uv.slug, uv.is_hotdeal, uv.refreshed_at,
    u.unit_no,
    u.unit_title,
    u.description,
    p.project_name,
    p.ref_number,
    ph.phase_name,
    prop.property_name,
    s.sharing_type,
    s.country_id,
    c.company_name
FROM sharing s
JOIN unit_versions uv ON uv.id = s.entity_id
JOIN units u ON u.id = uv.unit_id
LEFT JOIN property prop ON u.entity_id = prop.id 
    AND u.entity_type_id = 3
LEFT JOIN projects p ON (
    (u.entity_type_id = 1 AND u.entity_id = p.id) OR
    (prop.entity_type_id = 1 AND prop.entity_id = p.id)
)
LEFT JOIN phases ph ON (
    (u.entity_type_id = 2 AND u.entity_id = ph.id) OR
    (prop.entity_type_id = 2 AND prop.entity_id = ph.id)
)
LEFT JOIN companies c ON p.developer_companies_id = c.id
WHERE s.entity_type_id = 5
    AND (
        CASE 
            WHEN $3::bigint > 0 THEN s.created_by = $3
            WHEN $4::bigint > 0 THEN s.shared_to = $4
            ELSE true
        END
    )
    AND (
        u.unit_no ILIKE $5
        OR u.unit_title ILIKE $5
        OR prop.property_name ILIKE $5
        OR p.project_name ILIKE $5
        OR p.ref_number ILIKE $5
        OR ph.phase_name ILIKE $5
        OR c.company_name ILIKE $5
    )
LIMIT $1
OFFSET $2
`

type SearchSharedUnitsParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CreatedBy int64  `json:"created_by"`
	UserID    int64  `json:"user_id"`
	Query     string `json:"query"`
}

type SearchSharedUnitsRow struct {
	ID                int64              `json:"id"`
	Title             string             `json:"title"`
	ViewsCount        int64              `json:"views_count"`
	TitleArabic       pgtype.Text        `json:"title_arabic"`
	Description       string             `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	UnitID            int64              `json:"unit_id"`
	RefNo             string             `json:"ref_no"`
	Status            int64              `json:"status"`
	Type              int64              `json:"type"`
	UnitRank          int64              `json:"unit_rank"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	CreatedBy         int64              `json:"created_by"`
	UpdatedBy         int64              `json:"updated_by"`
	Facts             []byte             `json:"facts"`
	ListedBy          int64              `json:"listed_by"`
	HasGallery        pgtype.Bool        `json:"has_gallery"`
	HasPlans          pgtype.Bool        `json:"has_plans"`
	IsMain            bool               `json:"is_main"`
	IsVerified        bool               `json:"is_verified"`
	Exclusive         bool               `json:"exclusive"`
	StartDate         pgtype.Date        `json:"start_date"`
	EndDate           pgtype.Date        `json:"end_date"`
	Slug              string             `json:"slug"`
	IsHotdeal         bool               `json:"is_hotdeal"`
	RefreshedAt       pgtype.Timestamptz `json:"refreshed_at"`
	UnitNo            string             `json:"unit_no"`
	UnitTitle         string             `json:"unit_title"`
	Description_2     string             `json:"description_2"`
	ProjectName       pgtype.Text        `json:"project_name"`
	RefNumber         pgtype.Text        `json:"ref_number"`
	PhaseName         pgtype.Text        `json:"phase_name"`
	PropertyName      pgtype.Text        `json:"property_name"`
	SharingType       int32              `json:"sharing_type"`
	CountryID         pgtype.Int8        `json:"country_id"`
	CompanyName       pgtype.Text        `json:"company_name"`
}

// Unit search queries
func (q *Queries) SearchSharedUnits(ctx context.Context, arg SearchSharedUnitsParams) ([]SearchSharedUnitsRow, error) {
	rows, err := q.db.Query(ctx, searchSharedUnits,
		arg.Limit,
		arg.Offset,
		arg.CreatedBy,
		arg.UserID,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSharedUnitsRow
	for rows.Next() {
		var i SearchSharedUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.UnitID,
			&i.RefNo,
			&i.Status,
			&i.Type,
			&i.UnitRank,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.Facts,
			&i.ListedBy,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.UnitNo,
			&i.UnitTitle,
			&i.Description_2,
			&i.ProjectName,
			&i.RefNumber,
			&i.PhaseName,
			&i.PropertyName,
			&i.SharingType,
			&i.CountryID,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
