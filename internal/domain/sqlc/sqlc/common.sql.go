// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: common.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFilterHolidayHome = `-- name: CountFilterHolidayHome :one
With x As
(SELECT
    holiday_home.id, holiday_home.ref_no, holiday_home.company_types_id, holiday_home.is_branch, holiday_home.companies_id, holiday_home.title, holiday_home.title_ar, holiday_home.holiday_home_categories, holiday_home.countries_id, holiday_home.states_id, holiday_home.cities_id, holiday_home.communities_id, holiday_home.subcommunity_id, holiday_home.lat, holiday_home.lng, holiday_home.ranking, holiday_home.no_of_hours, holiday_home.no_of_rooms, holiday_home.no_of_bathrooms, holiday_home.views, holiday_home.facilities, holiday_home.holiday_package_inclusions, holiday_home.description, holiday_home.description_ar, holiday_home.posted_by, holiday_home.created_at, holiday_home.updated_at, holiday_home.status, holiday_home.holiday_home_type, holiday_home.no_of_guest, holiday_home.price_per_night, holiday_home.price_per_adults, holiday_home.price_per_children, holiday_home.amenities, holiday_home.location_url
FROM
    holiday_home
LEFT JOIN cities ON holiday_home.cities_id = cities.id
LEFT JOIN communities ON holiday_home.communities_id = communities.id
LEFT JOIN states ON holiday_home.states_id = states.id
LEFT JOIN countries ON holiday_home.countries_id = countries.id
LEFT JOIN sub_communities ON holiday_home.subcommunity_id = sub_communities.id
LEFT JOIN holiday_home_categories ON holiday_home_categories.id = ANY (holiday_home.holiday_home_categories)
LEFT JOIN holiday_media ON holiday_home.id = holiday_media.holiday_home_id
WHERE
        ( $1::bigint = 0 OR holiday_home.countries_id =  $1::bigint)  -- UAE
    AND ( $2::bigint = 0  OR holiday_home.states_id = $2::bigint )  -- states filter
    AND ( $3::bigint = 0  OR holiday_home.cities_id = $3::bigint )  -- subcommunity filter
    AND ( $4::bigint = 0  OR holiday_home.cities_id = $4::bigint )  -- City filter
    AND ($5::bigint = 0 OR holiday_home.holiday_home_type =  $5::bigint)  -- Type filter
    AND (holiday_home.price BETWEEN $6::bigint AND $7::bigint)  -- Price range filter
    AND (ARRAY_LENGTH($8::bigint[], 1) IS NULL OR holiday_home.no_of_rooms = ANY ($8::bigint[])) -- Bedrooms filter
    AND (ARRAY_LENGTH($9::bigint[], 1) IS NULL OR holiday_home.no_of_bathrooms = ANY ($9::bigint[]))  -- Bathrooms filter
    AND (CASE WHEN $10::bigint IS NULL THEN TRUE WHEN $10::bigint = 0 THEN TRUE ELSE holiday_home.status = $10::bigint END)  -- Status filter
    AND ($11::bigint = 0  OR holiday_home.posted_by = $11::bigint  ) -- Ownership filter
    AND (ARRAY_LENGTH($12::bigint[], 1) IS NULL OR (holiday_home.holiday_home_categories IS NOT NULL AND holiday_home.holiday_home_categories && $12::bigint[])) --categories filter
    AND (CASE WHEN ARRAY_LENGTH($13::bigint[], 1) IS NULL THEN TRUE ELSE holiday_home.facilities && $13::bigint[] END)  -- facilities filter
    	AND(
		CASE WHEN ARRAY_LENGTH($14::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			holiday_home."views" && $14::bigint []
		END) -- views
	-- media
	AND($15::bigint = 0
		OR(array_length(image_url,
				$16) IS NOT NULL)
		OR(array_length(image360_url,
				$17) IS NOT NULL)
		OR(array_length(video_url,
				$18) IS NOT NULL)
		OR(array_length(panaroma_url,
				$19) IS NOT NULL))
    AND (ARRAY_LENGTH($20::bigint[], 1) IS NULL OR holiday_home.ranking = ANY ($20::bigint[])) -- Ranking filter
    AND ($21::varchar IS NULL OR communities.community ILIKE $21::varchar)  -- Community filter 
    AND (CASE WHEN $22::varchar IS NULL THEN TRUE ELSE holiday_home.title ILIKE $22::varchar OR holiday_home.title_ar ILIKE $22::varchar OR cities.city ILIKE $22::varchar OR sub_communities.sub_community ILIKE $22::varchar OR holiday_home_categories.title ILIKE $22::varchar END)  -- Search purpose filter
    AND holiday_home.status NOT IN (5, 6) GROUP BY holiday_home.id) 
    SELECT COUNT(*) FROM x
`

type CountFilterHolidayHomeParams struct {
	CountryID             int64   `json:"country_id"`
	StatesID              int64   `json:"states_id"`
	SubcommunityID        int64   `json:"subcommunity_id"`
	CitiesID              int64   `json:"cities_id"`
	HolidayHomeType       int64   `json:"holiday_home_type"`
	MinPrice              int64   `json:"min_price"`
	MaxPrice              int64   `json:"max_price"`
	NoOfRooms             []int64 `json:"no_of_rooms"`
	NoOfBathrooms         []int64 `json:"no_of_bathrooms"`
	Status                int64   `json:"status"`
	UserID                int64   `json:"user_id"`
	HolidayHomeCategories []int64 `json:"holiday_home_categories"`
	Facilities            []int64 `json:"facilities"`
	Views                 []int64 `json:"views"`
	Media                 int64   `json:"media"`
	ImageUrl              int32   `json:"image_url"`
	Image360Url           int32   `json:"image360_url"`
	VideoUrl              int32   `json:"video_url"`
	PanaromaUrl           int32   `json:"panaroma_url"`
	Ranking               []int64 `json:"ranking"`
	Community             string  `json:"community"`
	Searchwith            string  `json:"searchwith"`
}

func (q *Queries) CountFilterHolidayHome(ctx context.Context, arg CountFilterHolidayHomeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFilterHolidayHome,
		arg.CountryID,
		arg.StatesID,
		arg.SubcommunityID,
		arg.CitiesID,
		arg.HolidayHomeType,
		arg.MinPrice,
		arg.MaxPrice,
		arg.NoOfRooms,
		arg.NoOfBathrooms,
		arg.Status,
		arg.UserID,
		arg.HolidayHomeCategories,
		arg.Facilities,
		arg.Views,
		arg.Media,
		arg.ImageUrl,
		arg.Image360Url,
		arg.VideoUrl,
		arg.PanaromaUrl,
		arg.Ranking,
		arg.Community,
		arg.Searchwith,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteExhibitionMedia = `-- name: DeleteExhibitionMedia :exec
DELETE FROM exhibitions_media WHERE id=$1
`

func (q *Queries) DeleteExhibitionMedia(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteExhibitionMedia, id)
	return err
}

const deleteExhibitionMediaByURL = `-- name: DeleteExhibitionMediaByURL :one



WITH X AS (
    SELECT id AS "media_id", array_remove(media_url, $2) AS new_array
    FROM exhibitions_media
    WHERE $2 = ANY(media_url) AND id=$1 
)
UPDATE exhibitions_media
SET media_url = x.new_array
FROM x
WHERE exhibitions_media.id = $1  AND (SELECT event_status FROM exhibitions WHERE id=exhibitions_id)!=5
RETURNING exhibitions_media.id, exhibitions_media.exhibitions_id, exhibitions_media.gallery_type, exhibitions_media.media_type, exhibitions_media.media_url, exhibitions_media.created_at, exhibitions_media.updated_at
`

type DeleteExhibitionMediaByURLParams struct {
	ID          int64       `json:"id"`
	ArrayRemove interface{} `json:"array_remove"`
}

// -- name: GetAllParentJobCategoriesWithSubcategoryCount :many
// WITH SubcategoryCount AS (
//
//	SELECT
//	    parent_category_id,
//	    COUNT(*) AS subcategory_count
//	FROM
//	    job_categories
//	WHERE
//	    status != 5 AND status != 6
//	GROUP BY
//	    parent_category_id
//
// )
// SELECT
//
//	jc.id,
//	-- jc.ref_no,
//	jc.parent_category_id,
//	jc.category_name,
//	jc.description,
//	-- jc.company_types_id,
//	-- jc.companies_id,
//	-- jc.is_branch,
//	jc.category_image,
//	jc.created_at,
//	jc.created_by,
//	jc.status,
//	jc.company_name,
//	COALESCE(sc.subcategory_count, 0) AS subcategory_count
//
// FROM
//
//	job_categories jc
//
// LEFT JOIN
//
//	SubcategoryCount sc ON jc.id = sc.parent_category_id
//
// WHERE
//
//	jc.parent_category_id = 0
//	AND jc.status != 5
//	AND jc.status != 6
//
// ORDER BY
//
//	jc.id DESC;
func (q *Queries) DeleteExhibitionMediaByURL(ctx context.Context, arg DeleteExhibitionMediaByURLParams) (ExhibitionsMedium, error) {
	row := q.db.QueryRow(ctx, deleteExhibitionMediaByURL, arg.ID, arg.ArrayRemove)
	var i ExhibitionsMedium
	err := row.Scan(
		&i.ID,
		&i.ExhibitionsID,
		&i.GalleryType,
		&i.MediaType,
		&i.MediaUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const filterExhibition = `-- name: FilterExhibition :many



WITH X AS (
    SELECT 
        e.id, e.title, e.description, e.ref_no, e.start_date, e.end_date,
        e.specific_address, em.media_url,e.event_logo_url,
       CAST( COALESCE((
            SELECT 
            ROUND((
            (AVG(clean) + AVG(facilities) + AVG(location) + AVG(securities)) / 4
        )::numeric, 1) AS overall_average
            FROM exhibition_reviews er
            WHERE er.exhibition_id = e.id
        ), 0.0) AS float) AS overall_average, 
        (SELECT COUNT(id)
        FROM exhibition_reviews WHERE exhibition_id=e.id
        ) AS number_of_reviews
    FROM 
        exhibitions e
    LEFT JOIN 
        exhibitions_media em ON e.id = em.exhibitions_id AND em.gallery_type = 1 AND em.media_type = 1
    WHERE 
        e.countries_id = $1 AND (e.event_status = $2 OR e.event_status = $3)
)
SELECT id, title, description, ref_no, start_date, end_date, specific_address, media_url, event_logo_url, overall_average,number_of_reviews
FROM X
ORDER BY 
    CASE WHEN $4= 'ASC' THEN overall_average END ASC,
    CASE WHEN $4= 'DESC' THEN overall_average END DESC
LIMIT $5
OFFSET $6
`

type FilterExhibitionParams struct {
	CountriesID   int64       `json:"countries_id"`
	EventStatus   int64       `json:"event_status"`
	EventStatus_2 int64       `json:"event_status_2"`
	Column4       interface{} `json:"column_4"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

type FilterExhibitionRow struct {
	ID              int64     `json:"id"`
	Title           string    `json:"title"`
	Description     string    `json:"description"`
	RefNo           string    `json:"ref_no"`
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	SpecificAddress string    `json:"specific_address"`
	MediaUrl        []string  `json:"media_url"`
	EventLogoUrl    string    `json:"event_logo_url"`
	OverallAverage  float64   `json:"overall_average"`
	NumberOfReviews int64     `json:"number_of_reviews"`
}

// -- name: SearchParentCategoriesByTitle :many
// WITH SubcategoryCount AS (
//
//	SELECT
//	    parent_category_id,
//	    COUNT(*) AS subcategory_count
//	FROM
//	    job_categories
//	WHERE
//	    status != 5 AND status != 6
//	GROUP BY
//	    parent_category_id
//
// )
// SELECT
//
//	jc.id,
//	-- jc.ref_no,
//	jc.parent_category_id,
//	jc.category_name,
//	jc.description,
//	-- jc.company_types_id,
//	-- jc.companies_id,
//	-- jc.is_branch,
//	jc.category_image,
//	jc.created_at,
//	jc.created_by,
//	jc.status,
//	jc.company_name,
//	COALESCE(sc.subcategory_count, 0) AS subcategory_count
//
// FROM
//
//	job_categories jc
//
// LEFT JOIN
//
//	SubcategoryCount sc ON jc.id = sc.parent_category_id
//
// WHERE
//
//	jc.parent_category_id = 0
//	AND jc.status != 5
//	AND jc.status != 6
//	AND jc.category_name ILIKE '%' || $1 || '%'
//
// ORDER BY
//
//	jc.id DESC;
func (q *Queries) FilterExhibition(ctx context.Context, arg FilterExhibitionParams) ([]FilterExhibitionRow, error) {
	rows, err := q.db.Query(ctx, filterExhibition,
		arg.CountriesID,
		arg.EventStatus,
		arg.EventStatus_2,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterExhibitionRow
	for rows.Next() {
		var i FilterExhibitionRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.RefNo,
			&i.StartDate,
			&i.EndDate,
			&i.SpecificAddress,
			&i.MediaUrl,
			&i.EventLogoUrl,
			&i.OverallAverage,
			&i.NumberOfReviews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllHolidayHomeStayReviewsWithOverAllAverages = `-- name: GetAllHolidayHomeStayReviewsWithOverAllAverages :one
WITH avg_calculations AS (
    SELECT 
        holiday_home_id,
        ROUND((
            (AVG(comfortness) + AVG(communications) + AVG(cleanliness) + AVG(location)) / 4
        )::numeric, 1) AS overall_average
    FROM 
        holiday_stay_reviews
    WHERE 
        holiday_home_id = $1
    GROUP BY 
        holiday_home_id
)
SELECT 
    hsr.id, hsr.holiday_home_id, hsr.review_date, hsr.user_id, hsr.comfortness, hsr.communications, hsr.cleanliness, hsr.location, hsr.title, hsr.review,
    ac.overall_average
FROM 
    holiday_stay_reviews hsr
JOIN 
    avg_calculations ac
ON 
    hsr.holiday_home_id = ac.holiday_home_id
WHERE 
    hsr.holiday_home_id = $1
`

type GetAllHolidayHomeStayReviewsWithOverAllAveragesRow struct {
	ID             int64          `json:"id"`
	HolidayHomeID  int64          `json:"holiday_home_id"`
	ReviewDate     time.Time      `json:"review_date"`
	UserID         int64          `json:"user_id"`
	Comfortness    float64        `json:"comfortness"`
	Communications float64        `json:"communications"`
	Cleanliness    float64        `json:"cleanliness"`
	Location       float64        `json:"location"`
	Title          string         `json:"title"`
	Review         string         `json:"review"`
	OverallAverage pgtype.Numeric `json:"overall_average"`
}

func (q *Queries) GetAllHolidayHomeStayReviewsWithOverAllAverages(ctx context.Context, holidayHomeID int64) (GetAllHolidayHomeStayReviewsWithOverAllAveragesRow, error) {
	row := q.db.QueryRow(ctx, getAllHolidayHomeStayReviewsWithOverAllAverages, holidayHomeID)
	var i GetAllHolidayHomeStayReviewsWithOverAllAveragesRow
	err := row.Scan(
		&i.ID,
		&i.HolidayHomeID,
		&i.ReviewDate,
		&i.UserID,
		&i.Comfortness,
		&i.Communications,
		&i.Cleanliness,
		&i.Location,
		&i.Title,
		&i.Review,
		&i.OverallAverage,
	)
	return i, err
}

const getTotalAvgHolidayHomeStayReviews = `-- name: GetTotalAvgHolidayHomeStayReviews :one
WITH averages AS (
    SELECT 
        AVG(comfortness) AS avg_comfortness, 
        AVG(communications) AS avg_communications, 
        AVG(cleanliness) AS avg_cleanliness, 
        AVG(location) AS avg_location
    FROM 
        holiday_stay_reviews
        Where holiday_home_id = $1
)
SELECT 
    ROUND((
        (avg_comfortness + avg_communications + avg_cleanliness + avg_location) / 4
    )::numeric, 1) AS overall_average
FROM 
    averages
`

func (q *Queries) GetTotalAvgHolidayHomeStayReviews(ctx context.Context, holidayHomeID int64) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getTotalAvgHolidayHomeStayReviews, holidayHomeID)
	var overall_average pgtype.Numeric
	err := row.Scan(&overall_average)
	return overall_average, err
}
