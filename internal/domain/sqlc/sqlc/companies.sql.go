// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: companies.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompanies = `-- name: CreateCompanies :one
INSERT INTO companies (
    ref_no,
    company_name,
    tag_line,
    description,
    logo_url,
    email,
    phone_number,
    whatsapp_number,
    is_verified,
    website_url,
    cover_image_url,
    no_of_employees,
    company_rank,
    status,
    company_type,
    addresses_id,
    users_id,
    created_by,
    created_at,
    updated_at,
    description_ar,
    updated_by,
    company_activities_id,
    company_parent_id,
    location_url,
    vat_no,
    vat_status,
    vat_file_url
)VALUES (
    $1 ,$2, $3, $4, $5, $6, $7, $8, $9, $10, 
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, 
    $21, $22, $23, $24, $25, $26, $27, $28
) RETURNING id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url
`

type CreateCompaniesParams struct {
	RefNo               string      `json:"ref_no"`
	CompanyName         string      `json:"company_name"`
	TagLine             pgtype.Text `json:"tag_line"`
	Description         string      `json:"description"`
	LogoUrl             string      `json:"logo_url"`
	Email               string      `json:"email"`
	PhoneNumber         string      `json:"phone_number"`
	WhatsappNumber      pgtype.Text `json:"whatsapp_number"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	WebsiteUrl          pgtype.Text `json:"website_url"`
	CoverImageUrl       string      `json:"cover_image_url"`
	NoOfEmployees       pgtype.Int8 `json:"no_of_employees"`
	CompanyRank         int64       `json:"company_rank"`
	Status              int64       `json:"status"`
	CompanyType         int64       `json:"company_type"`
	AddressesID         int64       `json:"addresses_id"`
	UsersID             int64       `json:"users_id"`
	CreatedBy           int64       `json:"created_by"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	DescriptionAr       pgtype.Text `json:"description_ar"`
	UpdatedBy           pgtype.Int8 `json:"updated_by"`
	CompanyActivitiesID []int64     `json:"company_activities_id"`
	CompanyParentID     pgtype.Int8 `json:"company_parent_id"`
	LocationUrl         pgtype.Text `json:"location_url"`
	VatNo               pgtype.Text `json:"vat_no"`
	VatStatus           pgtype.Int8 `json:"vat_status"`
	VatFileUrl          pgtype.Text `json:"vat_file_url"`
}

func (q *Queries) CreateCompanies(ctx context.Context, arg CreateCompaniesParams) (Company, error) {
	row := q.db.QueryRow(ctx, createCompanies,
		arg.RefNo,
		arg.CompanyName,
		arg.TagLine,
		arg.Description,
		arg.LogoUrl,
		arg.Email,
		arg.PhoneNumber,
		arg.WhatsappNumber,
		arg.IsVerified,
		arg.WebsiteUrl,
		arg.CoverImageUrl,
		arg.NoOfEmployees,
		arg.CompanyRank,
		arg.Status,
		arg.CompanyType,
		arg.AddressesID,
		arg.UsersID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DescriptionAr,
		arg.UpdatedBy,
		arg.CompanyActivitiesID,
		arg.CompanyParentID,
		arg.LocationUrl,
		arg.VatNo,
		arg.VatStatus,
		arg.VatFileUrl,
	)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const createCompaniesLeadership = `-- name: CreateCompaniesLeadership :one
INSERT INTO companies_leadership (
    name,
    position,
    description,
    description_ar,
    image_url,
    companies_id,
    created_by,
    created_at
)VALUES (
    $1 ,$2, $3, $4, $5, $6, $7, $8
) RETURNING id, name, position, description_ar, description, image_url, is_verified, companies_id, created_by, created_at, updated_at
`

type CreateCompaniesLeadershipParams struct {
	Name          string      `json:"name"`
	Position      string      `json:"position"`
	Description   string      `json:"description"`
	DescriptionAr pgtype.Text `json:"description_ar"`
	ImageUrl      string      `json:"image_url"`
	CompaniesID   int64       `json:"companies_id"`
	CreatedBy     int64       `json:"created_by"`
	CreatedAt     time.Time   `json:"created_at"`
}

func (q *Queries) CreateCompaniesLeadership(ctx context.Context, arg CreateCompaniesLeadershipParams) (CompaniesLeadership, error) {
	row := q.db.QueryRow(ctx, createCompaniesLeadership,
		arg.Name,
		arg.Position,
		arg.Description,
		arg.DescriptionAr,
		arg.ImageUrl,
		arg.CompaniesID,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	var i CompaniesLeadership
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Position,
		&i.DescriptionAr,
		&i.Description,
		&i.ImageUrl,
		&i.IsVerified,
		&i.CompaniesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLicense = `-- name: CreateLicense :one
INSERT INTO license(
    license_file_url,
    license_no,
    license_issue_date,
    license_registration_date,
    license_expiry_date,
    license_type_id,
    state_id,
    entity_type_id,
    entity_id,
    metadata
)VALUES(
    $1 ,$2, $3, $4, $5, $6, $7, $8, $9, $10
)RETURNING id, license_file_url, license_no, license_issue_date, license_registration_date, license_expiry_date, license_type_id, state_id, entity_type_id, entity_id, metadata
`

type CreateLicenseParams struct {
	LicenseFileUrl          pgtype.Text        `json:"license_file_url"`
	LicenseNo               string             `json:"license_no"`
	LicenseIssueDate        pgtype.Timestamptz `json:"license_issue_date"`
	LicenseRegistrationDate pgtype.Timestamptz `json:"license_registration_date"`
	LicenseExpiryDate       pgtype.Timestamptz `json:"license_expiry_date"`
	LicenseTypeID           int64              `json:"license_type_id"`
	StateID                 int64              `json:"state_id"`
	EntityTypeID            int64              `json:"entity_type_id"`
	EntityID                int64              `json:"entity_id"`
	Metadata                []byte             `json:"metadata"`
}

func (q *Queries) CreateLicense(ctx context.Context, arg CreateLicenseParams) (License, error) {
	row := q.db.QueryRow(ctx, createLicense,
		arg.LicenseFileUrl,
		arg.LicenseNo,
		arg.LicenseIssueDate,
		arg.LicenseRegistrationDate,
		arg.LicenseExpiryDate,
		arg.LicenseTypeID,
		arg.StateID,
		arg.EntityTypeID,
		arg.EntityID,
		arg.Metadata,
	)
	var i License
	err := row.Scan(
		&i.ID,
		&i.LicenseFileUrl,
		&i.LicenseNo,
		&i.LicenseIssueDate,
		&i.LicenseRegistrationDate,
		&i.LicenseExpiryDate,
		&i.LicenseTypeID,
		&i.StateID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Metadata,
	)
	return i, err
}

const createStateLicenseFields = `-- name: CreateStateLicenseFields :one
INSERT INTO state_license_fields(
    field_name,
    field_value,
    license_id
)VALUES(
    $1 ,$2, $3
)RETURNING id, field_name, field_value, license_id
`

type CreateStateLicenseFieldsParams struct {
	FieldName  string `json:"field_name"`
	FieldValue string `json:"field_value"`
	LicenseID  int64  `json:"license_id"`
}

func (q *Queries) CreateStateLicenseFields(ctx context.Context, arg CreateStateLicenseFieldsParams) (StateLicenseField, error) {
	row := q.db.QueryRow(ctx, createStateLicenseFields, arg.FieldName, arg.FieldValue, arg.LicenseID)
	var i StateLicenseField
	err := row.Scan(
		&i.ID,
		&i.FieldName,
		&i.FieldValue,
		&i.LicenseID,
	)
	return i, err
}

const deleteAllLicensesByIds = `-- name: DeleteAllLicensesByIds :exec
DELETE FROM license WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteAllLicensesByIds(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, deleteAllLicensesByIds, ids)
	return err
}

const deleteCompaniesLeadership = `-- name: DeleteCompaniesLeadership :exec
DELETE FROM companies_leadership
Where id = $1
`

func (q *Queries) DeleteCompaniesLeadership(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCompaniesLeadership, id)
	return err
}

const deleteStateLicenseFieldsByNames = `-- name: DeleteStateLicenseFieldsByNames :exec
DELETE FROM state_license_fields
WHERE field_name = ANY($1::varchar[]) AND license_id = $2::bigint
`

type DeleteStateLicenseFieldsByNamesParams struct {
	FieldNames []string `json:"field_names"`
	LicenseID  int64    `json:"license_id"`
}

func (q *Queries) DeleteStateLicenseFieldsByNames(ctx context.Context, arg DeleteStateLicenseFieldsByNamesParams) error {
	_, err := q.db.Exec(ctx, deleteStateLicenseFieldsByNames, arg.FieldNames, arg.LicenseID)
	return err
}

const getAUsersFromCompanyId = `-- name: GetAUsersFromCompanyId :one

SELECT companies.users_id From companies
WHERE id = $1
`

// -- name: GetAllUsersFromCompanyIds :many
// SELECT companies.users_id From companies
// WHERE id = ANY(@companies_id::bigint[]);
func (q *Queries) GetAUsersFromCompanyId(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAUsersFromCompanyId, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getAllBrokerCompanyNamesByStateOrCity = `-- name: GetAllBrokerCompanyNamesByStateOrCity :many
SELECT companies.id,company_name,
    CASE WHEN company_parent_id IS NULL THEN FALSE::boolean ELSE TRUE::boolean END AS is_branch
FROM companies
INNER JOIN addresses ON companies.addresses_id = addresses.id
INNER JOIN company_types ON company_types.id = companies.company_type
WHERE 
CASE WHEN $1::boolean = FALSE THEN addresses.cities_id = $2::bigint ELSE addresses.states_id = $2::bigint END 
AND company_types.id = 1
`

type GetAllBrokerCompanyNamesByStateOrCityParams struct {
	IsState bool  `json:"is_state"`
	ID      int64 `json:"id"`
}

type GetAllBrokerCompanyNamesByStateOrCityRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
	IsBranch    bool   `json:"is_branch"`
}

func (q *Queries) GetAllBrokerCompanyNamesByStateOrCity(ctx context.Context, arg GetAllBrokerCompanyNamesByStateOrCityParams) ([]GetAllBrokerCompanyNamesByStateOrCityRow, error) {
	rows, err := q.db.Query(ctx, getAllBrokerCompanyNamesByStateOrCity, arg.IsState, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBrokerCompanyNamesByStateOrCityRow
	for rows.Next() {
		var i GetAllBrokerCompanyNamesByStateOrCityRow
		if err := rows.Scan(&i.ID, &i.CompanyName, &i.IsBranch); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanies = `-- name: GetAllCompanies :many
SELECT  
	c.id, c.created_at, c.company_name, c.logo_url, c.email,c.phone_number, c.status, c.company_rank,  c.addresses_id, c.created_by,c.users_id,c.company_type,c.created_at,
	cl.license_no,CONCAT(profiles.first_name,' ',profiles.last_name)::varchar AS admin_name, addresses.full_address ,roles.role AS added_by_role
    -- , cl.orn_license_no, cl.orn_license_file_url, cl.orn_registration_date, cl.orn_license_expiry
FROM companies as c
 INNER JOIN addresses ON c.addresses_id = addresses.id
 INNER JOIN countries ON addresses.countries_id = countries.id
 INNER JOIN states ON addresses.states_id = states.id
 INNER JOIN cities ON addresses.cities_id = cities.id 
  LEFT JOIN communities ON addresses.communities_id = communities.id
 LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id

 INNER JOIN users ON c.created_by = users.id 
 INNER JOIN users as admin ON c.users_id = admin.id
 INNER JOIN profiles ON admin.id = profiles.users_id
 LEFT  JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
 INNER JOIN license cl ON cl.entity_id = c.id AND entity_type_id = $3::bigint AND license_type_id = $4::bigint
WHERE
    (
       $5 = '%%'
       OR c.company_name ILIKE $5
       OR (CASE 
        WHEN 'standard' ILIKE $5 THEN c.company_rank = 1
        WHEN 'featured' ILIKE $5 THEN c.company_rank = 2 
        WHEN 'premium'  ILIKE $5 THEN c.company_rank = 3
        WHEN 'top deal' ILIKE $5 THEN c.company_rank = 4
        ELSE FALSE
      END)
      OR cl.license_no ILIKE $5
      OR countries.country ILIKE $5
      OR states.state ILIKE $5
      OR cities.city ILIKE $5    
      OR communities.community ILIKE $5 
      OR sub_communities.sub_community ILIKE $5    
      OR roles."role" ILIKE $5
      OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $5
      OR c.email ILIKE $5
      OR c.phone_number ILIKE $5
    )
    AND
  	CASE WHEN $6 != true THEN true ELSE c.id = $7::bigint AND c.company_type =   $8::bigint END
   AND 
    -- CASE WHEN @country_id::bigint = 0 THEN true WHEN @is_international::boolean = true THEN addresses.countries_id != @country_id::bigint ELSE addresses.countries_id = @country_id::bigint END
   CASE 
   WHEN $9::bigint = 0 THEN true
        WHEN 'international' = $10::varchar THEN addresses.countries_id != $9::bigint 
  		WHEN 'local' = $10::varchar THEN addresses.countries_id = $9::bigint END
   AND CASE WHEN $11::bigint = 0 Then true ELSE addresses.cities_id = $11::bigint END
   AND CASE WHEN $12::bigint = 0 THEN true ELSE addresses.communities_id = $12::bigint END
   AND CASE WHEN $13::bigint = 0 THEN true ELSE addresses.sub_communities_id = $13::bigint END
   AND CASE WHEN $14::bigint = 0 THEN (c.status != 5 AND c.status != 6) ELSE c.status = $14::bigint END
ORDER BY created_at DESC  LIMIT $1 OFFSET $2
`

type GetAllCompaniesParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	EntityTypeID   int64       `json:"entity_type_id"`
	LicenseTypeID  int64       `json:"license_type_id"`
	Search         interface{} `json:"search"`
	IsCompanyUser  interface{} `json:"is_company_user"`
	CompanyID      int64       `json:"company_id"`
	CompanyType    int64       `json:"company_type"`
	CountryID      int64       `json:"country_id"`
	Localize       string      `json:"localize"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
	Status         int64       `json:"status"`
}

type GetAllCompaniesRow struct {
	ID          int64       `json:"id"`
	CreatedAt   time.Time   `json:"created_at"`
	CompanyName string      `json:"company_name"`
	LogoUrl     string      `json:"logo_url"`
	Email       string      `json:"email"`
	PhoneNumber string      `json:"phone_number"`
	Status      int64       `json:"status"`
	CompanyRank int64       `json:"company_rank"`
	AddressesID int64       `json:"addresses_id"`
	CreatedBy   int64       `json:"created_by"`
	UsersID     int64       `json:"users_id"`
	CompanyType int64       `json:"company_type"`
	CreatedAt_2 time.Time   `json:"created_at_2"`
	LicenseNo   string      `json:"license_no"`
	AdminName   string      `json:"admin_name"`
	FullAddress pgtype.Text `json:"full_address"`
	AddedByRole pgtype.Text `json:"added_by_role"`
}

// INNER JOIN companies_licenses cl ON cl.company_id = c.id
// LEFT  JOIN branch_companies ON branch_companies.companies_id = c.id
//
//	ELSE ''= @localize::varchar AND addresses.countries_id = @country_id::bigint END
//	AND CASE WHEN @status::bigint = 0 THEN c.company_parent_id IS NULL ELSE true END
func (q *Queries) GetAllCompanies(ctx context.Context, arg GetAllCompaniesParams) ([]GetAllCompaniesRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanies,
		arg.Limit,
		arg.Offset,
		arg.EntityTypeID,
		arg.LicenseTypeID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyID,
		arg.CompanyType,
		arg.CountryID,
		arg.Localize,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompaniesRow
	for rows.Next() {
		var i GetAllCompaniesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.CompanyName,
			&i.LogoUrl,
			&i.Email,
			&i.PhoneNumber,
			&i.Status,
			&i.CompanyRank,
			&i.AddressesID,
			&i.CreatedBy,
			&i.UsersID,
			&i.CompanyType,
			&i.CreatedAt_2,
			&i.LicenseNo,
			&i.AdminName,
			&i.FullAddress,
			&i.AddedByRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompaniesLeadersByCompany = `-- name: GetAllCompaniesLeadersByCompany :many
SELECT id, name, position, description_ar, description, image_url, is_verified, companies_id, created_by, created_at, updated_at, COUNT(id) OVER() AS total_count FROM companies_leadership WHERE companies_id = $3 ORDER BY id  LIMIT $1  OFFSET $2
`

type GetAllCompaniesLeadersByCompanyParams struct {
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
	CompaniesID int64 `json:"companies_id"`
}

type GetAllCompaniesLeadersByCompanyRow struct {
	ID            int64       `json:"id"`
	Name          string      `json:"name"`
	Position      string      `json:"position"`
	DescriptionAr pgtype.Text `json:"description_ar"`
	Description   string      `json:"description"`
	ImageUrl      string      `json:"image_url"`
	IsVerified    pgtype.Bool `json:"is_verified"`
	CompaniesID   int64       `json:"companies_id"`
	CreatedBy     int64       `json:"created_by"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	TotalCount    int64       `json:"total_count"`
}

func (q *Queries) GetAllCompaniesLeadersByCompany(ctx context.Context, arg GetAllCompaniesLeadersByCompanyParams) ([]GetAllCompaniesLeadersByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getAllCompaniesLeadersByCompany, arg.Limit, arg.Offset, arg.CompaniesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompaniesLeadersByCompanyRow
	for rows.Next() {
		var i GetAllCompaniesLeadersByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.DescriptionAr,
			&i.Description,
			&i.ImageUrl,
			&i.IsVerified,
			&i.CompaniesID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompaniesNameByCompanyType = `-- name: GetAllCompaniesNameByCompanyType :many
SELECT companies.id, company_name, company_type, 
CASE WHEN company_parent_id IS NULL THEN FALSE::boolean ELSE TRUE::boolean END AS is_branch 
FROM companies
WHERE company_type = $1
`

type GetAllCompaniesNameByCompanyTypeRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
	CompanyType int64  `json:"company_type"`
	IsBranch    bool   `json:"is_branch"`
}

func (q *Queries) GetAllCompaniesNameByCompanyType(ctx context.Context, companyType int64) ([]GetAllCompaniesNameByCompanyTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllCompaniesNameByCompanyType, companyType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompaniesNameByCompanyTypeRow
	for rows.Next() {
		var i GetAllCompaniesNameByCompanyTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.CompanyType,
			&i.IsBranch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyNames = `-- name: GetAllCompanyNames :many

 










SELECT companies.id, company_name, company_type, 
CASE WHEN company_parent_id IS NULL THEN FALSE::boolean ELSE TRUE::boolean END AS is_branch 
FROM companies
`

type GetAllCompanyNamesRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
	CompanyType int64  `json:"company_type"`
	IsBranch    bool   `json:"is_branch"`
}

// SELECT
//
//	COUNT(id)
//
// FROM companies
// WHERE status = $1;
// -- name: GetCompaniesByRank :many
// SELECT c.id, c.company_name, c.company_type, c.logo_url, c.email, c.phone_number, c.status, c.company_rank,  c.addresses_id,  c.users_id, cl.commercial_license_no,
// CASE WHEN company_parent_id IS NULL THEN FALSE::boolean ELSE TRUE::boolean END AS is_branch
// FROM companies c
// INNER JOIN companies_licenses cl ON c.id = cl.company_id
//
//	INNER JOIN addresses ON c.addresses_id = addresses.id
//	INNER JOIN countries ON addresses.countries_id = countries.id
//	INNER JOIN states ON addresses.states_id = states.id
//	INNER JOIN cities ON addresses.cities_id = cities.id
//	INNER JOIN users ON c.created_by = users.id
//	INNER JOIN users as admin ON c.users_id = admin.id
//	INNER JOIN profiles ON admin.profiles_id = profiles.id
//	LEFT  JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
//
// WHERE
//
//	 (
//	      @search = '%%'
//	      OR c.company_name ILIKE @search
//	      OR (CASE
//	       WHEN 'standard' ILIKE @search THEN c.company_rank = 1
//	       WHEN 'featured' ILIKE @search THEN c.company_rank = 2
//	       WHEN 'premium'  ILIKE @search THEN c.company_rank = 3
//	       WHEN 'top deal' ILIKE @search THEN c.company_rank = 4
//	       ELSE FALSE
//	     END)
//	     OR cl.commercial_license_no ILIKE @search
//	     OR countries.country ILIKE @search
//	     OR states.state ILIKE @search
//	     OR cities.city ILIKE @search
//	     OR roles."role" ILIKE @search
//	     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE @search
//	     OR c.email ILIKE @search
//	     OR c.phone_number ILIKE @search
//	   )
//	   AND
//		CASE WHEN @is_company_user != true THEN true ELSE c.id = @company_id::bigint AND c.company_type =   @company_type::bigint END
//	  AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id = @country_id::bigint END
//	  AND CASE WHEN @city_id::bigint = 0 Then true ELSE addresses.cities_id = @city_id::bigint END
//	  AND CASE WHEN @community_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
//	  AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint  END
//	  AND c.status NOT IN (5,6)
//
// AND c.company_rank = $3
// ORDER BY c.updated_at  DESC LIMIT $1 OFFSET $2;
// SELECT companies.id, company_name, company_type, logo_url, email, phone_number, status, company_rank,  addresses_id,  users_id ,
// companies_licenses.commercial_license_no,
// CASE WHEN branch_companies.id != 0 THEN TRUE::boolean ELSE FALSE::boolean END AS is_branch
// FROM companies
// INNER JOIN companies_licenses ON companies_licenses.id = companies.companies_licenses_id
// LEFT JOIN branch_companies ON branch_companies.companies_id = companies.id
// WHERE  companies.company_rank = $3
// ORDER BY id  LIMIT $1 OFFSET $2;
// -- name: GetCountCompaniesByRank :one
// SELECT COUNT(c.id)
// FROM companies c
// INNER JOIN companies_licenses cl ON c.id = cl.company_id
//
//	INNER JOIN addresses ON c.addresses_id = addresses.id
//	INNER JOIN countries ON addresses.countries_id = countries.id
//	INNER JOIN states ON addresses.states_id = states.id
//	INNER JOIN cities ON addresses.cities_id = cities.id
//	INNER JOIN users ON c.created_by = users.id
//	INNER JOIN users as admin ON c.users_id = admin.id
//	INNER JOIN profiles ON admin.profiles_id = profiles.id
//	LEFT  JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
//
// WHERE
//
//	 (
//	      @search = '%%'
//	      OR c.company_name ILIKE @search
//	      OR (CASE
//	       WHEN 'standard' ILIKE @search THEN c.company_rank = 1
//	       WHEN 'featured' ILIKE @search THEN c.company_rank = 2
//	       WHEN 'premium'  ILIKE @search THEN c.company_rank = 3
//	       WHEN 'top deal' ILIKE @search THEN c.company_rank = 4
//	       ELSE FALSE
//	     END)
//	     OR cl.commercial_license_no ILIKE @search
//	     OR countries.country ILIKE @search
//	     OR states.state ILIKE @search
//	     OR cities.city ILIKE @search
//	     OR roles."role" ILIKE @search
//	     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE @search
//	     OR c.email ILIKE @search
//	     OR c.phone_number ILIKE @search
//	   )
//	   AND
//		CASE WHEN @is_company_user != true THEN true ELSE c.id = @company_id::bigint AND c.company_type =   @company_type::bigint END
//	  AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id = @country_id::bigint END
//	  AND CASE WHEN @city_id::bigint = 0 Then true ELSE addresses.cities_id = @city_id::bigint END
//	  AND CASE WHEN @community_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
//	  AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint  END
//	  AND c.status NOT IN (5,6)
//
// AND c.company_rank = $1;
// -- SELECT
// --     COUNT(id)
// -- FROM companies
// -- WHERE company_rank = $1;
func (q *Queries) GetAllCompanyNames(ctx context.Context) ([]GetAllCompanyNamesRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyNamesRow
	for rows.Next() {
		var i GetAllCompanyNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.CompanyType,
			&i.IsBranch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyNamesByBranchAndType = `-- name: GetAllCompanyNamesByBranchAndType :many
SELECT companies.id, company_name
FROM companies
WHERE 
CASE 
	WHEN $1::boolean = TRUE THEN companies.company_type = $2 AND company_parent_id IS NOT NULL
	ELSE companies.company_type = $2 AND company_parent_id IS NULL
END AND status != 5 AND status != 6
`

type GetAllCompanyNamesByBranchAndTypeParams struct {
	IsBranch    bool  `json:"is_branch"`
	CompanyType int64 `json:"company_type"`
}

type GetAllCompanyNamesByBranchAndTypeRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
}

func (q *Queries) GetAllCompanyNamesByBranchAndType(ctx context.Context, arg GetAllCompanyNamesByBranchAndTypeParams) ([]GetAllCompanyNamesByBranchAndTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyNamesByBranchAndType, arg.IsBranch, arg.CompanyType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyNamesByBranchAndTypeRow
	for rows.Next() {
		var i GetAllCompanyNamesByBranchAndTypeRow
		if err := rows.Scan(&i.ID, &i.CompanyName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSocialByUser = `-- name: GetAllSocialByUser :many
SELECT id, social_media_name, social_media_url, entity_type_id, entity_id FROM social_media_profile
WHERE social_media_profile.entity_type_id = 9 AND social_media_profile.entity_id = $1
`

func (q *Queries) GetAllSocialByUser(ctx context.Context, userID int64) ([]SocialMediaProfile, error) {
	rows, err := q.db.Query(ctx, getAllSocialByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SocialMediaProfile
	for rows.Next() {
		var i SocialMediaProfile
		if err := rows.Scan(
			&i.ID,
			&i.SocialMediaName,
			&i.SocialMediaUrl,
			&i.EntityTypeID,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBranchCompanyNamesByParentCompany = `-- name: GetBranchCompanyNamesByParentCompany :many
SELECT companies.id, company_name
FROM companies
WHERE company_parent_id = $1
`

type GetBranchCompanyNamesByParentCompanyRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
}

func (q *Queries) GetBranchCompanyNamesByParentCompany(ctx context.Context, companyParentID pgtype.Int8) ([]GetBranchCompanyNamesByParentCompanyRow, error) {
	rows, err := q.db.Query(ctx, getBranchCompanyNamesByParentCompany, companyParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBranchCompanyNamesByParentCompanyRow
	for rows.Next() {
		var i GetBranchCompanyNamesByParentCompanyRow
		if err := rows.Scan(&i.ID, &i.CompanyName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBrnLicenseByUserID = `-- name: GetBrnLicenseByUserID :one
SELECT id, license_file_url, license_no, license_issue_date, license_registration_date, license_expiry_date, license_type_id, state_id, entity_type_id, entity_id, metadata FROM license 
WHERE license.license_type_id = 5 AND license.entity_type_id = 9 AND license.entity_id = $1
`

func (q *Queries) GetBrnLicenseByUserID(ctx context.Context, userID int64) (License, error) {
	row := q.db.QueryRow(ctx, getBrnLicenseByUserID, userID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.LicenseFileUrl,
		&i.LicenseNo,
		&i.LicenseIssueDate,
		&i.LicenseRegistrationDate,
		&i.LicenseExpiryDate,
		&i.LicenseTypeID,
		&i.StateID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Metadata,
	)
	return i, err
}

const getCompanies = `-- name: GetCompanies :one



SELECT id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url FROM companies
WHERE id = $1
`

// -- name: CheckCompanyByName :one
// SELECT companies.id FROM companies
// WHERE company_name ILIKE $1;
// -- name: CreateCompaniesService :one
// INSERT INTO companies_services (
//
//	companies_id,
//	services_id,
//	created_at,
//	updated_at
//
// )VALUES (
//
//	$1, $2, $3, $4
//
// ) RETURNING *;
// -- name: CheckParentCompanyExists :one
// SELECT id FROM companies
// WHERE id = $1;
func (q *Queries) GetCompanies(ctx context.Context, id int64) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanies, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const getCompaniesByStatus = `-- name: GetCompaniesByStatus :many
SELECT 
 c.id, c.company_name, c.company_type, c.logo_url, c.email, c.phone_number, c.status, c.company_rank, c.addresses_id, c.users_id,
 cl.license_no,
 CASE WHEN company_parent_id IS NULL THEN FALSE::boolean ELSE TRUE::boolean END AS is_branch
FROM companies c
 INNER JOIN license cl ON cl.entity_id = c.id AND entity_type_id = $3::bigint AND license_type_id = $4::bigint
 ------ 
 INNER JOIN addresses ON c.addresses_id = addresses.id
 INNER JOIN countries ON addresses.countries_id = countries.id
 INNER JOIN states ON addresses.states_id = states.id
 INNER JOIN cities ON addresses.cities_id = cities.id 
 INNER JOIN users ON c.created_by = users.id 
 INNER JOIN users as admin ON c.users_id = admin.id
 INNER JOIN profiles ON admin.profiles_id = profiles.id
 LEFT JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
WHERE 
    (
       $5 = '%%'
       OR c.company_name ILIKE $5
       OR (CASE 
        WHEN 'standard' ILIKE $5 THEN c.company_rank = 1
        WHEN 'featured' ILIKE $5 THEN c.company_rank = 2 
        WHEN 'premium'  ILIKE $5 THEN c.company_rank = 3
        WHEN 'top deal' ILIKE $5 THEN c.company_rank = 4
        ELSE FALSE
      END)
      OR cl.license_no ILIKE $5
      OR countries.country ILIKE $5
      OR states.state ILIKE $5
      OR cities.city ILIKE $5      
      OR roles."role" ILIKE $5
      OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $5
      OR c.email ILIKE $5
      OR c.phone_number ILIKE $5
    )
    AND
 	CASE WHEN $6 != true THEN true ELSE c.id = $7::bigint AND c.company_type =   $8::bigint END
   AND CASE WHEN $9::bigint = 0 THEN true ELSE addresses.countries_id = $9::bigint END
   AND CASE WHEN $10::bigint = 0 Then true ELSE addresses.cities_id = $10::bigint END
   AND CASE WHEN $11::bigint = 0 THEN true ELSE addresses.communities_id = $11::bigint END
   AND CASE WHEN $12::bigint = 0 THEN true ELSE addresses.sub_communities_id = $12::bigint  END
   AND  c.status = $13
ORDER BY id  LIMIT $1 OFFSET $2
`

type GetCompaniesByStatusParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	EntityTypeID   int64       `json:"entity_type_id"`
	LicenseTypeID  int64       `json:"license_type_id"`
	Search         interface{} `json:"search"`
	IsCompanyUser  interface{} `json:"is_company_user"`
	CompanyID      int64       `json:"company_id"`
	CompanyType    int64       `json:"company_type"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
	Status         int64       `json:"status"`
}

type GetCompaniesByStatusRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
	CompanyType int64  `json:"company_type"`
	LogoUrl     string `json:"logo_url"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phone_number"`
	Status      int64  `json:"status"`
	CompanyRank int64  `json:"company_rank"`
	AddressesID int64  `json:"addresses_id"`
	UsersID     int64  `json:"users_id"`
	LicenseNo   string `json:"license_no"`
	IsBranch    bool   `json:"is_branch"`
}

func (q *Queries) GetCompaniesByStatus(ctx context.Context, arg GetCompaniesByStatusParams) ([]GetCompaniesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getCompaniesByStatus,
		arg.Limit,
		arg.Offset,
		arg.EntityTypeID,
		arg.LicenseTypeID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyID,
		arg.CompanyType,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompaniesByStatusRow
	for rows.Next() {
		var i GetCompaniesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.CompanyType,
			&i.LogoUrl,
			&i.Email,
			&i.PhoneNumber,
			&i.Status,
			&i.CompanyRank,
			&i.AddressesID,
			&i.UsersID,
			&i.LicenseNo,
			&i.IsBranch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompaniesCountByActivity = `-- name: GetCompaniesCountByActivity :one




 
SELECT COUNT(*) FROM companies 
WHERE $1::BIGINT=any(company_activities_id)
`

// AND CASE WHEN @status::bigint = 0 THEN c.company_parent_id IS NULL ELSE true END;
func (q *Queries) GetCompaniesCountByActivity(ctx context.Context, dollar_1 int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCompaniesCountByActivity, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCompaniesLeadership = `-- name: GetCompaniesLeadership :one
SELECT id, name, position, description_ar, description, image_url, is_verified, companies_id, created_by, created_at, updated_at FROM companies_leadership 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCompaniesLeadership(ctx context.Context, id int64) (CompaniesLeadership, error) {
	row := q.db.QueryRow(ctx, getCompaniesLeadership, id)
	var i CompaniesLeadership
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Position,
		&i.DescriptionAr,
		&i.Description,
		&i.ImageUrl,
		&i.IsVerified,
		&i.CompaniesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyById = `-- name: GetCompanyById :one
SELECT companies.id, companies.ref_no, companies.company_name, companies.company_activities_id, companies.company_parent_id, companies.tag_line, companies.description, companies.description_ar, companies.logo_url, companies.email, companies.phone_number, companies.whatsapp_number, companies.is_verified, companies.website_url, companies.cover_image_url, companies.no_of_employees, companies.company_rank, companies.status, companies.company_type, companies.addresses_id, companies.users_id, companies.created_by, companies.created_at, companies.updated_at, companies.updated_by, companies.location_url, companies.vat_no, companies.vat_status, companies.vat_file_url, COALESCE(parent.company_name, '') AS company_parent_name  FROM companies
LEFT JOIN companies parent ON parent.id = companies.company_parent_id
WHERE companies.id = $1
`

type GetCompanyByIdRow struct {
	ID                  int64       `json:"id"`
	RefNo               string      `json:"ref_no"`
	CompanyName         string      `json:"company_name"`
	CompanyActivitiesID []int64     `json:"company_activities_id"`
	CompanyParentID     pgtype.Int8 `json:"company_parent_id"`
	TagLine             pgtype.Text `json:"tag_line"`
	Description         string      `json:"description"`
	DescriptionAr       pgtype.Text `json:"description_ar"`
	LogoUrl             string      `json:"logo_url"`
	Email               string      `json:"email"`
	PhoneNumber         string      `json:"phone_number"`
	WhatsappNumber      pgtype.Text `json:"whatsapp_number"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	WebsiteUrl          pgtype.Text `json:"website_url"`
	CoverImageUrl       string      `json:"cover_image_url"`
	NoOfEmployees       pgtype.Int8 `json:"no_of_employees"`
	CompanyRank         int64       `json:"company_rank"`
	Status              int64       `json:"status"`
	CompanyType         int64       `json:"company_type"`
	AddressesID         int64       `json:"addresses_id"`
	UsersID             int64       `json:"users_id"`
	CreatedBy           int64       `json:"created_by"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	UpdatedBy           pgtype.Int8 `json:"updated_by"`
	LocationUrl         pgtype.Text `json:"location_url"`
	VatNo               pgtype.Text `json:"vat_no"`
	VatStatus           pgtype.Int8 `json:"vat_status"`
	VatFileUrl          pgtype.Text `json:"vat_file_url"`
	CompanyParentName   string      `json:"company_parent_name"`
}

func (q *Queries) GetCompanyById(ctx context.Context, id int64) (GetCompanyByIdRow, error) {
	row := q.db.QueryRow(ctx, getCompanyById, id)
	var i GetCompanyByIdRow
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
		&i.CompanyParentName,
	)
	return i, err
}

const getCompanyDocs = `-- name: GetCompanyDocs :many
SELECT 
     license.id, license.license_file_url, license.license_no, license.license_issue_date, license.license_registration_date, license.license_expiry_date, license.license_type_id, license.state_id, license.entity_type_id, license.entity_id, license.metadata,logo_url,cover_image_url,vat_no,vat_status,vat_file_url, 
    COALESCE(
         NULLIF(JSON_AGG(ROW_TO_JSON(state_license_fields))::text, '[null]'), NULL
    )::jsonb AS state_license_fields
FROM license 
INNER JOIN companies ON companies.id = entity_id AND entity_type_id = 6
LEFT JOIN 
    state_license_fields 
    ON state_license_fields.license_id = license.id
WHERE companies.id = $1::bigint
GROUP BY 
    license.id,logo_url,cover_image_url,vat_no,vat_status,vat_file_url
`

type GetCompanyDocsRow struct {
	ID                      int64              `json:"id"`
	LicenseFileUrl          pgtype.Text        `json:"license_file_url"`
	LicenseNo               string             `json:"license_no"`
	LicenseIssueDate        pgtype.Timestamptz `json:"license_issue_date"`
	LicenseRegistrationDate pgtype.Timestamptz `json:"license_registration_date"`
	LicenseExpiryDate       pgtype.Timestamptz `json:"license_expiry_date"`
	LicenseTypeID           int64              `json:"license_type_id"`
	StateID                 int64              `json:"state_id"`
	EntityTypeID            int64              `json:"entity_type_id"`
	EntityID                int64              `json:"entity_id"`
	Metadata                []byte             `json:"metadata"`
	LogoUrl                 string             `json:"logo_url"`
	CoverImageUrl           string             `json:"cover_image_url"`
	VatNo                   pgtype.Text        `json:"vat_no"`
	VatStatus               pgtype.Int8        `json:"vat_status"`
	VatFileUrl              pgtype.Text        `json:"vat_file_url"`
	StateLicenseFields      []byte             `json:"state_license_fields"`
}

// SELECT
//
//	logo_url,
//	cover_image_url,
//	commercial_license_no,
//	commercial_license_file_url,
//	commercial_license_issue_date,
//	commercial_license_expiry,
//	commercial_license_registration_date,
//	rera_no,
//	rera_file_url,
//	rera_issue_date,
//	rera_expiry,
//	rera_registration_date,
//	vat_no,
//	vat_status,
//	vat_file_url,
//	orn_license_no,
//	orn_license_file_url,
//	orn_registration_date,
//	orn_license_expiry,
//	trakhees_permit_no,
//	license_dcci_no,
//	register_no,
//	extra_license,
//	company_id
//
// FROM companies_licenses
// INNER JOIN companies ON companies.id = companies_licenses.company_id
// WHERE companies.id = $1 LIMIT 1;
func (q *Queries) GetCompanyDocs(ctx context.Context, companyID int64) ([]GetCompanyDocsRow, error) {
	rows, err := q.db.Query(ctx, getCompanyDocs, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyDocsRow
	for rows.Next() {
		var i GetCompanyDocsRow
		if err := rows.Scan(
			&i.ID,
			&i.LicenseFileUrl,
			&i.LicenseNo,
			&i.LicenseIssueDate,
			&i.LicenseRegistrationDate,
			&i.LicenseExpiryDate,
			&i.LicenseTypeID,
			&i.StateID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Metadata,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
			&i.StateLicenseFields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllCompanies = `-- name: GetCountAllCompanies :one
SELECT COUNT(c.*)
FROM companies as c
 INNER JOIN addresses ON c.addresses_id = addresses.id
 INNER JOIN countries ON addresses.countries_id = countries.id
 INNER JOIN states ON addresses.states_id = states.id
 INNER JOIN cities ON addresses.cities_id = cities.id 
    LEFT JOIN communities ON addresses.communities_id = communities.id
 LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id

 INNER JOIN users ON c.created_by = users.id 
 INNER JOIN users as admin ON c.users_id = admin.id
 INNER JOIN profiles ON admin.id = profiles.users_id
 LEFT  JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
 INNER JOIN license cl ON cl.entity_id = c.id AND entity_type_id = $1::bigint AND license_type_id = $2::bigint
WHERE
    (
       $3 = '%%'
       OR c.company_name ILIKE $3
       OR (CASE 
        WHEN 'standard' ILIKE $3 THEN c.company_rank = 1
        WHEN 'featured' ILIKE $3 THEN c.company_rank = 2 
        WHEN 'premium'  ILIKE $3 THEN c.company_rank = 3
        WHEN 'top deal' ILIKE $3 THEN c.company_rank = 4
        ELSE FALSE
      END)
      OR cl.license_no ILIKE $3
      OR countries.country ILIKE $3
      OR states.state ILIKE $3
      OR cities.city ILIKE $3  
      OR communities.community ILIKE $3 
      OR sub_communities.sub_community ILIKE $3       
      OR roles."role" ILIKE $3
      OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $3
      OR c.email ILIKE $3
      OR c.phone_number ILIKE $3
    )
    AND
  	CASE WHEN $4 != true THEN true ELSE c.id = $5::bigint AND c.company_type =   $6::bigint END
    AND 
    CASE 
   		WHEN $7::bigint = 0 THEN true 
   		WHEN 'international' = $8::varchar THEN addresses.countries_id != $7::bigint 
  		WHEN 'local' = $8::varchar THEN addresses.countries_id = $7::bigint END
   AND CASE WHEN $9::bigint = 0 Then true ELSE addresses.cities_id = $9::bigint END
   AND CASE WHEN $10::bigint = 0 THEN true ELSE addresses.communities_id = $10::bigint END
   AND CASE WHEN $11::bigint = 0 THEN true ELSE addresses.sub_communities_id = $11::bigint END
   AND CASE WHEN $12::bigint = 0 THEN (c.status != 5 AND c.status != 6) ELSE c.status = $12::bigint END
`

type GetCountAllCompaniesParams struct {
	EntityTypeID   int64       `json:"entity_type_id"`
	LicenseTypeID  int64       `json:"license_type_id"`
	Search         interface{} `json:"search"`
	IsCompanyUser  interface{} `json:"is_company_user"`
	CompanyID      int64       `json:"company_id"`
	CompanyType    int64       `json:"company_type"`
	CountryID      int64       `json:"country_id"`
	Localize       string      `json:"localize"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
	Status         int64       `json:"status"`
}

//	INNER JOIN companies_licenses cl ON cl.company_id = c.id
//	LEFT  JOIN branch_companies ON branch_companies.companies_id = c.id
//
// CASE WHEN @country_id::bigint = 0 THEN true WHEN @is_international::boolean = true THEN addresses.countries_id != @country_id::bigint ELSE addresses.countries_id = @country_id::bigint END
//
//	ELSE '' = @localize::varchar AND addresses.countries_id = @country_id::bigint END
func (q *Queries) GetCountAllCompanies(ctx context.Context, arg GetCountAllCompaniesParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllCompanies,
		arg.EntityTypeID,
		arg.LicenseTypeID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyID,
		arg.CompanyType,
		arg.CountryID,
		arg.Localize,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountCompaniesByStatus = `-- name: GetCountCompaniesByStatus :one

SELECT  COUNT(c.id)
FROM companies c
 INNER JOIN license cl ON cl.entity_id = c.id AND entity_type_id = $1::bigint AND license_type_id = $2::bigint
 ------ 
 INNER JOIN addresses ON c.addresses_id = addresses.id
 INNER JOIN countries ON addresses.countries_id = countries.id
 INNER JOIN states ON addresses.states_id = states.id
 INNER JOIN cities ON addresses.cities_id = cities.id 
 INNER JOIN users ON c.created_by = users.id 
 INNER JOIN users as admin ON c.users_id = admin.id
 INNER JOIN profiles ON admin.profiles_id = profiles.id
 LEFT JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
WHERE 
    (
       $3 = '%%'
       OR c.company_name ILIKE $3
       OR (CASE 
        WHEN 'standard' ILIKE $3 THEN c.company_rank = 1
        WHEN 'featured' ILIKE $3 THEN c.company_rank = 2 
        WHEN 'premium'  ILIKE $3 THEN c.company_rank = 3
        WHEN 'top deal' ILIKE $3 THEN c.company_rank = 4
        ELSE FALSE
      END)
      OR cl.license_no ILIKE $3
      OR countries.country ILIKE $3
      OR states.state ILIKE $3
      OR cities.city ILIKE $3      
      OR roles."role" ILIKE $3
      OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $3
      OR c.email ILIKE $3
      OR c.phone_number ILIKE $3
    )
    AND
 	CASE WHEN $4 != true THEN true ELSE c.id = $5::bigint AND c.company_type =   $6::bigint END
   AND CASE WHEN $7::bigint = 0 THEN true ELSE addresses.countries_id = $7::bigint END
   AND CASE WHEN $8::bigint = 0 Then true ELSE addresses.cities_id = $8::bigint END
   AND CASE WHEN $9::bigint = 0 THEN true ELSE addresses.communities_id = $9::bigint END
   AND CASE WHEN $10::bigint = 0 THEN true ELSE addresses.sub_communities_id = $10::bigint  END
AND  c.status = $11
`

type GetCountCompaniesByStatusParams struct {
	EntityTypeID   int64       `json:"entity_type_id"`
	LicenseTypeID  int64       `json:"license_type_id"`
	Search         interface{} `json:"search"`
	IsCompanyUser  interface{} `json:"is_company_user"`
	CompanyID      int64       `json:"company_id"`
	CompanyType    int64       `json:"company_type"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
	Status         int64       `json:"status"`
}

// SELECT
// companies.id, company_name, company_type, logo_url, email, phone_number, status, company_rank, addresses_id, users_id ,
// companies_licenses.commercial_license_no,
// CASE WHEN branch_companies.id != 0 THEN TRUE::boolean ELSE FALSE::boolean END AS is_branch
// FROM companies
// INNER JOIN companies_licenses ON companies_licenses.id = companies.companies_licenses_id
// LEFT JOIN branch_companies ON branch_companies.companies_id = companies.id
// WHERE  companies.status = $3
// ORDER BY id  LIMIT $1 OFFSET $2;
func (q *Queries) GetCountCompaniesByStatus(ctx context.Context, arg GetCountCompaniesByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountCompaniesByStatus,
		arg.EntityTypeID,
		arg.LicenseTypeID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyID,
		arg.CompanyType,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountSubCompaniesByParent = `-- name: GetCountSubCompaniesByParent :one
SELECT  
	COUNT(c.id)
FROM companies as c
 INNER JOIN addresses ON c.addresses_id = addresses.id
 INNER JOIN countries ON addresses.countries_id = countries.id
 INNER JOIN states ON addresses.states_id = states.id
 INNER JOIN cities ON addresses.cities_id = cities.id 
  LEFT JOIN communities ON addresses.communities_id = communities.id
 LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id

 INNER JOIN users ON c.created_by = users.id 
 INNER JOIN users as admin ON c.users_id = admin.id
 INNER JOIN profiles ON admin.id = profiles.users_id
 LEFT  JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
 INNER JOIN license cl ON cl.entity_id = c.id AND entity_type_id = $1::bigint AND license_type_id = $2::bigint
WHERE
    (
       $3 = '%%'
       OR c.company_name ILIKE $3
       OR (CASE 
        WHEN 'standard' ILIKE $3 THEN c.company_rank = 1
        WHEN 'featured' ILIKE $3 THEN c.company_rank = 2 
        WHEN 'premium'  ILIKE $3 THEN c.company_rank = 3
        WHEN 'top deal' ILIKE $3 THEN c.company_rank = 4
        ELSE FALSE
      END)
      OR cl.license_no ILIKE $3
      OR countries.country ILIKE $3
      OR states.state ILIKE $3
      OR cities.city ILIKE $3    
      OR communities.community ILIKE $3 
      OR sub_communities.sub_community ILIKE $3    
      OR roles."role" ILIKE $3
      OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $3
      OR c.email ILIKE $3
      OR c.phone_number ILIKE $3
    )
    AND
  	CASE WHEN $4 != true THEN true ELSE c.id = $5::bigint AND c.company_type =   $6::bigint END
   AND CASE WHEN $7::bigint = 0 THEN true  ELSE addresses.countries_id = $7::bigint END
   AND CASE WHEN $8::bigint = 0 Then true ELSE addresses.cities_id = $8::bigint END
   AND CASE WHEN $9::bigint = 0 THEN true ELSE addresses.communities_id = $9::bigint END
   AND CASE WHEN $10::bigint = 0 THEN true ELSE addresses.sub_communities_id = $10::bigint END
   AND (c.status !=5 AND c.status != 6)  
   AND c.company_parent_id = $11::bigint
`

type GetCountSubCompaniesByParentParams struct {
	EntityTypeID    int64       `json:"entity_type_id"`
	LicenseTypeID   int64       `json:"license_type_id"`
	Search          interface{} `json:"search"`
	IsCompanyUser   interface{} `json:"is_company_user"`
	CompanyID       int64       `json:"company_id"`
	CompanyType     int64       `json:"company_type"`
	CountryID       int64       `json:"country_id"`
	CityID          int64       `json:"city_id"`
	CommunityID     int64       `json:"community_id"`
	SubCommunityID  int64       `json:"sub_community_id"`
	ParentCompanyID int64       `json:"parent_company_id"`
}

func (q *Queries) GetCountSubCompaniesByParent(ctx context.Context, arg GetCountSubCompaniesByParentParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountSubCompaniesByParent,
		arg.EntityTypeID,
		arg.LicenseTypeID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyID,
		arg.CompanyType,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.ParentCompanyID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLicensesByEntityAndEntityTypeID = `-- name: GetLicensesByEntityAndEntityTypeID :many
SELECT 
    license.id, license.license_file_url, license.license_no, license.license_issue_date, license.license_registration_date, license.license_expiry_date, license.license_type_id, license.state_id, license.entity_type_id, license.entity_id, license.metadata, 
    JSON_AGG(ROW_TO_JSON(state_license_fields)) AS state_license_fields
FROM 
    license
LEFT JOIN 
    state_license_fields 
    ON state_license_fields.license_id = license.id
WHERE 
    license.entity_type_id = $1 
    AND license.entity_id = $2
GROUP BY 
    license.id
`

type GetLicensesByEntityAndEntityTypeIDParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
}

type GetLicensesByEntityAndEntityTypeIDRow struct {
	ID                      int64              `json:"id"`
	LicenseFileUrl          pgtype.Text        `json:"license_file_url"`
	LicenseNo               string             `json:"license_no"`
	LicenseIssueDate        pgtype.Timestamptz `json:"license_issue_date"`
	LicenseRegistrationDate pgtype.Timestamptz `json:"license_registration_date"`
	LicenseExpiryDate       pgtype.Timestamptz `json:"license_expiry_date"`
	LicenseTypeID           int64              `json:"license_type_id"`
	StateID                 int64              `json:"state_id"`
	EntityTypeID            int64              `json:"entity_type_id"`
	EntityID                int64              `json:"entity_id"`
	Metadata                []byte             `json:"metadata"`
	StateLicenseFields      []byte             `json:"state_license_fields"`
}

func (q *Queries) GetLicensesByEntityAndEntityTypeID(ctx context.Context, arg GetLicensesByEntityAndEntityTypeIDParams) ([]GetLicensesByEntityAndEntityTypeIDRow, error) {
	rows, err := q.db.Query(ctx, getLicensesByEntityAndEntityTypeID, arg.EntityTypeID, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLicensesByEntityAndEntityTypeIDRow
	for rows.Next() {
		var i GetLicensesByEntityAndEntityTypeIDRow
		if err := rows.Scan(
			&i.ID,
			&i.LicenseFileUrl,
			&i.LicenseNo,
			&i.LicenseIssueDate,
			&i.LicenseRegistrationDate,
			&i.LicenseExpiryDate,
			&i.LicenseTypeID,
			&i.StateID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Metadata,
			&i.StateLicenseFields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLicensesByID = `-- name: GetLicensesByID :one
SELECT 
    license.id, license.license_file_url, license.license_no, license.license_issue_date, license.license_registration_date, license.license_expiry_date, license.license_type_id, license.state_id, license.entity_type_id, license.entity_id, license.metadata 
FROM 
    license 
WHERE 
    id = $1
`

func (q *Queries) GetLicensesByID(ctx context.Context, id int64) (License, error) {
	row := q.db.QueryRow(ctx, getLicensesByID, id)
	var i License
	err := row.Scan(
		&i.ID,
		&i.LicenseFileUrl,
		&i.LicenseNo,
		&i.LicenseIssueDate,
		&i.LicenseRegistrationDate,
		&i.LicenseExpiryDate,
		&i.LicenseTypeID,
		&i.StateID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Metadata,
	)
	return i, err
}

const getNocLicenseByUserID = `-- name: GetNocLicenseByUserID :one
SELECT id, license_file_url, license_no, license_issue_date, license_registration_date, license_expiry_date, license_type_id, state_id, entity_type_id, entity_id, metadata FROM license 
WHERE license.license_type_id = 6 AND license.entity_type_id = 9 AND license.entity_id = $1
`

func (q *Queries) GetNocLicenseByUserID(ctx context.Context, userID int64) (License, error) {
	row := q.db.QueryRow(ctx, getNocLicenseByUserID, userID)
	var i License
	err := row.Scan(
		&i.ID,
		&i.LicenseFileUrl,
		&i.LicenseNo,
		&i.LicenseIssueDate,
		&i.LicenseRegistrationDate,
		&i.LicenseExpiryDate,
		&i.LicenseTypeID,
		&i.StateID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Metadata,
	)
	return i, err
}

const getSingleCompanyByUserId = `-- name: GetSingleCompanyByUserId :one
select id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url from companies where users_id = $1
`

func (q *Queries) GetSingleCompanyByUserId(ctx context.Context, usersID int64) (Company, error) {
	row := q.db.QueryRow(ctx, getSingleCompanyByUserId, usersID)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const getSubCompaniesByParent = `-- name: GetSubCompaniesByParent :many
SELECT  
	c.id, c.created_at, c.company_name, c.logo_url, c.email,c.phone_number, c.status, c.company_rank,  c.addresses_id, c.created_by,c.users_id,c.company_type,c.created_at,
	cl.license_no,CONCAT(profiles.first_name,' ',profiles.last_name)::varchar AS admin_name,addresses.full_address ,roles.role AS added_by_role
    -- , cl.orn_license_no, cl.orn_license_file_url, cl.orn_registration_date, cl.orn_license_expiry
FROM companies as c
 INNER JOIN addresses ON c.addresses_id = addresses.id
 INNER JOIN countries ON addresses.countries_id = countries.id
 INNER JOIN states ON addresses.states_id = states.id
 INNER JOIN cities ON addresses.cities_id = cities.id 
  LEFT JOIN communities ON addresses.communities_id = communities.id
 LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id

 INNER JOIN users ON c.created_by = users.id 
 INNER JOIN users as admin ON c.users_id = admin.id
 INNER JOIN profiles ON admin.id = profiles.users_id
 LEFT  JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
 INNER JOIN license cl ON cl.entity_id = c.id AND entity_type_id = $3::bigint AND license_type_id = $4::bigint
WHERE
    (
       $5 = '%%'
       OR c.company_name ILIKE $5
       OR (CASE 
        WHEN 'standard' ILIKE $5 THEN c.company_rank = 1
        WHEN 'featured' ILIKE $5 THEN c.company_rank = 2 
        WHEN 'premium'  ILIKE $5 THEN c.company_rank = 3
        WHEN 'top deal' ILIKE $5 THEN c.company_rank = 4
        ELSE FALSE
      END)
      OR cl.license_no ILIKE $5
      OR countries.country ILIKE $5
      OR states.state ILIKE $5
      OR cities.city ILIKE $5    
      OR communities.community ILIKE $5 
      OR sub_communities.sub_community ILIKE $5    
      OR roles."role" ILIKE $5
      OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $5
      OR c.email ILIKE $5
      OR c.phone_number ILIKE $5
    )
    AND
  	CASE WHEN $6 != true THEN true ELSE c.id = $7::bigint AND c.company_type =   $8::bigint END
   AND CASE WHEN $9::bigint = 0 THEN true  ELSE addresses.countries_id = $9::bigint END
   AND CASE WHEN $10::bigint = 0 Then true ELSE addresses.cities_id = $10::bigint END
   AND CASE WHEN $11::bigint = 0 THEN true ELSE addresses.communities_id = $11::bigint END
   AND CASE WHEN $12::bigint = 0 THEN true ELSE addresses.sub_communities_id = $12::bigint END
   AND (c.status !=5 AND c.status != 6)  
   AND c.company_parent_id = $13::bigint
ORDER BY created_at DESC  LIMIT $1 OFFSET $2
`

type GetSubCompaniesByParentParams struct {
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
	EntityTypeID    int64       `json:"entity_type_id"`
	LicenseTypeID   int64       `json:"license_type_id"`
	Search          interface{} `json:"search"`
	IsCompanyUser   interface{} `json:"is_company_user"`
	CompanyID       int64       `json:"company_id"`
	CompanyType     int64       `json:"company_type"`
	CountryID       int64       `json:"country_id"`
	CityID          int64       `json:"city_id"`
	CommunityID     int64       `json:"community_id"`
	SubCommunityID  int64       `json:"sub_community_id"`
	ParentCompanyID int64       `json:"parent_company_id"`
}

type GetSubCompaniesByParentRow struct {
	ID          int64       `json:"id"`
	CreatedAt   time.Time   `json:"created_at"`
	CompanyName string      `json:"company_name"`
	LogoUrl     string      `json:"logo_url"`
	Email       string      `json:"email"`
	PhoneNumber string      `json:"phone_number"`
	Status      int64       `json:"status"`
	CompanyRank int64       `json:"company_rank"`
	AddressesID int64       `json:"addresses_id"`
	CreatedBy   int64       `json:"created_by"`
	UsersID     int64       `json:"users_id"`
	CompanyType int64       `json:"company_type"`
	CreatedAt_2 time.Time   `json:"created_at_2"`
	LicenseNo   string      `json:"license_no"`
	AdminName   string      `json:"admin_name"`
	FullAddress pgtype.Text `json:"full_address"`
	AddedByRole pgtype.Text `json:"added_by_role"`
}

func (q *Queries) GetSubCompaniesByParent(ctx context.Context, arg GetSubCompaniesByParentParams) ([]GetSubCompaniesByParentRow, error) {
	rows, err := q.db.Query(ctx, getSubCompaniesByParent,
		arg.Limit,
		arg.Offset,
		arg.EntityTypeID,
		arg.LicenseTypeID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyID,
		arg.CompanyType,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.ParentCompanyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubCompaniesByParentRow
	for rows.Next() {
		var i GetSubCompaniesByParentRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.CompanyName,
			&i.LogoUrl,
			&i.Email,
			&i.PhoneNumber,
			&i.Status,
			&i.CompanyRank,
			&i.AddressesID,
			&i.CreatedBy,
			&i.UsersID,
			&i.CompanyType,
			&i.CreatedAt_2,
			&i.LicenseNo,
			&i.AdminName,
			&i.FullAddress,
			&i.AddedByRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLicenseByID = `-- name: GetUserLicenseByID :one
SELECT 
    license.id, license.license_file_url, license.license_no, license.license_issue_date, license.license_registration_date, license.license_expiry_date, license.license_type_id, license.state_id, license.entity_type_id, license.entity_id, license.metadata 
FROM 
    license 
WHERE 
    id = $1 AND entity_type_id = 9
`

func (q *Queries) GetUserLicenseByID(ctx context.Context, id int64) (License, error) {
	row := q.db.QueryRow(ctx, getUserLicenseByID, id)
	var i License
	err := row.Scan(
		&i.ID,
		&i.LicenseFileUrl,
		&i.LicenseNo,
		&i.LicenseIssueDate,
		&i.LicenseRegistrationDate,
		&i.LicenseExpiryDate,
		&i.LicenseTypeID,
		&i.StateID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Metadata,
	)
	return i, err
}

const rejectCompanies = `-- name: RejectCompanies :one
Update companies 
SET status  = $2
Where id = $1
RETURNING id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url
`

type RejectCompaniesParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

func (q *Queries) RejectCompanies(ctx context.Context, arg RejectCompaniesParams) (Company, error) {
	row := q.db.QueryRow(ctx, rejectCompanies, arg.ID, arg.Status)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const updateCompanies = `-- name: UpdateCompanies :one

UPDATE companies
SET company_name = $2,
    tag_line = $3,
    description = $4,
    logo_url = $5,
    email = $6,
    phone_number = $7,
    whatsapp_number = $8,
    website_url = $9,
    cover_image_url = $10,
    no_of_employees = $11,
    updated_at = $12,
    description_ar = $13,
    company_activities_id = $14,
    updated_by = $15,
    location_url = $16,
    vat_no = $17,
    vat_status = $18,
    vat_file_url = $19
WHERE id = $1
RETURNING id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url
`

type UpdateCompaniesParams struct {
	ID                  int64       `json:"id"`
	CompanyName         string      `json:"company_name"`
	TagLine             pgtype.Text `json:"tag_line"`
	Description         string      `json:"description"`
	LogoUrl             string      `json:"logo_url"`
	Email               string      `json:"email"`
	PhoneNumber         string      `json:"phone_number"`
	WhatsappNumber      pgtype.Text `json:"whatsapp_number"`
	WebsiteUrl          pgtype.Text `json:"website_url"`
	CoverImageUrl       string      `json:"cover_image_url"`
	NoOfEmployees       pgtype.Int8 `json:"no_of_employees"`
	UpdatedAt           time.Time   `json:"updated_at"`
	DescriptionAr       pgtype.Text `json:"description_ar"`
	CompanyActivitiesID []int64     `json:"company_activities_id"`
	UpdatedBy           pgtype.Int8 `json:"updated_by"`
	LocationUrl         pgtype.Text `json:"location_url"`
	VatNo               pgtype.Text `json:"vat_no"`
	VatStatus           pgtype.Int8 `json:"vat_status"`
	VatFileUrl          pgtype.Text `json:"vat_file_url"`
}

// -- name: GetCompaniesLicenses :one
// SELECT * FROM companies_licenses WHERE id = $1 LIMIT 1;
func (q *Queries) UpdateCompanies(ctx context.Context, arg UpdateCompaniesParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompanies,
		arg.ID,
		arg.CompanyName,
		arg.TagLine,
		arg.Description,
		arg.LogoUrl,
		arg.Email,
		arg.PhoneNumber,
		arg.WhatsappNumber,
		arg.WebsiteUrl,
		arg.CoverImageUrl,
		arg.NoOfEmployees,
		arg.UpdatedAt,
		arg.DescriptionAr,
		arg.CompanyActivitiesID,
		arg.UpdatedBy,
		arg.LocationUrl,
		arg.VatNo,
		arg.VatStatus,
		arg.VatFileUrl,
	)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const updateCompaniesLeadership = `-- name: UpdateCompaniesLeadership :one
UPDATE companies_leadership
SET    name = $2,
    position = $3,
    description = $4,
    description_ar = $5,
    image_url = $6,
    updated_at = $7
Where id = $1
RETURNING id, name, position, description_ar, description, image_url, is_verified, companies_id, created_by, created_at, updated_at
`

type UpdateCompaniesLeadershipParams struct {
	ID            int64       `json:"id"`
	Name          string      `json:"name"`
	Position      string      `json:"position"`
	Description   string      `json:"description"`
	DescriptionAr pgtype.Text `json:"description_ar"`
	ImageUrl      string      `json:"image_url"`
	UpdatedAt     time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateCompaniesLeadership(ctx context.Context, arg UpdateCompaniesLeadershipParams) (CompaniesLeadership, error) {
	row := q.db.QueryRow(ctx, updateCompaniesLeadership,
		arg.ID,
		arg.Name,
		arg.Position,
		arg.Description,
		arg.DescriptionAr,
		arg.ImageUrl,
		arg.UpdatedAt,
	)
	var i CompaniesLeadership
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Position,
		&i.DescriptionAr,
		&i.Description,
		&i.ImageUrl,
		&i.IsVerified,
		&i.CompaniesID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCompaniesLogoAndCoverImage = `-- name: UpdateCompaniesLogoAndCoverImage :one
UPDATE companies
SET logo_url = $2,
    cover_image_url = $3,
    updated_at = $4
WHERE id = $1
RETURNING id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url
`

type UpdateCompaniesLogoAndCoverImageParams struct {
	ID            int64     `json:"id"`
	LogoUrl       string    `json:"logo_url"`
	CoverImageUrl string    `json:"cover_image_url"`
	UpdatedAt     time.Time `json:"updated_at"`
}

func (q *Queries) UpdateCompaniesLogoAndCoverImage(ctx context.Context, arg UpdateCompaniesLogoAndCoverImageParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompaniesLogoAndCoverImage,
		arg.ID,
		arg.LogoUrl,
		arg.CoverImageUrl,
		arg.UpdatedAt,
	)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const updateCompaniesRank = `-- name: UpdateCompaniesRank :one
UPDATE companies 
SET company_rank = $2 
Where id = $1 
RETURNING id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url
`

type UpdateCompaniesRankParams struct {
	ID          int64 `json:"id"`
	CompanyRank int64 `json:"company_rank"`
}

func (q *Queries) UpdateCompaniesRank(ctx context.Context, arg UpdateCompaniesRankParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompaniesRank, arg.ID, arg.CompanyRank)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const updateCompaniesStatus = `-- name: UpdateCompaniesStatus :one









UPDATE companies 
SET status = $2
WHERE id = $1 
RETURNING id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url
`

type UpdateCompaniesStatusParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

// -- name: DeleteAllCompanyServicesByCompanyId :exec
// DELETE FROM companies_services
// WHERE companies_id = $1;
// -- name: GetLocalCompanies :many
// SELECT
//
//	c.id, c.created_at, c.company_name, c.logo_url, c.email,c.phone_number, c.status, c.company_rank,  c.addresses_id, c.created_by,c.users_id,c.company_type,
//	cl.commercial_license_no, cl.orn_license_no, cl.orn_license_file_url, cl.orn_registration_date, cl.orn_license_expiry
//
// FROM companies as c
//
//	INNER JOIN addresses ON c.addresses_id = addresses.id
//	INNER JOIN countries ON addresses.countries_id = countries.id
//	INNER JOIN states ON addresses.states_id = states.id
//	INNER JOIN cities ON addresses.cities_id = cities.id
//	INNER JOIN users ON c.created_by = users.id
//	INNER JOIN users as admin ON c.users_id = admin.id
//	INNER JOIN profiles ON admin.profiles_id = profiles.id
//	LEFT  JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
//	INNER JOIN companies_licenses cl ON cl.company_id = c.id
//
// --  LEFT  JOIN branch_companies ON branch_companies.companies_id = c.id
// WHERE
//
//	  (
//	     @search = '%%'
//	     OR c.company_name ILIKE @search
//	     OR (CASE
//	      WHEN 'standard' ILIKE @search THEN c.company_rank = 1
//	      WHEN 'featured' ILIKE @search THEN c.company_rank = 2
//	      WHEN 'premium'  ILIKE @search THEN c.company_rank = 3
//	      WHEN 'top deal' ILIKE @search THEN c.company_rank = 4
//	      ELSE FALSE
//	    END)
//	    OR cl.commercial_license_no ILIKE @search
//	    OR countries.country ILIKE @search
//	    OR states.state ILIKE @search
//	    OR cities.city ILIKE @search
//	    OR roles."role" ILIKE @search
//	    OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE @search
//	    OR c.email ILIKE @search
//	    OR c.phone_number ILIKE @search
//	  )
//	  AND
//		CASE WHEN @is_company_user != true THEN true ELSE c.id = @company_id::bigint AND c.company_type =   @company_type::bigint END
//	 AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id = @country_id::bigint END
//	 AND CASE WHEN @city_id::bigint = 0 Then true ELSE addresses.cities_id = @city_id::bigint END
//	 AND CASE WHEN @community_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
//	 AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint END
//	 AND (c.status !=5 AND c.status != 6)
//	 AND companies.company_parent_id IS NULL
//
// ORDER BY created_at DESC  LIMIT $1 OFFSET $2;
// -- name: GetCountLocalCompanies :one
// SELECT  COUNT(c.*)
// FROM companies as c
//
//	INNER JOIN addresses ON c.addresses_id = addresses.id
//	INNER JOIN countries ON addresses.countries_id = countries.id
//	INNER JOIN states ON addresses.states_id = states.id
//	INNER JOIN cities ON addresses.cities_id = cities.id
//	INNER JOIN users ON c.created_by = users.id
//	INNER JOIN users as admin ON c.users_id = admin.id
//	INNER JOIN profiles ON admin.profiles_id = profiles.id
//	LEFT JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
//	INNER JOIN companies_licenses cl ON cl.company_id = c.id
//
// WHERE
//
//	   (
//	      @search = '%%'
//	      OR c.company_name ILIKE @search
//	      OR (CASE
//	       WHEN 'standard' ILIKE @search THEN c.company_rank = 1
//	       WHEN 'featured' ILIKE @search THEN c.company_rank = 2
//	       WHEN 'premium'  ILIKE @search THEN c.company_rank = 3
//	       WHEN 'top deal' ILIKE @search THEN c.company_rank = 4
//	       ELSE FALSE
//	     END)
//	     OR cl.commercial_license_no ILIKE @search
//	     OR countries.country ILIKE @search
//	     OR states.state ILIKE @search
//	     OR cities.city ILIKE @search
//	     OR roles."role" ILIKE @search
//	     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE @search
//	     OR c.email ILIKE @search
//	     OR c.phone_number ILIKE @search
//	   )
//	   AND
//		CASE WHEN @is_company_user != true THEN true ELSE c.id = @company_id::bigint AND c.company_type =   @company_type::bigint END
//	  AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id = @country_id::bigint END
//	  AND CASE WHEN @city_id::bigint = 0 Then true ELSE addresses.cities_id = @city_id::bigint END
//	  AND CASE WHEN @community_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
//	  AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint  END
//		AND (c.status !=5 AND c.status != 6)
//
// AND companies.company_parent_id IS NULL;
// -- name: GetInternationalCompanies :many
// SELECT
//
//	c.id, c.created_at, c.company_name, c.logo_url, c.email,c.phone_number, c.status, c.company_rank,  c.addresses_id, c.created_by,c.users_id,c.company_type,
//	cl.commercial_license_no, cl.orn_license_no, cl.orn_license_file_url, cl.orn_registration_date, cl.orn_license_expiry
//
// FROM companies as c
//
//	INNER JOIN addresses ON c.addresses_id = addresses.id
//	INNER JOIN countries ON addresses.countries_id = countries.id
//	INNER JOIN states ON addresses.states_id = states.id
//	INNER JOIN cities ON addresses.cities_id = cities.id
//	INNER JOIN users ON c.created_by = users.id
//	INNER JOIN users as admin ON c.users_id = admin.id
//	INNER JOIN profiles ON admin.profiles_id = profiles.id
//	LEFT JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
//	INNER JOIN companies_licenses cl ON cl.company_id = c.id
//
// WHERE
//
//	   (
//	      @search = '%%'
//	      OR c.company_name ILIKE @search
//	      OR (CASE
//	       WHEN 'standard' ILIKE @search THEN c.company_rank = 1
//	       WHEN 'featured' ILIKE @search THEN c.company_rank = 2
//	       WHEN 'premium'  ILIKE @search THEN c.company_rank = 3
//	       WHEN 'top deal' ILIKE @search THEN c.company_rank = 4
//	       ELSE FALSE
//	     END)
//	     OR cl.commercial_license_no ILIKE @search
//	     OR countries.country ILIKE @search
//	     OR states.state ILIKE @search
//	     OR cities.city ILIKE @search
//	     OR roles."role" ILIKE @search
//	     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE @search
//	     OR c.email ILIKE @search
//	     OR c.phone_number ILIKE @search
//	   )
//	   AND
//		CASE WHEN @is_company_user != true THEN true ELSE c.id = @company_id::bigint AND c.company_type =   @company_type::bigint END
//	  AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id != @country_id::bigint END
//	  AND CASE WHEN @city_id::bigint = 0 Then true ELSE addresses.cities_id = @city_id::bigint END
//	  AND CASE WHEN @community_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
//	  AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint  END
//		AND (c.status !=5 AND c.status != 6)
//	    AND companies.company_parent_id IS NULL
//
// ORDER BY created_at DESC  LIMIT $1 OFFSET $2;
// -- name: GetCountInternationalCompanies :one
// SELECT  COUNT(c.*)
// FROM companies as c
//
//	INNER JOIN addresses ON c.addresses_id = addresses.id
//	INNER JOIN countries ON addresses.countries_id = countries.id
//	INNER JOIN states ON addresses.states_id = states.id
//	INNER JOIN cities ON addresses.cities_id = cities.id
//	INNER JOIN users ON c.created_by = users.id
//	INNER JOIN users as admin ON c.users_id = admin.id
//	INNER JOIN profiles ON admin.profiles_id = profiles.id
//	LEFT JOIN roles ON users.roles_id =  roles.id AND users.roles_id IS NOT NULL
//	INNER JOIN companies_licenses cl ON cl.company_id = c.id
//
// WHERE
//
//	   (
//	      @search = '%%'
//	      OR c.company_name ILIKE @search
//	      OR (CASE
//	       WHEN 'standard' ILIKE @search THEN c.company_rank = 1
//	       WHEN 'featured' ILIKE @search THEN c.company_rank = 2
//	       WHEN 'premium'  ILIKE @search THEN c.company_rank = 3
//	       WHEN 'top deal' ILIKE @search THEN c.company_rank = 4
//	       ELSE FALSE
//	     END)
//	     OR cl.commercial_license_no ILIKE @search
//	     OR countries.country ILIKE @search
//	     OR states.state ILIKE @search
//	     OR cities.city ILIKE @search
//	     OR roles."role" ILIKE @search
//	     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE @search
//	     OR c.email ILIKE @search
//	     OR c.phone_number ILIKE @search
//	   )
//	   AND
//		CASE WHEN @is_company_user != true THEN true ELSE c.id = @company_id::bigint AND c.company_type =   @company_type::bigint END
//	  AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id != @country_id::bigint END
//	  AND CASE WHEN @city_id::bigint = 0 Then true ELSE addresses.cities_id = @city_id::bigint END
//	  AND CASE WHEN @community_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
//	  AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint  END
//		AND (c.status !=5 AND c.status != 6)
//
// AND companies.company_parent_id IS NULL;
func (q *Queries) UpdateCompaniesStatus(ctx context.Context, arg UpdateCompaniesStatusParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompaniesStatus, arg.ID, arg.Status)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const updateLicense = `-- name: UpdateLicense :one
UPDATE license
SET license_file_url = $2,
    license_no = $3,
    license_issue_date = $4,
    license_registration_date = $5,
    license_expiry_date = $6,
    state_id = $7,
    metadata = $8
WHERE id = $1
RETURNING id, license_file_url, license_no, license_issue_date, license_registration_date, license_expiry_date, license_type_id, state_id, entity_type_id, entity_id, metadata
`

type UpdateLicenseParams struct {
	ID                      int64              `json:"id"`
	LicenseFileUrl          pgtype.Text        `json:"license_file_url"`
	LicenseNo               string             `json:"license_no"`
	LicenseIssueDate        pgtype.Timestamptz `json:"license_issue_date"`
	LicenseRegistrationDate pgtype.Timestamptz `json:"license_registration_date"`
	LicenseExpiryDate       pgtype.Timestamptz `json:"license_expiry_date"`
	StateID                 int64              `json:"state_id"`
	Metadata                []byte             `json:"metadata"`
}

func (q *Queries) UpdateLicense(ctx context.Context, arg UpdateLicenseParams) (License, error) {
	row := q.db.QueryRow(ctx, updateLicense,
		arg.ID,
		arg.LicenseFileUrl,
		arg.LicenseNo,
		arg.LicenseIssueDate,
		arg.LicenseRegistrationDate,
		arg.LicenseExpiryDate,
		arg.StateID,
		arg.Metadata,
	)
	var i License
	err := row.Scan(
		&i.ID,
		&i.LicenseFileUrl,
		&i.LicenseNo,
		&i.LicenseIssueDate,
		&i.LicenseRegistrationDate,
		&i.LicenseExpiryDate,
		&i.LicenseTypeID,
		&i.StateID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Metadata,
	)
	return i, err
}

const updateLicenseByEntityID = `-- name: UpdateLicenseByEntityID :one
UPDATE license
SET license_file_url = $2,
    license_no = $3,
    license_issue_date = $4,
    license_registration_date = $5,
    license_expiry_date = $6,
    state_id = $7
WHERE  entity_type_id = 9 AND  entity_id = $1
RETURNING id, license_file_url, license_no, license_issue_date, license_registration_date, license_expiry_date, license_type_id, state_id, entity_type_id, entity_id, metadata
`

type UpdateLicenseByEntityIDParams struct {
	EntityID                int64              `json:"entity_id"`
	LicenseFileUrl          pgtype.Text        `json:"license_file_url"`
	LicenseNo               string             `json:"license_no"`
	LicenseIssueDate        pgtype.Timestamptz `json:"license_issue_date"`
	LicenseRegistrationDate pgtype.Timestamptz `json:"license_registration_date"`
	LicenseExpiryDate       pgtype.Timestamptz `json:"license_expiry_date"`
	StateID                 int64              `json:"state_id"`
}

func (q *Queries) UpdateLicenseByEntityID(ctx context.Context, arg UpdateLicenseByEntityIDParams) (License, error) {
	row := q.db.QueryRow(ctx, updateLicenseByEntityID,
		arg.EntityID,
		arg.LicenseFileUrl,
		arg.LicenseNo,
		arg.LicenseIssueDate,
		arg.LicenseRegistrationDate,
		arg.LicenseExpiryDate,
		arg.StateID,
	)
	var i License
	err := row.Scan(
		&i.ID,
		&i.LicenseFileUrl,
		&i.LicenseNo,
		&i.LicenseIssueDate,
		&i.LicenseRegistrationDate,
		&i.LicenseExpiryDate,
		&i.LicenseTypeID,
		&i.StateID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Metadata,
	)
	return i, err
}

const updateLicenseStateByEntityAndEntityTypeId = `-- name: UpdateLicenseStateByEntityAndEntityTypeId :exec
UPDATE license SET state_id = $1
WHERE entity_type_id = $2 AND entity_id = $3
`

type UpdateLicenseStateByEntityAndEntityTypeIdParams struct {
	StateID      int64 `json:"state_id"`
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
}

func (q *Queries) UpdateLicenseStateByEntityAndEntityTypeId(ctx context.Context, arg UpdateLicenseStateByEntityAndEntityTypeIdParams) error {
	_, err := q.db.Exec(ctx, updateLicenseStateByEntityAndEntityTypeId, arg.StateID, arg.EntityTypeID, arg.EntityID)
	return err
}

const updateStateLicenseFieldsByLicense = `-- name: UpdateStateLicenseFieldsByLicense :one
UPDATE state_license_fields
SET field_value = $3
WHERE license_id = $1 AND field_name = $2
RETURNING id, field_name, field_value, license_id
`

type UpdateStateLicenseFieldsByLicenseParams struct {
	LicenseID  int64  `json:"license_id"`
	FieldName  string `json:"field_name"`
	FieldValue string `json:"field_value"`
}

func (q *Queries) UpdateStateLicenseFieldsByLicense(ctx context.Context, arg UpdateStateLicenseFieldsByLicenseParams) (StateLicenseField, error) {
	row := q.db.QueryRow(ctx, updateStateLicenseFieldsByLicense, arg.LicenseID, arg.FieldName, arg.FieldValue)
	var i StateLicenseField
	err := row.Scan(
		&i.ID,
		&i.FieldName,
		&i.FieldValue,
		&i.LicenseID,
	)
	return i, err
}

const verifyCompanies = `-- name: VerifyCompanies :one
UPDATE companies 
SET status = 8,
is_verified = true
Where id =$1 
RETURNING id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url
`

func (q *Queries) VerifyCompanies(ctx context.Context, id int64) (Company, error) {
	row := q.db.QueryRow(ctx, verifyCompanies, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}
