// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: permissions.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (
    title,
    sub_title,
    section_permission_id,
    created_at,
    updated_at
)VALUES (
    $1,$2, $3, $4, $5
) RETURNING id, title, sub_title, indicator, section_permission_id, created_at, updated_at
`

type CreatePermissionParams struct {
	Title               string      `json:"title"`
	SubTitle            pgtype.Text `json:"sub_title"`
	SectionPermissionID int64       `json:"section_permission_id"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, createPermission,
		arg.Title,
		arg.SubTitle,
		arg.SectionPermissionID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SubTitle,
		&i.Indicator,
		&i.SectionPermissionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserPermission = `-- name: CreateUserPermission :one
INSERT INTO user_company_permissions (
    user_id,
    company_id,
    permissions_id,
    sub_sections_id
)VALUES (
    $1,$2,$3, $4
) RETURNING id, user_id, company_id, permissions_id, sub_sections_id
`

type CreateUserPermissionParams struct {
	UserID        int64       `json:"user_id"`
	CompanyID     pgtype.Int8 `json:"company_id"`
	PermissionsID []int64     `json:"permissions_id"`
	SubSectionsID []int64     `json:"sub_sections_id"`
}

func (q *Queries) CreateUserPermission(ctx context.Context, arg CreateUserPermissionParams) (UserCompanyPermission, error) {
	row := q.db.QueryRow(ctx, createUserPermission,
		arg.UserID,
		arg.CompanyID,
		arg.PermissionsID,
		arg.SubSectionsID,
	)
	var i UserCompanyPermission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.PermissionsID,
		&i.SubSectionsID,
	)
	return i, err
}

const createUserPermissionTest = `-- name: CreateUserPermissionTest :one
INSERT INTO user_company_permissions_test (
    user_id,
    company_id,
    permission_id,
    sub_section_id
)VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, company_id, permission_id, sub_section_id, created_at, updated_at
`

type CreateUserPermissionTestParams struct {
	UserID       pgtype.Int8 `json:"user_id"`
	CompanyID    pgtype.Int8 `json:"company_id"`
	PermissionID pgtype.Int8 `json:"permission_id"`
	SubSectionID pgtype.Int8 `json:"sub_section_id"`
}

func (q *Queries) CreateUserPermissionTest(ctx context.Context, arg CreateUserPermissionTestParams) (UserCompanyPermissionsTest, error) {
	row := q.db.QueryRow(ctx, createUserPermissionTest,
		arg.UserID,
		arg.CompanyID,
		arg.PermissionID,
		arg.SubSectionID,
	)
	var i UserCompanyPermissionsTest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.PermissionID,
		&i.SubSectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions
Where id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePermission, id)
	return err
}

const getAllForSuperUserPermissionBySectionPermissionId = `-- name: GetAllForSuperUserPermissionBySectionPermissionId :many


SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions
Where section_permission_id = $1 ORDER BY id
`

// SELECT p.* FROM permissions p
// LEFT JOIN LATERAL (
//
//	SELECT UNNEST(permissions_id) as permission_id
//	FROM users
//	WHERE users.id = $1
//
// ) u ON p.id = u.permission_id
// WHERE ($1 != 6 AND u.permission_id IS NOT NULL) OR $1 = 6;
func (q *Queries) GetAllForSuperUserPermissionBySectionPermissionId(ctx context.Context, sectionPermissionID int64) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getAllForSuperUserPermissionBySectionPermissionId, sectionPermissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SubTitle,
			&i.Indicator,
			&i.SectionPermissionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForSuperUserPermissionBySectionPermissionIdMV = `-- name: GetAllForSuperUserPermissionBySectionPermissionIdMV :many
SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions_mv
Where 
    CASE WHEN $1::bigint = 0 THEN true ELSE id = ANY($2::bigint[]) END -- by zero it will be super user 
AND 
section_permission_id = $3::bigint ORDER BY id
`

type GetAllForSuperUserPermissionBySectionPermissionIdMVParams struct {
	Issuperuserid       int64   `json:"issuperuserid"`
	Permission          []int64 `json:"permission"`
	SectionPermissionID int64   `json:"section_permission_id"`
}

func (q *Queries) GetAllForSuperUserPermissionBySectionPermissionIdMV(ctx context.Context, arg GetAllForSuperUserPermissionBySectionPermissionIdMVParams) ([]PermissionsMv, error) {
	rows, err := q.db.Query(ctx, getAllForSuperUserPermissionBySectionPermissionIdMV, arg.Issuperuserid, arg.Permission, arg.SectionPermissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PermissionsMv
	for rows.Next() {
		var i PermissionsMv
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SubTitle,
			&i.Indicator,
			&i.SectionPermissionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPermission = `-- name: GetAllPermission :many
SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllPermissionParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPermission(ctx context.Context, arg GetAllPermissionParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getAllPermission, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SubTitle,
			&i.Indicator,
			&i.SectionPermissionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPermissionBySectionPermissionId = `-- name: GetAllPermissionBySectionPermissionId :many
SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions
WHERE permissions.section_permission_id = $1
`

func (q *Queries) GetAllPermissionBySectionPermissionId(ctx context.Context, sectionPermissionID int64) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getAllPermissionBySectionPermissionId, sectionPermissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SubTitle,
			&i.Indicator,
			&i.SectionPermissionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPermissionFromUserByID = `-- name: GetAllPermissionFromUserByID :many
SELECT permission_id FROM user_company_permissions_test
WHERE 
(
    CASE when $1 != 0 then company_id = $2 else true END
)
AND   user_id = $3
`

type GetAllPermissionFromUserByIDParams struct {
	IsCompanyUser interface{} `json:"is_company_user"`
	CompanyID     pgtype.Int8 `json:"company_id"`
	UserID        pgtype.Int8 `json:"user_id"`
}

// this mean it's a company user or not
func (q *Queries) GetAllPermissionFromUserByID(ctx context.Context, arg GetAllPermissionFromUserByIDParams) ([]pgtype.Int8, error) {
	rows, err := q.db.Query(ctx, getAllPermissionFromUserByID, arg.IsCompanyUser, arg.CompanyID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Int8
	for rows.Next() {
		var permission_id pgtype.Int8
		if err := rows.Scan(&permission_id); err != nil {
			return nil, err
		}
		items = append(items, permission_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPermissionSectionIds = `-- name: GetAllPermissionSectionIds :many
SELECT id, section_permission_id FROM permissions ORDER by section_permission_id  LIMIT $1 OFFSET $2
`

type GetAllPermissionSectionIdsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllPermissionSectionIdsRow struct {
	ID                  int64 `json:"id"`
	SectionPermissionID int64 `json:"section_permission_id"`
}

func (q *Queries) GetAllPermissionSectionIds(ctx context.Context, arg GetAllPermissionSectionIdsParams) ([]GetAllPermissionSectionIdsRow, error) {
	rows, err := q.db.Query(ctx, getAllPermissionSectionIds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPermissionSectionIdsRow
	for rows.Next() {
		var i GetAllPermissionSectionIdsRow
		if err := rows.Scan(&i.ID, &i.SectionPermissionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPermissions = `-- name: GetAllPermissions :many
SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions ORDER by section_permission_id
`

func (q *Queries) GetAllPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getAllPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SubTitle,
			&i.Indicator,
			&i.SectionPermissionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSectionPermissionFromPermissionIDs = `-- name: GetAllSectionPermissionFromPermissionIDs :many
SELECT DISTINCT sp.id, sp.title, sp.sub_title, sp.indicator, sp.created_at, sp.updated_at 
FROM 
    section_permission_mv sp
LEFT JOIN 
    permissions p ON p.section_permission_id = sp.id
LEFT JOIN 
    sub_section ss ON ss.permissions_id = p.id
Where 
  CASE WHEN $1=0 THEN true ELSE p.id = ANY($2::bigint[]) END
ORDER BY 
    sp.id
`

type GetAllSectionPermissionFromPermissionIDsParams struct {
	IsSuperUser  interface{} `json:"is_super_user"`
	PermissionID []int64     `json:"permission_id"`
}

func (q *Queries) GetAllSectionPermissionFromPermissionIDs(ctx context.Context, arg GetAllSectionPermissionFromPermissionIDsParams) ([]SectionPermissionMv, error) {
	rows, err := q.db.Query(ctx, getAllSectionPermissionFromPermissionIDs, arg.IsSuperUser, arg.PermissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SectionPermissionMv
	for rows.Next() {
		var i SectionPermissionMv
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SubTitle,
			&i.Indicator,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubSectionPermissions = `-- name: GetAllSubSectionPermissions :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section ORDER BY permissions_id
`

func (q *Queries) GetAllSubSectionPermissions(ctx context.Context) ([]SubSection, error) {
	rows, err := q.db.Query(ctx, getAllSubSectionPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSection
	for rows.Next() {
		var i SubSection
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllPermissionSectionIds = `-- name: GetCountAllPermissionSectionIds :one
SELECT COUNT(*) FROM permissions
`

func (q *Queries) GetCountAllPermissionSectionIds(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllPermissionSectionIds)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPermission = `-- name: GetPermission :one
SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions 
WHERE id = $1
`

func (q *Queries) GetPermission(ctx context.Context, id int64) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermission, id)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SubTitle,
		&i.Indicator,
		&i.SectionPermissionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPermissionByIdAndSectionPermissionId = `-- name: GetPermissionByIdAndSectionPermissionId :one


SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions
Where id = $1 AND section_permission_id = $2 ORDER BY id
`

type GetPermissionByIdAndSectionPermissionIdParams struct {
	ID                  int64 `json:"id"`
	SectionPermissionID int64 `json:"section_permission_id"`
}

// LEFT JOIN LATERAL (
//
//	SELECT UNNEST(permissions_id) as permission_id
//	FROM users
//	WHERE users.id = $1
//
// ) u ON p.id = u.permission_id;
func (q *Queries) GetPermissionByIdAndSectionPermissionId(ctx context.Context, arg GetPermissionByIdAndSectionPermissionIdParams) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissionByIdAndSectionPermissionId, arg.ID, arg.SectionPermissionID)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SubTitle,
		&i.Indicator,
		&i.SectionPermissionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPermissionBySectionID = `-- name: GetPermissionBySectionID :many
SELECT id FROM permissions WHERE permissions.section_permission_id = $1
`

func (q *Queries) GetPermissionBySectionID(ctx context.Context, sectionPermissionID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getPermissionBySectionID, sectionPermissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionBySubTitle = `-- name: GetPermissionBySubTitle :one
SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions 
WHERE LOWER(sub_title) = LOWER($1)
`

func (q *Queries) GetPermissionBySubTitle(ctx context.Context, subTitle string) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissionBySubTitle, subTitle)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SubTitle,
		&i.Indicator,
		&i.SectionPermissionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPermissionByTitle = `-- name: GetPermissionByTitle :one
SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions 
WHERE LOWER(title) = LOWER($1)
`

func (q *Queries) GetPermissionByTitle(ctx context.Context, title string) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissionByTitle, title)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SubTitle,
		&i.Indicator,
		&i.SectionPermissionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPermissionMV = `-- name: GetPermissionMV :one


SELECT id, title, sub_title, indicator, section_permission_id, created_at, updated_at FROM permissions_mv
Where id = $1
`

// SELECT * FROM permissions_mv
// Where section_permission_id = $1 ORDER BY id;
func (q *Queries) GetPermissionMV(ctx context.Context, id int64) (PermissionsMv, error) {
	row := q.db.QueryRow(ctx, getPermissionMV, id)
	var i PermissionsMv
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SubTitle,
		&i.Indicator,
		&i.SectionPermissionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserCompanyPermissionsByID = `-- name: GetUserCompanyPermissionsByID :one
SELECT permissions_id::bigint[] FROM user_company_permissions 
WHERE 
(
    -- this mean it's a company user or not  
    CASE when $1 != 0 then company_id = $2 else true END
)
AND   user_id = $3
`

type GetUserCompanyPermissionsByIDParams struct {
	IsCompanyUser interface{} `json:"is_company_user"`
	CompanyID     pgtype.Int8 `json:"company_id"`
	UserID        int64       `json:"user_id"`
}

func (q *Queries) GetUserCompanyPermissionsByID(ctx context.Context, arg GetUserCompanyPermissionsByIDParams) ([]int64, error) {
	row := q.db.QueryRow(ctx, getUserCompanyPermissionsByID, arg.IsCompanyUser, arg.CompanyID, arg.UserID)
	var permissions_id []int64
	err := row.Scan(&permissions_id)
	return permissions_id, err
}

const getUserCompanySubSectionPermissionsByID = `-- name: GetUserCompanySubSectionPermissionsByID :one
SELECT sub_sections_id::bigint[] FROM user_company_permissions
WHERE 
(
    -- this mean it's a company user or not  
    CASE when $1 != 0 then company_id = $2 else true END
)
AND   user_id = $3
`

type GetUserCompanySubSectionPermissionsByIDParams struct {
	IsCompanyUser interface{} `json:"is_company_user"`
	CompanyID     pgtype.Int8 `json:"company_id"`
	UserID        int64       `json:"user_id"`
}

func (q *Queries) GetUserCompanySubSectionPermissionsByID(ctx context.Context, arg GetUserCompanySubSectionPermissionsByIDParams) ([]int64, error) {
	row := q.db.QueryRow(ctx, getUserCompanySubSectionPermissionsByID, arg.IsCompanyUser, arg.CompanyID, arg.UserID)
	var sub_sections_id []int64
	err := row.Scan(&sub_sections_id)
	return sub_sections_id, err
}

const getUserPermissionsByID = `-- name: GetUserPermissionsByID :one
SELECT id, user_id, company_id, permissions_id, sub_sections_id FROM user_company_permissions 
WHERE 
(
    -- this mean it's a company user or not  
    CASE when $1 != 0 then company_id = $2 else true END
)
AND   user_id = $3
`

type GetUserPermissionsByIDParams struct {
	IsCompanyUser interface{} `json:"is_company_user"`
	CompanyID     pgtype.Int8 `json:"company_id"`
	UserID        int64       `json:"user_id"`
}

func (q *Queries) GetUserPermissionsByID(ctx context.Context, arg GetUserPermissionsByIDParams) (UserCompanyPermission, error) {
	row := q.db.QueryRow(ctx, getUserPermissionsByID, arg.IsCompanyUser, arg.CompanyID, arg.UserID)
	var i UserCompanyPermission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.PermissionsID,
		&i.SubSectionsID,
	)
	return i, err
}

const getUserPermissionsTestByID = `-- name: GetUserPermissionsTestByID :many
SELECT permission_id::bigint FROM user_company_permissions_test
WHERE 
(
    -- this mean it's a company user or not  
    CASE when $1 != 0 then company_id = $2 else true END
)
AND   user_id = $3
`

type GetUserPermissionsTestByIDParams struct {
	IsCompanyUser interface{} `json:"is_company_user"`
	CompanyID     pgtype.Int8 `json:"company_id"`
	UserID        pgtype.Int8 `json:"user_id"`
}

// TODO: remove after checking ........
func (q *Queries) GetUserPermissionsTestByID(ctx context.Context, arg GetUserPermissionsTestByIDParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUserPermissionsTestByID, arg.IsCompanyUser, arg.CompanyID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var permission_id int64
		if err := rows.Scan(&permission_id); err != nil {
			return nil, err
		}
		items = append(items, permission_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSubSectionPermissionsTestByID = `-- name: GetUserSubSectionPermissionsTestByID :many
SELECT sub_section_id::bigint FROM user_company_permissions_test
WHERE 
(
    -- this mean it's a company user or not  
    CASE when $1 != 0 then company_id = $2 else true END
)
AND   user_id = $3
`

type GetUserSubSectionPermissionsTestByIDParams struct {
	IsCompanyUser interface{} `json:"is_company_user"`
	CompanyID     pgtype.Int8 `json:"company_id"`
	UserID        pgtype.Int8 `json:"user_id"`
}

func (q *Queries) GetUserSubSectionPermissionsTestByID(ctx context.Context, arg GetUserSubSectionPermissionsTestByIDParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUserSubSectionPermissionsTestByID, arg.IsCompanyUser, arg.CompanyID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var sub_section_id int64
		if err := rows.Scan(&sub_section_id); err != nil {
			return nil, err
		}
		items = append(items, sub_section_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePermission = `-- name: UpdatePermission :one
UPDATE permissions
SET title = $2,
    sub_title = $3,
    section_permission_id = $4,
    created_at = $5,
    updated_at = $6
Where id = $1
RETURNING id, title, sub_title, indicator, section_permission_id, created_at, updated_at
`

type UpdatePermissionParams struct {
	ID                  int64       `json:"id"`
	Title               string      `json:"title"`
	SubTitle            pgtype.Text `json:"sub_title"`
	SectionPermissionID int64       `json:"section_permission_id"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, updatePermission,
		arg.ID,
		arg.Title,
		arg.SubTitle,
		arg.SectionPermissionID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SubTitle,
		&i.Indicator,
		&i.SectionPermissionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPermissionsByID = `-- name: UpdateUserPermissionsByID :one
Update user_company_permissions
SET permissions_id = $1,
    sub_sections_id =  $2
WHERE 
(
  -- this mean it's a company user or not
  CASE when $3 != 0 then company_id = $4 else true END
)
AND  user_id = $5
RETURNING id, user_id, company_id, permissions_id, sub_sections_id
`

type UpdateUserPermissionsByIDParams struct {
	PermissionID []int64     `json:"permission_id"`
	SubSectionID []int64     `json:"sub_section_id"`
	IsCompany    interface{} `json:"is_company"`
	CompanyID    pgtype.Int8 `json:"company_id"`
	UserID       int64       `json:"user_id"`
}

func (q *Queries) UpdateUserPermissionsByID(ctx context.Context, arg UpdateUserPermissionsByIDParams) (UserCompanyPermission, error) {
	row := q.db.QueryRow(ctx, updateUserPermissionsByID,
		arg.PermissionID,
		arg.SubSectionID,
		arg.IsCompany,
		arg.CompanyID,
		arg.UserID,
	)
	var i UserCompanyPermission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.PermissionsID,
		&i.SubSectionsID,
	)
	return i, err
}
