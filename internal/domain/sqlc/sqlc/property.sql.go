// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: property.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteXMLProperties = `-- name: DeleteXMLProperties :exec
DELETE FROM property
WHERE id = ANY($1::bigint[])
  AND from_xml IS TRUE
`

func (q *Queries) DeleteXMLProperties(ctx context.Context, idsToDelete []int64) error {
	_, err := q.db.Exec(ctx, deleteXMLProperties, idsToDelete)
	return err
}

const deleteXMLPropertyVersions = `-- name: DeleteXMLPropertyVersions :exec
DELETE FROM property_versions
USING property
WHERE property.id = property_versions.property_id
  AND property.from_xml IS TRUE
  AND property_versions.id = ANY($1::bigint[])
`

func (q *Queries) DeleteXMLPropertyVersions(ctx context.Context, idsToDelete []int64) error {
	_, err := q.db.Exec(ctx, deleteXMLPropertyVersions, idsToDelete)
	return err
}

const disableExpiredExclusivePropertyVersions = `-- name: DisableExpiredExclusivePropertyVersions :exec
UPDATE property_versions
SET "exclusive" = FALSE
WHERE "exclusive" IS TRUE AND end_date < now()
`

func (q *Queries) DisableExpiredExclusivePropertyVersions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, disableExpiredExclusivePropertyVersions)
	return err
}

const getAllXMLPropertyRefNoByCompany = `-- name: GetAllXMLPropertyRefNoByCompany :many
SELECT ref_no FROM property_versions
INNER JOIN property ON property_versions.property_id = property.id
WHERE from_xml IS TRUE AND company_id = $1
`

func (q *Queries) GetAllXMLPropertyRefNoByCompany(ctx context.Context, companyID pgtype.Int8) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllXMLPropertyRefNoByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var ref_no string
		if err := rows.Scan(&ref_no); err != nil {
			return nil, err
		}
		items = append(items, ref_no)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertiesByPhasesIDs = `-- name: GetPropertiesByPhasesIDs :many
SELECT
    property_versions.id,
    property.entity_id AS phase_id
FROM
    property
    -- INNER JOIN phases ON phases.id = ANY (@phases_id::BIGINT[])
    -- AND phases.status != 6
JOIN property_versions ON property_versions.property_id=property.id
WHERE
    property.entity_type_id = $1 :: BIGINT
    AND property.entity_id = ANY ($2::BIGINT[])
    AND property.status != 6
    AND (SELECT phases.status from phases where phases.id=property.entity_id )!=6 AND property_versions.status!=6
`

type GetPropertiesByPhasesIDsParams struct {
	PhaseEntityTypeID int64   `json:"phase_entity_type_id"`
	PhasesID          []int64 `json:"phases_id"`
}

type GetPropertiesByPhasesIDsRow struct {
	ID      int64 `json:"id"`
	PhaseID int64 `json:"phase_id"`
}

func (q *Queries) GetPropertiesByPhasesIDs(ctx context.Context, arg GetPropertiesByPhasesIDsParams) ([]GetPropertiesByPhasesIDsRow, error) {
	rows, err := q.db.Query(ctx, getPropertiesByPhasesIDs, arg.PhaseEntityTypeID, arg.PhasesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertiesByPhasesIDsRow
	for rows.Next() {
		var i GetPropertiesByPhasesIDsRow
		if err := rows.Scan(&i.ID, &i.PhaseID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertiesByProjectID = `-- name: GetPropertiesByProjectID :many
SELECT 
    property_versions.id
FROM 
    property
JOIN property_versions ON property_versions.property_id=property.id
WHERE 
    property.status!=6 AND property.entity_type_id= $1::BIGINT AND property.entity_id= $2::BIGINT
    AND property_versions.status!=6
`

type GetPropertiesByProjectIDParams struct {
	ProjectEntityType int64 `json:"project_entity_type"`
	ProjectID         int64 `json:"project_id"`
}

func (q *Queries) GetPropertiesByProjectID(ctx context.Context, arg GetPropertiesByProjectIDParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getPropertiesByProjectID, arg.ProjectEntityType, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getXMLPropertyIDsToDelete = `-- name: GetXMLPropertyIDsToDelete :one
SELECT 
    array_agg(property.id)::bigint[] AS property_ids,
    array_agg(property.addresses_id)::bigint[] AS address_ids,
    array_agg(property_versions.id)::bigint[] AS property_version_ids
FROM property
INNER JOIN property_versions ON property_versions.property_id = property.id
WHERE property.from_xml IS TRUE
  AND property_versions.ref_no = ANY($1::varchar[])
  AND property.company_id = $2::bigint
`

type GetXMLPropertyIDsToDeleteParams struct {
	RefNoToDelete []string `json:"ref_no_to_delete"`
	CompanyID     int64    `json:"company_id"`
}

type GetXMLPropertyIDsToDeleteRow struct {
	PropertyIds        []int64 `json:"property_ids"`
	AddressIds         []int64 `json:"address_ids"`
	PropertyVersionIds []int64 `json:"property_version_ids"`
}

func (q *Queries) GetXMLPropertyIDsToDelete(ctx context.Context, arg GetXMLPropertyIDsToDeleteParams) (GetXMLPropertyIDsToDeleteRow, error) {
	row := q.db.QueryRow(ctx, getXMLPropertyIDsToDelete, arg.RefNoToDelete, arg.CompanyID)
	var i GetXMLPropertyIDsToDeleteRow
	err := row.Scan(&i.PropertyIds, &i.AddressIds, &i.PropertyVersionIds)
	return i, err
}

const makePropertyVersionVerified = `-- name: MakePropertyVersionVerified :exec
UPDATE
    property_versions
SET
    is_verified = true, 
    updated_at=$1, 
    updated_by=$2
WHERE
    id = $3 :: BIGINT AND status!=6
`

type MakePropertyVersionVerifiedParams struct {
	UpdatedAt         time.Time `json:"updated_at"`
	UpdatedBy         int64     `json:"updated_by"`
	PropertyVersionID int64     `json:"property_version_id"`
}

func (q *Queries) MakePropertyVersionVerified(ctx context.Context, arg MakePropertyVersionVerifiedParams) error {
	_, err := q.db.Exec(ctx, makePropertyVersionVerified, arg.UpdatedAt, arg.UpdatedBy, arg.PropertyVersionID)
	return err
}
