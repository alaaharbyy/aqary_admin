// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSignUpUser = `-- name: CreateSignUpUser :one
INSERT INTO users (
    email,
    username,
    password,
    status,
    roles_id,
    user_types_id,
    social_login,
    show_hide_details,
    experience_since,
    is_verified,
    created_at,
    updated_at,
    phone_number,
    is_phone_verified,
    is_email_verified
)VALUES (
 $1, $2, $3,$4, $5, $6, $7, $8, $9, $10, $11, $12, $13,$14,$15
) RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

type CreateSignUpUserParams struct {
	Email           string             `json:"email"`
	Username        string             `json:"username"`
	Password        string             `json:"password"`
	Status          int64              `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     int64              `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	IsPhoneVerified pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
}

func (q *Queries) CreateSignUpUser(ctx context.Context, arg CreateSignUpUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createSignUpUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.Status,
		arg.RolesID,
		arg.UserTypesID,
		arg.SocialLogin,
		arg.ShowHideDetails,
		arg.ExperienceSince,
		arg.IsVerified,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.PhoneNumber,
		arg.IsPhoneVerified,
		arg.IsEmailVerified,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email,
    username,
    password,
    status,
    roles_id,
    user_types_id,
    social_login,
    show_hide_details,
    experience_since,
    is_verified,
    created_at,
    updated_at,
    phone_number,
    country_code
)VALUES (
 $1, $2, $3,$4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

type CreateUserParams struct {
	Email           string             `json:"email"`
	Username        string             `json:"username"`
	Password        string             `json:"password"`
	Status          int64              `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     int64              `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	CountryCode     pgtype.Int8        `json:"country_code"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.Status,
		arg.RolesID,
		arg.UserTypesID,
		arg.SocialLogin,
		arg.ShowHideDetails,
		arg.ExperienceSince,
		arg.IsVerified,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.PhoneNumber,
		arg.CountryCode,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
Where id = $1 and user_types_id != 6
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getActiveUsersByType = `-- name: GetActiveUsersByType :many
SELECT users.id, TRIM(CONCAT(profiles.first_name, ' ', profiles.last_name)) AS full_name
FROM users
LEFT JOIN profiles ON users.id = profiles.users_id
LEFT JOIN addresses ON profiles.addresses_id = addresses.id
WHERE users.status NOT IN (5,6)
AND users.user_types_id = $1::bigint
AND addresses.countries_id = $2::bigint
AND ($3 = '%%'
    OR TRIM(CONCAT(profiles.first_name, ' ', profiles.last_name)) ILIKE $3
)
`

type GetActiveUsersByTypeParams struct {
	UserType  int64       `json:"user_type"`
	CountryID int64       `json:"country_id"`
	Search    interface{} `json:"search"`
}

type GetActiveUsersByTypeRow struct {
	ID       int64  `json:"id"`
	FullName string `json:"full_name"`
}

func (q *Queries) GetActiveUsersByType(ctx context.Context, arg GetActiveUsersByTypeParams) ([]GetActiveUsersByTypeRow, error) {
	rows, err := q.db.Query(ctx, getActiveUsersByType, arg.UserType, arg.CountryID, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveUsersByTypeRow
	for rows.Next() {
		var i GetActiveUsersByTypeRow
		if err := rows.Scan(&i.ID, &i.FullName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminUserByBrokerCompany = `-- name: GetAdminUserByBrokerCompany :one


SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views FROM users 
RIGHT JOIN broker_companies ON broker_companies.users_id = users.id
WHERE users.user_types_id = 1 AND broker_companies.id = $1
`

type GetAdminUserByBrokerCompanyRow struct {
	ID              pgtype.Int8        `json:"id"`
	Email           pgtype.Text        `json:"email"`
	Username        pgtype.Text        `json:"username"`
	Password        pgtype.Text        `json:"password"`
	Status          pgtype.Int8        `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     pgtype.Int8        `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	IsPhoneVerified pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany   pgtype.Int8        `json:"active_company"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	ProfileViews    pgtype.Int8        `json:"profile_views"`
}

// SELECT COUNT(*) from users
// WHERE status = 6;
func (q *Queries) GetAdminUserByBrokerCompany(ctx context.Context, id int64) (GetAdminUserByBrokerCompanyRow, error) {
	row := q.db.QueryRow(ctx, getAdminUserByBrokerCompany, id)
	var i GetAdminUserByBrokerCompanyRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getAdminUserByBrokerCompanyBranch = `-- name: GetAdminUserByBrokerCompanyBranch :one
SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views FROM users RIGHT JOIN broker_companies_branches ON broker_companies_branches.users_id = users.id 
WHERE users.user_types_id = 1 AND broker_companies_branches.id = $1
`

type GetAdminUserByBrokerCompanyBranchRow struct {
	ID              pgtype.Int8        `json:"id"`
	Email           pgtype.Text        `json:"email"`
	Username        pgtype.Text        `json:"username"`
	Password        pgtype.Text        `json:"password"`
	Status          pgtype.Int8        `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     pgtype.Int8        `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	IsPhoneVerified pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany   pgtype.Int8        `json:"active_company"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	ProfileViews    pgtype.Int8        `json:"profile_views"`
}

func (q *Queries) GetAdminUserByBrokerCompanyBranch(ctx context.Context, id int64) (GetAdminUserByBrokerCompanyBranchRow, error) {
	row := q.db.QueryRow(ctx, getAdminUserByBrokerCompanyBranch, id)
	var i GetAdminUserByBrokerCompanyBranchRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getAllAqaryDeletedUser = `-- name: GetAllAqaryDeletedUser :many
SELECT users.id, email, username, password, users.status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, users.created_at, users.updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views, profiles.id, first_name, last_name, addresses_id, profile_image_url, secondary_number, whatsapp_number, show_whatsapp_number, botim_number, show_botim_number, tawasal_number, show_tawasal_number, gender, profiles.created_at, profiles.updated_at, ref_no, cover_image_url, passport_no, passport_image_url, passport_expiry_date, about, about_arabic, users_id, telegram_number, roles.id, role, roles.created_at, roles.updated_at, department_id, role_ar, department.id, department, department_ar, department.status, company_id, department.created_at, department.updated_at from users 
 INNER JOIN profiles ON users.id =  profiles.users_id
 INNER JOIN roles ON users.roles_id = roles.id
 LEFT JOIN department ON roles.department_id = department.id
 WHERE 
      ($3 = '%%'
       OR users.username ILIKE $3
       OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $3   
       OR users.email ILIKE $3
       OR users.phone_number ILIKE $3
       OR roles.role ILIKE $3
       OR department.department ILIKE $3
      )
AND  users.status = 6
ORDER by users.updated_at DESC  LIMIT $1 OFFSET $2
`

type GetAllAqaryDeletedUserParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Search interface{} `json:"search"`
}

type GetAllAqaryDeletedUserRow struct {
	ID                 int64              `json:"id"`
	Email              string             `json:"email"`
	Username           string             `json:"username"`
	Password           string             `json:"password"`
	Status             int64              `json:"status"`
	RolesID            pgtype.Int8        `json:"roles_id"`
	UserTypesID        int64              `json:"user_types_id"`
	SocialLogin        pgtype.Text        `json:"social_login"`
	ShowHideDetails    pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince    pgtype.Timestamptz `json:"experience_since"`
	IsVerified         pgtype.Bool        `json:"is_verified"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
	PhoneNumber        pgtype.Text        `json:"phone_number"`
	IsPhoneVerified    pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified    pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany      pgtype.Int8        `json:"active_company"`
	CountryCode        pgtype.Int8        `json:"country_code"`
	ProfileViews       int64              `json:"profile_views"`
	ID_2               int64              `json:"id_2"`
	FirstName          string             `json:"first_name"`
	LastName           string             `json:"last_name"`
	AddressesID        int64              `json:"addresses_id"`
	ProfileImageUrl    pgtype.Text        `json:"profile_image_url"`
	SecondaryNumber    pgtype.Text        `json:"secondary_number"`
	WhatsappNumber     pgtype.Text        `json:"whatsapp_number"`
	ShowWhatsappNumber pgtype.Bool        `json:"show_whatsapp_number"`
	BotimNumber        pgtype.Text        `json:"botim_number"`
	ShowBotimNumber    pgtype.Bool        `json:"show_botim_number"`
	TawasalNumber      pgtype.Text        `json:"tawasal_number"`
	ShowTawasalNumber  pgtype.Bool        `json:"show_tawasal_number"`
	Gender             pgtype.Int8        `json:"gender"`
	CreatedAt_2        time.Time          `json:"created_at_2"`
	UpdatedAt_2        time.Time          `json:"updated_at_2"`
	RefNo              string             `json:"ref_no"`
	CoverImageUrl      pgtype.Text        `json:"cover_image_url"`
	PassportNo         pgtype.Text        `json:"passport_no"`
	PassportImageUrl   pgtype.Text        `json:"passport_image_url"`
	PassportExpiryDate pgtype.Timestamptz `json:"passport_expiry_date"`
	About              pgtype.Text        `json:"about"`
	AboutArabic        pgtype.Text        `json:"about_arabic"`
	UsersID            int64              `json:"users_id"`
	TelegramNumber     pgtype.Text        `json:"telegram_number"`
	ID_3               int64              `json:"id_3"`
	Role               string             `json:"role"`
	CreatedAt_3        time.Time          `json:"created_at_3"`
	UpdatedAt_3        time.Time          `json:"updated_at_3"`
	DepartmentID       pgtype.Int8        `json:"department_id"`
	RoleAr             pgtype.Text        `json:"role_ar"`
	ID_4               pgtype.Int8        `json:"id_4"`
	Department         pgtype.Text        `json:"department"`
	DepartmentAr       pgtype.Text        `json:"department_ar"`
	Status_2           pgtype.Int8        `json:"status_2"`
	CompanyID          pgtype.Int8        `json:"company_id"`
	CreatedAt_4        pgtype.Timestamptz `json:"created_at_4"`
	UpdatedAt_4        pgtype.Timestamptz `json:"updated_at_4"`
}

func (q *Queries) GetAllAqaryDeletedUser(ctx context.Context, arg GetAllAqaryDeletedUserParams) ([]GetAllAqaryDeletedUserRow, error) {
	rows, err := q.db.Query(ctx, getAllAqaryDeletedUser, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAqaryDeletedUserRow
	for rows.Next() {
		var i GetAllAqaryDeletedUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
			&i.ID_2,
			&i.FirstName,
			&i.LastName,
			&i.AddressesID,
			&i.ProfileImageUrl,
			&i.SecondaryNumber,
			&i.WhatsappNumber,
			&i.ShowWhatsappNumber,
			&i.BotimNumber,
			&i.ShowBotimNumber,
			&i.TawasalNumber,
			&i.ShowTawasalNumber,
			&i.Gender,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.RefNo,
			&i.CoverImageUrl,
			&i.PassportNo,
			&i.PassportImageUrl,
			&i.PassportExpiryDate,
			&i.About,
			&i.AboutArabic,
			&i.UsersID,
			&i.TelegramNumber,
			&i.ID_3,
			&i.Role,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
			&i.DepartmentID,
			&i.RoleAr,
			&i.ID_4,
			&i.Department,
			&i.DepartmentAr,
			&i.Status_2,
			&i.CompanyID,
			&i.CreatedAt_4,
			&i.UpdatedAt_4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAqaryDeletedUserWithoutPagination = `-- name: GetAllAqaryDeletedUserWithoutPagination :many
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views from users 
WHERE status = 6
`

func (q *Queries) GetAllAqaryDeletedUserWithoutPagination(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllAqaryDeletedUserWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAqaryUser = `-- name: GetAllAqaryUser :many
SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views, users.phone_number, roles.role, department.department, profiles.addresses_id FROM users
INNER JOIN profiles ON users.id = profiles.users_id
INNER JOIN roles ON users.roles_id = roles.id
INNER JOIN department ON roles.department_id = department.id
WHERE 
   (
     $3 = '%%'
     OR users.username ILIKE $3
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $3
     OR users.email ILIKE $3
     OR users.phone_number ILIKE $3
     OR roles.role ILIKE $3
    )
  AND user_types_id != 6  and users.status not in (5,6)
ORDER BY users.updated_at DESC
LIMIT $1
OFFSET $2
`

type GetAllAqaryUserParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Search interface{} `json:"search"`
}

type GetAllAqaryUserRow struct {
	ID              int64              `json:"id"`
	Email           string             `json:"email"`
	Username        string             `json:"username"`
	Password        string             `json:"password"`
	Status          int64              `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     int64              `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	IsPhoneVerified pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany   pgtype.Int8        `json:"active_company"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	ProfileViews    int64              `json:"profile_views"`
	PhoneNumber_2   pgtype.Text        `json:"phone_number_2"`
	Role            string             `json:"role"`
	Department      string             `json:"department"`
	AddressesID     int64              `json:"addresses_id"`
}

func (q *Queries) GetAllAqaryUser(ctx context.Context, arg GetAllAqaryUserParams) ([]GetAllAqaryUserRow, error) {
	rows, err := q.db.Query(ctx, getAllAqaryUser, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAqaryUserRow
	for rows.Next() {
		var i GetAllAqaryUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
			&i.PhoneNumber_2,
			&i.Role,
			&i.Department,
			&i.AddressesID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAqaryUsersByCountryId = `-- name: GetAllAqaryUsersByCountryId :many
WITH x AS (
  SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views, countries.id as country_id
  FROM users
  LEFT JOIN profiles ON users.id = profiles.users_id
  LEFT JOIN addresses ON profiles.addresses_id = addresses.id
  LEFT JOIN countries ON addresses.countries_id = countries.id
  WHERE countries.id = $3 AND users.user_types_id = 5 and user_types_id != 6  and status != 5 and status != 6
)
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views, country_id FROM x LIMIT $1 OFFSET $2
`

type GetAllAqaryUsersByCountryIdParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	ID     int64 `json:"id"`
}

type GetAllAqaryUsersByCountryIdRow struct {
	ID              int64              `json:"id"`
	Email           string             `json:"email"`
	Username        string             `json:"username"`
	Password        string             `json:"password"`
	Status          int64              `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     int64              `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	IsPhoneVerified pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany   pgtype.Int8        `json:"active_company"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	ProfileViews    int64              `json:"profile_views"`
	CountryID       pgtype.Int8        `json:"country_id"`
}

func (q *Queries) GetAllAqaryUsersByCountryId(ctx context.Context, arg GetAllAqaryUsersByCountryIdParams) ([]GetAllAqaryUsersByCountryIdRow, error) {
	rows, err := q.db.Query(ctx, getAllAqaryUsersByCountryId, arg.Limit, arg.Offset, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAqaryUsersByCountryIdRow
	for rows.Next() {
		var i GetAllAqaryUsersByCountryIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
			&i.CountryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyPendingUser = `-- name: GetAllCompanyPendingUser :many
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views from users 
where status = 1 AND user_types_id = 1
order by  updated_at desc LIMIT $1 OFFSET $2
`

type GetAllCompanyPendingUserParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllCompanyPendingUser(ctx context.Context, arg GetAllCompanyPendingUserParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllCompanyPendingUser, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllNestedSubSectionPermissonByButtonID = `-- name: GetAllNestedSubSectionPermissonByButtonID :many




SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section
Where sub_section_button_id = $1
`

// -- name: FetchSubSectionsForUser :many
// SELECT ss.*
// FROM sub_section ss
// JOIN (
//
//	SELECT UNNEST(sub_section_permission) as sub_section_permission
//	FROM users
//	WHERE users.id = $2
//
// ) u ON ss.id = u.sub_section_permission
// JOIN permissions p ON ss.permissions_id = p.id
// WHERE p.title ILIKE $1;
// -- name: FetchNestedButtonPermissionForUser :many
// SELECT ss.*
// FROM sub_section ss
// JOIN (
//
//	SELECT UNNEST(sub_section_permission) AS sub_section_permission
//	FROM users
//	WHERE users.id = $2
//
// ) u ON ss.id = u.sub_section_permission
// JOIN (
//
//	SELECT id FROM sub_section WHERE sub_section.sub_section_name ILIKE $1
//
// ) sss ON ss.sub_section_button_id = sss.id
// WHERE ss.sub_section_button_id IS NOT NULL;
func (q *Queries) GetAllNestedSubSectionPermissonByButtonID(ctx context.Context, subSectionButtonID int64) ([]SubSection, error) {
	rows, err := q.db.Query(ctx, getAllNestedSubSectionPermissonByButtonID, subSectionButtonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSection
	for rows.Next() {
		var i SubSection
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOtherUser = `-- name: GetAllOtherUser :many
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE user_types_id != 5 and user_types_id != 6  and status != 5 and status != 6  
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllOtherUserParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllOtherUser(ctx context.Context, arg GetAllOtherUserParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllOtherUser, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOtherUsersByCountryId = `-- name: GetAllOtherUsersByCountryId :many
WITH x AS (
  SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views, countries.id as country_id
  FROM users
  LEFT JOIN profiles ON users.id = profiles.users_id
  LEFT JOIN addresses ON profiles.addresses_id = addresses.id
  LEFT JOIN countries ON addresses.countries_id = countries.id
  WHERE countries.id = $3 AND users.user_types_id != 5 and user_types_id != 6   and status != 5 and status != 6
)
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views, country_id FROM x LIMIT $1 OFFSET $2
`

type GetAllOtherUsersByCountryIdParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	ID     int64 `json:"id"`
}

type GetAllOtherUsersByCountryIdRow struct {
	ID              int64              `json:"id"`
	Email           string             `json:"email"`
	Username        string             `json:"username"`
	Password        string             `json:"password"`
	Status          int64              `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     int64              `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	IsPhoneVerified pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany   pgtype.Int8        `json:"active_company"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	ProfileViews    int64              `json:"profile_views"`
	CountryID       pgtype.Int8        `json:"country_id"`
}

func (q *Queries) GetAllOtherUsersByCountryId(ctx context.Context, arg GetAllOtherUsersByCountryIdParams) ([]GetAllOtherUsersByCountryIdRow, error) {
	rows, err := q.db.Query(ctx, getAllOtherUsersByCountryId, arg.Limit, arg.Offset, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOtherUsersByCountryIdRow
	for rows.Next() {
		var i GetAllOtherUsersByCountryIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
			&i.CountryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTeamLeaders = `-- name: GetAllTeamLeaders :many
SELECT company_users.id, company_users.users_id, company_id, company_department, company_roles, user_rank, leader_id, company_users.is_verified, created_by, company_users.created_at, company_users.updated_at, active_listings, users.id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, users.is_verified, users.created_at, users.updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views, profiles.id, first_name, last_name, addresses_id, profile_image_url, secondary_number, whatsapp_number, show_whatsapp_number, botim_number, show_botim_number, tawasal_number, show_tawasal_number, gender, profiles.created_at, profiles.updated_at, ref_no, cover_image_url, passport_no, passport_image_url, passport_expiry_date, about, about_arabic, profiles.users_id, telegram_number, roles.id, role, roles.created_at, roles.updated_at, department_id, role_ar FROM company_users
INNER JOIN users ON company_users.users_id = users.id
INNER JOIN profiles ON  users.id = profiles.users_id
INNER JOIN roles ON users.roles_id = roles.id AND roles."role" ILIKE '%team leader%'
WHERE  CASE WHEN $1::bigint=0 THEN true ELSE  company_users.company_id = $1::bigint END
`

type GetAllTeamLeadersRow struct {
	ID                 int64              `json:"id"`
	UsersID            int64              `json:"users_id"`
	CompanyID          int64              `json:"company_id"`
	CompanyDepartment  pgtype.Int8        `json:"company_department"`
	CompanyRoles       pgtype.Int8        `json:"company_roles"`
	UserRank           int64              `json:"user_rank"`
	LeaderID           pgtype.Int8        `json:"leader_id"`
	IsVerified         pgtype.Bool        `json:"is_verified"`
	CreatedBy          int64              `json:"created_by"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
	ActiveListings     pgtype.Int8        `json:"active_listings"`
	ID_2               int64              `json:"id_2"`
	Email              string             `json:"email"`
	Username           string             `json:"username"`
	Password           string             `json:"password"`
	Status             int64              `json:"status"`
	RolesID            pgtype.Int8        `json:"roles_id"`
	UserTypesID        int64              `json:"user_types_id"`
	SocialLogin        pgtype.Text        `json:"social_login"`
	ShowHideDetails    pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince    pgtype.Timestamptz `json:"experience_since"`
	IsVerified_2       pgtype.Bool        `json:"is_verified_2"`
	CreatedAt_2        time.Time          `json:"created_at_2"`
	UpdatedAt_2        time.Time          `json:"updated_at_2"`
	PhoneNumber        pgtype.Text        `json:"phone_number"`
	IsPhoneVerified    pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified    pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany      pgtype.Int8        `json:"active_company"`
	CountryCode        pgtype.Int8        `json:"country_code"`
	ProfileViews       int64              `json:"profile_views"`
	ID_3               int64              `json:"id_3"`
	FirstName          string             `json:"first_name"`
	LastName           string             `json:"last_name"`
	AddressesID        int64              `json:"addresses_id"`
	ProfileImageUrl    pgtype.Text        `json:"profile_image_url"`
	SecondaryNumber    pgtype.Text        `json:"secondary_number"`
	WhatsappNumber     pgtype.Text        `json:"whatsapp_number"`
	ShowWhatsappNumber pgtype.Bool        `json:"show_whatsapp_number"`
	BotimNumber        pgtype.Text        `json:"botim_number"`
	ShowBotimNumber    pgtype.Bool        `json:"show_botim_number"`
	TawasalNumber      pgtype.Text        `json:"tawasal_number"`
	ShowTawasalNumber  pgtype.Bool        `json:"show_tawasal_number"`
	Gender             pgtype.Int8        `json:"gender"`
	CreatedAt_3        time.Time          `json:"created_at_3"`
	UpdatedAt_3        time.Time          `json:"updated_at_3"`
	RefNo              string             `json:"ref_no"`
	CoverImageUrl      pgtype.Text        `json:"cover_image_url"`
	PassportNo         pgtype.Text        `json:"passport_no"`
	PassportImageUrl   pgtype.Text        `json:"passport_image_url"`
	PassportExpiryDate pgtype.Timestamptz `json:"passport_expiry_date"`
	About              pgtype.Text        `json:"about"`
	AboutArabic        pgtype.Text        `json:"about_arabic"`
	UsersID_2          int64              `json:"users_id_2"`
	TelegramNumber     pgtype.Text        `json:"telegram_number"`
	ID_4               int64              `json:"id_4"`
	Role               string             `json:"role"`
	CreatedAt_4        time.Time          `json:"created_at_4"`
	UpdatedAt_4        time.Time          `json:"updated_at_4"`
	DepartmentID       pgtype.Int8        `json:"department_id"`
	RoleAr             pgtype.Text        `json:"role_ar"`
}

func (q *Queries) GetAllTeamLeaders(ctx context.Context, companyID int64) ([]GetAllTeamLeadersRow, error) {
	rows, err := q.db.Query(ctx, getAllTeamLeaders, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTeamLeadersRow
	for rows.Next() {
		var i GetAllTeamLeadersRow
		if err := rows.Scan(
			&i.ID,
			&i.UsersID,
			&i.CompanyID,
			&i.CompanyDepartment,
			&i.CompanyRoles,
			&i.UserRank,
			&i.LeaderID,
			&i.IsVerified,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ActiveListings,
			&i.ID_2,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
			&i.ID_3,
			&i.FirstName,
			&i.LastName,
			&i.AddressesID,
			&i.ProfileImageUrl,
			&i.SecondaryNumber,
			&i.WhatsappNumber,
			&i.ShowWhatsappNumber,
			&i.BotimNumber,
			&i.ShowBotimNumber,
			&i.TawasalNumber,
			&i.ShowTawasalNumber,
			&i.Gender,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
			&i.RefNo,
			&i.CoverImageUrl,
			&i.PassportNo,
			&i.PassportImageUrl,
			&i.PassportExpiryDate,
			&i.About,
			&i.AboutArabic,
			&i.UsersID_2,
			&i.TelegramNumber,
			&i.ID_4,
			&i.Role,
			&i.CreatedAt_4,
			&i.UpdatedAt_4,
			&i.DepartmentID,
			&i.RoleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTernary = `-- name: GetAllTernary :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section
Where sub_section_button_id = $1
`

func (q *Queries) GetAllTernary(ctx context.Context, subSectionButtonID int64) ([]SubSection, error) {
	rows, err := q.db.Query(ctx, getAllTernary, subSectionButtonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSection
	for rows.Next() {
		var i SubSection
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserNameByUserType = `-- name: GetAllUserNameByUserType :many
SELECT profiles.id AS profile_id,profiles.first_name,profiles.last_name,users.id AS user_id ,user_types.id AS user_types_id 
FROM user_types 
LEFT JOIN users ON users.user_types_id = user_types.id 
LEFT JOIN profiles ON profiles.users_id = users.id 
WHERE user_types.id = $3 and user_types_id != 6  and status != 5 and status != 6  LIMIT $1 OFFSET $2
`

type GetAllUserNameByUserTypeParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	ID     int64 `json:"id"`
}

type GetAllUserNameByUserTypeRow struct {
	ProfileID   pgtype.Int8 `json:"profile_id"`
	FirstName   pgtype.Text `json:"first_name"`
	LastName    pgtype.Text `json:"last_name"`
	UserID      pgtype.Int8 `json:"user_id"`
	UserTypesID int64       `json:"user_types_id"`
}

func (q *Queries) GetAllUserNameByUserType(ctx context.Context, arg GetAllUserNameByUserTypeParams) ([]GetAllUserNameByUserTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllUserNameByUserType, arg.Limit, arg.Offset, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserNameByUserTypeRow
	for rows.Next() {
		var i GetAllUserNameByUserTypeRow
		if err := rows.Scan(
			&i.ProfileID,
			&i.FirstName,
			&i.LastName,
			&i.UserID,
			&i.UserTypesID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserNameByUserTypeWithoutPagination = `-- name: GetAllUserNameByUserTypeWithoutPagination :many
SELECT profiles.id AS profile_id,profiles.first_name,profiles.last_name,users.id AS user_id ,user_types.id AS user_types_id 
FROM user_types 
RIGHT JOIN users ON users.user_types_id = user_types.id 
RIGHT JOIN profiles ON profiles.users_id = users.id 
WHERE user_types.id = $1 and user_types_id != 6  and status != 5 and status != 6
`

type GetAllUserNameByUserTypeWithoutPaginationRow struct {
	ProfileID   int64       `json:"profile_id"`
	FirstName   string      `json:"first_name"`
	LastName    string      `json:"last_name"`
	UserID      int64       `json:"user_id"`
	UserTypesID pgtype.Int8 `json:"user_types_id"`
}

func (q *Queries) GetAllUserNameByUserTypeWithoutPagination(ctx context.Context, id int64) ([]GetAllUserNameByUserTypeWithoutPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllUserNameByUserTypeWithoutPagination, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserNameByUserTypeWithoutPaginationRow
	for rows.Next() {
		var i GetAllUserNameByUserTypeWithoutPaginationRow
		if err := rows.Scan(
			&i.ProfileID,
			&i.FirstName,
			&i.LastName,
			&i.UserID,
			&i.UserTypesID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id FROM users
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersForInternalShareByIds = `-- name: GetAllUsersForInternalShareByIds :many
SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views,profiles.first_name,profiles.last_name,profiles.profile_image_url FROM users
INNER JOIN profiles ON users.id = profiles.users_id
WHERE users.id = ANY($1::bigint[])
ORDER BY ARRAY_POSITION($1::bigint[], users.id)
`

type GetAllUsersForInternalShareByIdsRow struct {
	ID              int64              `json:"id"`
	Email           string             `json:"email"`
	Username        string             `json:"username"`
	Password        string             `json:"password"`
	Status          int64              `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     int64              `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	IsPhoneVerified pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany   pgtype.Int8        `json:"active_company"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	ProfileViews    int64              `json:"profile_views"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	ProfileImageUrl pgtype.Text        `json:"profile_image_url"`
}

func (q *Queries) GetAllUsersForInternalShareByIds(ctx context.Context, dollar_1 []int64) ([]GetAllUsersForInternalShareByIdsRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersForInternalShareByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersForInternalShareByIdsRow
	for rows.Next() {
		var i GetAllUsersForInternalShareByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
			&i.FirstName,
			&i.LastName,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersWithUserTypes = `-- name: GetAllUsersWithUserTypes :many
SELECT users.id AS user_id,users.user_types_id,profiles.id AS profile_id,profiles.first_name,profiles.last_name FROM users 
JOIN profiles ON users.id=profiles.users_id 
WHERE users.user_types_id!=5 and user_types_id != 6  and status != 5 and status != 6
`

type GetAllUsersWithUserTypesRow struct {
	UserID      int64  `json:"user_id"`
	UserTypesID int64  `json:"user_types_id"`
	ProfileID   int64  `json:"profile_id"`
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
}

func (q *Queries) GetAllUsersWithUserTypes(ctx context.Context) ([]GetAllUsersWithUserTypesRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersWithUserTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithUserTypesRow
	for rows.Next() {
		var i GetAllUsersWithUserTypesRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserTypesID,
			&i.ProfileID,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAqaryDeletedUser = `-- name: GetAqaryDeletedUser :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE id =  $1
`

func (q *Queries) GetAqaryDeletedUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getAqaryDeletedUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getAqaryUser = `-- name: GetAqaryUser :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE id = $1 AND user_types_id = 5 and user_types_id != 6 and status != 5 and status != 6
`

func (q *Queries) GetAqaryUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getAqaryUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getAqaryUsersForContacts = `-- name: GetAqaryUsersForContacts :many
SELECT id,username FROM users
WHERE user_types_id IN (1, 2, 7)  and status != 5 and status != 6
`

type GetAqaryUsersForContactsRow struct {
	ID       int64  `json:"id"`
	Username string `json:"username"`
}

func (q *Queries) GetAqaryUsersForContacts(ctx context.Context) ([]GetAqaryUsersForContactsRow, error) {
	rows, err := q.db.Query(ctx, getAqaryUsersForContacts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAqaryUsersForContactsRow
	for rows.Next() {
		var i GetAqaryUsersForContactsRow
		if err := rows.Scan(&i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllAqaryDeletedUser = `-- name: GetCountAllAqaryDeletedUser :one
SELECT COUNT(users.id) from users 
 INNER JOIN profiles ON users.id =  profiles.users_id
 INNER JOIN roles ON users.roles_id = roles.id
 WHERE 
      ($1 = '%%'
       OR users.username ILIKE $1
       OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $1   
       OR users.email ILIKE $1
       OR users.phone_number ILIKE $1
       OR roles.role ILIKE $1
      --  OR department.title ILIKE @search
      )
AND  users.status = 6
`

// INNER JOIN department ON users.department = department.id
func (q *Queries) GetCountAllAqaryDeletedUser(ctx context.Context, search interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllAqaryDeletedUser, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllAqaryUser = `-- name: GetCountAllAqaryUser :one
SELECT COUNT(users.id) FROM users
INNER JOIN profiles ON users.id = profiles.users_id
INNER JOIN roles ON users.roles_id = roles.id
INNER JOIN department ON roles.department_id = department.id
WHERE 
   (
     $1 = '%%'
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $1   
     OR users.username ILIKE $1
     OR users.email ILIKE $1
     OR users.phone_number ILIKE $1
     OR roles.role ILIKE $1
    )
AND user_types_id != 6  and users.status not in (5,6)
`

func (q *Queries) GetCountAllAqaryUser(ctx context.Context, search interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllAqaryUser, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllAqaryUserByCountry = `-- name: GetCountAllAqaryUserByCountry :one
WITH x AS (
  SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views, countries.id as country_id
  FROM users
  LEFT JOIN profiles ON users.id = profiles.users_id
  LEFT JOIN addresses ON profiles.addresses_id = addresses.id
  LEFT JOIN countries ON addresses.countries_id = countries.id
  WHERE countries.id = $1 AND users.user_types_id = 5 and user_types_id != 6  and status != 5 and status != 6
)
SELECT COUNT(*) FROM x
`

func (q *Queries) GetCountAllAqaryUserByCountry(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllAqaryUserByCountry, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllOtherUser = `-- name: GetCountAllOtherUser :one


 


SELECT COUNT(*) FROM users Where user_types_id != 5 and user_types_id != 6  and status != 5 and status != 6
`

// SELECT COUNT(*) FROM users Where user_types_id = 5 and user_types_id != 6  and status != 5 and status != 6;
func (q *Queries) GetCountAllOtherUser(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllOtherUser)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllOtherUserByCountry = `-- name: GetCountAllOtherUserByCountry :one
WITH x AS (
  SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views, countries.id as country_id
  FROM users
  LEFT JOIN profiles ON users.id = profiles.users_id
  LEFT JOIN addresses ON profiles.addresses_id = addresses.id
  LEFT JOIN countries ON addresses.countries_id = countries.id
  WHERE countries.id = $1 AND users.user_types_id != 5 and user_types_id != 6  and status != 5 and status != 6
)
SELECT COUNT(*) FROM x
`

func (q *Queries) GetCountAllOtherUserByCountry(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllOtherUserByCountry, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllPendingUser = `-- name: GetCountAllPendingUser :one
SELECT COUNT(*) FROM users 
WHERE  status = 1 AND user_types_id = 1
`

func (q *Queries) GetCountAllPendingUser(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllPendingUser)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getListOfUsers = `-- name: GetListOfUsers :many
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE id = ANY($1::bigint[]) and user_types_id != 6 and status != 5 and status != 6
`

func (q *Queries) GetListOfUsers(ctx context.Context, dollar_1 []int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getListOfUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganization = `-- name: GetOrganization :many
SELECT profiles.id as profile_id, users.id as users_id,company_users.id as company_user_id,profiles.profile_image_url,profiles.first_name,profiles.last_name, users.email,
    CASE 
        WHEN $1::varchar = 'ar' THEN COALESCE(roles.role_ar,roles."role")
    ELSE COALESCE(roles."role", '') END::varchar AS role
FROM company_users 
JOIN users ON users.id=company_users.users_id
JOIN profiles ON users.id=profiles.users_id
JOIN roles ON roles.id=users.roles_id
WHERE company_id= $2::BIGINT
`

type GetOrganizationParams struct {
	Lang      string `json:"lang"`
	CompanyID int64  `json:"company_id"`
}

type GetOrganizationRow struct {
	ProfileID       int64       `json:"profile_id"`
	UsersID         int64       `json:"users_id"`
	CompanyUserID   int64       `json:"company_user_id"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Role            string      `json:"role"`
}

func (q *Queries) GetOrganization(ctx context.Context, arg GetOrganizationParams) ([]GetOrganizationRow, error) {
	rows, err := q.db.Query(ctx, getOrganization, arg.Lang, arg.CompanyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizationRow
	for rows.Next() {
		var i GetOrganizationRow
		if err := rows.Scan(
			&i.ProfileID,
			&i.UsersID,
			&i.CompanyUserID,
			&i.ProfileImageUrl,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOtherUser = `-- name: GetOtherUser :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE id = $1 AND user_types_id != 5 and user_types_id != 6 and status != 5 and status != 6
`

func (q *Queries) GetOtherUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getOtherUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getPendingUser = `-- name: GetPendingUser :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views from users 
where status = 1 and user_types_id != 5 AND  users.id = $1 and user_types_id != 6
`

func (q *Queries) GetPendingUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getPendingUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getSingleUsernameById = `-- name: GetSingleUsernameById :one
SELECT
    id AS user_id,
    username
FROM
    users
WHERE
    id = $1
`

type GetSingleUsernameByIdRow struct {
	UserID   int64  `json:"user_id"`
	Username string `json:"username"`
}

func (q *Queries) GetSingleUsernameById(ctx context.Context, id int64) (GetSingleUsernameByIdRow, error) {
	row := q.db.QueryRow(ctx, getSingleUsernameById, id)
	var i GetSingleUsernameByIdRow
	err := row.Scan(&i.UserID, &i.Username)
	return i, err
}

const getSuperUser = `-- name: GetSuperUser :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE user_types_id = 6
`

func (q *Queries) GetSuperUser(ctx context.Context) (User, error) {
	row := q.db.QueryRow(ctx, getSuperUser)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE id = $1 and user_types_id != 6 and status != 5 and status != 6
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getUserAddressByUserId = `-- name: GetUserAddressByUserId :one
SELECT addresses.id, addresses.countries_id, addresses.states_id, addresses.cities_id, addresses.communities_id, addresses.sub_communities_id, addresses.locations_id, addresses.created_at, addresses.updated_at, addresses.property_map_location_id, addresses.full_address, addresses.full_address_ar FROM addresses
INNER JOIN profiles ON profiles.addresses_id = addresses.id
INNER JOIN users ON users.id = profiles.users_id
WHERE users.id = $1
`

func (q *Queries) GetUserAddressByUserId(ctx context.Context, id int64) (Address, error) {
	row := q.db.QueryRow(ctx, getUserAddressByUserId, id)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunitiesID,
		&i.SubCommunitiesID,
		&i.LocationsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyMapLocationID,
		&i.FullAddress,
		&i.FullAddressAr,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE email = $1 and status != 5 and status != 6
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getUserByEmailRegardless = `-- name: GetUserByEmailRegardless :one
SELECT id, company_id, username, password, country_code, phone_number, date_of_birth, first_name, last_name, email, gender, profile_image_url, cover_image_url, about, addresses_id, is_phone_verified, is_email_verified, status, created_at, updated_at, nationality, social_login FROM platform_users
WHERE email = $1 AND company_id = $2 AND status NOT IN(5,6)
`

type GetUserByEmailRegardlessParams struct {
	Email     string      `json:"email"`
	CompanyID pgtype.Int8 `json:"company_id"`
}

func (q *Queries) GetUserByEmailRegardless(ctx context.Context, arg GetUserByEmailRegardlessParams) (PlatformUser, error) {
	row := q.db.QueryRow(ctx, getUserByEmailRegardless, arg.Email, arg.CompanyID)
	var i PlatformUser
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Username,
		&i.Password,
		&i.CountryCode,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Gender,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.About,
		&i.AddressesID,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Nationality,
		&i.SocialLogin,
	)
	return i, err
}

const getUserByEmailRegardlessSuperAdmin = `-- name: GetUserByEmailRegardlessSuperAdmin :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE email = $1 AND status NOT IN(5,6) AND user_types_id != 6
`

func (q *Queries) GetUserByEmailRegardlessSuperAdmin(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailRegardlessSuperAdmin, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE username = $1 and status != 5 and status != 6
`

func (q *Queries) GetUserByName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getUserByPhoneNumber = `-- name: GetUserByPhoneNumber :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE phone_number = $1 AND status != 5 and status != 6
`

func (q *Queries) GetUserByPhoneNumber(ctx context.Context, phoneNumber pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPhoneNumber, phoneNumber)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getUserByPhoneVerified = `-- name: GetUserByPhoneVerified :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE phone_number = $1 AND country_code = $2 AND is_verified = true and status != 5 and status != 6
`

type GetUserByPhoneVerifiedParams struct {
	PhoneNumber pgtype.Text `json:"phone_number"`
	CountryCode pgtype.Int8 `json:"country_code"`
}

func (q *Queries) GetUserByPhoneVerified(ctx context.Context, arg GetUserByPhoneVerifiedParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPhoneVerified, arg.PhoneNumber, arg.CountryCode)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getUserIDFromBrokerCompany = `-- name: GetUserIDFromBrokerCompany :one
SELECT  users_id from broker_companies Where id = $1
`

func (q *Queries) GetUserIDFromBrokerCompany(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDFromBrokerCompany, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getUserIDFromBrokerCompanyBranch = `-- name: GetUserIDFromBrokerCompanyBranch :one
SELECT users_id from broker_companies_branches Where id = $1
`

func (q *Queries) GetUserIDFromBrokerCompanyBranch(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDFromBrokerCompanyBranch, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getUserIDFromCompanies = `-- name: GetUserIDFromCompanies :one

SELECT  users_id from companies Where id = $1 and company_type = $2  LIMIT 1
`

type GetUserIDFromCompaniesParams struct {
	ID          int64 `json:"id"`
	CompanyType int64 `json:"company_type"`
}

// //! getting users from company ....
func (q *Queries) GetUserIDFromCompanies(ctx context.Context, arg GetUserIDFromCompaniesParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDFromCompanies, arg.ID, arg.CompanyType)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getUserIDFromDeveloperCompany = `-- name: GetUserIDFromDeveloperCompany :one
SELECT users_id from developer_companies Where id = $1
`

func (q *Queries) GetUserIDFromDeveloperCompany(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDFromDeveloperCompany, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getUserIDFromDeveloperCompanyBranch = `-- name: GetUserIDFromDeveloperCompanyBranch :one
SELECT users_id from developer_company_branches Where id = $1
`

func (q *Queries) GetUserIDFromDeveloperCompanyBranch(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDFromDeveloperCompanyBranch, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getUserIDFromServiceCompany = `-- name: GetUserIDFromServiceCompany :one
SELECT users_id from services_companies Where id = $1
`

func (q *Queries) GetUserIDFromServiceCompany(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDFromServiceCompany, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getUserIDFromServiceCompanyBranch = `-- name: GetUserIDFromServiceCompanyBranch :one
SELECT users_id from service_company_branches Where id = $1
`

func (q *Queries) GetUserIDFromServiceCompanyBranch(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDFromServiceCompanyBranch, id)
	var users_id int64
	err := row.Scan(&users_id)
	return users_id, err
}

const getUserIdByMobile = `-- name: GetUserIdByMobile :one
SELECT id FROM users WHERE phone_number = $1 LIMIT 1
`

func (q *Queries) GetUserIdByMobile(ctx context.Context, phoneNumber pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIdByMobile, phoneNumber)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserIdByProfileId = `-- name: GetUserIdByProfileId :one
SELECT users_id AS id FROM profiles 
INNER JOIN users ON users.id = profiles.users_id
WHERE profiles.id = $1 and user_types_id != 6 and status != 5 and status != 6
`

func (q *Queries) GetUserIdByProfileId(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIdByProfileId, id)
	err := row.Scan(&id)
	return id, err
}

const getUserInfoById = `-- name: GetUserInfoById :one
SELECT users.id AS users_id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified,
profiles.id AS profiles_id, profiles.first_name, profiles.last_name, profiles.addresses_id, profiles.profile_image_url, users.phone_number, profiles.secondary_number, profiles.whatsapp_number, profiles.show_whatsapp_number, profiles.botim_number, profiles.show_botim_number, profiles.tawasal_number, profiles.show_tawasal_number, profiles.gender, profiles.created_at, profiles.updated_at, profiles.ref_no, profiles.cover_image_url, profiles.passport_no, profiles.passport_image_url, profiles.passport_expiry_date, profiles.about, profiles.about_arabic, profiles.users_id FROM users
INNER JOIN profiles ON profiles.users_id = users.id
WHERE users.id = $1
`

type GetUserInfoByIdRow struct {
	UsersID            int64              `json:"users_id"`
	Email              string             `json:"email"`
	Username           string             `json:"username"`
	Password           string             `json:"password"`
	Status             int64              `json:"status"`
	RolesID            pgtype.Int8        `json:"roles_id"`
	UserTypesID        int64              `json:"user_types_id"`
	SocialLogin        pgtype.Text        `json:"social_login"`
	ShowHideDetails    pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince    pgtype.Timestamptz `json:"experience_since"`
	IsVerified         pgtype.Bool        `json:"is_verified"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
	PhoneNumber        pgtype.Text        `json:"phone_number"`
	IsPhoneVerified    pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified    pgtype.Bool        `json:"is_email_verified"`
	ProfilesID         int64              `json:"profiles_id"`
	FirstName          string             `json:"first_name"`
	LastName           string             `json:"last_name"`
	AddressesID        int64              `json:"addresses_id"`
	ProfileImageUrl    pgtype.Text        `json:"profile_image_url"`
	PhoneNumber_2      pgtype.Text        `json:"phone_number_2"`
	SecondaryNumber    pgtype.Text        `json:"secondary_number"`
	WhatsappNumber     pgtype.Text        `json:"whatsapp_number"`
	ShowWhatsappNumber pgtype.Bool        `json:"show_whatsapp_number"`
	BotimNumber        pgtype.Text        `json:"botim_number"`
	ShowBotimNumber    pgtype.Bool        `json:"show_botim_number"`
	TawasalNumber      pgtype.Text        `json:"tawasal_number"`
	ShowTawasalNumber  pgtype.Bool        `json:"show_tawasal_number"`
	Gender             pgtype.Int8        `json:"gender"`
	CreatedAt_2        time.Time          `json:"created_at_2"`
	UpdatedAt_2        time.Time          `json:"updated_at_2"`
	RefNo              string             `json:"ref_no"`
	CoverImageUrl      pgtype.Text        `json:"cover_image_url"`
	PassportNo         pgtype.Text        `json:"passport_no"`
	PassportImageUrl   pgtype.Text        `json:"passport_image_url"`
	PassportExpiryDate pgtype.Timestamptz `json:"passport_expiry_date"`
	About              pgtype.Text        `json:"about"`
	AboutArabic        pgtype.Text        `json:"about_arabic"`
	UsersID_2          int64              `json:"users_id_2"`
}

func (q *Queries) GetUserInfoById(ctx context.Context, id int64) (GetUserInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserInfoById, id)
	var i GetUserInfoByIdRow
	err := row.Scan(
		&i.UsersID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ProfilesID,
		&i.FirstName,
		&i.LastName,
		&i.AddressesID,
		&i.ProfileImageUrl,
		&i.PhoneNumber_2,
		&i.SecondaryNumber,
		&i.WhatsappNumber,
		&i.ShowWhatsappNumber,
		&i.BotimNumber,
		&i.ShowBotimNumber,
		&i.TawasalNumber,
		&i.ShowTawasalNumber,
		&i.Gender,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.RefNo,
		&i.CoverImageUrl,
		&i.PassportNo,
		&i.PassportImageUrl,
		&i.PassportExpiryDate,
		&i.About,
		&i.AboutArabic,
		&i.UsersID_2,
	)
	return i, err
}

const getUserRegardlessOfStatus = `-- name: GetUserRegardlessOfStatus :one
SELECT users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views,profiles.id AS profiles_id FROM users
INNER JOIN profiles ON profiles.users_id = users.id
WHERE users.id = $1
`

type GetUserRegardlessOfStatusRow struct {
	ID              int64              `json:"id"`
	Email           string             `json:"email"`
	Username        string             `json:"username"`
	Password        string             `json:"password"`
	Status          int64              `json:"status"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	UserTypesID     int64              `json:"user_types_id"`
	SocialLogin     pgtype.Text        `json:"social_login"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	IsVerified      pgtype.Bool        `json:"is_verified"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	IsPhoneVerified pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany   pgtype.Int8        `json:"active_company"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	ProfileViews    int64              `json:"profile_views"`
	ProfilesID      int64              `json:"profiles_id"`
}

// // use this one to fetch all
func (q *Queries) GetUserRegardlessOfStatus(ctx context.Context, id int64) (GetUserRegardlessOfStatusRow, error) {
	row := q.db.QueryRow(ctx, getUserRegardlessOfStatus, id)
	var i GetUserRegardlessOfStatusRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
		&i.ProfilesID,
	)
	return i, err
}

const getUserWithAdmin = `-- name: GetUserWithAdmin :one
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE id = $1 and status != 5 and status != 6
`

func (q *Queries) GetUserWithAdmin(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserWithAdmin, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const getUsernamesByUserIdsExcludingStatus6 = `-- name: GetUsernamesByUserIdsExcludingStatus6 :many
SELECT
    id AS user_id,
    username
FROM
    users
WHERE
    id IN ($1)
    AND status != 6
`

type GetUsernamesByUserIdsExcludingStatus6Row struct {
	UserID   int64  `json:"user_id"`
	Username string `json:"username"`
}

func (q *Queries) GetUsernamesByUserIdsExcludingStatus6(ctx context.Context, id int64) ([]GetUsernamesByUserIdsExcludingStatus6Row, error) {
	rows, err := q.db.Query(ctx, getUsernamesByUserIdsExcludingStatus6, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsernamesByUserIdsExcludingStatus6Row
	for rows.Next() {
		var i GetUsernamesByUserIdsExcludingStatus6Row
		if err := rows.Scan(&i.UserID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectBrokerBranchCompany = `-- name: RejectBrokerBranchCompany :one
Update broker_companies_branches 
SET status = 3
Where id = $1
RETURNING id, broker_companies_id, company_name, description, logo_url, addresses_id, email, phone_number, whatsapp_number, commercial_license_no, commercial_license_file_url, commercial_license_expiry, rera_no, rera_file_url, rera_expiry, is_verified, website_url, cover_image_url, tag_line, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, twitter_profile_url, no_of_employees, users_id, linkedin_profile_url, bank_account_details_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, rera_registration_date, rera_issue_date, commercial_license_registration_date, commercial_license_issue_date, extra_license_names, extra_license_files, extra_license_nos, extra_license_issue_date, extra_license_expiry_date, youtube_profile_url, orn_license_no, orn_license_file_url, orn_registration_date, orn_license_expiry, created_by, trakhees_permit_no, license_dcci_no, register_no, other_social_media
`

func (q *Queries) RejectBrokerBranchCompany(ctx context.Context, id int64) (BrokerCompaniesBranch, error) {
	row := q.db.QueryRow(ctx, rejectBrokerBranchCompany, id)
	var i BrokerCompaniesBranch
	err := row.Scan(
		&i.ID,
		&i.BrokerCompaniesID,
		&i.CompanyName,
		&i.Description,
		&i.LogoUrl,
		&i.AddressesID,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.CommercialLicenseNo,
		&i.CommercialLicenseFileUrl,
		&i.CommercialLicenseExpiry,
		&i.ReraNo,
		&i.ReraFileUrl,
		&i.ReraExpiry,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.TagLine,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
		&i.FacebookProfileUrl,
		&i.InstagramProfileUrl,
		&i.TwitterProfileUrl,
		&i.NoOfEmployees,
		&i.UsersID,
		&i.LinkedinProfileUrl,
		&i.BankAccountDetailsID,
		&i.CompanyRank,
		&i.Status,
		&i.CountryID,
		&i.CompanyType,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.ReraRegistrationDate,
		&i.ReraIssueDate,
		&i.CommercialLicenseRegistrationDate,
		&i.CommercialLicenseIssueDate,
		&i.ExtraLicenseNames,
		&i.ExtraLicenseFiles,
		&i.ExtraLicenseNos,
		&i.ExtraLicenseIssueDate,
		&i.ExtraLicenseExpiryDate,
		&i.YoutubeProfileUrl,
		&i.OrnLicenseNo,
		&i.OrnLicenseFileUrl,
		&i.OrnRegistrationDate,
		&i.OrnLicenseExpiry,
		&i.CreatedBy,
		&i.TrakheesPermitNo,
		&i.LicenseDcciNo,
		&i.RegisterNo,
		&i.OtherSocialMedia,
	)
	return i, err
}

const rejectBrokerCompany = `-- name: RejectBrokerCompany :one


Update broker_companies 
SET status  = 3
Where id = $1
RETURNING id, company_name, description, logo_url, addresses_id, email, phone_number, whatsapp_number, commercial_license_no, commercial_license_file_url, commercial_license_expiry, rera_no, rera_file_url, rera_expiry, is_verified, website_url, cover_image_url, tag_line, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, twitter_profile_url, no_of_employees, users_id, linkedin_profile_url, bank_account_details_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, rera_registration_date, rera_issue_date, commercial_license_registration_date, commercial_license_issue_date, extra_license_nos, extra_license_files, extra_license_names, extra_license_issue_date, extra_license_expiry_date, license_dcci_no, register_no, other_social_media, youtube_profile_url, orn_license_no, orn_license_file_url, orn_registration_date, orn_license_expiry, created_by, trakhees_permit_no
`

// -------------------------------
func (q *Queries) RejectBrokerCompany(ctx context.Context, id int64) (BrokerCompany, error) {
	row := q.db.QueryRow(ctx, rejectBrokerCompany, id)
	var i BrokerCompany
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.Description,
		&i.LogoUrl,
		&i.AddressesID,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.CommercialLicenseNo,
		&i.CommercialLicenseFileUrl,
		&i.CommercialLicenseExpiry,
		&i.ReraNo,
		&i.ReraFileUrl,
		&i.ReraExpiry,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.TagLine,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
		&i.FacebookProfileUrl,
		&i.InstagramProfileUrl,
		&i.TwitterProfileUrl,
		&i.NoOfEmployees,
		&i.UsersID,
		&i.LinkedinProfileUrl,
		&i.BankAccountDetailsID,
		&i.CompanyRank,
		&i.Status,
		&i.CountryID,
		&i.CompanyType,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.ReraRegistrationDate,
		&i.ReraIssueDate,
		&i.CommercialLicenseRegistrationDate,
		&i.CommercialLicenseIssueDate,
		&i.ExtraLicenseNos,
		&i.ExtraLicenseFiles,
		&i.ExtraLicenseNames,
		&i.ExtraLicenseIssueDate,
		&i.ExtraLicenseExpiryDate,
		&i.LicenseDcciNo,
		&i.RegisterNo,
		&i.OtherSocialMedia,
		&i.YoutubeProfileUrl,
		&i.OrnLicenseNo,
		&i.OrnLicenseFileUrl,
		&i.OrnRegistrationDate,
		&i.OrnLicenseExpiry,
		&i.CreatedBy,
		&i.TrakheesPermitNo,
	)
	return i, err
}

const rejectDeveloperBranchCompany = `-- name: RejectDeveloperBranchCompany :one
Update developer_company_branches 
SET status = 3
Where id = $1
RETURNING id, developer_companies_id, company_name, tag_line, commercial_license_no, commercial_license_file_url, commercial_license_expiry, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, linkedin_profile_url, twitter_profile_url, users_id, bank_account_details_id, no_of_employees, logo_url, cover_image_url, description, is_verified, website_url, phone_number, email, whatsapp_number, addresses_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, commercial_license_registration_date, commercial_license_issue_date, extra_license_names, extra_license_files, extra_license_nos, extra_license_issue_date, extra_license_expiry_date, youtube_profile_url, created_by, license_dcci_no, register_no, other_social_media
`

func (q *Queries) RejectDeveloperBranchCompany(ctx context.Context, id int64) (DeveloperCompanyBranch, error) {
	row := q.db.QueryRow(ctx, rejectDeveloperBranchCompany, id)
	var i DeveloperCompanyBranch
	err := row.Scan(
		&i.ID,
		&i.DeveloperCompaniesID,
		&i.CompanyName,
		&i.TagLine,
		&i.CommercialLicenseNo,
		&i.CommercialLicenseFileUrl,
		&i.CommercialLicenseExpiry,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
		&i.FacebookProfileUrl,
		&i.InstagramProfileUrl,
		&i.LinkedinProfileUrl,
		&i.TwitterProfileUrl,
		&i.UsersID,
		&i.BankAccountDetailsID,
		&i.NoOfEmployees,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.Description,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.PhoneNumber,
		&i.Email,
		&i.WhatsappNumber,
		&i.AddressesID,
		&i.CompanyRank,
		&i.Status,
		&i.CountryID,
		&i.CompanyType,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.CommercialLicenseRegistrationDate,
		&i.CommercialLicenseIssueDate,
		&i.ExtraLicenseNames,
		&i.ExtraLicenseFiles,
		&i.ExtraLicenseNos,
		&i.ExtraLicenseIssueDate,
		&i.ExtraLicenseExpiryDate,
		&i.YoutubeProfileUrl,
		&i.CreatedBy,
		&i.LicenseDcciNo,
		&i.RegisterNo,
		&i.OtherSocialMedia,
	)
	return i, err
}

const rejectDeveloperCompany = `-- name: RejectDeveloperCompany :one
Update developer_companies 
SET status  = 3
Where id = $1
RETURNING id, company_name, tag_line, commercial_license_no, commercial_license_file_url, commercial_license_expiry, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, linkedin_profile_url, twitter_profile_url, users_id, bank_account_details_id, no_of_employees, logo_url, cover_image_url, description, is_verified, website_url, phone_number, email, whatsapp_number, addresses_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, commercial_license_registration_date, commercial_license_issue_date, extra_license_nos, extra_license_files, extra_license_names, extra_license_issue_date, extra_license_expiry_date, license_dcci_no, register_no, other_social_media, youtube_profile_url, created_by
`

func (q *Queries) RejectDeveloperCompany(ctx context.Context, id int64) (DeveloperCompany, error) {
	row := q.db.QueryRow(ctx, rejectDeveloperCompany, id)
	var i DeveloperCompany
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.TagLine,
		&i.CommercialLicenseNo,
		&i.CommercialLicenseFileUrl,
		&i.CommercialLicenseExpiry,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
		&i.FacebookProfileUrl,
		&i.InstagramProfileUrl,
		&i.LinkedinProfileUrl,
		&i.TwitterProfileUrl,
		&i.UsersID,
		&i.BankAccountDetailsID,
		&i.NoOfEmployees,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.Description,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.PhoneNumber,
		&i.Email,
		&i.WhatsappNumber,
		&i.AddressesID,
		&i.CompanyRank,
		&i.Status,
		&i.CountryID,
		&i.CompanyType,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.CommercialLicenseRegistrationDate,
		&i.CommercialLicenseIssueDate,
		&i.ExtraLicenseNos,
		&i.ExtraLicenseFiles,
		&i.ExtraLicenseNames,
		&i.ExtraLicenseIssueDate,
		&i.ExtraLicenseExpiryDate,
		&i.LicenseDcciNo,
		&i.RegisterNo,
		&i.OtherSocialMedia,
		&i.YoutubeProfileUrl,
		&i.CreatedBy,
	)
	return i, err
}

const rejectServiceBranchCompany = `-- name: RejectServiceBranchCompany :one
Update service_company_branches 
SET status  = 3
Where id = $1
RETURNING id, services_companies_id, company_name, description, logo_url, addresses_id, email, phone_number, whatsapp_number, commercial_license_no, commercial_license_file_url, commercial_license_expiry, is_verified, website_url, cover_image_url, tag_line, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, twitter_profile_url, no_of_employees, users_id, linkedin_profile_url, bank_account_details_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, commercial_license_registration_date, commercial_license_issue_date, extra_license_names, extra_license_files, extra_license_nos, extra_license_issue_date, extra_license_expiry_date, youtube_profile_url, created_by, license_dcci_no, register_no, other_social_media
`

func (q *Queries) RejectServiceBranchCompany(ctx context.Context, id int64) (ServiceCompanyBranch, error) {
	row := q.db.QueryRow(ctx, rejectServiceBranchCompany, id)
	var i ServiceCompanyBranch
	err := row.Scan(
		&i.ID,
		&i.ServicesCompaniesID,
		&i.CompanyName,
		&i.Description,
		&i.LogoUrl,
		&i.AddressesID,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.CommercialLicenseNo,
		&i.CommercialLicenseFileUrl,
		&i.CommercialLicenseExpiry,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.TagLine,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
		&i.FacebookProfileUrl,
		&i.InstagramProfileUrl,
		&i.TwitterProfileUrl,
		&i.NoOfEmployees,
		&i.UsersID,
		&i.LinkedinProfileUrl,
		&i.BankAccountDetailsID,
		&i.CompanyRank,
		&i.Status,
		&i.CountryID,
		&i.CompanyType,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.CommercialLicenseRegistrationDate,
		&i.CommercialLicenseIssueDate,
		&i.ExtraLicenseNames,
		&i.ExtraLicenseFiles,
		&i.ExtraLicenseNos,
		&i.ExtraLicenseIssueDate,
		&i.ExtraLicenseExpiryDate,
		&i.YoutubeProfileUrl,
		&i.CreatedBy,
		&i.LicenseDcciNo,
		&i.RegisterNo,
		&i.OtherSocialMedia,
	)
	return i, err
}

const rejectServiceCompany = `-- name: RejectServiceCompany :one
Update services_companies 
SET status  = 3
Where id = $1
RETURNING id, company_name, description, logo_url, addresses_id, email, phone_number, whatsapp_number, commercial_license_no, commercial_license_file_url, commercial_license_expiry, is_verified, website_url, cover_image_url, tag_line, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, twitter_profile_url, no_of_employees, users_id, linkedin_profile_url, bank_account_details_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, commercial_license_registration_date, commercial_license_issue_date, youtube_profile_url, created_by, extra_license_nos, extra_license_files, extra_license_names, extra_license_issue_date, extra_license_expiry_date, license_dcci_no, register_no, other_social_media
`

func (q *Queries) RejectServiceCompany(ctx context.Context, id int64) (ServicesCompany, error) {
	row := q.db.QueryRow(ctx, rejectServiceCompany, id)
	var i ServicesCompany
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.Description,
		&i.LogoUrl,
		&i.AddressesID,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.CommercialLicenseNo,
		&i.CommercialLicenseFileUrl,
		&i.CommercialLicenseExpiry,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.TagLine,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
		&i.FacebookProfileUrl,
		&i.InstagramProfileUrl,
		&i.TwitterProfileUrl,
		&i.NoOfEmployees,
		&i.UsersID,
		&i.LinkedinProfileUrl,
		&i.BankAccountDetailsID,
		&i.CompanyRank,
		&i.Status,
		&i.CountryID,
		&i.CompanyType,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.CommercialLicenseRegistrationDate,
		&i.CommercialLicenseIssueDate,
		&i.YoutubeProfileUrl,
		&i.CreatedBy,
		&i.ExtraLicenseNos,
		&i.ExtraLicenseFiles,
		&i.ExtraLicenseNames,
		&i.ExtraLicenseIssueDate,
		&i.ExtraLicenseExpiryDate,
		&i.LicenseDcciNo,
		&i.RegisterNo,
		&i.OtherSocialMedia,
	)
	return i, err
}

const updateActiveCompany = `-- name: UpdateActiveCompany :one
UPDATE users 
SET active_company = $1
WHERE id = $2
RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

type UpdateActiveCompanyParams struct {
	ActiveCompany pgtype.Int8 `json:"active_company"`
	ID            int64       `json:"id"`
}

func (q *Queries) UpdateActiveCompany(ctx context.Context, arg UpdateActiveCompanyParams) (User, error) {
	row := q.db.QueryRow(ctx, updateActiveCompany, arg.ActiveCompany, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const updatePlatformUserPassword = `-- name: UpdatePlatformUserPassword :one
Update platform_users
SET password = $2
WHERE id = $1 
RETURNING id, company_id, username, password, country_code, phone_number, date_of_birth, first_name, last_name, email, gender, profile_image_url, cover_image_url, about, addresses_id, is_phone_verified, is_email_verified, status, created_at, updated_at, nationality, social_login
`

type UpdatePlatformUserPasswordParams struct {
	ID       int64  `json:"id"`
	Password string `json:"password"`
}

func (q *Queries) UpdatePlatformUserPassword(ctx context.Context, arg UpdatePlatformUserPasswordParams) (PlatformUser, error) {
	row := q.db.QueryRow(ctx, updatePlatformUserPassword, arg.ID, arg.Password)
	var i PlatformUser
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Username,
		&i.Password,
		&i.CountryCode,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Gender,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.About,
		&i.AddressesID,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Nationality,
		&i.SocialLogin,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET  
    roles_id = $2,  
    show_hide_details = $3,
    experience_since = $4,  
    updated_at = $5,
    phone_number = $6,
    username=$7,
    country_code = $8
Where id = $1
RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

type UpdateUserParams struct {
	ID              int64              `json:"id"`
	RolesID         pgtype.Int8        `json:"roles_id"`
	ShowHideDetails pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince pgtype.Timestamptz `json:"experience_since"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
	Username        string             `json:"username"`
	CountryCode     pgtype.Int8        `json:"country_code"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.RolesID,
		arg.ShowHideDetails,
		arg.ExperienceSince,
		arg.UpdatedAt,
		arg.PhoneNumber,
		arg.Username,
		arg.CountryCode,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const updateUserCounterView = `-- name: UpdateUserCounterView :exec
UPDATE users
SET 
    profile_views=profile_views+$2 
WHERE
    id=$1
`

type UpdateUserCounterViewParams struct {
	ID           int64 `json:"id"`
	ProfileViews int64 `json:"profile_views"`
}

func (q *Queries) UpdateUserCounterView(ctx context.Context, arg UpdateUserCounterViewParams) error {
	_, err := q.db.Exec(ctx, updateUserCounterView, arg.ID, arg.ProfileViews)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
Update users
SET password = $2
WHERE id = $1 
RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

type UpdateUserPasswordParams struct {
	ID       int64  `json:"id"`
	Password string `json:"password"`
}

// ! TODO:  uncomment this later.
// and user_types_id != 6
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.ID, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const updateUserPermission = `-- name: UpdateUserPermission :one
UPDATE user_company_permissions
 SET permissions_id = $2,
    sub_sections_id =  $3
 where user_id =$1
RETURNING id, user_id, company_id, permissions_id, sub_sections_id
`

type UpdateUserPermissionParams struct {
	UserID        int64   `json:"user_id"`
	PermissionsID []int64 `json:"permissions_id"`
	SubSectionsID []int64 `json:"sub_sections_id"`
}

func (q *Queries) UpdateUserPermission(ctx context.Context, arg UpdateUserPermissionParams) (UserCompanyPermission, error) {
	row := q.db.QueryRow(ctx, updateUserPermission, arg.UserID, arg.PermissionsID, arg.SubSectionsID)
	var i UserCompanyPermission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.PermissionsID,
		&i.SubSectionsID,
	)
	return i, err
}

const updateUserStatus = `-- name: UpdateUserStatus :one
Update users
SET status=$2,
updated_at = $3
Where id = $1
RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

type UpdateUserStatusParams struct {
	ID        int64     `json:"id"`
	Status    int64     `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserStatus, arg.ID, arg.Status, arg.UpdatedAt)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const updateUserStatusWithoutUpdateTime = `-- name: UpdateUserStatusWithoutUpdateTime :one
Update users
SET status=$2 
Where id = $1
RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

type UpdateUserStatusWithoutUpdateTimeParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

func (q *Queries) UpdateUserStatusWithoutUpdateTime(ctx context.Context, arg UpdateUserStatusWithoutUpdateTimeParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserStatusWithoutUpdateTime, arg.ID, arg.Status)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}

const verifyAndAvailableUser = `-- name: VerifyAndAvailableUser :one
UPDATE users
SET status = 8,
is_verified = TRUE
WHERE id = $1
RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

func (q *Queries) VerifyAndAvailableUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, verifyAndAvailableUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}
