// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sub_community_settings.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubCommunitySettings = `-- name: CreateSubCommunitySettings :one
INSERT INTO
    sub_communities (
        sub_community,
        communities_id,
        sub_community_ar,
        created_at,
        updated_at,
        status,
        updated_by
    )
SELECT
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
FROM 
	communities WHERE id= $2::BIGINT and status !=6 RETURNING 1
`

type CreateSubCommunitySettingsParams struct {
	SubCommunity   string      `json:"sub_community"`
	CommunitiesID  pgtype.Int8 `json:"communities_id"`
	SubCommunityAr pgtype.Text `json:"sub_community_ar"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	Status         int64       `json:"status"`
	UpdatedBy      int64       `json:"updated_by"`
}

func (q *Queries) CreateSubCommunitySettings(ctx context.Context, arg CreateSubCommunitySettingsParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, createSubCommunitySettings,
		arg.SubCommunity,
		arg.CommunitiesID,
		arg.SubCommunityAr,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.UpdatedBy,
	)
	var column_1 pgtype.Int8
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteRestoreSubCommunitySettings = `-- name: DeleteRestoreSubCommunitySettings :one
UPDATE sub_communities 
SET 
    status = $4::BIGINT,
    updated_at = $2, 
    updated_by=$3
WHERE 
    id = $1 RETURNING id
`

type DeleteRestoreSubCommunitySettingsParams struct {
	ID        int64     `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
	UpdatedBy int64     `json:"updated_by"`
	Status    int64     `json:"status"`
}

func (q *Queries) DeleteRestoreSubCommunitySettings(ctx context.Context, arg DeleteRestoreSubCommunitySettingsParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteRestoreSubCommunitySettings,
		arg.ID,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAllSubCommunitiesSettings = `-- name: GetAllSubCommunitiesSettings :many
SELECT
    sub_communities.id AS "sub_community_id",
    sub_communities.sub_community,
    sub_communities.sub_community_ar,
    communities.community,
    communities.community_ar,
    cities.city,
    cities.city_ar,
    states."state",
    states.state_ar,
    countries.country,
    countries.country_ar
FROM
    sub_communities
    INNER JOIN communities ON communities.id=sub_communities.communities_id
    INNER JOIN cities ON cities.id = communities.cities_id
    INNER JOIN states ON states.id = cities.states_id
    INNER JOIN countries ON countries.id = states.countries_id
WHERE 
    ($1::BIGINT = 6 AND sub_communities.status = 6) 
    OR ($1::BIGINT != 6 AND sub_communities.status IN (1, 2))
ORDER BY
    sub_communities.updated_at DESC
LIMIT $3 OFFSET $2
`

type GetAllSubCommunitiesSettingsParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllSubCommunitiesSettingsRow struct {
	SubCommunityID int64       `json:"sub_community_id"`
	SubCommunity   string      `json:"sub_community"`
	SubCommunityAr pgtype.Text `json:"sub_community_ar"`
	Community      string      `json:"community"`
	CommunityAr    pgtype.Text `json:"community_ar"`
	City           string      `json:"city"`
	CityAr         pgtype.Text `json:"city_ar"`
	State          string      `json:"state"`
	StateAr        pgtype.Text `json:"state_ar"`
	Country        string      `json:"country"`
	CountryAr      pgtype.Text `json:"country_ar"`
}

func (q *Queries) GetAllSubCommunitiesSettings(ctx context.Context, arg GetAllSubCommunitiesSettingsParams) ([]GetAllSubCommunitiesSettingsRow, error) {
	rows, err := q.db.Query(ctx, getAllSubCommunitiesSettings, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubCommunitiesSettingsRow
	for rows.Next() {
		var i GetAllSubCommunitiesSettingsRow
		if err := rows.Scan(
			&i.SubCommunityID,
			&i.SubCommunity,
			&i.SubCommunityAr,
			&i.Community,
			&i.CommunityAr,
			&i.City,
			&i.CityAr,
			&i.State,
			&i.StateAr,
			&i.Country,
			&i.CountryAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOfSubCommunitiesSettings = `-- name: GetNumberOfSubCommunitiesSettings :one
SELECT COUNT(*)
FROM
    sub_communities
    INNER JOIN communities ON communities.id=sub_communities.communities_id
    INNER JOIN cities ON cities.id = communities.cities_id
    INNER JOIN states ON states.id = cities.states_id
    INNER JOIN countries ON countries.id = states.countries_id
WHERE 
    ($1::BIGINT = 6 AND sub_communities.status = 6) 
    OR ($1::BIGINT != 6 AND sub_communities.status IN (1, 2))
`

func (q *Queries) GetNumberOfSubCommunitiesSettings(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOfSubCommunitiesSettings, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSubCommunitySettingsByID = `-- name: GetSubCommunitySettingsByID :one
SELECT
	sub_communities.id AS "sub_community_id",
	sub_communities.sub_community,
	sub_communities.sub_community_ar,
    communities.id AS "community_id",
    communities.community,
    communities.community_ar,
    cities.id AS "city_id",
    cities.city,
    cities.city_ar,
    states.id AS "state_id",
    states."state",
    states.state_ar,
    countries.id AS "country_id",
    countries.country,
    countries.country_ar
FROM
    sub_communities
    INNER JOIN communities ON communities.id=sub_communities.communities_id
    INNER JOIN cities ON cities.id = communities.cities_id
    INNER JOIN states ON states.id = cities.states_id
    INNER JOIN countries ON countries.id = states.countries_id
WHERE
    sub_communities.id = $1
    AND sub_communities.status != 6
`

type GetSubCommunitySettingsByIDRow struct {
	SubCommunityID int64       `json:"sub_community_id"`
	SubCommunity   string      `json:"sub_community"`
	SubCommunityAr pgtype.Text `json:"sub_community_ar"`
	CommunityID    int64       `json:"community_id"`
	Community      string      `json:"community"`
	CommunityAr    pgtype.Text `json:"community_ar"`
	CityID         int64       `json:"city_id"`
	City           string      `json:"city"`
	CityAr         pgtype.Text `json:"city_ar"`
	StateID        int64       `json:"state_id"`
	State          string      `json:"state"`
	StateAr        pgtype.Text `json:"state_ar"`
	CountryID      int64       `json:"country_id"`
	Country        string      `json:"country"`
	CountryAr      pgtype.Text `json:"country_ar"`
}

func (q *Queries) GetSubCommunitySettingsByID(ctx context.Context, id int64) (GetSubCommunitySettingsByIDRow, error) {
	row := q.db.QueryRow(ctx, getSubCommunitySettingsByID, id)
	var i GetSubCommunitySettingsByIDRow
	err := row.Scan(
		&i.SubCommunityID,
		&i.SubCommunity,
		&i.SubCommunityAr,
		&i.CommunityID,
		&i.Community,
		&i.CommunityAr,
		&i.CityID,
		&i.City,
		&i.CityAr,
		&i.StateID,
		&i.State,
		&i.StateAr,
		&i.CountryID,
		&i.Country,
		&i.CountryAr,
	)
	return i, err
}

const getSubCommunitySettingsForUpdate = `-- name: GetSubCommunitySettingsForUpdate :one
SELECT id,sub_community,communities_id 
FROM 
    sub_communities
WHERE 
    id=$1 AND status!=6
`

type GetSubCommunitySettingsForUpdateRow struct {
	ID            int64       `json:"id"`
	SubCommunity  string      `json:"sub_community"`
	CommunitiesID pgtype.Int8 `json:"communities_id"`
}

func (q *Queries) GetSubCommunitySettingsForUpdate(ctx context.Context, id int64) (GetSubCommunitySettingsForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getSubCommunitySettingsForUpdate, id)
	var i GetSubCommunitySettingsForUpdateRow
	err := row.Scan(&i.ID, &i.SubCommunity, &i.CommunitiesID)
	return i, err
}

const updateSubCommunitySettings = `-- name: UpdateSubCommunitySettings :one
Update
    sub_communities
SET
    sub_community = $2,
    sub_community_ar= $6,
    communities_id = $3,
    updated_at = $4,
    updated_by = $5
WHERE
    sub_communities.id = $1
    AND sub_communities.status != 6
    AND (
        
        $3 = communities_id
        OR EXISTS (SELECT 1 FROM communities WHERE id = $3 AND status != 6)
        
    )RETURNING id
`

type UpdateSubCommunitySettingsParams struct {
	ID             int64       `json:"id"`
	SubCommunity   string      `json:"sub_community"`
	CommunitiesID  pgtype.Int8 `json:"communities_id"`
	UpdatedAt      time.Time   `json:"updated_at"`
	UpdatedBy      int64       `json:"updated_by"`
	SubCommunityAr pgtype.Text `json:"sub_community_ar"`
}

func (q *Queries) UpdateSubCommunitySettings(ctx context.Context, arg UpdateSubCommunitySettingsParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateSubCommunitySettings,
		arg.ID,
		arg.SubCommunity,
		arg.CommunitiesID,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.SubCommunityAr,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
