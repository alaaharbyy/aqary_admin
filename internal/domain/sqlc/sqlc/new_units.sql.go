// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: new_units.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkIfUnitNoExist = `-- name: CheckIfUnitNoExist :one
SELECT EXISTS(
    SELECT 1 FROM units
    WHERE CASE WHEN $4::bigint = 0 THEN unit_no = $1 AND entity_id = $2 AND entity_type_id = $3 -- for create new unit case
    ELSE id != $4::bigint AND unit_no = $1 AND entity_id = $2 AND entity_type_id = $3 END -- for update unit case
)::boolean
`

type CheckIfUnitNoExistParams struct {
	UnitNo       string      `json:"unit_no"`
	EntityID     pgtype.Int8 `json:"entity_id"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	UnitID       int64       `json:"unit_id"`
}

func (q *Queries) CheckIfUnitNoExist(ctx context.Context, arg CheckIfUnitNoExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfUnitNoExist,
		arg.UnitNo,
		arg.EntityID,
		arg.EntityTypeID,
		arg.UnitID,
	)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createUnitVersion = `-- name: CreateUnitVersion :one
INSERT INTO unit_versions (
 title,
 title_arabic, 
 description,  
 description_arabic , 
 unit_id,  
 ref_no, 
 status, 
 type, 
 unit_rank,  
 created_at, 
 updated_at, 
 created_by, 
 updated_by, 
 facts, 
 listed_by, 
 is_verified,
 is_main,
exclusive,
start_date,
end_date,
refreshed_at
)VALUES (
	 $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16,$17,$18,$19,$20,$21
) RETURNING id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type CreateUnitVersionParams struct {
	Title             string             `json:"title"`
	TitleArabic       pgtype.Text        `json:"title_arabic"`
	Description       string             `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	UnitID            int64              `json:"unit_id"`
	RefNo             string             `json:"ref_no"`
	Status            int64              `json:"status"`
	Type              int64              `json:"type"`
	UnitRank          int64              `json:"unit_rank"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	CreatedBy         int64              `json:"created_by"`
	UpdatedBy         int64              `json:"updated_by"`
	Facts             []byte             `json:"facts"`
	ListedBy          int64              `json:"listed_by"`
	IsVerified        bool               `json:"is_verified"`
	IsMain            bool               `json:"is_main"`
	Exclusive         bool               `json:"exclusive"`
	StartDate         pgtype.Date        `json:"start_date"`
	EndDate           pgtype.Date        `json:"end_date"`
	RefreshedAt       pgtype.Timestamptz `json:"refreshed_at"`
}

func (q *Queries) CreateUnitVersion(ctx context.Context, arg CreateUnitVersionParams) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, createUnitVersion,
		arg.Title,
		arg.TitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.UnitID,
		arg.RefNo,
		arg.Status,
		arg.Type,
		arg.UnitRank,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.Facts,
		arg.ListedBy,
		arg.IsVerified,
		arg.IsMain,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.RefreshedAt,
	)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const createUnits = `-- name: CreateUnits :one
INSERT INTO units(
	unit_no,
	unitno_is_public,
	notes,
	notes_arabic,
	notes_public,
	is_verified,
    unit_title,
    description, 
    unit_title_arabic,
    description_arabic,
    created_at,
	updated_at,
	addresses_id,
    unit_type_id, 
    created_by,
    updated_by,
	type_name_id,
 	owner_users_id,
	from_xml,
    company_id,
    status,
    facts,
	entity_type_id,
	entity_id,
	is_project_unit
) VALUES(
	$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25
) RETURNING id, unit_no, unitno_is_public, notes, unit_title, description, description_arabic, unit_title_arabic, notes_arabic, notes_public, is_verified, entity_type_id, entity_id, created_at, updated_at, addresses_id, unit_type_id, created_by, updated_by, type_name_id, owner_users_id, from_xml, company_id, status, facts, is_project_unit, exclusive, start_date, end_date
`

type CreateUnitsParams struct {
	UnitNo            string      `json:"unit_no"`
	UnitnoIsPublic    pgtype.Bool `json:"unitno_is_public"`
	Notes             string      `json:"notes"`
	NotesArabic       string      `json:"notes_arabic"`
	NotesPublic       pgtype.Bool `json:"notes_public"`
	IsVerified        pgtype.Bool `json:"is_verified"`
	UnitTitle         string      `json:"unit_title"`
	Description       string      `json:"description"`
	UnitTitleArabic   string      `json:"unit_title_arabic"`
	DescriptionArabic string      `json:"description_arabic"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	AddressesID       int64       `json:"addresses_id"`
	UnitTypeID        int64       `json:"unit_type_id"`
	CreatedBy         int64       `json:"created_by"`
	UpdatedBy         int64       `json:"updated_by"`
	TypeNameID        pgtype.Int8 `json:"type_name_id"`
	OwnerUsersID      pgtype.Int8 `json:"owner_users_id"`
	FromXml           pgtype.Bool `json:"from_xml"`
	CompanyID         pgtype.Int8 `json:"company_id"`
	Status            int64       `json:"status"`
	Facts             []byte      `json:"facts"`
	EntityTypeID      pgtype.Int8 `json:"entity_type_id"`
	EntityID          pgtype.Int8 `json:"entity_id"`
	IsProjectUnit     pgtype.Bool `json:"is_project_unit"`
}

func (q *Queries) CreateUnits(ctx context.Context, arg CreateUnitsParams) (Unit, error) {
	row := q.db.QueryRow(ctx, createUnits,
		arg.UnitNo,
		arg.UnitnoIsPublic,
		arg.Notes,
		arg.NotesArabic,
		arg.NotesPublic,
		arg.IsVerified,
		arg.UnitTitle,
		arg.Description,
		arg.UnitTitleArabic,
		arg.DescriptionArabic,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AddressesID,
		arg.UnitTypeID,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.TypeNameID,
		arg.OwnerUsersID,
		arg.FromXml,
		arg.CompanyID,
		arg.Status,
		arg.Facts,
		arg.EntityTypeID,
		arg.EntityID,
		arg.IsProjectUnit,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.UnitTitle,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitTitleArabic,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.EntityTypeID,
		&i.EntityID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressesID,
		&i.UnitTypeID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.TypeNameID,
		&i.OwnerUsersID,
		&i.FromXml,
		&i.CompanyID,
		&i.Status,
		&i.Facts,
		&i.IsProjectUnit,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getAUnitWithID = `-- name: GetAUnitWithID :one
SELECT id, unit_no, unitno_is_public, notes, unit_title, description, description_arabic, unit_title_arabic, notes_arabic, notes_public, is_verified, entity_type_id, entity_id, created_at, updated_at, addresses_id, unit_type_id, created_by, updated_by, type_name_id, owner_users_id, from_xml, company_id, status, facts, is_project_unit, exclusive, start_date, end_date from units
WHERE units.id = $1 AND units.status = $2
`

type GetAUnitWithIDParams struct {
	UnitID int64 `json:"unit_id"`
	Status int64 `json:"status"`
}

func (q *Queries) GetAUnitWithID(ctx context.Context, arg GetAUnitWithIDParams) (Unit, error) {
	row := q.db.QueryRow(ctx, getAUnitWithID, arg.UnitID, arg.Status)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.UnitTitle,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitTitleArabic,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.EntityTypeID,
		&i.EntityID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressesID,
		&i.UnitTypeID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.TypeNameID,
		&i.OwnerUsersID,
		&i.FromXml,
		&i.CompanyID,
		&i.Status,
		&i.Facts,
		&i.IsProjectUnit,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getAUnitWithVersion = `-- name: GetAUnitWithVersion :one


SELECT unit_versions.id, title, views_count, title_arabic, unit_versions.description, unit_versions.description_arabic, unit_id, ref_no, unit_versions.status, type, unit_rank, unit_versions.created_at, unit_versions.updated_at, unit_versions.created_by, unit_versions.updated_by, unit_versions.facts, listed_by, has_gallery, has_plans, is_main, unit_versions.is_verified, unit_versions.exclusive, unit_versions.start_date, unit_versions.end_date, slug, is_hotdeal, refreshed_at, units.id, unit_no, unitno_is_public, notes, unit_title, units.description, units.description_arabic, unit_title_arabic, notes_arabic, notes_public, units.is_verified, entity_type_id, entity_id, units.created_at, units.updated_at, addresses_id, unit_type_id, units.created_by, units.updated_by, type_name_id, owner_users_id, from_xml, company_id, units.status, units.facts, is_project_unit, units.exclusive, units.start_date, units.end_date from unit_versions
INNER JOIN units ON unit_versions.unit_id =  units.id
WHERE units.id = $1 AND unit_versions.id = $2
`

type GetAUnitWithVersionParams struct {
	UnitID        int64 `json:"unit_id"`
	UnitVersionID int64 `json:"unit_version_id"`
}

type GetAUnitWithVersionRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	UnitID              int64              `json:"unit_id"`
	RefNo               string             `json:"ref_no"`
	Status              int64              `json:"status"`
	Type                int64              `json:"type"`
	UnitRank            int64              `json:"unit_rank"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	CreatedBy           int64              `json:"created_by"`
	UpdatedBy           int64              `json:"updated_by"`
	Facts               []byte             `json:"facts"`
	ListedBy            int64              `json:"listed_by"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	UnitNo              string             `json:"unit_no"`
	UnitnoIsPublic      pgtype.Bool        `json:"unitno_is_public"`
	Notes               string             `json:"notes"`
	UnitTitle           string             `json:"unit_title"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 string             `json:"description_arabic_2"`
	UnitTitleArabic     string             `json:"unit_title_arabic"`
	NotesArabic         string             `json:"notes_arabic"`
	NotesPublic         pgtype.Bool        `json:"notes_public"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	EntityTypeID        pgtype.Int8        `json:"entity_type_id"`
	EntityID            pgtype.Int8        `json:"entity_id"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	AddressesID         int64              `json:"addresses_id"`
	UnitTypeID          int64              `json:"unit_type_id"`
	CreatedBy_2         int64              `json:"created_by_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	TypeNameID          pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	Status_2            int64              `json:"status_2"`
	Facts_2             []byte             `json:"facts_2"`
	IsProjectUnit       pgtype.Bool        `json:"is_project_unit"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

// SELECT COUNT(*) FROM unit_versions
// INNER JOIN units ON unit_versions.unit_id = units.id
// INNER JOIN addresses ON units.addresses_id = addresses.id
// LEFT JOIN companies ON units.company_id = companies.id
// WHERE unit_versions."type" = @type AND units.is_project_unit = @is_project_unit
//
//	AND CASE WHEN @is_company_user != true THEN true ELSE companies.id = @company_id::bigint   END
//	AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id = @country_id::bigint END
//	AND CASE WHEN @states_id::bigint = 0 Then true ELSE addresses.states_id = @states_id::bigint END
//	AND CASE WHEN @cities_id::bigint = 0 Then true ELSE addresses.cities_id = @cities_id::bigint END
//	AND CASE WHEN @communities_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
//	AND CASE WHEN @sub_communities_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint END
//
// AND CASE WHEN @status::bigint = 0 THEN (unit_versions.status != ALL(ARRAY[5,6])) ELSE (unit_versions.status =  @status) END;
func (q *Queries) GetAUnitWithVersion(ctx context.Context, arg GetAUnitWithVersionParams) (GetAUnitWithVersionRow, error) {
	row := q.db.QueryRow(ctx, getAUnitWithVersion, arg.UnitID, arg.UnitVersionID)
	var i GetAUnitWithVersionRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
		&i.ID_2,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.UnitTitle,
		&i.Description_2,
		&i.DescriptionArabic_2,
		&i.UnitTitleArabic,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified_2,
		&i.EntityTypeID,
		&i.EntityID,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.AddressesID,
		&i.UnitTypeID,
		&i.CreatedBy_2,
		&i.UpdatedBy_2,
		&i.TypeNameID,
		&i.OwnerUsersID,
		&i.FromXml,
		&i.CompanyID,
		&i.Status_2,
		&i.Facts_2,
		&i.IsProjectUnit,
		&i.Exclusive_2,
		&i.StartDate_2,
		&i.EndDate_2,
	)
	return i, err
}

const getActiveGlobalPropertyTypeByType = `-- name: GetActiveGlobalPropertyTypeByType :one
SELECT id, type, code, property_type_facts, listing_facts, usage, created_at, updated_at, status, icon, is_project, type_ar FROM global_property_type 
Where TRIM(LOWER(type)) = TRIM(LOWER($2::varchar)) AND is_project IS false AND status = 2 AND usage = $1
`

type GetActiveGlobalPropertyTypeByTypeParams struct {
	Usage int64  `json:"usage"`
	Type  string `json:"type"`
}

func (q *Queries) GetActiveGlobalPropertyTypeByType(ctx context.Context, arg GetActiveGlobalPropertyTypeByTypeParams) (GlobalPropertyType, error) {
	row := q.db.QueryRow(ctx, getActiveGlobalPropertyTypeByType, arg.Usage, arg.Type)
	var i GlobalPropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.PropertyTypeFacts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.IsProject,
		&i.TypeAr,
	)
	return i, err
}

const getAllConsumeFactsCountByProjectPropertyId = `-- name: GetAllConsumeFactsCountByProjectPropertyId :one
















SELECT
    COALESCE(SUM((units.facts->> 'plot_area')::numeric), 0)::bigint AS plot_area_consume,
    COALESCE(SUM((units.facts->> 'built_up_area')::numeric), 0)::bigint AS built_up_area_consume,
    COALESCE(COUNT(units.id), 0)::bigint AS no_of_units_consume
FROM units
WHERE 
    units.status NOT IN (5,6)
    AND units.entity_id = $1 
    AND units.entity_type_id = $2
`

type GetAllConsumeFactsCountByProjectPropertyIdParams struct {
	UnitID       pgtype.Int8 `json:"unit_id"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
}

type GetAllConsumeFactsCountByProjectPropertyIdRow struct {
	PlotAreaConsume    int64 `json:"plot_area_consume"`
	BuiltUpAreaConsume int64 `json:"built_up_area_consume"`
	NoOfUnitsConsume   int64 `json:"no_of_units_consume"`
}

// -- name: GetUnitVerifyAndStatusAndRank :one
// WITH x AS(
//
//	SELECT status,unit_id,'sale' AS category
//	FROM sale_unit
//	UNION ALL
//	SELECT status,unit_id,'rent' AS category
//	FROM rent_unit
//
// )SELECT x.*,units.is_verified,units.property_unit_rank FROM x
// INNER JOIN units ON units.id = x.unit_id WHERE units.id = @unit_id AND x.category = LOWER(@category);
// -- name: CheckExistanceOfUnitByUnitId :one
// SELECT
// CASE WHEN sale_unit.unit_id = units.id THEN TRUE ELSE FALSE END AS is_sale,
// CASE WHEN rent_unit.unit_id = units.id THEN TRUE ELSE FALSE END AS is_rent,
// sale_unit.status AS sale_unit_status, rent_unit.status AS rent_unit_status,
// units.properties_id,units.property
// FROM units
// LEFT JOIN sale_unit ON sale_unit.unit_id = units.id AND sale_unit.status != 5 AND sale_unit.status != 6
// LEFT JOIN rent_unit ON rent_unit.unit_id = units.id AND rent_unit.status != 5 AND rent_unit.status != 6
// WHERE units.id = @unit_id;
// -- name: GetRentUnitByUnitID :one
// SELECT rent_unit.id AS rent_unit_id, rent_unit.title, rent_unit.title_arabic, rent_unit.description, rent_unit.description_arabic, rent_unit.unit_id,
//
//	rent_unit.unit_facts_id, rent_unit.created_at, rent_unit.updated_at, 'rent' AS category, rent_unit.status,
//	units.id AS units_id, units.unit_no,units.unitno_is_public, units.notes, units.notes_arabic, units.notes_public,
//	units.is_verified, units.amenities_id, units.property_unit_rank, units.properties_id, units.property,
//	units.created_at, units.updated_at, units.ref_no, units.addresses_id, units.countries_id, units.property_types_id,
//	units.created_by, units.property_name, units.section, units.type_name_id, units.owner_users_id, units.from_xml
//
// FROM units
// INNER JOIN rent_unit ON rent_unit.unit_id = units.id
// WHERE units.id = $1;
// -- name: GetSaleUnitByUnitID :one
// SELECT sale_unit.id AS sale_unit_id, sale_unit.title, sale_unit.title_arabic, sale_unit.description, sale_unit.description_arabic, sale_unit.unit_id,
//
//	sale_unit.unit_facts_id, sale_unit.created_at, sale_unit.updated_at, sale_unit.contract_start_datetime,
//	sale_unit.contract_end_datetime, sale_unit.contract_amount,sale_unit.contract_currency,'sale' AS category,sale_unit.status,
//	units.id AS units_id, units.unit_no,units.unitno_is_public, units.notes, units.notes_arabic, units.notes_public,
//	units.is_verified, units.amenities_id, units.property_unit_rank, units.properties_id, units.property,
//	units.created_at, units.updated_at, units.ref_no, units.addresses_id, units.countries_id, units.property_types_id,
//	units.created_by, units.property_name, units.section, units.type_name_id, units.owner_users_id, units.from_xml
//
// FROM units
// INNER JOIN sale_unit ON sale_unit.unit_id = units.id
// WHERE units.id = $1;
// -- name: UpdateSaleUnitRankByUnitID :one
// UPDATE units
// SET property_unit_rank = $2,
//
//	updated_at = $3
//
// FROM sale_unit
// WHERE sale_unit.unit_id = units.id AND sale_unit.unit_id = $1
// RETURNING *;
// -- name: UpdateRentUnitRankByUnitID :one
// UPDATE units
// SET property_unit_rank = $2,
//
//	updated_at = $3
//
// FROM rent_unit
// WHERE rent_unit.unit_id = units.id AND rent_unit.unit_id = $1
// RETURNING *;
// -- name: UpdateUnits :one
// UPDATE units
// SET	unit_no = $2,
//
//	unitno_is_public = $3,
//	notes = $4,
//	notes_arabic = $5,
//	notes_public = $6,
//	is_verified = $7,
//	amenities_id = $8,
//	property_unit_rank = $9,
//	properties_id = $10,
//	property = $11,
//	created_at = $12,
//	updated_at = $13,
//	ref_no = $14,
//	addresses_id = $15,
//	countries_id = $16,
//	property_types_id = $17,
//	created_by = $18,
//	property_name = $19,
//	section = $20,
//	type_name_id = $21,
//	owner_users_id = $22,
//	from_xml = $23
//
// WHERE id = $1 RETURNING *;
func (q *Queries) GetAllConsumeFactsCountByProjectPropertyId(ctx context.Context, arg GetAllConsumeFactsCountByProjectPropertyIdParams) (GetAllConsumeFactsCountByProjectPropertyIdRow, error) {
	row := q.db.QueryRow(ctx, getAllConsumeFactsCountByProjectPropertyId, arg.UnitID, arg.EntityTypeID)
	var i GetAllConsumeFactsCountByProjectPropertyIdRow
	err := row.Scan(&i.PlotAreaConsume, &i.BuiltUpAreaConsume, &i.NoOfUnitsConsume)
	return i, err
}

const getAllDeletedUnits = `-- name: GetAllDeletedUnits :many
select uv.ref_no,pr.project_name,pr1.project_name,ph.phase_name,u.unit_title,l.lat,l.lng from unit_versions uv
left join units u on u.id=uv.unit_id
left join property p on p.id =u.entity_id and u.entity_type_id =3 
left join phases ph on ph.id = p.entity_id and p.entity_type_id=2
left join projects pr1 on pr1.id=ph.projects_id
left join projects pr on pr.id = p.entity_id and p.entity_type_id =1
left join addresses a on a.id = u.addresses_id
left join locations l on l.id = a.locations_id
where uv.status=6
`

type GetAllDeletedUnitsRow struct {
	RefNo         string      `json:"ref_no"`
	ProjectName   pgtype.Text `json:"project_name"`
	ProjectName_2 pgtype.Text `json:"project_name_2"`
	PhaseName     pgtype.Text `json:"phase_name"`
	UnitTitle     pgtype.Text `json:"unit_title"`
	Lat           pgtype.Text `json:"lat"`
	Lng           pgtype.Text `json:"lng"`
}

func (q *Queries) GetAllDeletedUnits(ctx context.Context) ([]GetAllDeletedUnitsRow, error) {
	rows, err := q.db.Query(ctx, getAllDeletedUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDeletedUnitsRow
	for rows.Next() {
		var i GetAllDeletedUnitsRow
		if err := rows.Scan(
			&i.RefNo,
			&i.ProjectName,
			&i.ProjectName_2,
			&i.PhaseName,
			&i.UnitTitle,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnitVersion = `-- name: GetAllUnitVersion :many
SELECT unit_versions.id, unit_versions.title, unit_versions.views_count, unit_versions.title_arabic, unit_versions.description, unit_versions.description_arabic, unit_versions.unit_id, unit_versions.ref_no, unit_versions.status, unit_versions.type, unit_versions.unit_rank, unit_versions.created_at, unit_versions.updated_at, unit_versions.created_by, unit_versions.updated_by, unit_versions.facts, unit_versions.listed_by, unit_versions.has_gallery, unit_versions.has_plans, unit_versions.is_main, unit_versions.is_verified, unit_versions.exclusive, unit_versions.start_date, unit_versions.end_date, unit_versions.slug, unit_versions.is_hotdeal, unit_versions.refreshed_at, units.id, units.unit_no, units.unitno_is_public, units.notes, units.unit_title, units.description, units.description_arabic, units.unit_title_arabic, units.notes_arabic, units.notes_public, units.is_verified, units.entity_type_id, units.entity_id, units.created_at, units.updated_at, units.addresses_id, units.unit_type_id, units.created_by, units.updated_by, units.type_name_id, units.owner_users_id, units.from_xml, units.company_id, units.status, units.facts, units.is_project_unit, units.exclusive, units.start_date, units.end_date,projects.project_name,phases.phase_name,property.property_name,property.id as prop_id,addresses.full_address,unit_type.type as unit_type,unit_type.type_ar as unit_type_ar, unit_type.facts as unit_type_fact,
refresh_schedules.next_run_at AS next_run_at

FROM unit_versions
 LEFT JOIN refresh_schedules ON refresh_schedules.entity_type_id= $3::BIGINT AND refresh_schedules.entity_id= unit_versions.id AND refresh_schedules.status not in (5,6)
 INNER JOIN units ON unit_versions.unit_id = units.id
 INNER JOIN addresses ON units.addresses_id = addresses.id
 LEFT JOIN companies ON units.company_id = companies.id
 LEFT JOIN company_users ON company_users.users_id = unit_versions.listed_by
 LEFT JOIN countries ON addresses.countries_id = countries.id
 LEFT JOIN states ON addresses.states_id = states.id
 LEFT JOIN cities ON addresses.cities_id = cities.id
 LEFT JOIN communities ON addresses.communities_id =  communities.id
 LEFT JOIN sub_communities ON addresses.sub_communities_id =  sub_communities.id 
 LEFT JOIN property ON units.entity_id = property.id AND units.entity_type_id = 3 --  for units
 LEFT JOIN unit_type ON units.unit_type_id = unit_type.id
 LEFT JOIN phases ON property.entity_type_id = 2 AND phases.id = property.entity_id -- attach phase
 LEFT JOIN projects ON (property.entity_type_id = 1 AND projects.id = property.entity_id) OR (phases.projects_id = projects.id) -- attach project
WHERE 
     (
        $4::BIGINT = 0 
        OR units.company_id =  $4::BIGINT
        OR company_users.company_id =  $4::BIGINT
    )
    AND 
    (
         $5::BIGINT = 0 
        OR unit_versions.listed_by =  $5::BIGINT
    )
	AND  units.is_project_unit =  $6::boolean 
    AND CASE WHEN $7::bigint = 0 THEN true ELSE units.entity_id = $7::bigint END    
    AND CASE WHEN $8::bigint = 0 THEN true WHEN $9::bool = true THEN addresses.countries_id = $8::bigint ELSE addresses.countries_id != $8::bigint END
    AND (CASE WHEN $10::bigint= 0 THEN true ELSE (unit_versions.facts->'life_style')::bigint = $10 END)
    AND (
      $11 = '%%'
      OR  unit_versions.ref_no ILIKE $11
      OR  countries.country  ILIKE $11  
      OR  states."state" ILIKE $11
      OR  cities.city ILIKE $11
      OR  communities.community ILIKE $11
      OR  sub_communities.sub_community ILIKE $11
         ------
       OR units.facts->>'built_up_area'::TEXT ILIKE $11     
       OR units.facts->>'plot_area'::TEXT ILIKE $11
       -- for ownership and status 
      OR ( CASE 
          WHEN  'Freehold' ILIKE $11 THEN  (unit_versions.facts->>'ownership')::bigint = 1
          WHEN  'GCC Citizen'  ILIKE $11 THEN (unit_versions.facts->>'ownership')::bigint = 2
          WHEN  'Leasehold' ILIKE $11 THEN (unit_versions.facts->>'ownership')::bigint = 3
          WHEN  'Local Citizen' ILIKE $11 THEN (unit_versions.facts->>'ownership')::bigint = 4
          WHEN  'USUFRUCT' ILIKE $11 THEN (unit_versions.facts->>'ownership')::bigint = 5
          WHEN  'Other' ILIKE $11 THEN (unit_versions.facts->>'ownership')::bigint = 6
          WHEN  'draft' ILIKE $11 THEN unit_versions.status = 1
          WHEN  'available' ILIKE $11 THEN unit_versions.status = 2
          WHEN  'rented' ILIKE $11 THEN unit_versions.status = 4
          WHEN  'blocked' ILIKE $11 THEN unit_versions.status = 5
        ELSE FALSE
      END)
       OR (units.facts->>'parking')::TEXT ILIKE $11
       OR (unit_versions.facts->>'price')::TEXT  ILIKE $11
       OR (unit_versions.facts->>'service_charge')::TEXT  ILIKE $11
      OR property.property_name ILIKE $11 --  how can fetch this .....             
   )
 --  older version --------
  AND (case when $12::bigint=0 then true else unit_versions."type" = $12::BIGINT end)
AND CASE WHEN $13::bigint = 0 THEN (unit_versions.status != ALL(ARRAY[5,6])) ELSE (unit_versions.status =  $13) END
ORDER BY unit_versions.updated_at DESC
LIMIT $2 OFFSET $1
`

type GetAllUnitVersionParams struct {
	Offset                int32       `json:"offset"`
	Limit                 int32       `json:"limit"`
	UnitVersionEntityType int64       `json:"unit_version_entity_type"`
	CompanyID             int64       `json:"company_id"`
	AgentID               int64       `json:"agent_id"`
	IsProject             bool        `json:"is_project"`
	PropertyID            int64       `json:"property_id"`
	CountryID             int64       `json:"country_id"`
	IsLocal               pgtype.Bool `json:"is_local"`
	LifeStyle             int64       `json:"life_style"`
	Search                interface{} `json:"search"`
	UnitType              int64       `json:"unit_type"`
	Status                int64       `json:"status"`
}

type GetAllUnitVersionRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	UnitID              int64              `json:"unit_id"`
	RefNo               string             `json:"ref_no"`
	Status              int64              `json:"status"`
	Type                int64              `json:"type"`
	UnitRank            int64              `json:"unit_rank"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	CreatedBy           int64              `json:"created_by"`
	UpdatedBy           int64              `json:"updated_by"`
	Facts               []byte             `json:"facts"`
	ListedBy            int64              `json:"listed_by"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	UnitNo              string             `json:"unit_no"`
	UnitnoIsPublic      pgtype.Bool        `json:"unitno_is_public"`
	Notes               string             `json:"notes"`
	UnitTitle           string             `json:"unit_title"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 string             `json:"description_arabic_2"`
	UnitTitleArabic     string             `json:"unit_title_arabic"`
	NotesArabic         string             `json:"notes_arabic"`
	NotesPublic         pgtype.Bool        `json:"notes_public"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	EntityTypeID        pgtype.Int8        `json:"entity_type_id"`
	EntityID            pgtype.Int8        `json:"entity_id"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	AddressesID         int64              `json:"addresses_id"`
	UnitTypeID          int64              `json:"unit_type_id"`
	CreatedBy_2         int64              `json:"created_by_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	TypeNameID          pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	Status_2            int64              `json:"status_2"`
	Facts_2             []byte             `json:"facts_2"`
	IsProjectUnit       pgtype.Bool        `json:"is_project_unit"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	ProjectName         pgtype.Text        `json:"project_name"`
	PhaseName           pgtype.Text        `json:"phase_name"`
	PropertyName        pgtype.Text        `json:"property_name"`
	PropID              pgtype.Int8        `json:"prop_id"`
	FullAddress         pgtype.Text        `json:"full_address"`
	UnitType            pgtype.Text        `json:"unit_type"`
	UnitTypeAr          pgtype.Text        `json:"unit_type_ar"`
	UnitTypeFact        []byte             `json:"unit_type_fact"`
	NextRunAt           pgtype.Timestamptz `json:"next_run_at"`
}

// OR unit_type."type" ILIKE  @search
func (q *Queries) GetAllUnitVersion(ctx context.Context, arg GetAllUnitVersionParams) ([]GetAllUnitVersionRow, error) {
	rows, err := q.db.Query(ctx, getAllUnitVersion,
		arg.Offset,
		arg.Limit,
		arg.UnitVersionEntityType,
		arg.CompanyID,
		arg.AgentID,
		arg.IsProject,
		arg.PropertyID,
		arg.CountryID,
		arg.IsLocal,
		arg.LifeStyle,
		arg.Search,
		arg.UnitType,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUnitVersionRow
	for rows.Next() {
		var i GetAllUnitVersionRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.UnitID,
			&i.RefNo,
			&i.Status,
			&i.Type,
			&i.UnitRank,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.Facts,
			&i.ListedBy,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.UnitNo,
			&i.UnitnoIsPublic,
			&i.Notes,
			&i.UnitTitle,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.UnitTitleArabic,
			&i.NotesArabic,
			&i.NotesPublic,
			&i.IsVerified_2,
			&i.EntityTypeID,
			&i.EntityID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.AddressesID,
			&i.UnitTypeID,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
			&i.TypeNameID,
			&i.OwnerUsersID,
			&i.FromXml,
			&i.CompanyID,
			&i.Status_2,
			&i.Facts_2,
			&i.IsProjectUnit,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
			&i.ProjectName,
			&i.PhaseName,
			&i.PropertyName,
			&i.PropID,
			&i.FullAddress,
			&i.UnitType,
			&i.UnitTypeAr,
			&i.UnitTypeFact,
			&i.NextRunAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnitVersions = `-- name: GetAllUnitVersions :many
SELECT uv.id, title, views_count, title_arabic, uv.description, uv.description_arabic, unit_id, ref_no, uv.status, type, unit_rank, uv.created_at, uv.updated_at, uv.created_by, uv.updated_by, uv.facts, listed_by, has_gallery, has_plans, is_main, uv.is_verified, uv.exclusive, uv.start_date, uv.end_date, slug, is_hotdeal, refreshed_at, u.id, unit_no, unitno_is_public, notes, unit_title, u.description, u.description_arabic, unit_title_arabic, notes_arabic, notes_public, u.is_verified, entity_type_id, entity_id, u.created_at, u.updated_at, addresses_id, unit_type_id, u.created_by, u.updated_by, type_name_id, owner_users_id, from_xml, company_id, u.status, u.facts, is_project_unit, u.exclusive, u.start_date, u.end_date FROM unit_versions uv
inner join units u on uv.unit_id = u.id
WHERE uv.status!=6 and u.status!=6
`

type GetAllUnitVersionsRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	UnitID              int64              `json:"unit_id"`
	RefNo               string             `json:"ref_no"`
	Status              int64              `json:"status"`
	Type                int64              `json:"type"`
	UnitRank            int64              `json:"unit_rank"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	CreatedBy           int64              `json:"created_by"`
	UpdatedBy           int64              `json:"updated_by"`
	Facts               []byte             `json:"facts"`
	ListedBy            int64              `json:"listed_by"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	UnitNo              string             `json:"unit_no"`
	UnitnoIsPublic      pgtype.Bool        `json:"unitno_is_public"`
	Notes               string             `json:"notes"`
	UnitTitle           string             `json:"unit_title"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 string             `json:"description_arabic_2"`
	UnitTitleArabic     string             `json:"unit_title_arabic"`
	NotesArabic         string             `json:"notes_arabic"`
	NotesPublic         pgtype.Bool        `json:"notes_public"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	EntityTypeID        pgtype.Int8        `json:"entity_type_id"`
	EntityID            pgtype.Int8        `json:"entity_id"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	AddressesID         int64              `json:"addresses_id"`
	UnitTypeID          int64              `json:"unit_type_id"`
	CreatedBy_2         int64              `json:"created_by_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	TypeNameID          pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	Status_2            int64              `json:"status_2"`
	Facts_2             []byte             `json:"facts_2"`
	IsProjectUnit       pgtype.Bool        `json:"is_project_unit"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

func (q *Queries) GetAllUnitVersions(ctx context.Context) ([]GetAllUnitVersionsRow, error) {
	rows, err := q.db.Query(ctx, getAllUnitVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUnitVersionsRow
	for rows.Next() {
		var i GetAllUnitVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.UnitID,
			&i.RefNo,
			&i.Status,
			&i.Type,
			&i.UnitRank,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.Facts,
			&i.ListedBy,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.UnitNo,
			&i.UnitnoIsPublic,
			&i.Notes,
			&i.UnitTitle,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.UnitTitleArabic,
			&i.NotesArabic,
			&i.NotesPublic,
			&i.IsVerified_2,
			&i.EntityTypeID,
			&i.EntityID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.AddressesID,
			&i.UnitTypeID,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
			&i.TypeNameID,
			&i.OwnerUsersID,
			&i.FromXml,
			&i.CompanyID,
			&i.Status_2,
			&i.Facts_2,
			&i.IsProjectUnit,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnitVersionsIdS = `-- name: GetAllUnitVersionsIdS :many
SELECT id FROM unit_versions
`

func (q *Queries) GetAllUnitVersionsIdS(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllUnitVersionsIdS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllUnitVersion = `-- name: GetCountAllUnitVersion :one



SELECT COUNT(unit_versions.id) FROM unit_versions
 INNER JOIN units ON unit_versions.unit_id = units.id
 INNER JOIN addresses ON units.addresses_id = addresses.id
 LEFT JOIN companies ON units.company_id = companies.id
 LEFT JOIN company_users ON company_users.users_id = unit_versions.listed_by
 LEFT JOIN countries ON addresses.countries_id = countries.id
 LEFT JOIN states ON addresses.states_id = states.id
 LEFT JOIN cities ON addresses.cities_id = cities.id
 LEFT JOIN communities ON addresses.communities_id =  communities.id
 LEFT JOIN sub_communities ON addresses.sub_communities_id =  sub_communities.id 
 LEFT JOIN property ON units.entity_id = property.id AND units.entity_type_id = 3 --  for units
 LEFT JOIN unit_type ON units.unit_type_id = unit_type.id
 LEFT JOIN phases ON property.entity_type_id = 2 AND phases.id = property.entity_id -- attach phase
 LEFT JOIN projects ON (property.entity_type_id = 1 AND projects.id = property.entity_id) OR (phases.projects_id = projects.id) -- attach project
WHERE 
     (
        $1::BIGINT = 0 
        OR units.company_id =  $1::BIGINT
        OR company_users.company_id =  $1::BIGINT
    )
    AND 
    (
         $2::BIGINT = 0 
        OR unit_versions.listed_by =  $2::BIGINT
    )
	AND  units.is_project_unit =  $3::boolean 
    AND CASE WHEN $4::bigint = 0 THEN true ELSE units.entity_id = $4::bigint END    
    AND CASE WHEN $5::bigint = 0 THEN true WHEN $6::bool = true THEN addresses.countries_id = $5::bigint ELSE addresses.countries_id != $5::bigint END
    AND (CASE WHEN $7::bigint= 0 THEN true ELSE (unit_versions.facts->'life_style')::bigint = $7 END)
    AND (
      $8 = '%%'
      OR  unit_versions.ref_no ILIKE $8
      OR  countries.country  ILIKE $8  
      OR  states."state" ILIKE $8
      OR  cities.city ILIKE $8
      OR  communities.community ILIKE $8
      OR  sub_communities.sub_community ILIKE $8
         ------
       OR units.facts->>'built_up_area'::TEXT ILIKE $8     
       OR units.facts->>'plot_area'::TEXT ILIKE $8
       -- for ownership and status 
      OR ( CASE 
          WHEN  'Freehold' ILIKE $8 THEN  (unit_versions.facts->>'ownership')::bigint = 1
          WHEN  'GCC Citizen'  ILIKE $8 THEN (unit_versions.facts->>'ownership')::bigint = 2
          WHEN  'Leasehold' ILIKE $8 THEN (unit_versions.facts->>'ownership')::bigint = 3
          WHEN  'Local Citizen' ILIKE $8 THEN (unit_versions.facts->>'ownership')::bigint = 4
          WHEN  'USUFRUCT' ILIKE $8 THEN (unit_versions.facts->>'ownership')::bigint = 5
          WHEN  'Other' ILIKE $8 THEN (unit_versions.facts->>'ownership')::bigint = 6
          WHEN  'draft' ILIKE $8 THEN unit_versions.status = 1
          WHEN  'available' ILIKE $8 THEN unit_versions.status = 2
          WHEN  'rented' ILIKE $8 THEN unit_versions.status = 4
          WHEN  'blocked' ILIKE $8 THEN unit_versions.status = 5
        ELSE FALSE
      END)
       OR (units.facts->>'parking')::TEXT ILIKE $8
       OR (unit_versions.facts->>'price')::TEXT  ILIKE $8
       OR (unit_versions.facts->>'service_charge')::TEXT  ILIKE $8
      OR property.property_name ILIKE $8 --  how can fetch this .....             
   )
 --  older version --------
  AND (case when $9::bigint=0 then true else unit_versions."type" = $9::BIGINT end)
AND CASE WHEN $10::bigint = 0 THEN (unit_versions.status != ALL(ARRAY[5,6])) ELSE (unit_versions.status =  $10) END
`

type GetCountAllUnitVersionParams struct {
	CompanyID  int64       `json:"company_id"`
	AgentID    int64       `json:"agent_id"`
	IsProject  bool        `json:"is_project"`
	PropertyID int64       `json:"property_id"`
	CountryID  int64       `json:"country_id"`
	IsLocal    pgtype.Bool `json:"is_local"`
	LifeStyle  int64       `json:"life_style"`
	Search     interface{} `json:"search"`
	UnitType   int64       `json:"unit_type"`
	Status     int64       `json:"status"`
}

// SELECT unit_versions.*, units.* FROM unit_versions
// INNER JOIN units ON unit_versions.unit_id = units.id
// INNER JOIN addresses ON units.addresses_id = addresses.id
// LEFT JOIN companies ON units.company_id = companies.id
// WHERE unit_versions."type" = @type AND units.is_project_unit = @is_project_unit
//
//	AND CASE WHEN @is_company_user != true THEN true ELSE companies.id = @company_id::bigint   END
//	AND CASE WHEN @country_id::bigint = 0 THEN true ELSE addresses.countries_id = @country_id::bigint END
//	AND CASE WHEN @states_id::bigint = 0 Then true ELSE addresses.states_id = @states_id::bigint END
//	AND CASE WHEN @cities_id::bigint = 0 Then true ELSE addresses.cities_id = @cities_id::bigint END
//	AND CASE WHEN @communities_id::bigint = 0 THEN true ELSE addresses.communities_id = @community_id::bigint END
//	AND CASE WHEN @sub_communities_id::bigint = 0 THEN true ELSE addresses.sub_communities_id = @sub_community_id::bigint END
//
// --   AND (unit_versions.status NOT IN (@status::bigint[]))
// --  AND   (unit_versions.status != ALL(@status::bigint[]))
//
//	AND CASE WHEN @status::bigint = 0 THEN (unit_versions.status != ALL(ARRAY[5,6])) ELSE (unit_versions.status =  @status) END
//
// LIMIT $1 OFFSET $2;
//
//	OR unit_type."type" ILIKE  @search
func (q *Queries) GetCountAllUnitVersion(ctx context.Context, arg GetCountAllUnitVersionParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllUnitVersion,
		arg.CompanyID,
		arg.AgentID,
		arg.IsProject,
		arg.PropertyID,
		arg.CountryID,
		arg.IsLocal,
		arg.LifeStyle,
		arg.Search,
		arg.UnitType,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFirstUnitVersionWithUnitID = `-- name: GetFirstUnitVersionWithUnitID :one
SELECT id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at from unit_versions uv
WHERE uv.unit_id = $1 
ORDER BY uv.created_at ASC
LIMIT 1
`

func (q *Queries) GetFirstUnitVersionWithUnitID(ctx context.Context, unitID int64) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, getFirstUnitVersionWithUnitID, unitID)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const getGlobalPropertyByID = `-- name: GetGlobalPropertyByID :one








SELECT id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date FROM property
Where id = $1
`

// WITH x AS(
// SELECT id,unit_id,'sale' AS category
// FROM sale_unit
// WHERE status != 6
// UNION ALL
// SELECT id,unit_id,'rent' AS category
// FROM rent_unit
// WHERE status != 6
// ) SELECT
// COALESCE(SUM(unit_facts.plot_area), 0)::bigint AS plot_area_consume,
// COALESCE(SUM(unit_facts.built_up_area), 0)::bigint AS built_up_area_consume,
// COALESCE(COUNT(x.id), 0)::bigint AS no_of_units_consume
// FROM x
// INNER JOIN unit_facts ON unit_facts.unit_id = x.unit_id AND unit_facts.category = x.category
// INNER JOIN units ON units.id = x.unit_id
// WHERE units.properties_id = $1 AND units.property = 1;
// -- name: GetAllProjectUnitsByStatus :many
// SELECT
//
//	x.*,
//	units.ref_no,
//	units.property_name,
//	units.addresses_id,
//	units.properties_id,
//	units.property_types_id,
//	projects.project_name,
//	property_types."type" AS unit_type,
//	phases.phase_name,
//	countries.country,
//	states."state",
//	cities.city,
//	communities.community,
//	sub_communities.sub_community
//
// FROM (
//
//	SELECT
//	    sale_unit.unit_id,
//	    'sale'::varchar AS category,
//	    sale_unit.title,
//	    sale_unit.status
//	FROM
//	    sale_unit
//	WHERE
//	    sale_unit.status = $3
//	UNION ALL
//	SELECT
//	    rent_unit.unit_id,
//	    'rent'::varchar AS category,
//	    rent_unit.title,
//	    rent_unit.status
//	FROM
//	    rent_unit
//	WHERE
//	    rent_unit.status = $3
//
// ) AS x
// INNER JOIN units ON units.id = x.unit_id
// INNER JOIN property_types ON property_types.id = units.property_types_id
// INNER JOIN project_properties ON project_properties.id = units.properties_id
//
//	AND units.property = 1
//
// LEFT JOIN phases ON phases.id = project_properties.phases_id
// LEFT JOIN projects ON projects.id = project_properties.projects_id
//
//	AND project_properties.phases_id IS NULL
//
// LEFT JOIN addresses ON addresses.id = units.addresses_id
// LEFT JOIN countries ON countries.id = addresses.countries_id
// LEFT JOIN states ON states.id = addresses.states_id
// LEFT JOIN cities ON cities.id = addresses.cities_id
// LEFT JOIN communities ON communities.id = addresses.communities_id
// LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
// LEFT JOIN unit_facts ON units.id = unit_facts.unit_id
// WHERE (
//
//	@search = '%%'
//	OR units.ref_no ILIKE @search
//	OR countries.country ILIKE @search
//	OR states."state" ILIKE @search
//	OR cities.city ILIKE @search
//	OR communities.community ILIKE @search
//	OR sub_communities.sub_community ILIKE @search
//	OR units.property_name ILIKE @search
//	OR unit_facts.built_up_area::TEXT ILIKE @search
//	OR unit_facts.plot_area::TEXT ILIKE @search
//	OR (CASE
//	    WHEN 'Freehold' ILIKE @search THEN unit_facts.ownership = 1
//	    WHEN 'GCC Citizen' ILIKE @search THEN unit_facts.ownership = 2
//	    WHEN 'Leasehold' ILIKE @search THEN unit_facts.ownership = 3
//	    WHEN 'Local Citizen' ILIKE @search THEN unit_facts.ownership = 4
//	    WHEN 'USUFRUCT' ILIKE @search THEN unit_facts.ownership = 5
//	    WHEN 'Other' ILIKE @search THEN unit_facts.ownership = 6
//	    WHEN 'draft' ILIKE @search THEN x.status = 1
//	    WHEN 'available' ILIKE @search THEN x.status = 2
//	    WHEN 'rented' ILIKE @search THEN x.status = 4
//	    WHEN 'blocked' ILIKE @search THEN x.status = 5
//	    ELSE FALSE
//	END)
//	OR unit_facts.category ILIKE @search
//	OR unit_facts.parking::TEXT ILIKE @search
//	OR unit_facts.price::TEXT ILIKE @search
//	OR unit_facts.service_charge::TEXT ILIKE @search
//	OR property_types."type" ILIKE @search
//
// )
// ORDER BY units.created_at DESC
// LIMIT $1 OFFSET $2;
func (q *Queries) GetGlobalPropertyByID(ctx context.Context, id int64) (Property, error) {
	row := q.db.QueryRow(ctx, getGlobalPropertyByID, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getGlobalPropertyTypeByID = `-- name: GetGlobalPropertyTypeByID :one
SELECT id, type, code, property_type_facts, listing_facts, usage, created_at, updated_at, status, icon, is_project, type_ar FROM global_property_type 
Where id = $1
`

func (q *Queries) GetGlobalPropertyTypeByID(ctx context.Context, id int64) (GlobalPropertyType, error) {
	row := q.db.QueryRow(ctx, getGlobalPropertyTypeByID, id)
	var i GlobalPropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.PropertyTypeFacts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.IsProject,
		&i.TypeAr,
	)
	return i, err
}

const getLocationByAddressID = `-- name: GetLocationByAddressID :one
SELECT a.id, countries_id, states_id, cities_id, communities_id, sub_communities_id, locations_id, a.created_at, a.updated_at, property_map_location_id, full_address, full_address_ar, l.id, lat, lng, l.created_at, l.updated_at from addresses a inner join locations l on a.locations_id = l.id
WHERE a.id = $1
`

type GetLocationByAddressIDRow struct {
	ID                    int64       `json:"id"`
	CountriesID           pgtype.Int8 `json:"countries_id"`
	StatesID              pgtype.Int8 `json:"states_id"`
	CitiesID              pgtype.Int8 `json:"cities_id"`
	CommunitiesID         pgtype.Int8 `json:"communities_id"`
	SubCommunitiesID      pgtype.Int8 `json:"sub_communities_id"`
	LocationsID           pgtype.Int8 `json:"locations_id"`
	CreatedAt             time.Time   `json:"created_at"`
	UpdatedAt             time.Time   `json:"updated_at"`
	PropertyMapLocationID pgtype.Int8 `json:"property_map_location_id"`
	FullAddress           pgtype.Text `json:"full_address"`
	FullAddressAr         pgtype.Text `json:"full_address_ar"`
	ID_2                  int64       `json:"id_2"`
	Lat                   string      `json:"lat"`
	Lng                   string      `json:"lng"`
	CreatedAt_2           time.Time   `json:"created_at_2"`
	UpdatedAt_2           time.Time   `json:"updated_at_2"`
}

func (q *Queries) GetLocationByAddressID(ctx context.Context, addressID int64) (GetLocationByAddressIDRow, error) {
	row := q.db.QueryRow(ctx, getLocationByAddressID, addressID)
	var i GetLocationByAddressIDRow
	err := row.Scan(
		&i.ID,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunitiesID,
		&i.SubCommunitiesID,
		&i.LocationsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyMapLocationID,
		&i.FullAddress,
		&i.FullAddressAr,
		&i.ID_2,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getLocationByAddressId = `-- name: GetLocationByAddressId :one
SELECT CONCAT_WS(', ', 
    countries.country, 
    cities.city, 
    communities.community, 
    sub_communities.sub_community
) AS combined_address
FROM addresses
LEFT JOIN countries ON addresses.countries_id = countries.id
LEFT JOIN states ON addresses.states_id = states.id
LEFT JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
WHERE addresses.id = $1 LIMIT 1
`

// states.state,
func (q *Queries) GetLocationByAddressId(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getLocationByAddressId, id)
	var combined_address string
	err := row.Scan(&combined_address)
	return combined_address, err
}

const getUnitByID = `-- name: GetUnitByID :one
SELECT id, unit_no, unitno_is_public, notes, unit_title, description, description_arabic, unit_title_arabic, notes_arabic, notes_public, is_verified, entity_type_id, entity_id, created_at, updated_at, addresses_id, unit_type_id, created_by, updated_by, type_name_id, owner_users_id, from_xml, company_id, status, facts, is_project_unit, exclusive, start_date, end_date FROM units 
WHERE id =  $1
`

func (q *Queries) GetUnitByID(ctx context.Context, id int64) (Unit, error) {
	row := q.db.QueryRow(ctx, getUnitByID, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.UnitTitle,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitTitleArabic,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.EntityTypeID,
		&i.EntityID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressesID,
		&i.UnitTypeID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.TypeNameID,
		&i.OwnerUsersID,
		&i.FromXml,
		&i.CompanyID,
		&i.Status,
		&i.Facts,
		&i.IsProjectUnit,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getUnitTypeVariation = `-- name: GetUnitTypeVariation :one
SELECT id, description, min_area, max_area, min_price, max_price, parking, balcony, bedrooms, bathroom, property_id, unit_type_id, title, image_url, description_ar, status, ref_no, created_at, updated_at, title_ar FROM unit_type_variation
WHERE id = $1
`

func (q *Queries) GetUnitTypeVariation(ctx context.Context, id int64) (UnitTypeVariation, error) {
	row := q.db.QueryRow(ctx, getUnitTypeVariation, id)
	var i UnitTypeVariation
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.MinArea,
		&i.MaxArea,
		&i.MinPrice,
		&i.MaxPrice,
		&i.Parking,
		&i.Balcony,
		&i.Bedrooms,
		&i.Bathroom,
		&i.PropertyID,
		&i.UnitTypeID,
		&i.Title,
		&i.ImageUrl,
		&i.DescriptionAr,
		&i.Status,
		&i.RefNo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const getUnitVersionById = `-- name: GetUnitVersionById :one
SELECT id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at FROM unit_versions 
WHERE id =  $1
`

func (q *Queries) GetUnitVersionById(ctx context.Context, id int64) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, getUnitVersionById, id)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const getUnitVersionByUnitId = `-- name: GetUnitVersionByUnitId :one
SELECT id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at FROM unit_versions 
WHERE unit_id =  $1
`

func (q *Queries) GetUnitVersionByUnitId(ctx context.Context, unitID int64) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, getUnitVersionByUnitId, unitID)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const getUnitVersionByUnitVersionID = `-- name: GetUnitVersionByUnitVersionID :one
SELECT unit_versions.id, title, views_count, title_arabic, unit_versions.description, unit_versions.description_arabic, unit_id, ref_no, unit_versions.status, type, unit_rank, unit_versions.created_at, unit_versions.updated_at, unit_versions.created_by, unit_versions.updated_by, unit_versions.facts, listed_by, has_gallery, has_plans, is_main, unit_versions.is_verified, unit_versions.exclusive, unit_versions.start_date, unit_versions.end_date, slug, is_hotdeal, refreshed_at, units.id, unit_no, unitno_is_public, notes, unit_title, units.description, units.description_arabic, unit_title_arabic, notes_arabic, notes_public, units.is_verified, entity_type_id, entity_id, units.created_at, units.updated_at, addresses_id, unit_type_id, units.created_by, units.updated_by, type_name_id, owner_users_id, from_xml, company_id, units.status, units.facts, is_project_unit, units.exclusive, units.start_date, units.end_date FROM unit_versions 
INNER JOIN units ON units.id = unit_versions.unit_id
WHERE unit_id =  $1
`

type GetUnitVersionByUnitVersionIDRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	UnitID              int64              `json:"unit_id"`
	RefNo               string             `json:"ref_no"`
	Status              int64              `json:"status"`
	Type                int64              `json:"type"`
	UnitRank            int64              `json:"unit_rank"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	CreatedBy           int64              `json:"created_by"`
	UpdatedBy           int64              `json:"updated_by"`
	Facts               []byte             `json:"facts"`
	ListedBy            int64              `json:"listed_by"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	UnitNo              string             `json:"unit_no"`
	UnitnoIsPublic      pgtype.Bool        `json:"unitno_is_public"`
	Notes               string             `json:"notes"`
	UnitTitle           string             `json:"unit_title"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 string             `json:"description_arabic_2"`
	UnitTitleArabic     string             `json:"unit_title_arabic"`
	NotesArabic         string             `json:"notes_arabic"`
	NotesPublic         pgtype.Bool        `json:"notes_public"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	EntityTypeID        pgtype.Int8        `json:"entity_type_id"`
	EntityID            pgtype.Int8        `json:"entity_id"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	AddressesID         int64              `json:"addresses_id"`
	UnitTypeID          int64              `json:"unit_type_id"`
	CreatedBy_2         int64              `json:"created_by_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	TypeNameID          pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	Status_2            int64              `json:"status_2"`
	Facts_2             []byte             `json:"facts_2"`
	IsProjectUnit       pgtype.Bool        `json:"is_project_unit"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

func (q *Queries) GetUnitVersionByUnitVersionID(ctx context.Context, unitID int64) (GetUnitVersionByUnitVersionIDRow, error) {
	row := q.db.QueryRow(ctx, getUnitVersionByUnitVersionID, unitID)
	var i GetUnitVersionByUnitVersionIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
		&i.ID_2,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.UnitTitle,
		&i.Description_2,
		&i.DescriptionArabic_2,
		&i.UnitTitleArabic,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified_2,
		&i.EntityTypeID,
		&i.EntityID,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.AddressesID,
		&i.UnitTypeID,
		&i.CreatedBy_2,
		&i.UpdatedBy_2,
		&i.TypeNameID,
		&i.OwnerUsersID,
		&i.FromXml,
		&i.CompanyID,
		&i.Status_2,
		&i.Facts_2,
		&i.IsProjectUnit,
		&i.Exclusive_2,
		&i.StartDate_2,
		&i.EndDate_2,
	)
	return i, err
}

const getUnitsByPropertyIDs = `-- name: GetUnitsByPropertyIDs :many
with Properties as(
	SELECT DISTINCT
	 property_versions.property_id as property_id
	FROM 
	property_versions
	WHERE property_versions.id =ANY( $2:: BIGINT[]) AND property_versions.status!=6
)  
SELECT
    unit_versions.id, 
    units.entity_id AS property_id 
FROM
    units
JOIN Properties ON units.entity_id=Properties.property_id
JOIN unit_versions ON unit_versions.unit_id=units.id
WHERE
    units.entity_type_id = $1 :: BIGINT
    AND units.status != 6 AND unit_versions.status!=6 
    AND (SELECT property.status FROM property WHERE property.id=units.entity_id )!=6
`

type GetUnitsByPropertyIDsParams struct {
	PropertyEntity     int64   `json:"property_entity"`
	PropertyVersionIds []int64 `json:"property_version_ids"`
}

type GetUnitsByPropertyIDsRow struct {
	ID         int64       `json:"id"`
	PropertyID pgtype.Int8 `json:"property_id"`
}

func (q *Queries) GetUnitsByPropertyIDs(ctx context.Context, arg GetUnitsByPropertyIDsParams) ([]GetUnitsByPropertyIDsRow, error) {
	rows, err := q.db.Query(ctx, getUnitsByPropertyIDs, arg.PropertyEntity, arg.PropertyVersionIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitsByPropertyIDsRow
	for rows.Next() {
		var i GetUnitsByPropertyIDsRow
		if err := rows.Scan(&i.ID, &i.PropertyID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUnit = `-- name: UpdateUnit :one
UPDATE units
SET unit_no = $2,
	unitno_is_public = $3,
	notes = $4,
	notes_arabic = $5,
	notes_public = $6,
	is_verified = $7,
    unit_title =  $8,
    description = $9, 
    unit_title_arabic = $10,
    description_arabic = $11,
	updated_at =  now(),
	addresses_id =  $12,
    unit_type_id = $13,
    updated_by =  $14,
	type_name_id = $15,
 	owner_users_id  =$16,
	from_xml = $17,
    company_id = $18,
    status = $19,
    facts = $20,
	entity_type_id = $21,
	entity_id = $22,
	is_project_unit = $23
Where id = $1
RETURNING id, unit_no, unitno_is_public, notes, unit_title, description, description_arabic, unit_title_arabic, notes_arabic, notes_public, is_verified, entity_type_id, entity_id, created_at, updated_at, addresses_id, unit_type_id, created_by, updated_by, type_name_id, owner_users_id, from_xml, company_id, status, facts, is_project_unit, exclusive, start_date, end_date
`

type UpdateUnitParams struct {
	ID                int64       `json:"id"`
	UnitNo            string      `json:"unit_no"`
	UnitnoIsPublic    pgtype.Bool `json:"unitno_is_public"`
	Notes             string      `json:"notes"`
	NotesArabic       string      `json:"notes_arabic"`
	NotesPublic       pgtype.Bool `json:"notes_public"`
	IsVerified        pgtype.Bool `json:"is_verified"`
	UnitTitle         string      `json:"unit_title"`
	Description       string      `json:"description"`
	UnitTitleArabic   string      `json:"unit_title_arabic"`
	DescriptionArabic string      `json:"description_arabic"`
	AddressesID       int64       `json:"addresses_id"`
	UnitTypeID        int64       `json:"unit_type_id"`
	UpdatedBy         int64       `json:"updated_by"`
	TypeNameID        pgtype.Int8 `json:"type_name_id"`
	OwnerUsersID      pgtype.Int8 `json:"owner_users_id"`
	FromXml           pgtype.Bool `json:"from_xml"`
	CompanyID         pgtype.Int8 `json:"company_id"`
	Status            int64       `json:"status"`
	Facts             []byte      `json:"facts"`
	EntityTypeID      pgtype.Int8 `json:"entity_type_id"`
	EntityID          pgtype.Int8 `json:"entity_id"`
	IsProjectUnit     pgtype.Bool `json:"is_project_unit"`
}

func (q *Queries) UpdateUnit(ctx context.Context, arg UpdateUnitParams) (Unit, error) {
	row := q.db.QueryRow(ctx, updateUnit,
		arg.ID,
		arg.UnitNo,
		arg.UnitnoIsPublic,
		arg.Notes,
		arg.NotesArabic,
		arg.NotesPublic,
		arg.IsVerified,
		arg.UnitTitle,
		arg.Description,
		arg.UnitTitleArabic,
		arg.DescriptionArabic,
		arg.AddressesID,
		arg.UnitTypeID,
		arg.UpdatedBy,
		arg.TypeNameID,
		arg.OwnerUsersID,
		arg.FromXml,
		arg.CompanyID,
		arg.Status,
		arg.Facts,
		arg.EntityTypeID,
		arg.EntityID,
		arg.IsProjectUnit,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.UnitTitle,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitTitleArabic,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.EntityTypeID,
		&i.EntityID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressesID,
		&i.UnitTypeID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.TypeNameID,
		&i.OwnerUsersID,
		&i.FromXml,
		&i.CompanyID,
		&i.Status,
		&i.Facts,
		&i.IsProjectUnit,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const updateUnitVersion = `-- name: UpdateUnitVersion :one
UPDATE  unit_versions
SET  title = $2,
 title_arabic = $3, 
 description = $4,  
 description_arabic = $5,   
 status = $6, 
 type = $7, 
 unit_rank = $8,   
 updated_at = $9, 
 updated_by = $10, 
 facts = $11, 
 listed_by = $12,
is_verified = $13
Where id =  $1
RETURNING id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type UpdateUnitVersionParams struct {
	ID                int64       `json:"id"`
	Title             string      `json:"title"`
	TitleArabic       pgtype.Text `json:"title_arabic"`
	Description       string      `json:"description"`
	DescriptionArabic pgtype.Text `json:"description_arabic"`
	Status            int64       `json:"status"`
	Type              int64       `json:"type"`
	UnitRank          int64       `json:"unit_rank"`
	UpdatedAt         time.Time   `json:"updated_at"`
	UpdatedBy         int64       `json:"updated_by"`
	Facts             []byte      `json:"facts"`
	ListedBy          int64       `json:"listed_by"`
	IsVerified        bool        `json:"is_verified"`
}

func (q *Queries) UpdateUnitVersion(ctx context.Context, arg UpdateUnitVersionParams) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, updateUnitVersion,
		arg.ID,
		arg.Title,
		arg.TitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.Status,
		arg.Type,
		arg.UnitRank,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Facts,
		arg.ListedBy,
		arg.IsVerified,
	)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const updateUnitVersionCounterView = `-- name: UpdateUnitVersionCounterView :exec
UPDATE unit_versions
SET 
    views_count=views_count+$2 
WHERE
    id=$1
`

type UpdateUnitVersionCounterViewParams struct {
	ID         int64 `json:"id"`
	ViewsCount int64 `json:"views_count"`
}

func (q *Queries) UpdateUnitVersionCounterView(ctx context.Context, arg UpdateUnitVersionCounterViewParams) error {
	_, err := q.db.Exec(ctx, updateUnitVersionCounterView, arg.ID, arg.ViewsCount)
	return err
}

const updateUnitVersionRank = `-- name: UpdateUnitVersionRank :one
UPDATE  unit_versions
SET   
   unit_rank = $2
Where id =  $1
RETURNING id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type UpdateUnitVersionRankParams struct {
	ID       int64 `json:"id"`
	UnitRank int64 `json:"unit_rank"`
}

// updated_at=now()
func (q *Queries) UpdateUnitVersionRank(ctx context.Context, arg UpdateUnitVersionRankParams) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, updateUnitVersionRank, arg.ID, arg.UnitRank)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const updateUnitVersionStatus = `-- name: UpdateUnitVersionStatus :one
UPDATE  unit_versions
SET   
   status = $2,
   facts = $3
  --  updated_at=now() 
Where id =  $1
RETURNING id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type UpdateUnitVersionStatusParams struct {
	ID     int64  `json:"id"`
	Status int64  `json:"status"`
	Facts  []byte `json:"facts"`
}

func (q *Queries) UpdateUnitVersionStatus(ctx context.Context, arg UpdateUnitVersionStatusParams) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, updateUnitVersionStatus, arg.ID, arg.Status, arg.Facts)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const updateUnitVersionType = `-- name: UpdateUnitVersionType :one
UPDATE  unit_versions
SET   
   type = $2,
   facts = $3,
   updated_at=now()
Where id =  $1
RETURNING id, title, views_count, title_arabic, description, description_arabic, unit_id, ref_no, status, type, unit_rank, created_at, updated_at, created_by, updated_by, facts, listed_by, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type UpdateUnitVersionTypeParams struct {
	ID    int64  `json:"id"`
	Type  int64  `json:"type"`
	Facts []byte `json:"facts"`
}

func (q *Queries) UpdateUnitVersionType(ctx context.Context, arg UpdateUnitVersionTypeParams) (UnitVersion, error) {
	row := q.db.QueryRow(ctx, updateUnitVersionType, arg.ID, arg.Type, arg.Facts)
	var i UnitVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitID,
		&i.RefNo,
		&i.Status,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.Facts,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const updateUnitVersionsStatusForAgent = `-- name: UpdateUnitVersionsStatusForAgent :exec
UPDATE 
	unit_versions
SET 
	status= $1::BIGINT
WHERE 
	listed_by= $2::BIGINT
`

type UpdateUnitVersionsStatusForAgentParams struct {
	Status  int64 `json:"status"`
	AgentID int64 `json:"agent_id"`
}

func (q *Queries) UpdateUnitVersionsStatusForAgent(ctx context.Context, arg UpdateUnitVersionsStatusForAgentParams) error {
	_, err := q.db.Exec(ctx, updateUnitVersionsStatusForAgent, arg.Status, arg.AgentID)
	return err
}
