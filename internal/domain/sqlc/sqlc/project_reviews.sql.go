// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_reviews.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllProjectRating = `-- name: GetAllProjectRating :many
SELECT 
COUNT(project_reviews.id) OVER() AS total_count,
	project_reviews.id,
	project_reviews.ref_no,
	projects.project_name,
	project_reviews.project_clean,
	project_reviews.project_location,
	project_reviews.project_facilities,
	project_reviews.project_securities,
	project_reviews.description,
	users.email,
	(profiles.first_name ||' '|| profiles.last_name)::varchar AS user_name,
	users.phone_number,
	project_reviews.review_date,
	project_reviews.title,
	project_reviews.proof_images
FROM project_reviews 
INNER JOIN projects ON project_reviews.projects_id = projects.id
INNER JOIN users ON project_reviews.reviewer = users.id
INNER JOIN profiles ON users.id= profiles.users_id
WHERE project_reviews.projects_id = $3 AND project_reviews.is_project = TRUE
ORDER BY project_reviews.id DESC
LIMIT $1 OFFSET $2
`

type GetAllProjectRatingParams struct {
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	ProjectsID int64 `json:"projects_id"`
}

type GetAllProjectRatingRow struct {
	TotalCount        int64       `json:"total_count"`
	ID                int64       `json:"id"`
	RefNo             string      `json:"ref_no"`
	ProjectName       string      `json:"project_name"`
	ProjectClean      float64     `json:"project_clean"`
	ProjectLocation   float64     `json:"project_location"`
	ProjectFacilities float64     `json:"project_facilities"`
	ProjectSecurities float64     `json:"project_securities"`
	Description       string      `json:"description"`
	Email             string      `json:"email"`
	UserName          string      `json:"user_name"`
	PhoneNumber       pgtype.Text `json:"phone_number"`
	ReviewDate        time.Time   `json:"review_date"`
	Title             pgtype.Text `json:"title"`
	ProofImages       []string    `json:"proof_images"`
}

func (q *Queries) GetAllProjectRating(ctx context.Context, arg GetAllProjectRatingParams) ([]GetAllProjectRatingRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectRating, arg.Limit, arg.Offset, arg.ProjectsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectRatingRow
	for rows.Next() {
		var i GetAllProjectRatingRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.RefNo,
			&i.ProjectName,
			&i.ProjectClean,
			&i.ProjectLocation,
			&i.ProjectFacilities,
			&i.ProjectSecurities,
			&i.Description,
			&i.Email,
			&i.UserName,
			&i.PhoneNumber,
			&i.ReviewDate,
			&i.Title,
			&i.ProofImages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountProjectReviews = `-- name: GetCountProjectReviews :one
select  
count (*)
from projects p 
join project_reviews pr on pr.projects_id=p.id
where p.users_id=$1 AND p.status!=6
`

func (q *Queries) GetCountProjectReviews(ctx context.Context, usersID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProjectReviews, usersID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectReviews = `-- name: GetProjectReviews :many


SELECT  
    p.id as projects_id,
    p.project_name,
    pr.id as reviews_id,
    pr.ref_no,
    pr.project_clean,
    pr.project_location,
    pr.project_facilities,
    pr.project_securities,
    pr.description as review,
    pr.reviewer,
    u.email,
    u.username
FROM 
    projects p 
JOIN 
    project_reviews pr ON pr.projects_id=p.id
JOIN 
    users u ON u.id=pr.reviewer
WHERE 
    p.users_id=$3 AND p.status!=6
LIMIT $1 OFFSET $2
`

type GetProjectReviewsParams struct {
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
	UsersID int64 `json:"users_id"`
}

type GetProjectReviewsRow struct {
	ProjectsID        int64   `json:"projects_id"`
	ProjectName       string  `json:"project_name"`
	ReviewsID         int64   `json:"reviews_id"`
	RefNo             string  `json:"ref_no"`
	ProjectClean      float64 `json:"project_clean"`
	ProjectLocation   float64 `json:"project_location"`
	ProjectFacilities float64 `json:"project_facilities"`
	ProjectSecurities float64 `json:"project_securities"`
	Review            string  `json:"review"`
	Reviewer          int64   `json:"reviewer"`
	Email             string  `json:"email"`
	Username          string  `json:"username"`
}

// -- name: UpdateProjectRatingIsVerified :one
// UPDATE project_reviews
// SET is_verified=$2
// WHERE id=$1
// RETURNING *;
// -- name: GetCounterNumberProjectRating :one
// SELECT COUNT(id)
// FROM project_reviews
// WHERE projects_id=$1 AND is_project=$2;
func (q *Queries) GetProjectReviews(ctx context.Context, arg GetProjectReviewsParams) ([]GetProjectReviewsRow, error) {
	rows, err := q.db.Query(ctx, getProjectReviews, arg.Limit, arg.Offset, arg.UsersID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectReviewsRow
	for rows.Next() {
		var i GetProjectReviewsRow
		if err := rows.Scan(
			&i.ProjectsID,
			&i.ProjectName,
			&i.ReviewsID,
			&i.RefNo,
			&i.ProjectClean,
			&i.ProjectLocation,
			&i.ProjectFacilities,
			&i.ProjectSecurities,
			&i.Review,
			&i.Reviewer,
			&i.Email,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
