// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: company_activity.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const companyCategoryExistsInActivity = `-- name: CompanyCategoryExistsInActivity :one
SELECT count(*) FROM company_activities WHERE company_category_id=$1
`

func (q *Queries) CompanyCategoryExistsInActivity(ctx context.Context, companyCategoryID int64) (int64, error) {
	row := q.db.QueryRow(ctx, companyCategoryExistsInActivity, companyCategoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCompanyActivities = `-- name: CreateCompanyActivities :one
INSERT INTO company_activities(
	company_category_id,
	activity_name,
	icon_url,
	tags,
	created_by,
	created_at,
	updated_at,
	updated_by,
    status,
	activity_name_ar, 
	description, 
	description_ar
)VALUES($1, $2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
RETURNING id, company_category_id, activity_name, icon_url, tags, created_by, created_at, updated_at, updated_by, description, description_ar, status, activity_name_ar
`

type CreateCompanyActivitiesParams struct {
	CompanyCategoryID int64       `json:"company_category_id"`
	ActivityName      string      `json:"activity_name"`
	IconUrl           pgtype.Text `json:"icon_url"`
	Tags              []string    `json:"tags"`
	CreatedBy         int64       `json:"created_by"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	UpdatedBy         pgtype.Int8 `json:"updated_by"`
	Status            int64       `json:"status"`
	ActivityNameAr    pgtype.Text `json:"activity_name_ar"`
	Description       pgtype.Text `json:"description"`
	DescriptionAr     pgtype.Text `json:"description_ar"`
}

func (q *Queries) CreateCompanyActivities(ctx context.Context, arg CreateCompanyActivitiesParams) (CompanyActivity, error) {
	row := q.db.QueryRow(ctx, createCompanyActivities,
		arg.CompanyCategoryID,
		arg.ActivityName,
		arg.IconUrl,
		arg.Tags,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
		arg.ActivityNameAr,
		arg.Description,
		arg.DescriptionAr,
	)
	var i CompanyActivity
	err := row.Scan(
		&i.ID,
		&i.CompanyCategoryID,
		&i.ActivityName,
		&i.IconUrl,
		&i.Tags,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Description,
		&i.DescriptionAr,
		&i.Status,
		&i.ActivityNameAr,
	)
	return i, err
}

const getAllActiveCompanyCategoryAndActivitiesByType = `-- name: GetAllActiveCompanyCategoryAndActivitiesByType :many
SELECT 
    company_category.id,
	CASE WHEN $2::varchar = 'ar' THEN COALESCE(company_category.category_name_ar,company_category.category_name)
    ELSE COALESCE(company_category.category_name, '') END::varchar AS company_category,

    JSON_AGG(
		JSON_BUILD_OBJECT(
			'id', company_activities.id, 
			'label',CASE WHEN $2::varchar = 'ar' THEN COALESCE(company_activities.activity_name_ar,company_activities.activity_name)
    		ELSE COALESCE(company_activities.activity_name, '') END::varchar
			 
	)) AS activities 
FROM 
    company_category
INNER JOIN 
    company_activities ON company_activities.company_category_id = company_category.id 
INNER JOIN company_types ON company_types.id = company_category.company_type
WHERE company_activities.status = 2 AND company_category.status = 2 AND company_category.company_type = $1
GROUP BY 
    company_category.id
	order by company_category.id desc
`

type GetAllActiveCompanyCategoryAndActivitiesByTypeParams struct {
	CompanyType int64  `json:"company_type"`
	Lang        string `json:"lang"`
}

type GetAllActiveCompanyCategoryAndActivitiesByTypeRow struct {
	ID              int64  `json:"id"`
	CompanyCategory string `json:"company_category"`
	Activities      []byte `json:"activities"`
}

func (q *Queries) GetAllActiveCompanyCategoryAndActivitiesByType(ctx context.Context, arg GetAllActiveCompanyCategoryAndActivitiesByTypeParams) ([]GetAllActiveCompanyCategoryAndActivitiesByTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllActiveCompanyCategoryAndActivitiesByType, arg.CompanyType, arg.Lang)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllActiveCompanyCategoryAndActivitiesByTypeRow
	for rows.Next() {
		var i GetAllActiveCompanyCategoryAndActivitiesByTypeRow
		if err := rows.Scan(&i.ID, &i.CompanyCategory, &i.Activities); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyActivities = `-- name: GetAllCompanyActivities :many
SELECT company_activities.id, company_activities.company_category_id, company_activities.activity_name, company_activities.icon_url, company_activities.tags, company_activities.created_by, company_activities.created_at, company_activities.updated_at, company_activities.updated_by, company_activities.description, company_activities.description_ar, company_activities.status, company_activities.activity_name_ar,
company_category.category_name,
company_category.category_name_ar,
company_types.id AS company_type_id, company_types.title AS company_type_title, company_types.title_ar AS company_type_title_ar, COUNT(*) OVER() AS total_count
FROM company_activities
INNER JOIN company_category ON company_category.id = company_activities.company_category_id
INNER JOIN company_types ON company_types.id = company_category.company_type
WHERE CASE WHEN $1::bigint = 0 THEN company_activities.status != 6 AND company_category.status != 6 ELSE company_activities.status = $1::bigint END
ORDER BY company_activities.id desc
LIMIT $3  
OFFSET $2
`

type GetAllCompanyActivitiesParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllCompanyActivitiesRow struct {
	ID                 int64       `json:"id"`
	CompanyCategoryID  int64       `json:"company_category_id"`
	ActivityName       string      `json:"activity_name"`
	IconUrl            pgtype.Text `json:"icon_url"`
	Tags               []string    `json:"tags"`
	CreatedBy          int64       `json:"created_by"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	UpdatedBy          pgtype.Int8 `json:"updated_by"`
	Description        pgtype.Text `json:"description"`
	DescriptionAr      pgtype.Text `json:"description_ar"`
	Status             int64       `json:"status"`
	ActivityNameAr     pgtype.Text `json:"activity_name_ar"`
	CategoryName       string      `json:"category_name"`
	CategoryNameAr     pgtype.Text `json:"category_name_ar"`
	CompanyTypeID      int64       `json:"company_type_id"`
	CompanyTypeTitle   string      `json:"company_type_title"`
	CompanyTypeTitleAr pgtype.Text `json:"company_type_title_ar"`
	TotalCount         int64       `json:"total_count"`
}

func (q *Queries) GetAllCompanyActivities(ctx context.Context, arg GetAllCompanyActivitiesParams) ([]GetAllCompanyActivitiesRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyActivities, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyActivitiesRow
	for rows.Next() {
		var i GetAllCompanyActivitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyCategoryID,
			&i.ActivityName,
			&i.IconUrl,
			&i.Tags,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Description,
			&i.DescriptionAr,
			&i.Status,
			&i.ActivityNameAr,
			&i.CategoryName,
			&i.CategoryNameAr,
			&i.CompanyTypeID,
			&i.CompanyTypeTitle,
			&i.CompanyTypeTitleAr,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompaniesCountByCategory = `-- name: GetCompaniesCountByCategory :one
SELECT COUNT(c.*) FROM companies as c
JOIN company_activities ca on ca.id=any(c.company_activities_id) 
JOIN company_category cc ON ca.company_category_id = cc.id
WHERE cc.id=$1 AND c.status!=6
`

func (q *Queries) GetCompaniesCountByCategory(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCompaniesCountByCategory, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCompanyCategoryAndAcitivites = `-- name: GetCompanyCategoryAndAcitivites :many
SELECT company_activities.id, company_activities.company_category_id, company_activities.activity_name, company_activities.icon_url, company_activities.tags, company_activities.created_by, company_activities.created_at, company_activities.updated_at, company_activities.updated_by, company_activities.description, company_activities.description_ar, company_activities.status, company_activities.activity_name_ar,company_category.category_name, company_category.category_name_ar,company_activities.id AS activity_id FROM companies 
CROSS JOIN UNNEST(companies.company_activities_id) AS group_id(id)
JOIN company_activities ON company_activities.id = group_id.id 
INNER JOIN company_category ON company_category.id = company_activities.company_category_id
WHERE companies.id = $1
`

type GetCompanyCategoryAndAcitivitesRow struct {
	ID                int64       `json:"id"`
	CompanyCategoryID int64       `json:"company_category_id"`
	ActivityName      string      `json:"activity_name"`
	IconUrl           pgtype.Text `json:"icon_url"`
	Tags              []string    `json:"tags"`
	CreatedBy         int64       `json:"created_by"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	UpdatedBy         pgtype.Int8 `json:"updated_by"`
	Description       pgtype.Text `json:"description"`
	DescriptionAr     pgtype.Text `json:"description_ar"`
	Status            int64       `json:"status"`
	ActivityNameAr    pgtype.Text `json:"activity_name_ar"`
	CategoryName      string      `json:"category_name"`
	CategoryNameAr    pgtype.Text `json:"category_name_ar"`
	ActivityID        int64       `json:"activity_id"`
}

func (q *Queries) GetCompanyCategoryAndAcitivites(ctx context.Context, id int64) ([]GetCompanyCategoryAndAcitivitesRow, error) {
	rows, err := q.db.Query(ctx, getCompanyCategoryAndAcitivites, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyCategoryAndAcitivitesRow
	for rows.Next() {
		var i GetCompanyCategoryAndAcitivitesRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyCategoryID,
			&i.ActivityName,
			&i.IconUrl,
			&i.Tags,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Description,
			&i.DescriptionAr,
			&i.Status,
			&i.ActivityNameAr,
			&i.CategoryName,
			&i.CategoryNameAr,
			&i.ActivityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleCompanyActivity = `-- name: GetSingleCompanyActivity :one
SELECT id, company_category_id, activity_name, icon_url, tags, created_by, created_at, updated_at, updated_by, description, description_ar, status, activity_name_ar FROM company_activities
WHERE id=$1
`

func (q *Queries) GetSingleCompanyActivity(ctx context.Context, id int64) (CompanyActivity, error) {
	row := q.db.QueryRow(ctx, getSingleCompanyActivity, id)
	var i CompanyActivity
	err := row.Scan(
		&i.ID,
		&i.CompanyCategoryID,
		&i.ActivityName,
		&i.IconUrl,
		&i.Tags,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Description,
		&i.DescriptionAr,
		&i.Status,
		&i.ActivityNameAr,
	)
	return i, err
}

const getSingleCompanyCategoryAndActivities = `-- name: GetSingleCompanyCategoryAndActivities :one
SELECT 
    company_category.id,
    company_category.category_name,
    company_category.category_name_ar,
	company_category.company_type,
	company_types.title,
    company_types.title_ar,
    company_activities.icon_url, 
	company_activities.tags,
    JSON_BUILD_OBJECT(
	'id', company_activities.id, 
	'label',CASE WHEN $2::varchar = 'ar' THEN COALESCE(company_activities.activity_name_ar,company_activities.activity_name)
    	ELSE COALESCE(company_activities.activity_name, '') END::varchar
	
	) AS activities,
	COUNT(*) OVER() AS total_count  
FROM 
    company_category
LEFT JOIN 
    company_activities ON company_activities.company_category_id = company_category.id 
LEFT JOIN company_types ON company_types.id = company_category.company_type
WHERE company_activities.id = $1 AND company_activities.status!=6 AND company_category.status!=6
GROUP BY 
    company_category.id,company_activities.id, company_category.company_type, company_types.title,company_types.title_ar, company_activities.icon_url, company_activities.tags
`

type GetSingleCompanyCategoryAndActivitiesParams struct {
	ID   int64  `json:"id"`
	Lang string `json:"lang"`
}

type GetSingleCompanyCategoryAndActivitiesRow struct {
	ID             int64       `json:"id"`
	CategoryName   string      `json:"category_name"`
	CategoryNameAr pgtype.Text `json:"category_name_ar"`
	CompanyType    int64       `json:"company_type"`
	Title          pgtype.Text `json:"title"`
	TitleAr        pgtype.Text `json:"title_ar"`
	IconUrl        pgtype.Text `json:"icon_url"`
	Tags           []string    `json:"tags"`
	Activities     []byte      `json:"activities"`
	TotalCount     int64       `json:"total_count"`
}

func (q *Queries) GetSingleCompanyCategoryAndActivities(ctx context.Context, arg GetSingleCompanyCategoryAndActivitiesParams) (GetSingleCompanyCategoryAndActivitiesRow, error) {
	row := q.db.QueryRow(ctx, getSingleCompanyCategoryAndActivities, arg.ID, arg.Lang)
	var i GetSingleCompanyCategoryAndActivitiesRow
	err := row.Scan(
		&i.ID,
		&i.CategoryName,
		&i.CategoryNameAr,
		&i.CompanyType,
		&i.Title,
		&i.TitleAr,
		&i.IconUrl,
		&i.Tags,
		&i.Activities,
		&i.TotalCount,
	)
	return i, err
}

const updateCompanyActivity = `-- name: UpdateCompanyActivity :one
UPDATE company_activities
SET 
	company_category_id=$1,
	icon_url=$2,
	tags=$3,
	updated_at=$4,
	updated_by=$5,
	activity_name=$6,
    status=$8,
	activity_name_ar=$9, 
	description=$10, 
	description_ar=$11
WHERE id=$7
RETURNING id, company_category_id, activity_name, icon_url, tags, created_by, created_at, updated_at, updated_by, description, description_ar, status, activity_name_ar
`

type UpdateCompanyActivityParams struct {
	CompanyCategoryID int64       `json:"company_category_id"`
	IconUrl           pgtype.Text `json:"icon_url"`
	Tags              []string    `json:"tags"`
	UpdatedAt         time.Time   `json:"updated_at"`
	UpdatedBy         pgtype.Int8 `json:"updated_by"`
	ActivityName      string      `json:"activity_name"`
	ID                int64       `json:"id"`
	Status            int64       `json:"status"`
	ActivityNameAr    pgtype.Text `json:"activity_name_ar"`
	Description       pgtype.Text `json:"description"`
	DescriptionAr     pgtype.Text `json:"description_ar"`
}

func (q *Queries) UpdateCompanyActivity(ctx context.Context, arg UpdateCompanyActivityParams) (CompanyActivity, error) {
	row := q.db.QueryRow(ctx, updateCompanyActivity,
		arg.CompanyCategoryID,
		arg.IconUrl,
		arg.Tags,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.ActivityName,
		arg.ID,
		arg.Status,
		arg.ActivityNameAr,
		arg.Description,
		arg.DescriptionAr,
	)
	var i CompanyActivity
	err := row.Scan(
		&i.ID,
		&i.CompanyCategoryID,
		&i.ActivityName,
		&i.IconUrl,
		&i.Tags,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Description,
		&i.DescriptionAr,
		&i.Status,
		&i.ActivityNameAr,
	)
	return i, err
}

const updateCompanyActivityStatus = `-- name: UpdateCompanyActivityStatus :one
UPDATE company_activities
SET 
	status=$2, 
	updated_at=$3, 
	updated_by=$4
WHERE 
	id=$1 RETURNING 1
`

type UpdateCompanyActivityStatusParams struct {
	ID        int64       `json:"id"`
	Status    int64       `json:"status"`
	UpdatedAt time.Time   `json:"updated_at"`
	UpdatedBy pgtype.Int8 `json:"updated_by"`
}

func (q *Queries) UpdateCompanyActivityStatus(ctx context.Context, arg UpdateCompanyActivityStatusParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, updateCompanyActivityStatus,
		arg.ID,
		arg.Status,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	var column_1 pgtype.Int8
	err := row.Scan(&column_1)
	return column_1, err
}
