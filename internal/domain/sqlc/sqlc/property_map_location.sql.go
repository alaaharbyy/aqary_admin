// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: property_map_location.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPropertyMapLocation = `-- name: CreatePropertyMapLocation :one
INSERT INTO properties_map_location(
	property,
	property_ar,
	sub_communities_id,
	lat,
	lng,
	status,
	updated_by,
	updated_at
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
RETURNING id, property, sub_communities_id, lat, lng, created_at, updated_at, status, deleted_at, updated_by, property_ar
`

type CreatePropertyMapLocationParams struct {
	Property         string             `json:"property"`
	PropertyAr       pgtype.Text        `json:"property_ar"`
	SubCommunitiesID int64              `json:"sub_communities_id"`
	Lat              float64            `json:"lat"`
	Lng              float64            `json:"lng"`
	Status           int64              `json:"status"`
	UpdatedBy        int64              `json:"updated_by"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreatePropertyMapLocation(ctx context.Context, arg CreatePropertyMapLocationParams) (PropertiesMapLocation, error) {
	row := q.db.QueryRow(ctx, createPropertyMapLocation,
		arg.Property,
		arg.PropertyAr,
		arg.SubCommunitiesID,
		arg.Lat,
		arg.Lng,
		arg.Status,
		arg.UpdatedBy,
		arg.UpdatedAt,
	)
	var i PropertiesMapLocation
	err := row.Scan(
		&i.ID,
		&i.Property,
		&i.SubCommunitiesID,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.PropertyAr,
	)
	return i, err
}

const createPropertyMapLocationInBulk = `-- name: CreatePropertyMapLocationInBulk :exec
INSERT INTO properties_map_location(property,sub_communities_id)
VALUES(
    unnest($1::text[]),
    unnest($2::bigint[])
)
`

type CreatePropertyMapLocationInBulkParams struct {
	Property         []string `json:"property"`
	SubCommunitiesID []int64  `json:"sub_communities_id"`
}

func (q *Queries) CreatePropertyMapLocationInBulk(ctx context.Context, arg CreatePropertyMapLocationInBulkParams) error {
	_, err := q.db.Exec(ctx, createPropertyMapLocationInBulk, arg.Property, arg.SubCommunitiesID)
	return err
}

const getAllPropertyLocations = `-- name: GetAllPropertyLocations :many
SELECT 
 COALESCE(countries.id::bigint,0)::bigint as country_id ,
 COALESCE(countries.country::varchar,'')::varchar as country ,
 COALESCE(countries.country_ar::varchar,'')::varchar as country_ar ,

 COALESCE(states.id::bigint,0)::bigint as states_id ,
 COALESCE(states."state"::VARCHAR,'')::VARCHAR as state,
 COALESCE(states.state_ar::VARCHAR,'')::VARCHAR as state_ar,  

 COALESCE(cities.id::bigint,0)::bigint as cities_id ,
 COALESCE(cities.city::varchar,'')::varchar as city,
 COALESCE(cities.city_ar::varchar,'')::varchar as city_ar,

 COALESCE(communities.id::bigint,0)::bigint as community_id ,
 COALESCE(communities.community::varchar,'')::varchar as community,
 COALESCE(communities.community_ar::varchar,'')::varchar as community_ar, 

 COALESCE(sub_communities.id::bigint,0)::bigint as sub_communities_id ,
 COALESCE(sub_communities.sub_community::varchar,'')::varchar as subcommunity,
 COALESCE(sub_communities.sub_community_ar::varchar,'')::varchar as subcommunity_ar, 

 properties_map_location.id, properties_map_location.property, properties_map_location.sub_communities_id, properties_map_location.lat, properties_map_location.lng, properties_map_location.created_at, properties_map_location.updated_at, properties_map_location.status, properties_map_location.deleted_at, properties_map_location.updated_by, properties_map_location.property_ar FROM properties_map_location 
left join sub_communities on sub_communities.id=properties_map_location.sub_communities_id
left join communities on communities.id=sub_communities.communities_id
left join cities on cities.id=communities.cities_id
left join states on states.id=cities.states_id
left join countries on countries.id=states.countries_id
WHERE properties_map_location.status!=6
ORDER BY properties_map_location.updated_at desc
LIMIT $2
OFFSET $1
`

type GetAllPropertyLocationsParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllPropertyLocationsRow struct {
	CountryID          int64              `json:"country_id"`
	Country            string             `json:"country"`
	CountryAr          string             `json:"country_ar"`
	StatesID           int64              `json:"states_id"`
	State              string             `json:"state"`
	StateAr            string             `json:"state_ar"`
	CitiesID           int64              `json:"cities_id"`
	City               string             `json:"city"`
	CityAr             string             `json:"city_ar"`
	CommunityID        int64              `json:"community_id"`
	Community          string             `json:"community"`
	CommunityAr        string             `json:"community_ar"`
	SubCommunitiesID   int64              `json:"sub_communities_id"`
	Subcommunity       string             `json:"subcommunity"`
	SubcommunityAr     string             `json:"subcommunity_ar"`
	ID                 int64              `json:"id"`
	Property           string             `json:"property"`
	SubCommunitiesID_2 int64              `json:"sub_communities_id_2"`
	Lat                float64            `json:"lat"`
	Lng                float64            `json:"lng"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Status             int64              `json:"status"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy          int64              `json:"updated_by"`
	PropertyAr         pgtype.Text        `json:"property_ar"`
}

func (q *Queries) GetAllPropertyLocations(ctx context.Context, arg GetAllPropertyLocationsParams) ([]GetAllPropertyLocationsRow, error) {
	rows, err := q.db.Query(ctx, getAllPropertyLocations, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPropertyLocationsRow
	for rows.Next() {
		var i GetAllPropertyLocationsRow
		if err := rows.Scan(
			&i.CountryID,
			&i.Country,
			&i.CountryAr,
			&i.StatesID,
			&i.State,
			&i.StateAr,
			&i.CitiesID,
			&i.City,
			&i.CityAr,
			&i.CommunityID,
			&i.Community,
			&i.CommunityAr,
			&i.SubCommunitiesID,
			&i.Subcommunity,
			&i.SubcommunityAr,
			&i.ID,
			&i.Property,
			&i.SubCommunitiesID_2,
			&i.Lat,
			&i.Lng,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.PropertyAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedPropertyLocations = `-- name: GetDeletedPropertyLocations :many
SELECT
 COALESCE(countries.id::bigint,0)::bigint as country_id ,
 COALESCE(countries.country::varchar,'')::varchar as country ,
 COALESCE(countries.country_ar::varchar,'')::varchar as country_ar ,

 COALESCE(states.id::bigint,0)::bigint as states_id ,
 COALESCE(states."state"::VARCHAR,'')::VARCHAR as state,
 COALESCE(states.state_ar::VARCHAR,'')::VARCHAR as state_ar,  

 COALESCE(cities.id::bigint,0)::bigint as cities_id ,
 COALESCE(cities.city::varchar,'')::varchar as city,
 COALESCE(cities.city_ar::varchar,'')::varchar as city_ar,

 COALESCE(communities.id::bigint,0)::bigint as community_id ,
 COALESCE(communities.community::varchar,'')::varchar as community,
 COALESCE(communities.community_ar::varchar,'')::varchar as community_ar, 

 COALESCE(sub_communities.sub_community::varchar,'')::varchar as subcommunity,
 COALESCE(sub_communities.sub_community_ar::varchar,'')::varchar as subcommunity_ar, 

 properties_map_location.id, properties_map_location.property, properties_map_location.sub_communities_id, properties_map_location.lat, properties_map_location.lng, properties_map_location.created_at, properties_map_location.updated_at, properties_map_location.status, properties_map_location.deleted_at, properties_map_location.updated_by, properties_map_location.property_ar FROM properties_map_location 
left join sub_communities on sub_communities.id=properties_map_location.sub_communities_id
left join communities on communities.id=sub_communities.communities_id
left join cities on cities.id=communities.cities_id
left join states on states.id=cities.states_id
left join countries on countries.id=states.countries_id
WHERE properties_map_location.status=6
ORDER BY properties_map_location.deleted_at DESC
LIMIT $2
OFFSET $1
`

type GetDeletedPropertyLocationsParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetDeletedPropertyLocationsRow struct {
	CountryID        int64              `json:"country_id"`
	Country          string             `json:"country"`
	CountryAr        string             `json:"country_ar"`
	StatesID         int64              `json:"states_id"`
	State            string             `json:"state"`
	StateAr          string             `json:"state_ar"`
	CitiesID         int64              `json:"cities_id"`
	City             string             `json:"city"`
	CityAr           string             `json:"city_ar"`
	CommunityID      int64              `json:"community_id"`
	Community        string             `json:"community"`
	CommunityAr      string             `json:"community_ar"`
	Subcommunity     string             `json:"subcommunity"`
	SubcommunityAr   string             `json:"subcommunity_ar"`
	ID               int64              `json:"id"`
	Property         string             `json:"property"`
	SubCommunitiesID int64              `json:"sub_communities_id"`
	Lat              float64            `json:"lat"`
	Lng              float64            `json:"lng"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	Status           int64              `json:"status"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy        int64              `json:"updated_by"`
	PropertyAr       pgtype.Text        `json:"property_ar"`
}

func (q *Queries) GetDeletedPropertyLocations(ctx context.Context, arg GetDeletedPropertyLocationsParams) ([]GetDeletedPropertyLocationsRow, error) {
	rows, err := q.db.Query(ctx, getDeletedPropertyLocations, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeletedPropertyLocationsRow
	for rows.Next() {
		var i GetDeletedPropertyLocationsRow
		if err := rows.Scan(
			&i.CountryID,
			&i.Country,
			&i.CountryAr,
			&i.StatesID,
			&i.State,
			&i.StateAr,
			&i.CitiesID,
			&i.City,
			&i.CityAr,
			&i.CommunityID,
			&i.Community,
			&i.CommunityAr,
			&i.Subcommunity,
			&i.SubcommunityAr,
			&i.ID,
			&i.Property,
			&i.SubCommunitiesID,
			&i.Lat,
			&i.Lng,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.PropertyAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedPropertyLocationsCount = `-- name: GetDeletedPropertyLocationsCount :one
SELECT  count(*) FROM properties_map_location 
WHERE status=6
`

func (q *Queries) GetDeletedPropertyLocationsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getDeletedPropertyLocationsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPropertyLocationByID = `-- name: GetPropertyLocationByID :one
SELECT
 COALESCE(countries.id::bigint,0)::bigint as country_id ,
 COALESCE(countries.country::varchar,'')::varchar as country ,
 COALESCE(countries.country_ar::varchar,'')::varchar as country_ar ,

 COALESCE(states.id::bigint,0)::bigint as states_id ,
 COALESCE(states."state"::VARCHAR,'')::VARCHAR as state,
 COALESCE(states.state_ar::VARCHAR,'')::VARCHAR as state_ar,  

 COALESCE(cities.id::bigint,0)::bigint as cities_id ,
 COALESCE(cities.city::varchar,'')::varchar as city,
 COALESCE(cities.city_ar::varchar,'')::varchar as city_ar,

 COALESCE(communities.id::bigint,0)::bigint as community_id ,
 COALESCE(communities.community::varchar,'')::varchar as community,
 COALESCE(communities.community_ar::varchar,'')::varchar as community_ar, 

 COALESCE(sub_communities.id::bigint,0)::bigint as sub_communities_id ,
 COALESCE(sub_communities.sub_community::varchar,'')::varchar as subcommunity,
 COALESCE(sub_communities.sub_community_ar::varchar,'')::varchar as subcommunity_ar, 

 properties_map_location.id, properties_map_location.property, properties_map_location.sub_communities_id, properties_map_location.lat, properties_map_location.lng, properties_map_location.created_at, properties_map_location.updated_at, properties_map_location.status, properties_map_location.deleted_at, properties_map_location.updated_by, properties_map_location.property_ar FROM properties_map_location 
left join sub_communities on sub_communities.id=properties_map_location.sub_communities_id
left join communities on communities.id=sub_communities.communities_id
left join cities on cities.id=communities.cities_id
left join states on states.id=cities.states_id
left join countries on countries.id=states.countries_id
WHERE properties_map_location.id=$1
`

type GetPropertyLocationByIDRow struct {
	CountryID          int64              `json:"country_id"`
	Country            string             `json:"country"`
	CountryAr          string             `json:"country_ar"`
	StatesID           int64              `json:"states_id"`
	State              string             `json:"state"`
	StateAr            string             `json:"state_ar"`
	CitiesID           int64              `json:"cities_id"`
	City               string             `json:"city"`
	CityAr             string             `json:"city_ar"`
	CommunityID        int64              `json:"community_id"`
	Community          string             `json:"community"`
	CommunityAr        string             `json:"community_ar"`
	SubCommunitiesID   int64              `json:"sub_communities_id"`
	Subcommunity       string             `json:"subcommunity"`
	SubcommunityAr     string             `json:"subcommunity_ar"`
	ID                 int64              `json:"id"`
	Property           string             `json:"property"`
	SubCommunitiesID_2 int64              `json:"sub_communities_id_2"`
	Lat                float64            `json:"lat"`
	Lng                float64            `json:"lng"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Status             int64              `json:"status"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy          int64              `json:"updated_by"`
	PropertyAr         pgtype.Text        `json:"property_ar"`
}

func (q *Queries) GetPropertyLocationByID(ctx context.Context, id int64) (GetPropertyLocationByIDRow, error) {
	row := q.db.QueryRow(ctx, getPropertyLocationByID, id)
	var i GetPropertyLocationByIDRow
	err := row.Scan(
		&i.CountryID,
		&i.Country,
		&i.CountryAr,
		&i.StatesID,
		&i.State,
		&i.StateAr,
		&i.CitiesID,
		&i.City,
		&i.CityAr,
		&i.CommunityID,
		&i.Community,
		&i.CommunityAr,
		&i.SubCommunitiesID,
		&i.Subcommunity,
		&i.SubcommunityAr,
		&i.ID,
		&i.Property,
		&i.SubCommunitiesID_2,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.PropertyAr,
	)
	return i, err
}

const getPropertyLocationByProperty = `-- name: GetPropertyLocationByProperty :one
SELECT id, property, sub_communities_id, lat, lng, created_at, updated_at, status, deleted_at, updated_by, property_ar FROM properties_map_location 
WHERE property=$1 AND status!=6
`

func (q *Queries) GetPropertyLocationByProperty(ctx context.Context, property string) (PropertiesMapLocation, error) {
	row := q.db.QueryRow(ctx, getPropertyLocationByProperty, property)
	var i PropertiesMapLocation
	err := row.Scan(
		&i.ID,
		&i.Property,
		&i.SubCommunitiesID,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.PropertyAr,
	)
	return i, err
}

const getPropertyLocationsCount = `-- name: GetPropertyLocationsCount :one
SELECT  count(*) FROM properties_map_location 
WHERE status!=6
`

func (q *Queries) GetPropertyLocationsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getPropertyLocationsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updatePropertyLocation = `-- name: UpdatePropertyLocation :one
UPDATE properties_map_location
SET 
property=$1,
property_ar=$2,
updated_by=$3,
updated_at=$4,
lat=$5,
lng=$6
WHERE id=$7
RETURNING id, property, sub_communities_id, lat, lng, created_at, updated_at, status, deleted_at, updated_by, property_ar
`

type UpdatePropertyLocationParams struct {
	Property   string             `json:"property"`
	PropertyAr pgtype.Text        `json:"property_ar"`
	UpdatedBy  int64              `json:"updated_by"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	Lat        float64            `json:"lat"`
	Lng        float64            `json:"lng"`
	ID         int64              `json:"id"`
}

func (q *Queries) UpdatePropertyLocation(ctx context.Context, arg UpdatePropertyLocationParams) (PropertiesMapLocation, error) {
	row := q.db.QueryRow(ctx, updatePropertyLocation,
		arg.Property,
		arg.PropertyAr,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.Lat,
		arg.Lng,
		arg.ID,
	)
	var i PropertiesMapLocation
	err := row.Scan(
		&i.ID,
		&i.Property,
		&i.SubCommunitiesID,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.PropertyAr,
	)
	return i, err
}

const updatePropertyLocationStatus = `-- name: UpdatePropertyLocationStatus :one
UPDATE properties_map_location
SET status=$1,
updated_by=$2,
updated_at=$3,
deleted_at=$4
WHERE id=$5
RETURNING id, property, sub_communities_id, lat, lng, created_at, updated_at, status, deleted_at, updated_by, property_ar
`

type UpdatePropertyLocationStatusParams struct {
	Status    int64              `json:"status"`
	UpdatedBy int64              `json:"updated_by"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	ID        int64              `json:"id"`
}

func (q *Queries) UpdatePropertyLocationStatus(ctx context.Context, arg UpdatePropertyLocationStatusParams) (PropertiesMapLocation, error) {
	row := q.db.QueryRow(ctx, updatePropertyLocationStatus,
		arg.Status,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.ID,
	)
	var i PropertiesMapLocation
	err := row.Scan(
		&i.ID,
		&i.Property,
		&i.SubCommunitiesID,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.PropertyAr,
	)
	return i, err
}
