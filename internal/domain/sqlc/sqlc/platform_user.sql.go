// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: platform_user.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeStatusOfPlatformUserByUserName = `-- name: ChangeStatusOfPlatformUserByUserName :one
UPDATE
    platform_users
SET
    status = $2
WHERE
    username = $1 AND (CASE WHEN $3::BIGINT IS NULL THEN company_id IS NULL ELSE company_id= $3::BIGINT END) AND status= $4::BIGINT
RETURNING 1
`

type ChangeStatusOfPlatformUserByUserNameParams struct {
	Username     string      `json:"username"`
	Status       int64       `json:"status"`
	CompanyID    pgtype.Int8 `json:"company_id"`
	ActiveStatus int64       `json:"active_status"`
}

func (q *Queries) ChangeStatusOfPlatformUserByUserName(ctx context.Context, arg ChangeStatusOfPlatformUserByUserNameParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, changeStatusOfPlatformUserByUserName,
		arg.Username,
		arg.Status,
		arg.CompanyID,
		arg.ActiveStatus,
	)
	var column_1 pgtype.Int8
	err := row.Scan(&column_1)
	return column_1, err
}

const createPlatformUser = `-- name: CreatePlatformUser :one
INSERT INTO
    platform_users (
        company_id,
        username,
        email,
        password,
        country_code,
        phone_number,
        first_name,
        last_name, 
        addresses_id, 
        status, 
        social_login, 
        gender, 
        nationality,
        is_email_verified
    )
VALUES(
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,   
        $7,
        $8, 
        $9, 
        $10, 
        $11, 
        $12, 
        $13, 
        $14
    )RETURNING id, company_id, username, password, country_code, phone_number, date_of_birth, first_name, last_name, email, gender, profile_image_url, cover_image_url, about, addresses_id, is_phone_verified, is_email_verified, status, created_at, updated_at, nationality, social_login
`

type CreatePlatformUserParams struct {
	CompanyID       pgtype.Int8 `json:"company_id"`
	Username        string      `json:"username"`
	Email           string      `json:"email"`
	Password        string      `json:"password"`
	CountryCode     pgtype.Text `json:"country_code"`
	PhoneNumber     pgtype.Int8 `json:"phone_number"`
	FirstName       pgtype.Text `json:"first_name"`
	LastName        pgtype.Text `json:"last_name"`
	AddressesID     int64       `json:"addresses_id"`
	Status          int64       `json:"status"`
	SocialLogin     pgtype.Text `json:"social_login"`
	Gender          pgtype.Int8 `json:"gender"`
	Nationality     pgtype.Int8 `json:"nationality"`
	IsEmailVerified pgtype.Bool `json:"is_email_verified"`
}

func (q *Queries) CreatePlatformUser(ctx context.Context, arg CreatePlatformUserParams) (PlatformUser, error) {
	row := q.db.QueryRow(ctx, createPlatformUser,
		arg.CompanyID,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.CountryCode,
		arg.PhoneNumber,
		arg.FirstName,
		arg.LastName,
		arg.AddressesID,
		arg.Status,
		arg.SocialLogin,
		arg.Gender,
		arg.Nationality,
		arg.IsEmailVerified,
	)
	var i PlatformUser
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Username,
		&i.Password,
		&i.CountryCode,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Gender,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.About,
		&i.AddressesID,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Nationality,
		&i.SocialLogin,
	)
	return i, err
}

const getPlatformUserByEmail = `-- name: GetPlatformUserByEmail :one
SELECT id, company_id, username, password, country_code, phone_number, date_of_birth, first_name, last_name, email, gender, profile_image_url, cover_image_url, about, addresses_id, is_phone_verified, is_email_verified, status, created_at, updated_at, nationality, social_login FROM platform_users
WHERE email = $1 and status != 5 and status != 6
`

func (q *Queries) GetPlatformUserByEmail(ctx context.Context, email string) (PlatformUser, error) {
	row := q.db.QueryRow(ctx, getPlatformUserByEmail, email)
	var i PlatformUser
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Username,
		&i.Password,
		&i.CountryCode,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Gender,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.About,
		&i.AddressesID,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Nationality,
		&i.SocialLogin,
	)
	return i, err
}

const getPlatformUserByEmailAndCompanyID = `-- name: GetPlatformUserByEmailAndCompanyID :one
SELECT id, company_id, username, password, country_code, phone_number, date_of_birth, first_name, last_name, email, gender, profile_image_url, cover_image_url, about, addresses_id, is_phone_verified, is_email_verified, status, created_at, updated_at, nationality, social_login FROM platform_users
WHERE email = $1 and (CASE WHEN $2::BIGINT IS NULL THEN company_id IS NULL ELSE company_id= $2::BIGINT END) AND status = $3::BIGINT AND is_email_verified= true
`

type GetPlatformUserByEmailAndCompanyIDParams struct {
	Email      string      `json:"email"`
	CompanyID  pgtype.Int8 `json:"company_id"`
	ActiveUser int64       `json:"active_user"`
}

func (q *Queries) GetPlatformUserByEmailAndCompanyID(ctx context.Context, arg GetPlatformUserByEmailAndCompanyIDParams) (PlatformUser, error) {
	row := q.db.QueryRow(ctx, getPlatformUserByEmailAndCompanyID, arg.Email, arg.CompanyID, arg.ActiveUser)
	var i PlatformUser
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Username,
		&i.Password,
		&i.CountryCode,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Gender,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.About,
		&i.AddressesID,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Nationality,
		&i.SocialLogin,
	)
	return i, err
}

const getPlatformUserDetailsByUserName = `-- name: GetPlatformUserDetailsByUserName :one
SELECT
    pu.id,
    username,
    first_name,
    last_name,
    email,
    gender,
    pu.country_code,
    phone_number,
    countries.id AS "country_id",
    countries.country,
    countries.country_ar,
    countries."flag"
FROM
    platform_users pu
    LEFT JOIN countries ON countries.id = nationality
WHERE
    username = $1
    AND pu.status != $2::BIGINT
`

type GetPlatformUserDetailsByUserNameParams struct {
	Username      string `json:"username"`
	DeletedStatus int64  `json:"deleted_status"`
}

type GetPlatformUserDetailsByUserNameRow struct {
	ID          int64       `json:"id"`
	Username    string      `json:"username"`
	FirstName   pgtype.Text `json:"first_name"`
	LastName    pgtype.Text `json:"last_name"`
	Email       string      `json:"email"`
	Gender      pgtype.Int8 `json:"gender"`
	CountryCode pgtype.Text `json:"country_code"`
	PhoneNumber pgtype.Int8 `json:"phone_number"`
	CountryID   pgtype.Int8 `json:"country_id"`
	Country     pgtype.Text `json:"country"`
	CountryAr   pgtype.Text `json:"country_ar"`
	Flag        pgtype.Text `json:"flag"`
}

func (q *Queries) GetPlatformUserDetailsByUserName(ctx context.Context, arg GetPlatformUserDetailsByUserNameParams) (GetPlatformUserDetailsByUserNameRow, error) {
	row := q.db.QueryRow(ctx, getPlatformUserDetailsByUserName, arg.Username, arg.DeletedStatus)
	var i GetPlatformUserDetailsByUserNameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Gender,
		&i.CountryCode,
		&i.PhoneNumber,
		&i.CountryID,
		&i.Country,
		&i.CountryAr,
		&i.Flag,
	)
	return i, err
}
