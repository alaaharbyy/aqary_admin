// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: careers.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const careersAdvancedSearch = `-- name: CareersAdvancedSearch :many


SELECT
    -- COALESCE(cc.count, 0) AS candidate_count,
    cr.id, cr.ref_no, cr.job_title, cr.job_title_ar, cr.employment_types, cr.employment_mode, cr.job_style, cr.job_categories, cr.career_level, cr.addresses_id, cr.is_urgent, cr.job_description, cr.job_image, cr.number_of_positions, cr.years_of_experience, cr.gender, cr.nationality_id, cr.min_salary, cr.max_salary, cr.languages, cr.uploaded_by, cr.date_expired, cr.career_status, cr.education_level, cr.specialization, cr.skills, cr.global_tagging_id, cr.created_at, cr.updated_at, cr.field_of_study, cr.status, cr.rank,
    -- sqlc.embed(e),
    co.id, co.country, co.flag, co.created_at, co.updated_at, co.alpha2_code, co.alpha3_code, co.country_code, co.lat, co.lng, co.name, co.numcode, co.default_settings, co.status, co.deleted_at, co.updated_by, co.country_ar,
    ci.id, ci.city, ci.states_id, ci.created_at, ci.updated_at, ci.lat, ci.lng, ci.status, ci.deleted_at, ci.updated_by, ci.city_ar, ci.cover_image, ci.description,
    com.id, com.community, com.cities_id, com.created_at, com.updated_at, com.lat, com.lng, com.status, com.deleted_at, com.updated_by, com.community_ar
FROM
    careers cr
JOIN
    countries co ON cr.countries_id = co.id
JOIN
    cities ci ON cr.city_id = ci.id
JOIN
    communities com ON cr.community_id = com.id
WHERE
    (cr.min_salary >=  $3 OR $4::BOOLEAN)
AND
    (cr.max_salary <= $5 OR $6::BOOLEAN)
AND
    (cr.is_urgent = $7 OR $8::BOOLEAN)
AND
    (CASE WHEN ARRAY_LENGTH($9::VARCHAR[], 1) IS NULL THEN TRUE
    ELSE cr.job_title = ANY($9::VARCHAR[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($10::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.gender = ANY($10::BIGINT[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($11::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.career_status = ANY($11::bigint[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($12::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.career_level = ANY($12::bigint[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($13::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.years_of_experience = ANY($13::bigint[]) END)
AND 
	 (CASE WHEN ARRAY_LENGTH($14::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.job_categories = ANY($14::bigint[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($15::VARCHAR[], 1) IS NULL THEN TRUE ELSE cr.job_title ILIKE ANY($15::VARCHAR[])
    OR cr.ref_no ILIKE ANY($15::VARCHAR[])
    OR cr.job_description ILIKE ANY($15::VARCHAR[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($16::bigint[], 1) IS NULL THEN TRUE ELSE cr.benefits && $16::bigint[] END) AND
    (CASE WHEN ARRAY_LENGTH($17::bigint[], 1) IS NULL THEN TRUE ELSE cr.languages && $17::bigint[] END) AND
    (CASE WHEN ARRAY_LENGTH($18::bigint[], 1) IS NULL THEN TRUE ELSE cr.employment_types && $18::bigint[] END) AND
    (CASE WHEN ARRAY_LENGTH($19::bigint[], 1) IS NULL THEN TRUE ELSE cr.education_level && $19::bigint[] END)
AND
    (CASE WHEN COALESCE($20::BIGINT,1) =1 THEN true WHEN $20::BIGINT= 2 THEN cr.created_at >= DATE_TRUNC
        ('day', CURRENT_DATE) WHEN $20::BIGINT = 3 THEN cr.created_at >= DATE_TRUNC('week', CURRENT_DATE - INTERVAL '1 week')AND cr.created_at < DATE_TRUNC('week', CURRENT_DATE)
        WHEN $20::BIGINT = 4 THEN cr.created_at >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
        AND cr.created_at < DATE_TRUNC('month', CURRENT_DATE)
     END)
AND
    (CASE WHEN ARRAY_LENGTH($21::bigint[], 1) IS NULL THEN TRUE ELSE ci.id = ANY($21::bigint[]) END)  AND
    (CASE WHEN ARRAY_LENGTH($22::bigint[], 1) IS NULL THEN TRUE ELSE com.id = ANY($22::bigint[])END) AND
    (CASE WHEN ARRAY_LENGTH($23::bigint[], 1) IS NULL THEN TRUE ELSE co.id = ANY($23::bigint[]) END)
ORDER BY
    CASE
        WHEN $24::bigint = 1 THEN cc.count END DESC,
    CASE
        WHEN $24::bigint = 2 THEN cr.created_at END DESC,
    CASE
        WHEN $24::bigint = 3 THEN cr.min_salary END DESC,
    CASE
        WHEN $24::bigint = 4 THEN cr.min_salary END ASC
LIMIT $1 OFFSET $2
`

type CareersAdvancedSearchParams struct {
	Limit             int32         `json:"limit"`
	Offset            int32         `json:"offset"`
	MinSalary         pgtype.Float8 `json:"min_salary"`
	DisableMinSalary  bool          `json:"disable_min_salary"`
	MaxSalary         pgtype.Float8 `json:"max_salary"`
	DisableMaxSalary  bool          `json:"disable_max_salary"`
	IsUrgent          bool          `json:"is_urgent"`
	DisableIsUrgent   bool          `json:"disable_is_urgent"`
	JobTitle          []string      `json:"job_title"`
	Gender            []int64       `json:"gender"`
	CareerStatus      []int64       `json:"career_status"`
	CareerLevel       []int64       `json:"career_level"`
	YearsOfExperience []int64       `json:"years_of_experience"`
	JobCategory       []int64       `json:"job_category"`
	Keywords          []string      `json:"keywords"`
	Benefits          []int64       `json:"benefits"`
	Languages         []int64       `json:"languages"`
	EmploymentTypes   []int64       `json:"employment_types"`
	EducationLevel    []int64       `json:"education_level"`
	Dates             int64         `json:"dates"`
	CitiesID          []int64       `json:"cities_id"`
	CommunitiesID     []int64       `json:"communities_id"`
	CountryID         []int64       `json:"country_id"`
	Sort              int64         `json:"sort"`
}

type CareersAdvancedSearchRow struct {
	Career    Career    `json:"career"`
	Country   Country   `json:"country"`
	City      City      `json:"city"`
	Community Community `json:"community"`
}

// -- name: GetCareerActivitiesCount :one
// SELECT COUNT(*) FROM careers c
// JOIN careers_activities ca ON c.id=ca.ref_activity_id
// WHERE c.employers_id=$1 ;
// WITH
// candidate_count AS (
//
//	SELECT
//	    c.careers_id,
//	    COUNT(c.id) AS count
//	FROM
//	    candidates c
//	JOIN
//	    applicants a ON c.applicants_id = a.id
//	JOIN
//	    careers car ON c.careers_id = car.id
//	WHERE
//	    c.application_status != 6 AND (car.career_status != 6 AND car.career_status != 5)
//	GROUP BY
//	    c.careers_id
//
// )
// LEFT JOIN
//
//	candidate_count cc ON cr.id = cc.careers_id
//
// JOIN
//
//	employers e ON cr.employers_id = e.id
func (q *Queries) CareersAdvancedSearch(ctx context.Context, arg CareersAdvancedSearchParams) ([]CareersAdvancedSearchRow, error) {
	rows, err := q.db.Query(ctx, careersAdvancedSearch,
		arg.Limit,
		arg.Offset,
		arg.MinSalary,
		arg.DisableMinSalary,
		arg.MaxSalary,
		arg.DisableMaxSalary,
		arg.IsUrgent,
		arg.DisableIsUrgent,
		arg.JobTitle,
		arg.Gender,
		arg.CareerStatus,
		arg.CareerLevel,
		arg.YearsOfExperience,
		arg.JobCategory,
		arg.Keywords,
		arg.Benefits,
		arg.Languages,
		arg.EmploymentTypes,
		arg.EducationLevel,
		arg.Dates,
		arg.CitiesID,
		arg.CommunitiesID,
		arg.CountryID,
		arg.Sort,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CareersAdvancedSearchRow
	for rows.Next() {
		var i CareersAdvancedSearchRow
		if err := rows.Scan(
			&i.Career.ID,
			&i.Career.RefNo,
			&i.Career.JobTitle,
			&i.Career.JobTitleAr,
			&i.Career.EmploymentTypes,
			&i.Career.EmploymentMode,
			&i.Career.JobStyle,
			&i.Career.JobCategories,
			&i.Career.CareerLevel,
			&i.Career.AddressesID,
			&i.Career.IsUrgent,
			&i.Career.JobDescription,
			&i.Career.JobImage,
			&i.Career.NumberOfPositions,
			&i.Career.YearsOfExperience,
			&i.Career.Gender,
			&i.Career.NationalityID,
			&i.Career.MinSalary,
			&i.Career.MaxSalary,
			&i.Career.Languages,
			&i.Career.UploadedBy,
			&i.Career.DateExpired,
			&i.Career.CareerStatus,
			&i.Career.EducationLevel,
			&i.Career.Specialization,
			&i.Career.Skills,
			&i.Career.GlobalTaggingID,
			&i.Career.CreatedAt,
			&i.Career.UpdatedAt,
			&i.Career.FieldOfStudy,
			&i.Career.Status,
			&i.Career.Rank,
			&i.Country.ID,
			&i.Country.Country,
			&i.Country.Flag,
			&i.Country.CreatedAt,
			&i.Country.UpdatedAt,
			&i.Country.Alpha2Code,
			&i.Country.Alpha3Code,
			&i.Country.CountryCode,
			&i.Country.Lat,
			&i.Country.Lng,
			&i.Country.Name,
			&i.Country.Numcode,
			&i.Country.DefaultSettings,
			&i.Country.Status,
			&i.Country.DeletedAt,
			&i.Country.UpdatedBy,
			&i.Country.CountryAr,
			&i.City.ID,
			&i.City.City,
			&i.City.StatesID,
			&i.City.CreatedAt,
			&i.City.UpdatedAt,
			&i.City.Lat,
			&i.City.Lng,
			&i.City.Status,
			&i.City.DeletedAt,
			&i.City.UpdatedBy,
			&i.City.CityAr,
			&i.City.CoverImage,
			&i.City.Description,
			&i.Community.ID,
			&i.Community.Community,
			&i.Community.CitiesID,
			&i.Community.CreatedAt,
			&i.Community.UpdatedAt,
			&i.Community.Lat,
			&i.Community.Lng,
			&i.Community.Status,
			&i.Community.DeletedAt,
			&i.Community.UpdatedBy,
			&i.Community.CommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const careersAdvancedSearchCount = `-- name: CareersAdvancedSearchCount :one
SELECT
    count(cr.*)
FROM
    careers cr

    -- employers e ON cr.employers_id = e.id
JOIN
    countries co ON cr.countries_id = co.id
JOIN
    cities ci ON cr.city_id = ci.id
JOIN
    communities com ON cr.community_id = com.id
WHERE
    (cr.min_salary >=  $1 OR $2::BOOLEAN)
AND
    (cr.max_salary <= $3 OR $4::BOOLEAN)
AND
    (cr.is_urgent = $5 OR $6::BOOLEAN)
AND
    (CASE WHEN ARRAY_LENGTH($7::VARCHAR[], 1) IS NULL THEN TRUE
    ELSE cr.job_title = ANY($7::VARCHAR[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($8::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.gender = ANY($8::BIGINT[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($9::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.career_status = ANY($9::bigint[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($10::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.career_level = ANY($10::bigint[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($11::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.years_of_experience = ANY($11::bigint[]) END)
AND 
	 (CASE WHEN ARRAY_LENGTH($12::BIGINT[], 1) IS NULL THEN TRUE
    ELSE cr.job_categories = ANY($12::bigint[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($13::VARCHAR[], 1) IS NULL THEN TRUE ELSE cr.job_title ILIKE ANY($13::VARCHAR[])
    OR cr.ref_no ILIKE ANY($13::VARCHAR[])
    OR cr.job_description ILIKE ANY($13::VARCHAR[]) END)
AND
    (CASE WHEN ARRAY_LENGTH($14::bigint[], 1) IS NULL THEN TRUE ELSE cr.benefits && $14::bigint[] END) AND
    (CASE WHEN ARRAY_LENGTH($15::bigint[], 1) IS NULL THEN TRUE ELSE cr.languages && $15::bigint[] END) AND
    (CASE WHEN ARRAY_LENGTH($16::bigint[], 1) IS NULL THEN TRUE ELSE cr.employment_types && $16::bigint[] END) AND
    (CASE WHEN ARRAY_LENGTH($17::bigint[], 1) IS NULL THEN TRUE ELSE cr.education_level && $17::bigint[] END)
AND
    (CASE WHEN COALESCE($18::BIGINT,1) =1 THEN true WHEN $18::BIGINT= 2 THEN cr.created_at >= DATE_TRUNC
        ('day', CURRENT_DATE) WHEN $18::BIGINT = 3 THEN cr.created_at >= DATE_TRUNC('week', CURRENT_DATE - INTERVAL '1 week')AND cr.created_at < DATE_TRUNC('week', CURRENT_DATE)
        WHEN $18::BIGINT = 4 THEN cr.created_at >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
        AND cr.created_at < DATE_TRUNC('month', CURRENT_DATE)
     END)
AND
    (CASE WHEN ARRAY_LENGTH($19::bigint[], 1) IS NULL THEN TRUE ELSE ci.id = ANY($19::bigint[]) END)  AND
    (CASE WHEN ARRAY_LENGTH($20::bigint[], 1) IS NULL THEN TRUE ELSE com.id = ANY($20::bigint[])END) AND
    (CASE WHEN ARRAY_LENGTH($21::bigint[], 1) IS NULL THEN TRUE ELSE co.id = ANY($21::bigint[]) END)
`

type CareersAdvancedSearchCountParams struct {
	MinSalary         pgtype.Float8 `json:"min_salary"`
	DisableMinSalary  bool          `json:"disable_min_salary"`
	MaxSalary         pgtype.Float8 `json:"max_salary"`
	DisableMaxSalary  bool          `json:"disable_max_salary"`
	IsUrgent          bool          `json:"is_urgent"`
	DisableIsUrgent   bool          `json:"disable_is_urgent"`
	JobTitle          []string      `json:"job_title"`
	Gender            []int64       `json:"gender"`
	CareerStatus      []int64       `json:"career_status"`
	CareerLevel       []int64       `json:"career_level"`
	YearsOfExperience []int64       `json:"years_of_experience"`
	JobCategory       []int64       `json:"job_category"`
	Keywords          []string      `json:"keywords"`
	Benefits          []int64       `json:"benefits"`
	Languages         []int64       `json:"languages"`
	EmploymentTypes   []int64       `json:"employment_types"`
	EducationLevel    []int64       `json:"education_level"`
	Dates             int64         `json:"dates"`
	CitiesID          []int64       `json:"cities_id"`
	CommunitiesID     []int64       `json:"communities_id"`
	CountryID         []int64       `json:"country_id"`
}

// JOIN
func (q *Queries) CareersAdvancedSearchCount(ctx context.Context, arg CareersAdvancedSearchCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, careersAdvancedSearchCount,
		arg.MinSalary,
		arg.DisableMinSalary,
		arg.MaxSalary,
		arg.DisableMaxSalary,
		arg.IsUrgent,
		arg.DisableIsUrgent,
		arg.JobTitle,
		arg.Gender,
		arg.CareerStatus,
		arg.CareerLevel,
		arg.YearsOfExperience,
		arg.JobCategory,
		arg.Keywords,
		arg.Benefits,
		arg.Languages,
		arg.EmploymentTypes,
		arg.EducationLevel,
		arg.Dates,
		arg.CitiesID,
		arg.CommunitiesID,
		arg.CountryID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCareerBenefits = `-- name: GetCareerBenefits :many
SELECT bens.id, bens.career, bens.title, bens.title_ar, bens.icon_url, bens.created_at, bens.updated_at, bens.status
FROM
    careers cr
JOIN LATERAL unnest(cr.benefits) AS ben ON true
JOIN benefits bens ON ben = bens.id
WHERE cr.id=$1
`

func (q *Queries) GetCareerBenefits(ctx context.Context, id int64) ([]Benefit, error) {
	rows, err := q.db.Query(ctx, getCareerBenefits, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Benefit
	for rows.Next() {
		var i Benefit
		if err := rows.Scan(
			&i.ID,
			&i.Career,
			&i.Title,
			&i.TitleAr,
			&i.IconUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCareerFieldsOfStudy = `-- name: GetCareerFieldsOfStudy :many
SELECT foss.id, foss.title, foss.title_ar, foss.created_at, foss.updated_at
FROM
    careers cr
JOIN LATERAL unnest(cr.field_of_studies) AS fos ON true
JOIN field_of_studies as foss ON fos = foss.id
WHERE cr.id=$1
`

func (q *Queries) GetCareerFieldsOfStudy(ctx context.Context, id int64) ([]FieldOfStudy, error) {
	rows, err := q.db.Query(ctx, getCareerFieldsOfStudy, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldOfStudy
	for rows.Next() {
		var i FieldOfStudy
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TitleAr,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCareerLanguages = `-- name: GetCareerLanguages :many
SELECT langs.id, langs.language, langs.created_at, langs.updated_at, langs.code, langs.flag
FROM
    careers cr
JOIN LATERAL unnest(cr.languages) AS lang ON true
JOIN all_languages langs ON lang = langs.id
WHERE cr.id=$1
`

func (q *Queries) GetCareerLanguages(ctx context.Context, id int64) ([]AllLanguage, error) {
	rows, err := q.db.Query(ctx, getCareerLanguages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllLanguage
	for rows.Next() {
		var i AllLanguage
		if err := rows.Scan(
			&i.ID,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Code,
			&i.Flag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCareerNationalities = `-- name: GetCareerNationalities :many
SELECT nats.id, nats.country, nats.flag, nats.created_at, nats.updated_at, nats.alpha2_code, nats.alpha3_code, nats.country_code, nats.lat, nats.lng, nats.name, nats.numcode, nats.default_settings, nats.status, nats.deleted_at, nats.updated_by, nats.country_ar
FROM
    careers cr
JOIN LATERAL unnest(cr.nationality_id) AS nat ON true
JOIN countries nats ON nat = nats.id
WHERE cr.id=$1
`

func (q *Queries) GetCareerNationalities(ctx context.Context, id int64) ([]Country, error) {
	rows, err := q.db.Query(ctx, getCareerNationalities, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Country
	for rows.Next() {
		var i Country
		if err := rows.Scan(
			&i.ID,
			&i.Country,
			&i.Flag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Alpha2Code,
			&i.Alpha3Code,
			&i.CountryCode,
			&i.Lat,
			&i.Lng,
			&i.Name,
			&i.Numcode,
			&i.DefaultSettings,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CountryAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCareerSpecializations = `-- name: GetCareerSpecializations :many
SELECT specs.id, specs.title, specs.title_ar
FROM
    careers cr
JOIN LATERAL unnest(cr.specialization) AS spec ON true
JOIN specialization as specs ON spec = specs.id
WHERE cr.id=$1
`

func (q *Queries) GetCareerSpecializations(ctx context.Context, id int64) ([]Specialization, error) {
	rows, err := q.db.Query(ctx, getCareerSpecializations, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Specialization
	for rows.Next() {
		var i Specialization
		if err := rows.Scan(&i.ID, &i.Title, &i.TitleAr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCareerTags = `-- name: GetCareerTags :many
SELECT tags.id, tags.section, tags.tag_name, tags.created_at
FROM
    careers cr
JOIN LATERAL unnest(cr.global_tagging_id) AS tag ON true
JOIN global_tagging as tags ON tag = tags.id
WHERE cr.id=$1
`

func (q *Queries) GetCareerTags(ctx context.Context, id int64) ([]GlobalTagging, error) {
	rows, err := q.db.Query(ctx, getCareerTags, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GlobalTagging
	for rows.Next() {
		var i GlobalTagging
		if err := rows.Scan(
			&i.ID,
			&i.Section,
			&i.TagName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSkillsForCareer = `-- name: GetSkillsForCareer :one






SELECT
    array_agg(DISTINCT COALESCE( skill.id,0))::bigint[] AS skills_ids, 
    array_agg(DISTINCT COALESCE (skill.title,''))::text[] AS skills 
    from careers c
LEFT JOIN LATERAL unnest(c.skills) AS skill_id ON true
LEFT JOIN skills as skill ON skill_id = skill.id
where c.id=$1
`

type GetSkillsForCareerRow struct {
	SkillsIds []int64  `json:"skills_ids"`
	Skills    []string `json:"skills"`
}

// -- name: SearchEmployerCareersByTitle :many
// SELECT sqlc.embed(c)
// FROM careers c
// JOIN employers e ON e.id= c.employers_id
// WHERE
// job_title ILIKE '%' || $2 || '%' AND
// career_status != 6 AND e.users_id=$1;
// -- name: GetCareersCountForEmployer :one
// SELECT COUNT(*)
// FROM careers c
// JOIN employers e ON e.id= c.employers_id
// WHERE e.users_id=$1 AND c.career_status!=6;
func (q *Queries) GetSkillsForCareer(ctx context.Context, id int64) (GetSkillsForCareerRow, error) {
	row := q.db.QueryRow(ctx, getSkillsForCareer, id)
	var i GetSkillsForCareerRow
	err := row.Scan(&i.SkillsIds, &i.Skills)
	return i, err
}
