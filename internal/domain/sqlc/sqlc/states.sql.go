// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: states.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createState = `-- name: CreateState :one
INSERT INTO states (
    state,
    state_ar,
    countries_id,
    -- lat,
    -- lng,
    status,
    updated_by,
    created_at,
    updated_at,
    is_capital
)VALUES (
    $1 ,$2, $3, $4, $5, $6, $7, $8
) RETURNING id, state, countries_id, is_capital, created_at, updated_at, lat, lng, status, deleted_at, updated_by, state_ar
`

type CreateStateParams struct {
	State       string      `json:"state"`
	StateAr     pgtype.Text `json:"state_ar"`
	CountriesID pgtype.Int8 `json:"countries_id"`
	Status      int64       `json:"status"`
	UpdatedBy   int64       `json:"updated_by"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	IsCapital   pgtype.Bool `json:"is_capital"`
}

func (q *Queries) CreateState(ctx context.Context, arg CreateStateParams) (State, error) {
	row := q.db.QueryRow(ctx, createState,
		arg.State,
		arg.StateAr,
		arg.CountriesID,
		arg.Status,
		arg.UpdatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsCapital,
	)
	var i State
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CountriesID,
		&i.IsCapital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.StateAr,
	)
	return i, err
}

const deleteState = `-- name: DeleteState :exec
DELETE FROM states
Where id = $1
`

func (q *Queries) DeleteState(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteState, id)
	return err
}

const getAllStates = `-- name: GetAllStates :many
SELECT 
    states.id, states.state, states.countries_id, states.is_capital, states.created_at, states.updated_at, states.lat, states.lng, states.status, states.deleted_at, states.updated_by, states.state_ar,
    countries.country,
    countries.country_ar,
    COUNT(*) OVER() AS total_count
FROM states
LEFT JOIN countries ON countries.id = states.countries_id
WHERE states.status = ANY($1::bigint[])
ORDER BY updated_at DESC
LIMIT $3
OFFSET $2
`

type GetAllStatesParams struct {
	Column1 []int64     `json:"column_1"`
	Offset  pgtype.Int4 `json:"offset"`
	Limit   pgtype.Int4 `json:"limit"`
}

type GetAllStatesRow struct {
	ID          int64              `json:"id"`
	State       string             `json:"state"`
	CountriesID pgtype.Int8        `json:"countries_id"`
	IsCapital   pgtype.Bool        `json:"is_capital"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Lat         pgtype.Float8      `json:"lat"`
	Lng         pgtype.Float8      `json:"lng"`
	Status      int64              `json:"status"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy   int64              `json:"updated_by"`
	StateAr     pgtype.Text        `json:"state_ar"`
	Country     pgtype.Text        `json:"country"`
	CountryAr   pgtype.Text        `json:"country_ar"`
	TotalCount  int64              `json:"total_count"`
}

func (q *Queries) GetAllStates(ctx context.Context, arg GetAllStatesParams) ([]GetAllStatesRow, error) {
	rows, err := q.db.Query(ctx, getAllStates, arg.Column1, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllStatesRow
	for rows.Next() {
		var i GetAllStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.State,
			&i.CountriesID,
			&i.IsCapital,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.StateAr,
			&i.Country,
			&i.CountryAr,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCityByCountryId = `-- name: GetCityByCountryId :many
SELECT cities.id, city, states_id, cities.created_at, cities.updated_at, cities.lat, cities.lng, cities.status, cities.deleted_at, cities.updated_by, city_ar, cover_image, description, states.id, state, countries_id, is_capital, states.created_at, states.updated_at, states.lat, states.lng, states.status, states.deleted_at, states.updated_by, state_ar FROM cities
INNER JOIN states ON cities.id = states.id
Where states.countries_id = $1
`

type GetCityByCountryIdRow struct {
	ID          int64              `json:"id"`
	City        string             `json:"city"`
	StatesID    pgtype.Int8        `json:"states_id"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Lat         pgtype.Float8      `json:"lat"`
	Lng         pgtype.Float8      `json:"lng"`
	Status      int64              `json:"status"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy   int64              `json:"updated_by"`
	CityAr      pgtype.Text        `json:"city_ar"`
	CoverImage  pgtype.Text        `json:"cover_image"`
	Description pgtype.Text        `json:"description"`
	ID_2        int64              `json:"id_2"`
	State       string             `json:"state"`
	CountriesID pgtype.Int8        `json:"countries_id"`
	IsCapital   pgtype.Bool        `json:"is_capital"`
	CreatedAt_2 time.Time          `json:"created_at_2"`
	UpdatedAt_2 time.Time          `json:"updated_at_2"`
	Lat_2       pgtype.Float8      `json:"lat_2"`
	Lng_2       pgtype.Float8      `json:"lng_2"`
	Status_2    int64              `json:"status_2"`
	DeletedAt_2 pgtype.Timestamptz `json:"deleted_at_2"`
	UpdatedBy_2 int64              `json:"updated_by_2"`
	StateAr     pgtype.Text        `json:"state_ar"`
}

func (q *Queries) GetCityByCountryId(ctx context.Context, countriesID pgtype.Int8) ([]GetCityByCountryIdRow, error) {
	rows, err := q.db.Query(ctx, getCityByCountryId, countriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCityByCountryIdRow
	for rows.Next() {
		var i GetCityByCountryIdRow
		if err := rows.Scan(
			&i.ID,
			&i.City,
			&i.StatesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CityAr,
			&i.CoverImage,
			&i.Description,
			&i.ID_2,
			&i.State,
			&i.CountriesID,
			&i.IsCapital,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.Lat_2,
			&i.Lng_2,
			&i.Status_2,
			&i.DeletedAt_2,
			&i.UpdatedBy_2,
			&i.StateAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getState = `-- name: GetState :one
SELECT id, state, countries_id, is_capital, created_at, updated_at, lat, lng, status, deleted_at, updated_by, state_ar FROM states 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetState(ctx context.Context, limit int32) (State, error) {
	row := q.db.QueryRow(ctx, getState, limit)
	var i State
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CountriesID,
		&i.IsCapital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.StateAr,
	)
	return i, err
}

const getStateByCountryId = `-- name: GetStateByCountryId :many
SELECT id, state, countries_id, is_capital, created_at, updated_at, lat, lng, status, deleted_at, updated_by, state_ar FROM states
Where countries_id = $1 AND status= $2::BIGINT ORDER BY id
`

type GetStateByCountryIdParams struct {
	CountriesID  pgtype.Int8 `json:"countries_id"`
	ActiveStatus int64       `json:"active_status"`
}

func (q *Queries) GetStateByCountryId(ctx context.Context, arg GetStateByCountryIdParams) ([]State, error) {
	rows, err := q.db.Query(ctx, getStateByCountryId, arg.CountriesID, arg.ActiveStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []State
	for rows.Next() {
		var i State
		if err := rows.Scan(
			&i.ID,
			&i.State,
			&i.CountriesID,
			&i.IsCapital,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.StateAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStateByName = `-- name: GetStateByName :one
SELECT id, state, countries_id, is_capital, created_at, updated_at, lat, lng, status, deleted_at, updated_by, state_ar FROM states 
WHERE state = $2 LIMIT $1
`

type GetStateByNameParams struct {
	Limit int32  `json:"limit"`
	State string `json:"state"`
}

func (q *Queries) GetStateByName(ctx context.Context, arg GetStateByNameParams) (State, error) {
	row := q.db.QueryRow(ctx, getStateByName, arg.Limit, arg.State)
	var i State
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CountriesID,
		&i.IsCapital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.StateAr,
	)
	return i, err
}

const getStateNew = `-- name: GetStateNew :one
SELECT id, state, countries_id, is_capital, created_at, updated_at, lat, lng, status, deleted_at, updated_by, state_ar FROM states 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStateNew(ctx context.Context, id int64) (State, error) {
	row := q.db.QueryRow(ctx, getStateNew, id)
	var i State
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CountriesID,
		&i.IsCapital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.StateAr,
	)
	return i, err
}

const updateState = `-- name: UpdateState :one
UPDATE states
SET 
    state = $2,
    status = $3,
    -- lat = $4,
    -- lng = $5,
    countries_id = $4,
    updated_at = $5,
    updated_by = $6,
    state_ar = $7,
    is_capital = $8

WHERE id = $1
RETURNING id, state, countries_id, is_capital, created_at, updated_at, lat, lng, status, deleted_at, updated_by, state_ar
`

type UpdateStateParams struct {
	ID          int64       `json:"id"`
	State       string      `json:"state"`
	Status      int64       `json:"status"`
	CountriesID pgtype.Int8 `json:"countries_id"`
	UpdatedAt   time.Time   `json:"updated_at"`
	UpdatedBy   int64       `json:"updated_by"`
	StateAr     pgtype.Text `json:"state_ar"`
	IsCapital   pgtype.Bool `json:"is_capital"`
}

func (q *Queries) UpdateState(ctx context.Context, arg UpdateStateParams) (State, error) {
	row := q.db.QueryRow(ctx, updateState,
		arg.ID,
		arg.State,
		arg.Status,
		arg.CountriesID,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.StateAr,
		arg.IsCapital,
	)
	var i State
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CountriesID,
		&i.IsCapital,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.StateAr,
	)
	return i, err
}
