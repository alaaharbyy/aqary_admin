// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: leaders.sql

package sqlc

import (
	"context"
	"time"
)

const createLeaders = `-- name: CreateLeaders :one
INSERT INTO leaders (
    name,
    position,
    description,
    image_url,
    is_branch,
    company_type,
    company_id,
    users_id,
    created_at,
    updated_at
)VALUES (
    $1 ,$2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, name, position, description, image_url, is_branch, company_type, company_id, users_id, created_at, updated_at, is_verified
`

type CreateLeadersParams struct {
	Name        string    `json:"name"`
	Position    string    `json:"position"`
	Description string    `json:"description"`
	ImageUrl    string    `json:"image_url"`
	IsBranch    bool      `json:"is_branch"`
	CompanyType int64     `json:"company_type"`
	CompanyID   int64     `json:"company_id"`
	UsersID     int64     `json:"users_id"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) CreateLeaders(ctx context.Context, arg CreateLeadersParams) (Leader, error) {
	row := q.db.QueryRow(ctx, createLeaders,
		arg.Name,
		arg.Position,
		arg.Description,
		arg.ImageUrl,
		arg.IsBranch,
		arg.CompanyType,
		arg.CompanyID,
		arg.UsersID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Leader
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Position,
		&i.Description,
		&i.ImageUrl,
		&i.IsBranch,
		&i.CompanyType,
		&i.CompanyID,
		&i.UsersID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsVerified,
	)
	return i, err
}

const deleteLeaders = `-- name: DeleteLeaders :exec
DELETE FROM leaders
Where id = $1
`

func (q *Queries) DeleteLeaders(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteLeaders, id)
	return err
}

const getAllLeaders = `-- name: GetAllLeaders :many
SELECT id, name, position, description, image_url, is_branch, company_type, company_id, users_id, created_at, updated_at, is_verified FROM leaders
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllLeadersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllLeaders(ctx context.Context, arg GetAllLeadersParams) ([]Leader, error) {
	rows, err := q.db.Query(ctx, getAllLeaders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Leader
	for rows.Next() {
		var i Leader
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.Description,
			&i.ImageUrl,
			&i.IsBranch,
			&i.CompanyType,
			&i.CompanyID,
			&i.UsersID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLeadersByCompany = `-- name: GetAllLeadersByCompany :many
SELECT id, name, position, description, image_url, is_branch, company_type, company_id, users_id, created_at, updated_at, is_verified FROM leaders WHERE company_id = $3 AND company_type = $4 AND is_branch = $5  ORDER BY id  LIMIT $1  OFFSET $2
`

type GetAllLeadersByCompanyParams struct {
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
	CompanyID   int64 `json:"company_id"`
	CompanyType int64 `json:"company_type"`
	IsBranch    bool  `json:"is_branch"`
}

func (q *Queries) GetAllLeadersByCompany(ctx context.Context, arg GetAllLeadersByCompanyParams) ([]Leader, error) {
	rows, err := q.db.Query(ctx, getAllLeadersByCompany,
		arg.Limit,
		arg.Offset,
		arg.CompanyID,
		arg.CompanyType,
		arg.IsBranch,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Leader
	for rows.Next() {
		var i Leader
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.Description,
			&i.ImageUrl,
			&i.IsBranch,
			&i.CompanyType,
			&i.CompanyID,
			&i.UsersID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLeadersWithoutPagination = `-- name: GetAllLeadersWithoutPagination :many
SELECT id, name, position, description, image_url, is_branch, company_type, company_id, users_id, created_at, updated_at, is_verified FROM leaders
ORDER BY id
`

func (q *Queries) GetAllLeadersWithoutPagination(ctx context.Context) ([]Leader, error) {
	rows, err := q.db.Query(ctx, getAllLeadersWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Leader
	for rows.Next() {
		var i Leader
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.Description,
			&i.ImageUrl,
			&i.IsBranch,
			&i.CompanyType,
			&i.CompanyID,
			&i.UsersID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllLeadersByCompany = `-- name: GetCountAllLeadersByCompany :one
SELECT COUNT(*) FROM leaders WHERE company_id = $1 AND company_type = $2 AND is_branch = $3
`

type GetCountAllLeadersByCompanyParams struct {
	CompanyID   int64 `json:"company_id"`
	CompanyType int64 `json:"company_type"`
	IsBranch    bool  `json:"is_branch"`
}

func (q *Queries) GetCountAllLeadersByCompany(ctx context.Context, arg GetCountAllLeadersByCompanyParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllLeadersByCompany, arg.CompanyID, arg.CompanyType, arg.IsBranch)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLeaders = `-- name: GetLeaders :one
SELECT id, name, position, description, image_url, is_branch, company_type, company_id, users_id, created_at, updated_at, is_verified FROM leaders 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLeaders(ctx context.Context, id int64) (Leader, error) {
	row := q.db.QueryRow(ctx, getLeaders, id)
	var i Leader
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Position,
		&i.Description,
		&i.ImageUrl,
		&i.IsBranch,
		&i.CompanyType,
		&i.CompanyID,
		&i.UsersID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsVerified,
	)
	return i, err
}

const updateLeaders = `-- name: UpdateLeaders :one
UPDATE leaders
SET    name = $2,
    position = $3,
    description = $4,
    image_url = $5,
    is_branch = $6,
    company_type = $7,
    company_id = $8,
    users_id = $9,
    created_at = $10,
    updated_at = $11
Where id = $1
RETURNING id, name, position, description, image_url, is_branch, company_type, company_id, users_id, created_at, updated_at, is_verified
`

type UpdateLeadersParams struct {
	ID          int64     `json:"id"`
	Name        string    `json:"name"`
	Position    string    `json:"position"`
	Description string    `json:"description"`
	ImageUrl    string    `json:"image_url"`
	IsBranch    bool      `json:"is_branch"`
	CompanyType int64     `json:"company_type"`
	CompanyID   int64     `json:"company_id"`
	UsersID     int64     `json:"users_id"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) UpdateLeaders(ctx context.Context, arg UpdateLeadersParams) (Leader, error) {
	row := q.db.QueryRow(ctx, updateLeaders,
		arg.ID,
		arg.Name,
		arg.Position,
		arg.Description,
		arg.ImageUrl,
		arg.IsBranch,
		arg.CompanyType,
		arg.CompanyID,
		arg.UsersID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Leader
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Position,
		&i.Description,
		&i.ImageUrl,
		&i.IsBranch,
		&i.CompanyType,
		&i.CompanyID,
		&i.UsersID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsVerified,
	)
	return i, err
}
