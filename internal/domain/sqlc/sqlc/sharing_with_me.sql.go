// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sharing_with_me.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllProjectPhaseSharingWithMe = `-- name: CountAllProjectPhaseSharingWithMe :one
WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        external_sharing.external_company_id as company_ids,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        external_sharing.external_is_enabled AS is_enabled,
        phase_id
    FROM
        external_sharing
    INNER JOIN
        users  ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = true
          AND external_sharing.phase_id IS NOT NULL
          AND (external_sharing.is_property IS NULL OR  external_sharing.is_property IS FALSE)
         AND (external_sharing.is_unit IS NULL OR external_sharing.is_unit IS FALSE) 
         AND CASE WHEN $2::bigint = 0 THEN true ELSE $2::bigint = ANY(external_company_id) END 
         AND CASE WHEN $3::bigint = 0 THEN true ELSE  $4::bool = ANY(external_is_branch)  END
         AND CASE WHEN $5::bigint = 0 THEN true ELSE $5::bigint = ANY(external_company_type) END
    UNION ALL
  SELECT
        internal_sharing.project_id as project_id,
        internal_sharing.shared_to as company_ids,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        internal_sharing.is_enabled AS is_enabled,
        phase_id
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
    Where internal_sharing.is_project = true 
    AND internal_sharing.phase_id IS NOT NULL
    AND (internal_sharing.is_property IS NULL OR  internal_sharing.is_property IS FALSE)
    AND (internal_sharing.is_unit IS NULL OR internal_sharing.is_unit IS FALSE) 
    AND CASE WHEN $6::bigint = 0 THEN true ELSE $6::bigint = ANY(shared_to) END
)
SELECT
     COUNT(DISTINCT x.project_id) AS total_count
FROM 
    x
  INNER JOIN projects p ON x.project_id = p.id
    -- other joins 
  INNER JOIN phases ON p.id = phases.projects_id
  INNER JOIN phases_facts ON phases.id = phases_facts.phases_id
  INNER JOIN companies ON p.developer_companies_id = companies.id 
WHERE   
     (
     $1 = '%%'
      OR phases.ref_no ILIKE $1
      OR p.project_name ILIKE $1
      OR companies.company_name ILIKE $1
      OR phases.phase_name ILIKE $1
       OR (CASE 
        WHEN 'ready' ILIKE $1 THEN phases_facts.completion_status = 5
        WHEN 'off plan'ILIKE $1  THEN phases_facts.completion_status = 4
        WHEN '^[0-9]+$' ~ $1  THEN phases_facts.completion_percentage::TEXT % $1
        ELSE FALSE
      END)
     )   
   ---------------------     
AND  p.status NOT IN (5, 6)
`

type CountAllProjectPhaseSharingWithMeParams struct {
	Search      interface{} `json:"search"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
	UserID      int64       `json:"user_id"`
}

//	AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by  END
//
// AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by  END
func (q *Queries) CountAllProjectPhaseSharingWithMe(ctx context.Context, arg CountAllProjectPhaseSharingWithMeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProjectPhaseSharingWithMe,
		arg.Search,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
		arg.UserID,
	)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countAllProjectPropertyUnitSharingWithMe = `-- name: CountAllProjectPropertyUnitSharingWithMe :one
WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        external_sharing.external_company_id as company_ids,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        external_sharing.unit_id,
        unit_category,
        property_id,
        phase_id,
        external_sharing.external_is_enabled AS is_enabled,
        sale_unit.title,
        rent_unit.title as rent_title       
    FROM
        external_sharing
    INNER JOIN
        users ON users.id = external_sharing.created_by
    LEFT JOIN units ON external_sharing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%')
    LEFT JOIN sale_unit ON units.id = sale_unit.unit_id AND unit_category ILIKE '%sale%' 
    LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%' 
    WHERE
         external_sharing.is_project = true
         AND external_sharing.unit_id IS NOT NULL
         AND external_sharing.is_unit = true
         -- 
         AND CASE WHEN $2::bigint = 0 THEN TRUE ELSE $2::bigint = ANY (external_company_id) END
         AND CASE WHEN $3::bigint = 0 THEN TRUE ELSE $4::bool = ANY (external_is_branch) END
         AND CASE WHEN $5::bigint = 0 THEN TRUE ELSE $5::bigint = ANY(external_company_type) END 
    UNION ALL 
           
  SELECT
          internal_sharing.project_id as project_id,
         internal_sharing.shared_to as company_ids,
         'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        internal_sharing.unit_id,
        unit_category,
        property_id,
        phase_id,
        internal_sharing.is_enabled AS is_enabled,
        sale_unit.title,
        rent_unit.title as rent_title 
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
     LEFT JOIN units ON internal_sharing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%' )
     LEFT JOIN sale_unit ON units.id = sale_unit.unit_id   AND unit_category ILIKE '%sale%'
     LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%'
    Where internal_sharing.is_project = true 
    AND internal_sharing.is_unit = true  
    AND internal_sharing.unit_id IS NOT NULL
    ---
    AND CASE WHEN $6::bigint = 0 THEN TRUE ELSE $6::bigint = ANY (shared_to) END 
)
SELECT
     COUNT(DISTINCT x.unit_id) AS total_count
FROM
    x
    LEFT JOIN projects ON x.project_id = projects.id
    LEFT JOIN units ON x.unit_id = units.id
    LEFT JOIN project_properties ON x.property_id =  project_properties.id
    LEFT JOIN phases ON x.phase_id = phases.id
WHERE 
   ($1 = '%%'
     OR  units.ref_no ILIKE $1
     OR  projects.project_name ILIKE $1
     OR  project_properties.property_name ILIKE $1
     OR  phases.phase_name ILIKE $1
     OR  x.unit_category ILIKE $1
     OR  x.title ILIKE $1
     OR  x.rent_title ILIKE $1
   )
`

type CountAllProjectPropertyUnitSharingWithMeParams struct {
	Search      interface{} `json:"search"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
	UserID      int64       `json:"user_id"`
}

func (q *Queries) CountAllProjectPropertyUnitSharingWithMe(ctx context.Context, arg CountAllProjectPropertyUnitSharingWithMeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProjectPropertyUnitSharingWithMe,
		arg.Search,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
		arg.UserID,
	)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countAllProjectSharingWithMe = `-- name: CountAllProjectSharingWithMe :one
WITH x AS (
    SELECT
        external_sharing.id as share_id,
        external_sharing.external_company_id as company_ids,
        external_sharing.project_id AS project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.external_is_enabled AS is_enabled,
        external_sharing.id AS external_id
    FROM
        external_sharing
        INNER JOIN users ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = TRUE
        AND external_sharing.phase_id IS NULL
        AND (external_sharing.is_property IS NULL OR external_sharing.is_property IS FALSE)
        AND (external_sharing.is_unit IS NULL OR external_sharing.is_unit IS FALSE)
        AND CASE WHEN $2::bigint = 0 THEN TRUE ELSE $2::bigint = ANY (external_company_id) END
        AND CASE WHEN $3::bigint = 0 THEN TRUE ELSE $4::bool = ANY (external_is_branch) END
        AND CASE WHEN $5::bigint = 0 THEN TRUE ELSE $5::bigint = ANY(external_company_type) END
    UNION ALL
    SELECT
        internal_sharing.id as share_id,
        internal_sharing.shared_to as company_ids,
        internal_sharing.project_id AS project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        internal_sharing.is_enabled AS is_enabled,
        0 AS external_id
    FROM
        internal_sharing
        INNER JOIN users u ON u.id = internal_sharing.created_by
    WHERE
        internal_sharing.is_project = TRUE
        AND internal_sharing.phase_id IS NULL
        AND (internal_sharing.is_property IS NULL OR internal_sharing.is_property IS FALSE)
        AND (internal_sharing.is_unit IS NULL OR internal_sharing.is_unit IS FALSE)
        AND CASE WHEN $6::bigint = 0 THEN TRUE ELSE $6::bigint = ANY (shared_to) END
)
SELECT
    COUNT(DISTINCT x.project_id) AS total_count
FROM
    x
    INNER JOIN projects p ON x.project_id = p.id
    INNER JOIN addresses ON p.addresses_id = addresses.id 
    INNER JOIN countries ON addresses.countries_id = countries.id  
    INNER JOIN states ON addresses.states_id = states.id   
    INNER JOIN cities ON addresses.cities_id = cities.id    
    INNER JOIN companies ON p.developer_companies_id = companies.id    
    INNER JOIN properties_facts ON p.id = properties_facts.project_id AND properties_facts.is_project_fact = true  
WHERE
 -- Search criteria
    ($1 = '%%' OR 
     p.project_name % $1 OR 
     p.ref_number % $1 OR
     countries.country % $1 OR 
     states."state" % $1 OR 
     cities.city % $1 OR 
     companies.company_name % $1  
      OR (CASE 
        WHEN 'ready' ILIKE $1 THEN properties_facts.completion_status = 5
        WHEN 'off plan' ILIKE $1  THEN properties_facts.completion_status = 4
        WHEN '^[0-9]+$' ~ $1  THEN properties_facts.completion_percentage::TEXT % $1
        WHEN 'draft' ILIKE $1  THEN p.status = 1
        WHEN 'available' ILIKE $1  THEN p.status = 2
        WHEN 'block' ILIKE $1  THEN p.status = 5
        WHEN 'single' ILIKE $1  THEN p.is_multiphase = false
        WHEN 'multiple' ILIKE $1  THEN p.is_multiphase = true 
        ELSE FALSE
      END)
      )
AND 
    p.status NOT IN (5, 6)
`

type CountAllProjectSharingWithMeParams struct {
	Search      interface{} `json:"search"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
	UserID      int64       `json:"user_id"`
}

// AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by  END
// AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by  END
func (q *Queries) CountAllProjectSharingWithMe(ctx context.Context, arg CountAllProjectSharingWithMeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllProjectSharingWithMe,
		arg.Search,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
		arg.UserID,
	)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countAllShareRequestByOwnerID = `-- name: CountAllShareRequestByOwnerID :one
SELECT COUNT(DISTINCT (sharing.entity_id,sharing.shared_to)) as unique_entities_count
FROM share_requests
INNER JOIN shared_documents ON shared_documents.id = share_requests.document_id
INNER JOIN sharing ON sharing.id = shared_documents.sharing_id
WHERE owner_id = $1
`

func (q *Queries) CountAllShareRequestByOwnerID(ctx context.Context, ownerID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countAllShareRequestByOwnerID, ownerID)
	var unique_entities_count int64
	err := row.Scan(&unique_entities_count)
	return unique_entities_count, err
}

const countProjectPropertySharingWithMe = `-- name: CountProjectPropertySharingWithMe :one
WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        property_id,
        phase_id
    FROM
        external_sharing
    INNER JOIN
        users ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = true 
        AND external_sharing.property_key IS NOT NULL
        AND external_sharing.property_id IS NOT NULL
        AND external_sharing.is_property = true
        AND (external_sharing.is_unit IS false OR external_sharing.is_unit IS NULL)
        AND CASE WHEN $2::bigint = 0 THEN TRUE ELSE $2::bigint = ANY (external_company_id) END
        AND CASE WHEN $3::bigint = 0 THEN TRUE ELSE $4::bool = ANY (external_is_branch) END
        AND CASE WHEN $5::bigint = 0 THEN TRUE ELSE $5::bigint = ANY(external_company_type) END  
        
    UNION ALL 
           
    SELECT
        internal_sharing.project_id as project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        property_id,
        phase_id
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
    WHERE
        internal_sharing.is_project = true 
        AND internal_sharing.is_property = true
        AND internal_sharing.property_key IS NOT NULL
        AND internal_sharing.property_id IS NOT NULL
        AND (internal_sharing.is_unit IS false OR internal_sharing.is_unit IS NULL)
        AND CASE WHEN $6::bigint = 0 THEN TRUE ELSE $6::bigint = ANY (shared_to) END

)
SELECT
    COUNT(DISTINCT x.property_id) AS total_count
FROM
    x
    LEFT JOIN projects ON project_id = projects.id
	LEFT JOIN phases ON x.phase_id = phases.id
    LEFT JOIN project_properties ON x.property_id =  project_properties.id    
WHERE 
   ( $1 = '%%'
      OR  projects.project_name ILIKE $1
      OR project_properties.ref_no ILIKE $1
      OR project_properties.property_name ILIKE $1
      OR phases.phase_name ILIKE $1
     )
`

type CountProjectPropertySharingWithMeParams struct {
	Search      interface{} `json:"search"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
	UserID      int64       `json:"user_id"`
}

// AND CASE WHEN @user_id::bigint = 0 THEN true ELSE @user_id::bigint = created_by END
// AND CASE WHEN @user_id::bigint = 0 THEN true ELSE @user_id::bigint = created_by END
func (q *Queries) CountProjectPropertySharingWithMe(ctx context.Context, arg CountProjectPropertySharingWithMeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectPropertySharingWithMe,
		arg.Search,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
		arg.UserID,
	)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getAllProjectPhaseSharingWithMe = `-- name: GetAllProjectPhaseSharingWithMe :many

WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        external_sharing.external_company_id as company_ids,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        external_sharing.external_is_enabled AS is_enabled,
        phase_id
    FROM
        external_sharing
    INNER JOIN
        users  ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = true
          AND external_sharing.phase_id IS NOT NULL
          AND (external_sharing.is_property IS NULL OR  external_sharing.is_property IS FALSE)
         AND (external_sharing.is_unit IS NULL OR external_sharing.is_unit IS FALSE) 
         AND CASE WHEN $5::bigint = 0 THEN true ELSE $5::bigint = ANY(external_company_id) END 
         AND CASE WHEN $6::bigint = 0 THEN true ELSE  $7::bool = ANY(external_is_branch)  END
         AND CASE WHEN $8::bigint = 0 THEN true ELSE $8::bigint = ANY(external_company_type) END
    UNION ALL
  SELECT
        internal_sharing.project_id as project_id,
        internal_sharing.shared_to as company_ids,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        internal_sharing.is_enabled AS is_enabled,
        phase_id
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
    Where internal_sharing.is_project = true 
    AND internal_sharing.phase_id IS NOT NULL
    AND (internal_sharing.is_property IS NULL OR  internal_sharing.is_property IS FALSE)
    AND (internal_sharing.is_unit IS NULL OR internal_sharing.is_unit IS FALSE) 
    AND CASE WHEN $3::bigint = 0 THEN true ELSE $3::bigint = ANY(shared_to) END
)
SELECT
    x.external_id,
    x.project_id, 
    x.company_ids,
    x.created_by,
    MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = x.created_by THEN true ELSE false END AS unshared_available,
    x.phase_id,
    x.created_at,
    x.is_enabled
FROM 
    x
  INNER JOIN projects p ON x.project_id = p.id
    -- other joins 
  INNER JOIN phases ON p.id = phases.projects_id
  INNER JOIN phases_facts ON phases.id = phases_facts.phases_id
  INNER JOIN companies ON p.developer_companies_id = companies.id 
WHERE   
     (
     $4 = '%%'
      OR phases.ref_no ILIKE $4
      OR p.project_name ILIKE $4
      OR companies.company_name ILIKE $4
      OR phases.phase_name ILIKE $4
       OR (CASE 
        WHEN 'ready' ILIKE $4 THEN phases_facts.completion_status = 5
        WHEN 'off plan'ILIKE $4  THEN phases_facts.completion_status = 4
        WHEN '^[0-9]+$' ~ $4  THEN phases_facts.completion_percentage::TEXT % $4
        ELSE FALSE
      END)
     )   
   ---------------------     
   AND  p.status NOT IN (5, 6)
GROUP BY
    x.project_id,
    x.company_ids,
    x.created_by,
    x.external_id,
    x.created_at,
    x.phase_id,
    x.is_enabled
    ORDER BY created_at DESC
    LIMIT $1 OFFSET $2
`

type GetAllProjectPhaseSharingWithMeParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	UserID      int64       `json:"user_id"`
	Search      interface{} `json:"search"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
}

type GetAllProjectPhaseSharingWithMeRow struct {
	ExternalID        int64         `json:"external_id"`
	ProjectID         pgtype.Int8   `json:"project_id"`
	CompanyIds        []int64       `json:"company_ids"`
	CreatedBy         int64         `json:"created_by"`
	Internal          string        `json:"internal"`
	External          string        `json:"external"`
	UnsharedAvailable pgtype.Bool   `json:"unshared_available"`
	PhaseID           pgtype.Int8   `json:"phase_id"`
	CreatedAt         time.Time     `json:"created_at"`
	IsEnabled         []pgtype.Bool `json:"is_enabled"`
}

// ! ******************************************  Share Project Phase   *****************************************************
//
//	     AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by  END
//	AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by  END
func (q *Queries) GetAllProjectPhaseSharingWithMe(ctx context.Context, arg GetAllProjectPhaseSharingWithMeParams) ([]GetAllProjectPhaseSharingWithMeRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPhaseSharingWithMe,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Search,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPhaseSharingWithMeRow
	for rows.Next() {
		var i GetAllProjectPhaseSharingWithMeRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.ProjectID,
			&i.CompanyIds,
			&i.CreatedBy,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
			&i.PhaseID,
			&i.CreatedAt,
			&i.IsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertySharingWithMe = `-- name: GetAllProjectPropertySharingWithMe :many



 
 
WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        external_sharing.external_company_id as company_ids,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        external_sharing.external_is_enabled AS is_enabled,
        property_id,
        phase_id
    FROM
        external_sharing
    INNER JOIN
        users  ON users.id = external_sharing.created_by
    WHERE
         external_sharing.is_project = true 
         AND external_sharing.property_key IS NOT NULL
         AND external_sharing.property_id IS NOT NULL
         AND external_sharing.is_property = true
         AND (external_sharing.is_unit IS false OR external_sharing.is_unit IS NULL)
         ---
         AND CASE WHEN $5::bigint = 0 THEN TRUE ELSE $5::bigint = ANY (external_company_id) END
         AND CASE WHEN $6::bigint = 0 THEN TRUE ELSE $7::bool = ANY (external_is_branch) END
         AND CASE WHEN $8::bigint = 0 THEN TRUE ELSE $8::bigint = ANY(external_company_type) END       
    UNION ALL 
           
  SELECT
        internal_sharing.project_id as project_id,
        internal_sharing.shared_to as company_ids,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        internal_sharing.is_enabled AS is_enabled,
        property_id,
        phase_id
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
    Where internal_sharing.is_project = true 
    AND internal_sharing.is_property = true AND internal_sharing.property_key  IS NOT NULL
    AND internal_sharing.property_id  IS NOT NULL
    AND (internal_sharing.is_unit IS false OR internal_sharing.is_unit IS NULL)
    ---
    AND CASE WHEN $3::bigint = 0 THEN TRUE ELSE $3::bigint = ANY (shared_to) END

)
SELECT
    x.external_id,
    x.project_id,
    x.company_ids,
    x.created_by,
    MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = x.created_by THEN true ELSE false END AS unshared_available,
    x.created_at,
    x.property_id,
    x.phase_id,
    x.is_enabled
FROM
    x
    LEFT JOIN projects ON project_id = projects.id
	LEFT JOIN phases ON x.phase_id = phases.id
    LEFT JOIN project_properties ON x.property_id =  project_properties.id
     
WHERE 
   ( $4 = '%%'
      OR  projects.project_name ILIKE $4
      OR project_properties.ref_no ILIKE $4
      OR project_properties.property_name ILIKE $4
      OR phases.phase_name ILIKE $4
     ) 
GROUP BY
    project_id,
    x.created_by,
    x.company_ids,
    x.external_id,
    x.created_at,
    x.property_id,
    x.phase_id,
    x.is_enabled
    ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllProjectPropertySharingWithMeParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	UserID      int64       `json:"user_id"`
	Search      interface{} `json:"search"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
}

type GetAllProjectPropertySharingWithMeRow struct {
	ExternalID        int64         `json:"external_id"`
	ProjectID         pgtype.Int8   `json:"project_id"`
	CompanyIds        []int64       `json:"company_ids"`
	CreatedBy         int64         `json:"created_by"`
	Internal          string        `json:"internal"`
	External          string        `json:"external"`
	UnsharedAvailable pgtype.Bool   `json:"unshared_available"`
	CreatedAt         time.Time     `json:"created_at"`
	PropertyID        pgtype.Int8   `json:"property_id"`
	PhaseID           pgtype.Int8   `json:"phase_id"`
	IsEnabled         []pgtype.Bool `json:"is_enabled"`
}

// ! ******************************************  Share Property   *****************************************************
//
//	AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by END
func (q *Queries) GetAllProjectPropertySharingWithMe(ctx context.Context, arg GetAllProjectPropertySharingWithMeParams) ([]GetAllProjectPropertySharingWithMeRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertySharingWithMe,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Search,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPropertySharingWithMeRow
	for rows.Next() {
		var i GetAllProjectPropertySharingWithMeRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.ProjectID,
			&i.CompanyIds,
			&i.CreatedBy,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
			&i.CreatedAt,
			&i.PropertyID,
			&i.PhaseID,
			&i.IsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertyUnitSharingWithMe = `-- name: GetAllProjectPropertyUnitSharingWithMe :many

WITH x AS (
    SELECT  
        external_sharing.project_id as project_id,
        external_sharing.external_company_id as company_ids,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.id as external_id,
        external_sharing.unit_id,
        unit_category,
        property_id,
        phase_id,
        external_sharing.external_is_enabled AS is_enabled,
        sale_unit.title,
        rent_unit.title as rent_title       
    FROM
        external_sharing
    INNER JOIN
        users ON users.id = external_sharing.created_by
    LEFT JOIN units ON external_sharing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%')
    LEFT JOIN sale_unit ON units.id = sale_unit.unit_id AND unit_category ILIKE '%sale%' 
    LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%' 
    WHERE
         external_sharing.is_project = true
         AND external_sharing.unit_id IS NOT NULL
         AND external_sharing.is_unit = true
         -- 
         AND CASE WHEN $5::bigint = 0 THEN TRUE ELSE $5::bigint = ANY (external_company_id) END
         AND CASE WHEN $6::bigint = 0 THEN TRUE ELSE $7::bool = ANY (external_is_branch) END
         AND CASE WHEN $8::bigint = 0 THEN TRUE ELSE $8::bigint = ANY(external_company_type) END 
    UNION ALL 
           
  SELECT
          internal_sharing.project_id as project_id,
         internal_sharing.shared_to as company_ids,
         'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        0 as external_id,
        internal_sharing.unit_id,
        unit_category,
        property_id,
        phase_id,
        internal_sharing.is_enabled AS is_enabled,
        sale_unit.title,
        rent_unit.title as rent_title 
    FROM
        internal_sharing
    INNER JOIN
        users u ON u.id = internal_sharing.created_by
     LEFT JOIN units ON internal_sharing.unit_id = units.id AND (unit_category ILIKE '%sale%' OR unit_category ILIKE '%rent%' )
     LEFT JOIN sale_unit ON units.id = sale_unit.unit_id   AND unit_category ILIKE '%sale%'
     LEFT JOIN rent_unit ON units.id = rent_unit.unit_id AND unit_category ILIKE '%rent%'
    Where internal_sharing.is_project = true 
    AND internal_sharing.is_unit = true  
    AND internal_sharing.unit_id IS NOT NULL
    ---
    AND CASE WHEN $3::bigint = 0 THEN TRUE ELSE $3::bigint = ANY (shared_to) END
)
SELECT
    x.external_id,
    x.project_id,
    x.company_ids,
    x.created_by,
    MAX(CASE WHEN source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = x.created_by THEN true ELSE false END AS unshared_available,
    x.created_at,
    x.unit_id,
    x.unit_category,
    x.property_id,
    x.phase_id,
    x.is_enabled,
    MAX(x.title) as title,
    MAX(x.rent_title)as rent_title
FROM
    x
    LEFT JOIN projects ON x.project_id = projects.id
    LEFT JOIN units ON x.unit_id = units.id
    LEFT JOIN project_properties ON x.property_id =  project_properties.id
    LEFT JOIN phases ON x.phase_id = phases.id
WHERE 
   ($4 = '%%'
     OR  units.ref_no ILIKE $4
     OR  projects.project_name ILIKE $4
     OR  project_properties.property_name ILIKE $4
     OR  phases.phase_name ILIKE $4
     OR  x.unit_category ILIKE $4
     OR  x.title ILIKE $4
     OR  x.rent_title ILIKE $4
   ) 
GROUP BY
    x.project_id,
    x.created_by,
    x.company_ids,
    x.external_id,
    x.created_at,
    x.unit_id,
    x.unit_category,
    x.property_id,
    x.phase_id,
    x.title,
    x.rent_title,
    x.is_enabled
    ORDER BY x.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllProjectPropertyUnitSharingWithMeParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	UserID      int64       `json:"user_id"`
	Search      interface{} `json:"search"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
}

type GetAllProjectPropertyUnitSharingWithMeRow struct {
	ExternalID        int64         `json:"external_id"`
	ProjectID         pgtype.Int8   `json:"project_id"`
	CompanyIds        []int64       `json:"company_ids"`
	CreatedBy         int64         `json:"created_by"`
	Internal          string        `json:"internal"`
	External          string        `json:"external"`
	UnsharedAvailable pgtype.Bool   `json:"unshared_available"`
	CreatedAt         time.Time     `json:"created_at"`
	UnitID            pgtype.Int8   `json:"unit_id"`
	UnitCategory      pgtype.Text   `json:"unit_category"`
	PropertyID        pgtype.Int8   `json:"property_id"`
	PhaseID           pgtype.Int8   `json:"phase_id"`
	IsEnabled         []pgtype.Bool `json:"is_enabled"`
	Title             interface{}   `json:"title"`
	RentTitle         interface{}   `json:"rent_title"`
}

// ! ******************************************  Share Unit  *****************************************************
//
//	AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  internal_sharing.created_by  END
func (q *Queries) GetAllProjectPropertyUnitSharingWithMe(ctx context.Context, arg GetAllProjectPropertyUnitSharingWithMeParams) ([]GetAllProjectPropertyUnitSharingWithMeRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertyUnitSharingWithMe,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Search,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPropertyUnitSharingWithMeRow
	for rows.Next() {
		var i GetAllProjectPropertyUnitSharingWithMeRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.ProjectID,
			&i.CompanyIds,
			&i.CreatedBy,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
			&i.CreatedAt,
			&i.UnitID,
			&i.UnitCategory,
			&i.PropertyID,
			&i.PhaseID,
			&i.IsEnabled,
			&i.Title,
			&i.RentTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectSharingWithMe = `-- name: GetAllProjectSharingWithMe :many
WITH x AS (
    SELECT
        external_sharing.id as share_id,
        external_sharing.external_company_id as company_ids,
        external_sharing.project_id AS project_id,
        'external' AS source,
        external_sharing.created_at,
        external_sharing.created_by,
        external_sharing.external_is_enabled AS is_enabled,
        external_sharing.id AS external_id
    FROM
        external_sharing
        INNER JOIN users ON users.id = external_sharing.created_by
    WHERE
        external_sharing.is_project = TRUE
        AND external_sharing.phase_id IS NULL
        AND (external_sharing.is_property IS NULL OR external_sharing.is_property IS FALSE)
        AND (external_sharing.is_unit IS NULL OR external_sharing.is_unit IS FALSE)
        AND CASE WHEN $5::bigint = 0 THEN TRUE ELSE $5::bigint = ANY (external_company_id) END
        AND CASE WHEN $6::bigint = 0 THEN TRUE ELSE $7::bool = ANY (external_is_branch) END
        AND CASE WHEN $8::bigint = 0 THEN TRUE ELSE $8::bigint = ANY(external_company_type) END
    UNION ALL
    SELECT
        internal_sharing.id as share_id,
        internal_sharing.shared_to as company_ids,
        internal_sharing.project_id AS project_id,
        'internal' AS source,
        internal_sharing.created_at,
        internal_sharing.created_by,
        internal_sharing.is_enabled AS is_enabled,
        0 AS external_id
    FROM
        internal_sharing
        INNER JOIN users u ON u.id = internal_sharing.created_by
    WHERE
        internal_sharing.is_project = TRUE
        AND internal_sharing.phase_id IS NULL
        AND (internal_sharing.is_property IS NULL OR internal_sharing.is_property IS FALSE)
        AND (internal_sharing.is_unit IS NULL OR internal_sharing.is_unit IS FALSE)
        AND CASE WHEN $3::bigint = 0 THEN TRUE ELSE $3::bigint = ANY (shared_to) END
)
SELECT
    x.share_id,
    x.company_ids,
    x.external_id,
    x.project_id,
    x.created_by,
    MAX(CASE WHEN x.source = 'internal' THEN 'internal' ELSE '' END)::varchar AS internal,
    MAX(CASE WHEN x.source = 'external' THEN 'external' ELSE '' END)::varchar AS external,
    CASE WHEN $3::bigint = x.created_by THEN TRUE ELSE FALSE END AS unshared_available,
    x.created_at,
    x.is_enabled
FROM
    x
    LEFT JOIN projects p ON x.project_id = p.id
    LEFT JOIN addresses ON p.addresses_id = addresses.id 
    LEFT JOIN countries ON addresses.countries_id = countries.id  
    LEFT JOIN states ON addresses.states_id = states.id   
    LEFT JOIN cities ON addresses.cities_id = cities.id    
    LEFT JOIN companies ON p.developer_companies_id = companies.id    
    LEFT JOIN properties_facts ON p.id = properties_facts.project_id AND properties_facts.is_project_fact = true  
WHERE
 -- Search criteria
    ($4 = '%%' OR 
     p.project_name % $4 OR 
     p.ref_number % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     companies.company_name % $4  
      OR (CASE 
        WHEN 'ready' ILIKE $4 THEN properties_facts.completion_status = 5
        WHEN 'off plan' ILIKE $4  THEN properties_facts.completion_status = 4
        WHEN '^[0-9]+$' ~ $4  THEN properties_facts.completion_percentage::TEXT % $4
        WHEN 'draft' ILIKE $4  THEN p.status = 1
        WHEN 'available' ILIKE $4  THEN p.status = 2
        WHEN 'block' ILIKE $4  THEN p.status = 5
        WHEN 'single' ILIKE $4  THEN p.is_multiphase = false
        WHEN 'multiple' ILIKE $4  THEN p.is_multiphase = true 
        ELSE FALSE
      END)
      )
AND 
    p.status NOT IN (5, 6)
GROUP BY
    x.share_id,
    x.company_ids,
    x.project_id,
    x.created_by,
    x.external_id,
    x.created_at,
    x.is_enabled
ORDER BY
    x.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllProjectSharingWithMeParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	UserID      int64       `json:"user_id"`
	Search      interface{} `json:"search"`
	CompanyID   int64       `json:"company_id"`
	IsBranchID  int64       `json:"is_branch_id"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	CompanyType int64       `json:"company_type"`
}

type GetAllProjectSharingWithMeRow struct {
	ShareID           int64         `json:"share_id"`
	CompanyIds        []int64       `json:"company_ids"`
	ExternalID        int64         `json:"external_id"`
	ProjectID         pgtype.Int8   `json:"project_id"`
	CreatedBy         int64         `json:"created_by"`
	Internal          string        `json:"internal"`
	External          string        `json:"external"`
	UnsharedAvailable pgtype.Bool   `json:"unshared_available"`
	CreatedAt         time.Time     `json:"created_at"`
	IsEnabled         []pgtype.Bool `json:"is_enabled"`
}

// AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by  END
// AND CASE WHEN @user_id::bigint = 0 THEN true ELSE  @user_id::bigint =  created_by  END
func (q *Queries) GetAllProjectSharingWithMe(ctx context.Context, arg GetAllProjectSharingWithMeParams) ([]GetAllProjectSharingWithMeRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectSharingWithMe,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Search,
		arg.CompanyID,
		arg.IsBranchID,
		arg.IsBranch,
		arg.CompanyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectSharingWithMeRow
	for rows.Next() {
		var i GetAllProjectSharingWithMeRow
		if err := rows.Scan(
			&i.ShareID,
			&i.CompanyIds,
			&i.ExternalID,
			&i.ProjectID,
			&i.CreatedBy,
			&i.Internal,
			&i.External,
			&i.UnsharedAvailable,
			&i.CreatedAt,
			&i.IsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllShareRequestByOwnerID = `-- name: GetAllShareRequestByOwnerID :many
SELECT DISTINCT ON (sharing.entity_id,sharing.shared_to)
 share_requests.requester_id, share_requests.owner_id, share_requests.created_at,share_requests.created_by,
 shared_documents.is_allowed, shared_documents.sharing_id, sharing.entity_type_id, sharing.entity_id 
 FROM share_requests
INNER JOIN shared_documents ON shared_documents.id =  share_requests.document_id
INNER JOIN sharing ON sharing.id = shared_documents.sharing_id
WHERE owner_id = $3
ORDER BY sharing.entity_id,sharing.shared_to, created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllShareRequestByOwnerIDParams struct {
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	OwnerID pgtype.Int8 `json:"owner_id"`
}

type GetAllShareRequestByOwnerIDRow struct {
	RequesterID  pgtype.Int8        `json:"requester_id"`
	OwnerID      pgtype.Int8        `json:"owner_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CreatedBy    pgtype.Int8        `json:"created_by"`
	IsAllowed    pgtype.Bool        `json:"is_allowed"`
	SharingID    pgtype.Int8        `json:"sharing_id"`
	EntityTypeID pgtype.Int8        `json:"entity_type_id"`
	EntityID     int64              `json:"entity_id"`
}

// ----------------------------------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetAllShareRequestByOwnerID(ctx context.Context, arg GetAllShareRequestByOwnerIDParams) ([]GetAllShareRequestByOwnerIDRow, error) {
	rows, err := q.db.Query(ctx, getAllShareRequestByOwnerID, arg.Limit, arg.Offset, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllShareRequestByOwnerIDRow
	for rows.Next() {
		var i GetAllShareRequestByOwnerIDRow
		if err := rows.Scan(
			&i.RequesterID,
			&i.OwnerID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsAllowed,
			&i.SharingID,
			&i.EntityTypeID,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
