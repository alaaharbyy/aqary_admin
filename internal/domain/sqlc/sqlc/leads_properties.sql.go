// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: leads_properties.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkLeadProperty = `-- name: CheckLeadProperty :one
select id, leads_id, properies_type_id, property_id, unit_category, unit_id, is_branch, date_added, is_property from leads_properties where properies_type_id = $1 and property_id = $2 and unit_category = $3 and is_branch = $4 and is_property = $5 and leads_id = $6 limit 1
`

type CheckLeadPropertyParams struct {
	ProperiesTypeID pgtype.Int8 `json:"properies_type_id"`
	PropertyID      pgtype.Int8 `json:"property_id"`
	UnitCategory    pgtype.Text `json:"unit_category"`
	IsBranch        pgtype.Bool `json:"is_branch"`
	IsProperty      pgtype.Bool `json:"is_property"`
	LeadsID         pgtype.Int8 `json:"leads_id"`
}

func (q *Queries) CheckLeadProperty(ctx context.Context, arg CheckLeadPropertyParams) (LeadsProperty, error) {
	row := q.db.QueryRow(ctx, checkLeadProperty,
		arg.ProperiesTypeID,
		arg.PropertyID,
		arg.UnitCategory,
		arg.IsBranch,
		arg.IsProperty,
		arg.LeadsID,
	)
	var i LeadsProperty
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.ProperiesTypeID,
		&i.PropertyID,
		&i.UnitCategory,
		&i.UnitID,
		&i.IsBranch,
		&i.DateAdded,
		&i.IsProperty,
	)
	return i, err
}

const createLeadProperties = `-- name: CreateLeadProperties :one
INSERT INTO leads_properties (
    leads_id,
    properies_type_id,
    property_id,
    unit_category,
    unit_id,
    is_branch,
    date_added,
    is_property
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, leads_id, properies_type_id, property_id, unit_category, unit_id, is_branch, date_added, is_property
`

type CreateLeadPropertiesParams struct {
	LeadsID         pgtype.Int8 `json:"leads_id"`
	ProperiesTypeID pgtype.Int8 `json:"properies_type_id"`
	PropertyID      pgtype.Int8 `json:"property_id"`
	UnitCategory    pgtype.Text `json:"unit_category"`
	UnitID          pgtype.Int8 `json:"unit_id"`
	IsBranch        pgtype.Bool `json:"is_branch"`
	DateAdded       time.Time   `json:"date_added"`
	IsProperty      pgtype.Bool `json:"is_property"`
}

func (q *Queries) CreateLeadProperties(ctx context.Context, arg CreateLeadPropertiesParams) (LeadsProperty, error) {
	row := q.db.QueryRow(ctx, createLeadProperties,
		arg.LeadsID,
		arg.ProperiesTypeID,
		arg.PropertyID,
		arg.UnitCategory,
		arg.UnitID,
		arg.IsBranch,
		arg.DateAdded,
		arg.IsProperty,
	)
	var i LeadsProperty
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.ProperiesTypeID,
		&i.PropertyID,
		&i.UnitCategory,
		&i.UnitID,
		&i.IsBranch,
		&i.DateAdded,
		&i.IsProperty,
	)
	return i, err
}

const deleteLeadPropertyByLeadId = `-- name: DeleteLeadPropertyByLeadId :exec
DELETE FROM leads_properties where id = $1
`

func (q *Queries) DeleteLeadPropertyByLeadId(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteLeadPropertyByLeadId, id)
	return err
}

const getAllLeadPropertiesByLeadId = `-- name: GetAllLeadPropertiesByLeadId :many
SELECT id, leads_id, properies_type_id, property_id, unit_category, unit_id, is_branch, date_added, is_property
FROM leads_properties
WHERE leads_id = $1
ORDER BY id
OFFSET $2
LIMIT $3
`

type GetAllLeadPropertiesByLeadIdParams struct {
	LeadsID pgtype.Int8 `json:"leads_id"`
	Offset  int32       `json:"offset"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) GetAllLeadPropertiesByLeadId(ctx context.Context, arg GetAllLeadPropertiesByLeadIdParams) ([]LeadsProperty, error) {
	rows, err := q.db.Query(ctx, getAllLeadPropertiesByLeadId, arg.LeadsID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadsProperty
	for rows.Next() {
		var i LeadsProperty
		if err := rows.Scan(
			&i.ID,
			&i.LeadsID,
			&i.ProperiesTypeID,
			&i.PropertyID,
			&i.UnitCategory,
			&i.UnitID,
			&i.IsBranch,
			&i.DateAdded,
			&i.IsProperty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllLeadsPropertiesByLeadId = `-- name: GetCountAllLeadsPropertiesByLeadId :one
SELECT COUNT(*) FROM leads_properties WHERE leads_id = $1
`

func (q *Queries) GetCountAllLeadsPropertiesByLeadId(ctx context.Context, leadsID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllLeadsPropertiesByLeadId, leadsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPropertyTypesByCategoryForLeads = `-- name: GetPropertyTypesByCategoryForLeads :many
SELECT 
pt.id, 
pt.type as label, 
CASE 
    WHEN ARRAY[1]::bigint[] <@ ARRAY_AGG(lt.fact_id) THEN TRUE 
    ELSE FALSE 
END AS bed,
CASE 
    WHEN ARRAY[2]::bigint[] <@ ARRAY_AGG(lt.fact_id) THEN TRUE 
    ELSE FALSE 
END AS bath
FROM 
property_types pt
LEFT JOIN LATERAL (
    SELECT fact_id
    FROM UNNEST(pt.property_type_facts_id) AS lt(fact_id)
    LIMIT 2
) lt ON TRUE
WHERE 
pt.category % $1
GROUP BY 
pt.id, 
pt.type
ORDER BY 
pt.id
`

type GetPropertyTypesByCategoryForLeadsRow struct {
	ID    int64       `json:"id"`
	Label string      `json:"label"`
	Bed   pgtype.Bool `json:"bed"`
	Bath  pgtype.Bool `json:"bath"`
}

func (q *Queries) GetPropertyTypesByCategoryForLeads(ctx context.Context, category string) ([]GetPropertyTypesByCategoryForLeadsRow, error) {
	rows, err := q.db.Query(ctx, getPropertyTypesByCategoryForLeads, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertyTypesByCategoryForLeadsRow
	for rows.Next() {
		var i GetPropertyTypesByCategoryForLeadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Bed,
			&i.Bath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyTypesByIdListForLeads = `-- name: GetPropertyTypesByIdListForLeads :many
SELECT 
pt.id, 
pt.type as label, 
CASE 
    WHEN ARRAY[1]::bigint[] <@ ARRAY_AGG(lt.fact_id) THEN TRUE 
    ELSE FALSE 
END AS bed,
CASE 
    WHEN ARRAY[2]::bigint[] <@ ARRAY_AGG(lt.fact_id) THEN TRUE 
    ELSE FALSE 
END AS bath
FROM 
property_types pt
LEFT JOIN LATERAL (
    SELECT fact_id
    FROM UNNEST(pt.property_type_facts_id) AS lt(fact_id)
    LIMIT 2
) lt ON TRUE
WHERE 
pt.id = ANY($1::bigint[])
GROUP BY 
pt.id, 
pt.type
ORDER BY 
pt.id
`

type GetPropertyTypesByIdListForLeadsRow struct {
	ID    int64       `json:"id"`
	Label string      `json:"label"`
	Bed   pgtype.Bool `json:"bed"`
	Bath  pgtype.Bool `json:"bath"`
}

func (q *Queries) GetPropertyTypesByIdListForLeads(ctx context.Context, dollar_1 []int64) ([]GetPropertyTypesByIdListForLeadsRow, error) {
	rows, err := q.db.Query(ctx, getPropertyTypesByIdListForLeads, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertyTypesByIdListForLeadsRow
	for rows.Next() {
		var i GetPropertyTypesByIdListForLeadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Bed,
			&i.Bath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleLeadProperty = `-- name: GetSingleLeadProperty :one
select id, leads_id, properies_type_id, property_id, unit_category, unit_id, is_branch, date_added, is_property from leads_properties where id = $1
`

func (q *Queries) GetSingleLeadProperty(ctx context.Context, id int64) (LeadsProperty, error) {
	row := q.db.QueryRow(ctx, getSingleLeadProperty, id)
	var i LeadsProperty
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.ProperiesTypeID,
		&i.PropertyID,
		&i.UnitCategory,
		&i.UnitID,
		&i.IsBranch,
		&i.DateAdded,
		&i.IsProperty,
	)
	return i, err
}

const updateLeadProperties = `-- name: UpdateLeadProperties :one
UPDATE
    leads_properties
SET
    properies_type_id = $1,
    property_id = $2,
    unit_category = $3,
    unit_id = $4,
    is_branch = $5,
    date_added = $6,
    is_property = $7
WHERE
    id = $8 RETURNING id, leads_id, properies_type_id, property_id, unit_category, unit_id, is_branch, date_added, is_property
`

type UpdateLeadPropertiesParams struct {
	ProperiesTypeID pgtype.Int8 `json:"properies_type_id"`
	PropertyID      pgtype.Int8 `json:"property_id"`
	UnitCategory    pgtype.Text `json:"unit_category"`
	UnitID          pgtype.Int8 `json:"unit_id"`
	IsBranch        pgtype.Bool `json:"is_branch"`
	DateAdded       time.Time   `json:"date_added"`
	IsProperty      pgtype.Bool `json:"is_property"`
	ID              int64       `json:"id"`
}

func (q *Queries) UpdateLeadProperties(ctx context.Context, arg UpdateLeadPropertiesParams) (LeadsProperty, error) {
	row := q.db.QueryRow(ctx, updateLeadProperties,
		arg.ProperiesTypeID,
		arg.PropertyID,
		arg.UnitCategory,
		arg.UnitID,
		arg.IsBranch,
		arg.DateAdded,
		arg.IsProperty,
		arg.ID,
	)
	var i LeadsProperty
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.ProperiesTypeID,
		&i.PropertyID,
		&i.UnitCategory,
		&i.UnitID,
		&i.IsBranch,
		&i.DateAdded,
		&i.IsProperty,
	)
	return i, err
}

const updateMultipleLeadPropertiesLeadID = `-- name: UpdateMultipleLeadPropertiesLeadID :one
UPDATE leads_properties SET leads_id = $1 WHERE id = ANY($2::bigint[]) RETURNING id, leads_id, properies_type_id, property_id, unit_category, unit_id, is_branch, date_added, is_property
`

type UpdateMultipleLeadPropertiesLeadIDParams struct {
	LeadsID pgtype.Int8 `json:"leads_id"`
	Column2 []int64     `json:"column_2"`
}

func (q *Queries) UpdateMultipleLeadPropertiesLeadID(ctx context.Context, arg UpdateMultipleLeadPropertiesLeadIDParams) (LeadsProperty, error) {
	row := q.db.QueryRow(ctx, updateMultipleLeadPropertiesLeadID, arg.LeadsID, arg.Column2)
	var i LeadsProperty
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.ProperiesTypeID,
		&i.PropertyID,
		&i.UnitCategory,
		&i.UnitID,
		&i.IsBranch,
		&i.DateAdded,
		&i.IsProperty,
	)
	return i, err
}

const updateSingleLeadPropertiesLeadID = `-- name: UpdateSingleLeadPropertiesLeadID :one
UPDATE leads_properties SET leads_id = $1 WHERE id = $2 RETURNING id, leads_id, properies_type_id, property_id, unit_category, unit_id, is_branch, date_added, is_property
`

type UpdateSingleLeadPropertiesLeadIDParams struct {
	LeadsID pgtype.Int8 `json:"leads_id"`
	ID      int64       `json:"id"`
}

func (q *Queries) UpdateSingleLeadPropertiesLeadID(ctx context.Context, arg UpdateSingleLeadPropertiesLeadIDParams) (LeadsProperty, error) {
	row := q.db.QueryRow(ctx, updateSingleLeadPropertiesLeadID, arg.LeadsID, arg.ID)
	var i LeadsProperty
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.ProperiesTypeID,
		&i.PropertyID,
		&i.UnitCategory,
		&i.UnitID,
		&i.IsBranch,
		&i.DateAdded,
		&i.IsProperty,
	)
	return i, err
}
