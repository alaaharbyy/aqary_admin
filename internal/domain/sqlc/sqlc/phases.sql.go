// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: phases.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPhases = `-- name: CreatePhases :one
INSERT INTO phases (
    phase_name,
    created_at,
    updated_at,
    status,
    live_status,
    ref_no,
    projects_id,
    addresses_id,
    rating,
    description,
    description_ar,
    polygon_coords,
    facts,
    bank_name,
    registration_date,
    escrow_number
)VALUES (
    $1 , $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13,$14, $15, $16
) RETURNING id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number
`

type CreatePhasesParams struct {
	PhaseName        string      `json:"phase_name"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Status           int64       `json:"status"`
	LiveStatus       pgtype.Bool `json:"live_status"`
	RefNo            string      `json:"ref_no"`
	ProjectsID       int64       `json:"projects_id"`
	AddressesID      pgtype.Int8 `json:"addresses_id"`
	Rating           float64     `json:"rating"`
	Description      string      `json:"description"`
	DescriptionAr    pgtype.Text `json:"description_ar"`
	PolygonCoords    []byte      `json:"polygon_coords"`
	Facts            []byte      `json:"facts"`
	BankName         string      `json:"bank_name"`
	RegistrationDate time.Time   `json:"registration_date"`
	EscrowNumber     string      `json:"escrow_number"`
}

func (q *Queries) CreatePhases(ctx context.Context, arg CreatePhasesParams) (Phase, error) {
	row := q.db.QueryRow(ctx, createPhases,
		arg.PhaseName,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.LiveStatus,
		arg.RefNo,
		arg.ProjectsID,
		arg.AddressesID,
		arg.Rating,
		arg.Description,
		arg.DescriptionAr,
		arg.PolygonCoords,
		arg.Facts,
		arg.BankName,
		arg.RegistrationDate,
		arg.EscrowNumber,
	)
	var i Phase
	err := row.Scan(
		&i.ID,
		&i.PhaseName,
		&i.AddressesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.LiveStatus,
		&i.RefNo,
		&i.ProjectsID,
		&i.Rating,
		&i.Description,
		&i.DescriptionAr,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
	)
	return i, err
}

const deletePhases = `-- name: DeletePhases :exec
DELETE FROM phases
Where id = $1
`

func (q *Queries) DeletePhases(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePhases, id)
	return err
}

const getAllPhases = `-- name: GetAllPhases :many
SELECT id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number FROM phases
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllPhasesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPhases(ctx context.Context, arg GetAllPhasesParams) ([]Phase, error) {
	rows, err := q.db.Query(ctx, getAllPhases, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Phase
	for rows.Next() {
		var i Phase
		if err := rows.Scan(
			&i.ID,
			&i.PhaseName,
			&i.AddressesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.LiveStatus,
			&i.RefNo,
			&i.ProjectsID,
			&i.Rating,
			&i.Description,
			&i.DescriptionAr,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPhasesByProject = `-- name: GetAllPhasesByProject :many
SELECT
	phases.id, phases.phase_name, phases.addresses_id, phases.created_at, phases.updated_at, phases.status, phases.live_status, phases.ref_no, phases.projects_id, phases.rating, phases.description, phases.description_ar, phases.polygon_coords, phases.facts, phases.exclusive, phases.start_date, phases.end_date, phases.bank_name, phases.registration_date, phases.escrow_number
FROM
	phases
    LEFT JOIN projects ON projects.id = phases.projects_id
	LEFT JOIN addresses ON addresses.id = phases.addresses_id
    LEFT JOIN countries ON countries.id = addresses.countries_id
    LEFT JOIN states ON states.id = addresses.states_id
    LEFT JOIN cities ON cities.id = addresses.cities_id
    LEFT JOIN communities ON communities.id = addresses.communities_id
    LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
WHERE
    -- Search criteria
    ($4 = '%%' OR 
     projects.project_name % $4 OR 
      phases.phase_name % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     communities.community % $4 OR 
     sub_communities.sub_community % $4  
       OR (CASE 
         WHEN 'ready' ILIKE $4 THEN (phases.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $4  THEN (phases.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $4  THEN (phases.facts->>'completion_percentage')::TEXT % $4
        WHEN 'draft'ILIKE $4  THEN projects.status = 1
        WHEN 'available'ILIKE $4  THEN projects.status = 2
        WHEN 'block'ILIKE $4  THEN projects.status = 5
        WHEN 'single'ILIKE $4  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $4  THEN projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
     -- Company and branch permissions
     AND (
        $5::BOOLEAN != true
        OR (
            ($6 != false OR projects.developer_companies_id = $7::bigint)
            AND ($6 != true OR projects.developer_company_branches_id = $7::bigint)
        )
    )
    -- Location filters
    AND ($8::bigint = 0 OR addresses.countries_id = $8::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    -- AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
    -- AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
    -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)
	AND projects.id = $3 AND (phases.status != 5 AND phases.status != 6)
ORDER BY
	phases.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllPhasesByProjectParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	ID            int64       `json:"id"`
	Search        interface{} `json:"search"`
	IsCompanyUser bool        `json:"is_company_user"`
	CompanyBranch interface{} `json:"company_branch"`
	CompanyID     int64       `json:"company_id"`
	CountryID     int64       `json:"country_id"`
}

func (q *Queries) GetAllPhasesByProject(ctx context.Context, arg GetAllPhasesByProjectParams) ([]Phase, error) {
	rows, err := q.db.Query(ctx, getAllPhasesByProject,
		arg.Limit,
		arg.Offset,
		arg.ID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyBranch,
		arg.CompanyID,
		arg.CountryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Phase
	for rows.Next() {
		var i Phase
		if err := rows.Scan(
			&i.ID,
			&i.PhaseName,
			&i.AddressesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.LiveStatus,
			&i.RefNo,
			&i.ProjectsID,
			&i.Rating,
			&i.Description,
			&i.DescriptionAr,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPhasesByStatus = `-- name: GetAllPhasesByStatus :many
SELECT phases.id, phases.phase_name, phases.addresses_id, phases.created_at, phases.updated_at, phases.status, phases.live_status, phases.ref_no, phases.projects_id, phases.rating, phases.description, phases.description_ar, phases.polygon_coords, phases.facts, phases.exclusive, phases.start_date, phases.end_date, phases.bank_name, phases.registration_date, phases.escrow_number,projects.project_name, addresses.full_address,coalesce(companies.company_name, '')::VARCHAR as "company_name"
FROM phases
    LEFT JOIN projects ON projects.id = phases.projects_id
    LEFT JOIN companies ON companies.id=projects.developer_companies_id
	LEFT JOIN addresses ON addresses.id = phases.addresses_id
    LEFT JOIN countries ON countries.id = addresses.countries_id
    LEFT JOIN states ON states.id = addresses.states_id
    LEFT JOIN cities ON cities.id = addresses.cities_id
    LEFT JOIN communities ON communities.id = addresses.communities_id
    LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
WHERE 
    -- Search criteria
    ($4 = '%%' OR 
     projects.project_name % $4 OR 
      phases.phase_name % $4 OR
     countries.country % $4 OR 
     states."state" % $4 OR 
     cities.city % $4 OR 
     communities.community % $4 OR 
     sub_communities.sub_community % $4  
       OR (CASE 
        WHEN 'ready' ILIKE $4 THEN (phases.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $4  THEN (phases.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $4  THEN (phases.facts->>'completion_percentage')::TEXT % $4
        WHEN 'draft'ILIKE $4  THEN projects.status = 1
        WHEN 'available'ILIKE $4  THEN projects.status = 2
        WHEN 'block'ILIKE $4  THEN projects.status = 5
        WHEN 'single'ILIKE $4  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $4  THEN projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
     -- Company and branch permissions
     AND (
        $5 != true
        OR (
            ($6 != false OR projects.developer_companies_id = $7::bigint)
            AND ($6 != true OR projects.developer_company_branches_id = $7::bigint)
        )
    )

    -- Location filters
    AND ($8::bigint = 0 OR addresses.countries_id = $8::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    AND ($9::bigint = 0 OR addresses.cities_id = $9::bigint)
    AND ($10::bigint = 0 OR addresses.communities_id = $10::bigint)
    AND ($11::bigint = 0 OR addresses.sub_communities_id = $11::bigint)
    
AND phases.status = $3
ORDER BY phases.created_at DESC 
LIMIT $1 OFFSET $2
`

type GetAllPhasesByStatusParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	Status         int64       `json:"status"`
	Search         interface{} `json:"search"`
	IsCompanyUser  interface{} `json:"is_company_user"`
	CompanyBranch  interface{} `json:"company_branch"`
	CompanyID      int64       `json:"company_id"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
}

type GetAllPhasesByStatusRow struct {
	ID               int64       `json:"id"`
	PhaseName        string      `json:"phase_name"`
	AddressesID      pgtype.Int8 `json:"addresses_id"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Status           int64       `json:"status"`
	LiveStatus       pgtype.Bool `json:"live_status"`
	RefNo            string      `json:"ref_no"`
	ProjectsID       int64       `json:"projects_id"`
	Rating           float64     `json:"rating"`
	Description      string      `json:"description"`
	DescriptionAr    pgtype.Text `json:"description_ar"`
	PolygonCoords    []byte      `json:"polygon_coords"`
	Facts            []byte      `json:"facts"`
	Exclusive        bool        `json:"exclusive"`
	StartDate        pgtype.Date `json:"start_date"`
	EndDate          pgtype.Date `json:"end_date"`
	BankName         string      `json:"bank_name"`
	RegistrationDate time.Time   `json:"registration_date"`
	EscrowNumber     string      `json:"escrow_number"`
	ProjectName      pgtype.Text `json:"project_name"`
	FullAddress      pgtype.Text `json:"full_address"`
	CompanyName      string      `json:"company_name"`
}

func (q *Queries) GetAllPhasesByStatus(ctx context.Context, arg GetAllPhasesByStatusParams) ([]GetAllPhasesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAllPhasesByStatus,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyBranch,
		arg.CompanyID,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPhasesByStatusRow
	for rows.Next() {
		var i GetAllPhasesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.PhaseName,
			&i.AddressesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.LiveStatus,
			&i.RefNo,
			&i.ProjectsID,
			&i.Rating,
			&i.Description,
			&i.DescriptionAr,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.ProjectName,
			&i.FullAddress,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSharedPhasesByIds = `-- name: GetAllSharedPhasesByIds :many
SELECT phases.id,phases.ref_no,phases.phase_name,
projects.project_name,
developer_companies.company_name
FROM phases
LEFT JOIN projects ON projects.id = phases.projects_id
LEFT JOIN developer_companies ON developer_companies.id = projects.developer_companies_id
WHERE phases.id = ($1::bigint[])
`

type GetAllSharedPhasesByIdsRow struct {
	ID          int64       `json:"id"`
	RefNo       string      `json:"ref_no"`
	PhaseName   string      `json:"phase_name"`
	ProjectName pgtype.Text `json:"project_name"`
	CompanyName pgtype.Text `json:"company_name"`
}

func (q *Queries) GetAllSharedPhasesByIds(ctx context.Context, dollar_1 []int64) ([]GetAllSharedPhasesByIdsRow, error) {
	rows, err := q.db.Query(ctx, getAllSharedPhasesByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSharedPhasesByIdsRow
	for rows.Next() {
		var i GetAllSharedPhasesByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.PhaseName,
			&i.ProjectName,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllPhasesByProject = `-- name: GetCountAllPhasesByProject :one
SELECT
	COUNT(phases.id)
FROM
	phases
   LEFT JOIN projects ON projects.id = phases.projects_id
	--INNER JOIN phases_facts ON phases.id = phases_facts.phases_id
	LEFT JOIN addresses ON addresses.id = phases.addresses_id
    LEFT JOIN countries ON countries.id = addresses.countries_id
    LEFT JOIN states ON states.id = addresses.states_id
    LEFT JOIN cities ON cities.id = addresses.cities_id
    LEFT JOIN communities ON communities.id = addresses.communities_id
    LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
WHERE
    -- Search criteria
    ($2 = '%%' OR 
     projects.project_name % $2 OR 
      phases.phase_name % $2 OR
     countries.country % $2 OR 
     states."state" % $2 OR 
     cities.city % $2 OR 
     communities.community % $2 OR 
     sub_communities.sub_community % $2  
       OR (CASE 
        WHEN 'ready' ILIKE $2 THEN (phases.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $2  THEN (phases.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $2  THEN (phases.facts->>'completion_percentage')::TEXT % $2
        WHEN 'draft'ILIKE $2  THEN projects.status = 1
        WHEN 'available'ILIKE $2  THEN projects.status = 2
        WHEN 'block'ILIKE $2  THEN projects.status = 5
        WHEN 'single'ILIKE $2  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $2  THEN projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
     -- Company and branch permissions
     AND (
        $3::BOOLEAN != true
        OR (
            ($4 != false OR projects.developer_companies_id = $5::bigint)
            AND ($4 != true OR projects.developer_company_branches_id = $5::bigint)
        )
    )
    -- Location filters
    AND ($6::bigint = 0 OR addresses.countries_id = $6::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
  --  AND (@city_id::bigint = 0 OR addresses.cities_id = @city_id::bigint)
  --  AND (@community_id::bigint = 0 OR addresses.communities_id = @community_id::bigint)
   -- AND (@sub_community_id::bigint = 0 OR addresses.sub_communities_id = @sub_community_id::bigint)


 AND projects.id = $1 AND (phases.status != 5 AND phases.status != 6)
`

type GetCountAllPhasesByProjectParams struct {
	ID            int64       `json:"id"`
	Search        interface{} `json:"search"`
	IsCompanyUser bool        `json:"is_company_user"`
	CompanyBranch interface{} `json:"company_branch"`
	CompanyID     int64       `json:"company_id"`
	CountryID     int64       `json:"country_id"`
}

func (q *Queries) GetCountAllPhasesByProject(ctx context.Context, arg GetCountAllPhasesByProjectParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllPhasesByProject,
		arg.ID,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyBranch,
		arg.CompanyID,
		arg.CountryID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllPhasesByStatus = `-- name: GetCountAllPhasesByStatus :one
SELECT 
	COUNT(phases.id)
FROM phases
    LEFT JOIN projects ON projects.id = phases.projects_id
	LEFT JOIN addresses ON addresses.id = phases.addresses_id
    LEFT JOIN countries ON countries.id = addresses.countries_id
    LEFT JOIN states ON states.id = addresses.states_id
    LEFT JOIN cities ON cities.id = addresses.cities_id
    LEFT JOIN communities ON communities.id = addresses.communities_id
    LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id 
WHERE 
 -- Search criteria
    ($2 = '%%' OR 
     projects.project_name % $2 OR 
      phases.phase_name % $2 OR
     countries.country % $2 OR 
     states."state" % $2 OR 
     cities.city % $2 OR 
     communities.community % $2 OR 
     sub_communities.sub_community % $2  
       OR (CASE 
        WHEN 'ready' ILIKE $2 THEN (phases.facts->>'completion_status')::BIGINT = 5
        WHEN 'off plan'ILIKE $2  THEN (phases.facts->>'completion_status')::BIGINT = 4
        WHEN '^[0-9]+$' ~ $2  THEN (phases.facts->>'completion_percentage')::TEXT % $2
        WHEN 'draft'ILIKE $2  THEN projects.status = 1
        WHEN 'available'ILIKE $2  THEN projects.status = 2
        WHEN 'block'ILIKE $2  THEN projects.status = 5
        WHEN 'single'ILIKE $2  THEN projects.is_multiphase = false
        WHEN 'multiple'ILIKE $2  THEN projects.is_multiphase = true 
        ELSE FALSE
      END)
      )
     -- Company and branch permissions
     AND (
        $3 != true
        OR (
            ($4 != false OR projects.developer_companies_id = $5::bigint)
            AND ($4 != true OR projects.developer_company_branches_id = $5::bigint)
        )
    )
    -- Location filters
    AND ($6::bigint = 0 OR addresses.countries_id = $6::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    AND ($7::bigint = 0 OR addresses.cities_id = $7::bigint)
    AND ($8::bigint = 0 OR addresses.communities_id = $8::bigint)
    AND ($9::bigint = 0 OR addresses.sub_communities_id = $9::bigint)
 AND phases.status = $1
`

type GetCountAllPhasesByStatusParams struct {
	Status         int64       `json:"status"`
	Search         interface{} `json:"search"`
	IsCompanyUser  interface{} `json:"is_company_user"`
	CompanyBranch  interface{} `json:"company_branch"`
	CompanyID      int64       `json:"company_id"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
}

func (q *Queries) GetCountAllPhasesByStatus(ctx context.Context, arg GetCountAllPhasesByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllPhasesByStatus,
		arg.Status,
		arg.Search,
		arg.IsCompanyUser,
		arg.CompanyBranch,
		arg.CompanyID,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPhaseByNameAndProjectId = `-- name: GetPhaseByNameAndProjectId :one
SELECT id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number FROM phases WHERE phase_name ILIKE $1 AND projects_id = $2
`

type GetPhaseByNameAndProjectIdParams struct {
	PhaseName  string `json:"phase_name"`
	ProjectsID int64  `json:"projects_id"`
}

func (q *Queries) GetPhaseByNameAndProjectId(ctx context.Context, arg GetPhaseByNameAndProjectIdParams) (Phase, error) {
	row := q.db.QueryRow(ctx, getPhaseByNameAndProjectId, arg.PhaseName, arg.ProjectsID)
	var i Phase
	err := row.Scan(
		&i.ID,
		&i.PhaseName,
		&i.AddressesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.LiveStatus,
		&i.RefNo,
		&i.ProjectsID,
		&i.Rating,
		&i.Description,
		&i.DescriptionAr,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
	)
	return i, err
}

const getPhaseByProjectIdAndPhase = `-- name: GetPhaseByProjectIdAndPhase :one
SELECT id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number FROM phases
WHERE phases.id = $1 AND phases.projects_id = $2
`

type GetPhaseByProjectIdAndPhaseParams struct {
	ID         int64 `json:"id"`
	ProjectsID int64 `json:"projects_id"`
}

func (q *Queries) GetPhaseByProjectIdAndPhase(ctx context.Context, arg GetPhaseByProjectIdAndPhaseParams) (Phase, error) {
	row := q.db.QueryRow(ctx, getPhaseByProjectIdAndPhase, arg.ID, arg.ProjectsID)
	var i Phase
	err := row.Scan(
		&i.ID,
		&i.PhaseName,
		&i.AddressesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.LiveStatus,
		&i.RefNo,
		&i.ProjectsID,
		&i.Rating,
		&i.Description,
		&i.DescriptionAr,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
	)
	return i, err
}

const getPhaseExceptDeletedAndBlocked = `-- name: GetPhaseExceptDeletedAndBlocked :one
SELECT id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number FROM phases 
WHERE id = $1 AND (status != 5 AND status != 6) LIMIT 1
`

func (q *Queries) GetPhaseExceptDeletedAndBlocked(ctx context.Context, id int64) (Phase, error) {
	row := q.db.QueryRow(ctx, getPhaseExceptDeletedAndBlocked, id)
	var i Phase
	err := row.Scan(
		&i.ID,
		&i.PhaseName,
		&i.AddressesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.LiveStatus,
		&i.RefNo,
		&i.ProjectsID,
		&i.Rating,
		&i.Description,
		&i.DescriptionAr,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
	)
	return i, err
}

const getPhaseName = `-- name: GetPhaseName :one
SELECT phase_name FROM phases 
WHERE id = $1
`

func (q *Queries) GetPhaseName(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getPhaseName, id)
	var phase_name string
	err := row.Scan(&phase_name)
	return phase_name, err
}

const getPhases = `-- name: GetPhases :one
SELECT id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number FROM phases 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetPhases(ctx context.Context, limit int32) (Phase, error) {
	row := q.db.QueryRow(ctx, getPhases, limit)
	var i Phase
	err := row.Scan(
		&i.ID,
		&i.PhaseName,
		&i.AddressesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.LiveStatus,
		&i.RefNo,
		&i.ProjectsID,
		&i.Rating,
		&i.Description,
		&i.DescriptionAr,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
	)
	return i, err
}

const getPhasesByProjectID = `-- name: GetPhasesByProjectID :many
SELECT
    phases.id
FROM
    phases
    INNER JOIN projects ON projects.id = $1 :: BIGINT
    AND projects.status != 6
WHERE
     phases.projects_id = $1 :: BIGINT
    AND phases.status != 6
`

func (q *Queries) GetPhasesByProjectID(ctx context.Context, projectID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getPhasesByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePhaseByStatus = `-- name: UpdatePhaseByStatus :one
UPDATE phases SET status = $2 WHERE id = $1 RETURNING id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number
`

type UpdatePhaseByStatusParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

func (q *Queries) UpdatePhaseByStatus(ctx context.Context, arg UpdatePhaseByStatusParams) (Phase, error) {
	row := q.db.QueryRow(ctx, updatePhaseByStatus, arg.ID, arg.Status)
	var i Phase
	err := row.Scan(
		&i.ID,
		&i.PhaseName,
		&i.AddressesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.LiveStatus,
		&i.RefNo,
		&i.ProjectsID,
		&i.Rating,
		&i.Description,
		&i.DescriptionAr,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
	)
	return i, err
}

const updatePhases = `-- name: UpdatePhases :one
UPDATE phases
SET phase_name = $2,
    created_at = $3,
    updated_at = $4,
    status = $5,
    live_status = $6,
    ref_no = $7,
    projects_id = $8,
    addresses_id = $9,
    
    rating = $10,
    facts=$11,
    description = $12,
    description_ar = $13,
    polygon_coords = $14,
    bank_name=$15,
    registration_date=$16,
    escrow_number=$17
Where id = $1
RETURNING id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number
`

type UpdatePhasesParams struct {
	ID               int64       `json:"id"`
	PhaseName        string      `json:"phase_name"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Status           int64       `json:"status"`
	LiveStatus       pgtype.Bool `json:"live_status"`
	RefNo            string      `json:"ref_no"`
	ProjectsID       int64       `json:"projects_id"`
	AddressesID      pgtype.Int8 `json:"addresses_id"`
	Rating           float64     `json:"rating"`
	Facts            []byte      `json:"facts"`
	Description      string      `json:"description"`
	DescriptionAr    pgtype.Text `json:"description_ar"`
	PolygonCoords    []byte      `json:"polygon_coords"`
	BankName         string      `json:"bank_name"`
	RegistrationDate time.Time   `json:"registration_date"`
	EscrowNumber     string      `json:"escrow_number"`
}

func (q *Queries) UpdatePhases(ctx context.Context, arg UpdatePhasesParams) (Phase, error) {
	row := q.db.QueryRow(ctx, updatePhases,
		arg.ID,
		arg.PhaseName,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.LiveStatus,
		arg.RefNo,
		arg.ProjectsID,
		arg.AddressesID,
		arg.Rating,
		arg.Facts,
		arg.Description,
		arg.DescriptionAr,
		arg.PolygonCoords,
		arg.BankName,
		arg.RegistrationDate,
		arg.EscrowNumber,
	)
	var i Phase
	err := row.Scan(
		&i.ID,
		&i.PhaseName,
		&i.AddressesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.LiveStatus,
		&i.RefNo,
		&i.ProjectsID,
		&i.Rating,
		&i.Description,
		&i.DescriptionAr,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
	)
	return i, err
}
