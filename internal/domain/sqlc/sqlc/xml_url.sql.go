// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: xml_url.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createXMLURL = `-- name: CreateXMLURL :one
INSERT INTO xml_url (
url,
company_id,
status,
created_at,
updated_at,
contact_email
)VALUES (
    $1, $2, $3,$4, $5, $6 
) RETURNING id, url, company_id, contact_email, status, created_at, updated_at, last_update, last_report
`

type CreateXMLURLParams struct {
	Url          string    `json:"url"`
	CompanyID    int64     `json:"company_id"`
	Status       int64     `json:"status"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	ContactEmail string    `json:"contact_email"`
}

func (q *Queries) CreateXMLURL(ctx context.Context, arg CreateXMLURLParams) (XmlUrl, error) {
	row := q.db.QueryRow(ctx, createXMLURL,
		arg.Url,
		arg.CompanyID,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ContactEmail,
	)
	var i XmlUrl
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.CompanyID,
		&i.ContactEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUpdate,
		&i.LastReport,
	)
	return i, err
}

const deleteXMLURL = `-- name: DeleteXMLURL :exec
DELETE FROM xml_url
Where id = $1
`

func (q *Queries) DeleteXMLURL(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteXMLURL, id)
	return err
}

const getAllActiveXMLUrls = `-- name: GetAllActiveXMLUrls :many
SELECT id, url, company_id, contact_email, status, created_at, updated_at, last_update, last_report FROM xml_url
WHERE status = 1
`

func (q *Queries) GetAllActiveXMLUrls(ctx context.Context) ([]XmlUrl, error) {
	rows, err := q.db.Query(ctx, getAllActiveXMLUrls)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []XmlUrl
	for rows.Next() {
		var i XmlUrl
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.CompanyID,
			&i.ContactEmail,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUpdate,
			&i.LastReport,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllXMLURLl = `-- name: GetAllXMLURLl :many
SELECT 
	xml_url.id, xml_url.url, xml_url.company_id, xml_url.contact_email, xml_url.status, xml_url.created_at, xml_url.updated_at, xml_url.last_update, xml_url.last_report ,
	companies.company_name
FROM xml_url
JOIN companies on companies.id= xml_url.company_id
ORDER BY xml_url.updated_at DESC
LIMIT $2
OFFSET $1
`

type GetAllXMLURLlParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllXMLURLlRow struct {
	XmlUrl      XmlUrl `json:"xml_url"`
	CompanyName string `json:"company_name"`
}

func (q *Queries) GetAllXMLURLl(ctx context.Context, arg GetAllXMLURLlParams) ([]GetAllXMLURLlRow, error) {
	rows, err := q.db.Query(ctx, getAllXMLURLl, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllXMLURLlRow
	for rows.Next() {
		var i GetAllXMLURLlRow
		if err := rows.Scan(
			&i.XmlUrl.ID,
			&i.XmlUrl.Url,
			&i.XmlUrl.CompanyID,
			&i.XmlUrl.ContactEmail,
			&i.XmlUrl.Status,
			&i.XmlUrl.CreatedAt,
			&i.XmlUrl.UpdatedAt,
			&i.XmlUrl.LastUpdate,
			&i.XmlUrl.LastReport,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllXmlFeedUrls = `-- name: GetCountAllXmlFeedUrls :one
SELECT COUNT(*) FROM xml_url
`

func (q *Queries) GetCountAllXmlFeedUrls(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllXmlFeedUrls)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getXMLURL = `-- name: GetXMLURL :one
SELECT 
	xml_url.id, xml_url.url, xml_url.company_id, xml_url.contact_email, xml_url.status, xml_url.created_at, xml_url.updated_at, xml_url.last_update, xml_url.last_report,
	companies.company_name,
	companies.company_type
FROM xml_url 
JOIN companies on companies.id= xml_url.company_id
WHERE xml_url.id = $1
`

type GetXMLURLRow struct {
	XmlUrl      XmlUrl `json:"xml_url"`
	CompanyName string `json:"company_name"`
	CompanyType int64  `json:"company_type"`
}

func (q *Queries) GetXMLURL(ctx context.Context, id int64) (GetXMLURLRow, error) {
	row := q.db.QueryRow(ctx, getXMLURL, id)
	var i GetXMLURLRow
	err := row.Scan(
		&i.XmlUrl.ID,
		&i.XmlUrl.Url,
		&i.XmlUrl.CompanyID,
		&i.XmlUrl.ContactEmail,
		&i.XmlUrl.Status,
		&i.XmlUrl.CreatedAt,
		&i.XmlUrl.UpdatedAt,
		&i.XmlUrl.LastUpdate,
		&i.XmlUrl.LastReport,
		&i.CompanyName,
		&i.CompanyType,
	)
	return i, err
}

const updateLastUpdate = `-- name: UpdateLastUpdate :exec
UPDATE xml_url
SET last_update = $2
WHERE id = $1
`

type UpdateLastUpdateParams struct {
	ID         int64              `json:"id"`
	LastUpdate pgtype.Timestamptz `json:"last_update"`
}

func (q *Queries) UpdateLastUpdate(ctx context.Context, arg UpdateLastUpdateParams) error {
	_, err := q.db.Exec(ctx, updateLastUpdate, arg.ID, arg.LastUpdate)
	return err
}

const updateXMLURL = `-- name: UpdateXMLURL :one
UPDATE xml_url
SET  
url = $2,
company_id = $3,
status = $4,
created_at = $5,
updated_at = $6,
contact_email = $7
Where id = $1
RETURNING id, url, company_id, contact_email, status, created_at, updated_at, last_update, last_report
`

type UpdateXMLURLParams struct {
	ID           int64     `json:"id"`
	Url          string    `json:"url"`
	CompanyID    int64     `json:"company_id"`
	Status       int64     `json:"status"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	ContactEmail string    `json:"contact_email"`
}

func (q *Queries) UpdateXMLURL(ctx context.Context, arg UpdateXMLURLParams) (XmlUrl, error) {
	row := q.db.QueryRow(ctx, updateXMLURL,
		arg.ID,
		arg.Url,
		arg.CompanyID,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ContactEmail,
	)
	var i XmlUrl
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.CompanyID,
		&i.ContactEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUpdate,
		&i.LastReport,
	)
	return i, err
}

const updateXMLUrlLastReport = `-- name: UpdateXMLUrlLastReport :one
UPDATE xml_url SET last_report = $1 
WHERE id = $2
RETURNING id, url, company_id, contact_email, status, created_at, updated_at, last_update, last_report
`

type UpdateXMLUrlLastReportParams struct {
	LastReport pgtype.Text `json:"last_report"`
	ID         int64       `json:"id"`
}

func (q *Queries) UpdateXMLUrlLastReport(ctx context.Context, arg UpdateXMLUrlLastReportParams) (XmlUrl, error) {
	row := q.db.QueryRow(ctx, updateXMLUrlLastReport, arg.LastReport, arg.ID)
	var i XmlUrl
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.CompanyID,
		&i.ContactEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUpdate,
		&i.LastReport,
	)
	return i, err
}
