// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: top_developers_companies.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const filterBrokerCompanies = `-- name: FilterBrokerCompanies :many
WITH 
comp_reviews AS(
	SELECT company_id, 
	ROUND((AVG(customer_service) + AVG(staff_courstesy) + AVG(implementation) + AVG(quality)) / 4.0,2) AS average_rating
	FROM company_review
	GROUP BY company_id
),
property_counts AS(
  SELECT developer_companies_id, COUNT(project_properties.id) AS property_count
  FROM project_properties
  GROUP BY developer_companies_id
)

		SELECT 
		companies.id, companies.ref_no, companies.company_name, companies.company_activities_id, companies.company_parent_id, companies.tag_line, companies.description, companies.description_ar, companies.logo_url, companies.email, companies.phone_number, companies.whatsapp_number, companies.is_verified, companies.website_url, companies.cover_image_url, companies.no_of_employees, companies.company_rank, companies.status, companies.company_type, companies.addresses_id, companies.users_id, companies.created_by, companies.created_at, companies.updated_at, companies.updated_by, companies.location_url, companies.vat_no, companies.vat_status, companies.vat_file_url,
		COALESCE(comp_reviews.average_rating, 0.0)::float AS average_rating,
		COALESCE(property_counts.property_count, 0)::bigint AS property_count
		FROM companies
		LEFT JOIN social_connections ON social_connections.requested_by=companies.id
		LEFT JOIN addresses ON companies.addresses_id = addresses.id 
		LEFT JOIN cities ON addresses.cities_id = cities.id
		LEFT JOIN communities ON addresses.communities_id = communities.id
		LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
		LEFT JOIN property_counts ON property_counts.developer_companies_id = companies.id
		LEFT JOIN comp_reviews ON comp_reviews.company_id = companies.id
		WHERE 
		(case when $3::bigint= 0 then true else social_connections.comapnies_id= $3::bigint end)
		AND
		addresses.countries_id = $4::bigint
	-- location
		AND (CASE WHEN $5::bigint=0 THEN TRUE ELSE addresses.cities_id= $5::bigint END)
	    AND (CASE WHEN $6::bigint=0 THEN TRUE ELSE addresses.communities_id= $6::bigint END)
	    AND (CASE WHEN $7::bigint=0 THEN TRUE ELSE addresses.sub_communities_id= $7::bigint END)
	    AND (ARRAY_LENGTH($8::bigint [], 1) IS NULL OR companies.company_rank = ANY ($8::bigint []))
		AND ($9::bool IS NULL OR companies.is_verified = $9::bool)
	    AND (CASE WHEN $10::varchar IS NULL THEN
			TRUE
			ELSE
			companies.company_name ILIKE $10::varchar
			OR companies.description ILIKE $10::varchar
			OR cities.city ILIKE $10::varchar
			OR communities.community ILIKE $10::varchar
			OR sub_communities.sub_community ILIKE $10::varchar
	END) 
	AND companies.status != 5 and companies.status != 6 AND company_type = $11::bigint
	
ORDER BY 
	CASE WHEN $12::int = 1 THEN comp_reviews.average_rating END DESC, -- 1 rating - high to low
	CASE WHEN $12::int = 2 THEN comp_reviews.average_rating END, -- 2 rating - low to high
	CASE WHEN $12::int = 3 THEN property_counts.property_count END DESC, -- 3 projects - high to low
	CASE WHEN $12::int = 4 THEN property_counts.property_count END-- 4 projects - low to high
LIMIT $1 OFFSET $2
`

type FilterBrokerCompaniesParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	CompanyID    int64       `json:"company_id"`
	CountryID    int64       `json:"country_id"`
	CityID       int64       `json:"city_id"`
	CommunityID  int64       `json:"community_id"`
	SubCommunity int64       `json:"sub_community"`
	CompanyRank  []int64     `json:"company_rank"`
	IsVerified   pgtype.Bool `json:"is_verified"`
	Search       string      `json:"search"`
	CompanyType  int64       `json:"company_type"`
	SortedBy     int32       `json:"sorted_by"`
}

type FilterBrokerCompaniesRow struct {
	Company       Company `json:"company"`
	AverageRating float64 `json:"average_rating"`
	PropertyCount int64   `json:"property_count"`
}

func (q *Queries) FilterBrokerCompanies(ctx context.Context, arg FilterBrokerCompaniesParams) ([]FilterBrokerCompaniesRow, error) {
	rows, err := q.db.Query(ctx, filterBrokerCompanies,
		arg.Limit,
		arg.Offset,
		arg.CompanyID,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunity,
		arg.CompanyRank,
		arg.IsVerified,
		arg.Search,
		arg.CompanyType,
		arg.SortedBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterBrokerCompaniesRow
	for rows.Next() {
		var i FilterBrokerCompaniesRow
		if err := rows.Scan(
			&i.Company.ID,
			&i.Company.RefNo,
			&i.Company.CompanyName,
			&i.Company.CompanyActivitiesID,
			&i.Company.CompanyParentID,
			&i.Company.TagLine,
			&i.Company.Description,
			&i.Company.DescriptionAr,
			&i.Company.LogoUrl,
			&i.Company.Email,
			&i.Company.PhoneNumber,
			&i.Company.WhatsappNumber,
			&i.Company.IsVerified,
			&i.Company.WebsiteUrl,
			&i.Company.CoverImageUrl,
			&i.Company.NoOfEmployees,
			&i.Company.CompanyRank,
			&i.Company.Status,
			&i.Company.CompanyType,
			&i.Company.AddressesID,
			&i.Company.UsersID,
			&i.Company.CreatedBy,
			&i.Company.CreatedAt,
			&i.Company.UpdatedAt,
			&i.Company.UpdatedBy,
			&i.Company.LocationUrl,
			&i.Company.VatNo,
			&i.Company.VatStatus,
			&i.Company.VatFileUrl,
			&i.AverageRating,
			&i.PropertyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterCountCompanies = `-- name: FilterCountCompanies :one
SELECT 
	count(c)
	FROM companies as c
	LEFT JOIN social_connections ON social_connections.requested_by=c.id
	LEFT JOIN addresses ON c.addresses_id = addresses.id 
	LEFT JOIN cities ON addresses.cities_id = cities.id
	LEFT JOIN communities ON addresses.communities_id = communities.id
	LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
	WHERE 
	(case when $1::bigint= 0 then true else social_connections.comapnies_id= $1::bigint end)
	AND
	addresses.countries_id = $2::bigint
	-- location
	AND (CASE WHEN $3::bigint=0 THEN TRUE ELSE addresses.cities_id= $3::bigint END)
    AND (CASE WHEN $4::bigint=0 THEN TRUE ELSE addresses.communities_id= $4::bigint END)
    AND (CASE WHEN $5::bigint=0 THEN TRUE ELSE addresses.sub_communities_id= $5::bigint END)
    AND (ARRAY_LENGTH($6::bigint [], 1) IS NULL OR c.company_rank = ANY ($6::bigint []))
	AND ($7::bool IS NULL OR c.is_verified = $7::bool)
    AND (CASE WHEN $8::varchar IS NULL THEN
			TRUE
			ELSE
			c.company_name ILIKE $8::varchar
			OR c.description ILIKE $8::varchar
			OR cities.city ILIKE $8::varchar
			OR communities.community ILIKE $8::varchar
			OR sub_communities.sub_community ILIKE $8::varchar
	END) 
	AND c.status != 5 and c.status != 6 AND company_type = $9::bigint
`

type FilterCountCompaniesParams struct {
	CompanyID    int64       `json:"company_id"`
	CountryID    int64       `json:"country_id"`
	CityID       int64       `json:"city_id"`
	CommunityID  int64       `json:"community_id"`
	SubCommunity int64       `json:"sub_community"`
	CompanyRank  []int64     `json:"company_rank"`
	IsVerified   pgtype.Bool `json:"is_verified"`
	Search       string      `json:"search"`
	CompanyType  int64       `json:"company_type"`
}

func (q *Queries) FilterCountCompanies(ctx context.Context, arg FilterCountCompaniesParams) (int64, error) {
	row := q.db.QueryRow(ctx, filterCountCompanies,
		arg.CompanyID,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunity,
		arg.CompanyRank,
		arg.IsVerified,
		arg.Search,
		arg.CompanyType,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterDeveloperCompanies = `-- name: FilterDeveloperCompanies :many


WITH 
comp_reviews AS(
	SELECT company_id, 
	ROUND((AVG(customer_service) + AVG(staff_courstesy) + AVG(implementation) + AVG(quality)) / 4.0,2) AS average_rating
	FROM company_review
	GROUP BY company_id
),
project_counts AS(
	SELECT developer_companies_id, COUNT(projects.id) AS project_count
	FROM projects
	GROUP BY developer_companies_id
)

	SELECT 
	c.id, c.ref_no, c.company_name, c.company_activities_id, c.company_parent_id, c.tag_line, c.description, c.description_ar, c.logo_url, c.email, c.phone_number, c.whatsapp_number, c.is_verified, c.website_url, c.cover_image_url, c.no_of_employees, c.company_rank, c.status, c.company_type, c.addresses_id, c.users_id, c.created_by, c.created_at, c.updated_at, c.updated_by, c.location_url, c.vat_no, c.vat_status, c.vat_file_url,
	COALESCE(comp_reviews.average_rating, 0.0)::float AS average_rating,
	COALESCE(project_counts.project_count,0)::bigint AS project_count
	FROM companies as c
	LEFT JOIN social_connections ON social_connections.requested_by=companies.id
	LEFT JOIN addresses ON c.addresses_id = addresses.id 
	LEFT JOIN cities ON addresses.cities_id = cities.id
	LEFT JOIN communities ON addresses.communities_id = communities.id
	LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
	LEFT JOIN project_counts ON project_counts.developer_companies_id = c.id
	LEFT JOIN comp_reviews ON comp_reviews.company_id = c.id
	WHERE 
	addresses.countries_id = $3::bigint
	AND
	(case when $4::bigint= 0 then true else social_connections.comapnies_id= $4::bigint end)
	-- location
	AND (CASE WHEN $5::bigint=0 THEN TRUE ELSE addresses.cities_id= $5::bigint END)
    AND (CASE WHEN $6::bigint=0 THEN TRUE ELSE addresses.communities_id= $6::bigint END)
    AND (CASE WHEN $7::bigint=0 THEN TRUE ELSE addresses.sub_communities_id= $7::bigint END)
    AND (ARRAY_LENGTH($8::bigint [], 1) IS NULL OR c.company_rank = ANY ($8::bigint []))
	AND ($9::bool IS NULL OR c.is_verified = $9::bool)
    AND (CASE WHEN $10::varchar IS NULL THEN
			TRUE
			ELSE
			c.company_name ILIKE $10::varchar
			OR c.description ILIKE $10::varchar
			OR cities.city ILIKE $10::varchar
			OR communities.community ILIKE $10::varchar
			OR sub_communities.sub_community ILIKE $10::varchar
	END) 
	AND c.status != 5 and c.status != 6 AND company_type = $11::bigint
	
	ORDER BY 
	CASE WHEN $12::int = 1 THEN comp_reviews.average_rating END DESC, -- 1 rating - high to low
	CASE WHEN $12::int = 2 THEN comp_reviews.average_rating END, -- 2 rating - low to high
	CASE WHEN $12::int = 3 THEN project_counts.project_count END DESC, -- 3 projects - high to low
	CASE WHEN $12::int = 4 THEN project_counts.project_count END -- 4 projects - low to high
 LIMIT $1 OFFSET $2
`

type FilterDeveloperCompaniesParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	CountryID    int64       `json:"country_id"`
	CompanyID    int64       `json:"company_id"`
	CityID       int64       `json:"city_id"`
	CommunityID  int64       `json:"community_id"`
	SubCommunity int64       `json:"sub_community"`
	CompanyRank  []int64     `json:"company_rank"`
	IsVerified   pgtype.Bool `json:"is_verified"`
	Search       string      `json:"search"`
	CompanyType  int64       `json:"company_type"`
	SortedBy     int32       `json:"sorted_by"`
}

type FilterDeveloperCompaniesRow struct {
	Company       Company `json:"company"`
	AverageRating float64 `json:"average_rating"`
	ProjectCount  int64   `json:"project_count"`
}

// -- name: GetCountDeveloperCompanyProjects :one
// select count(*) from projects
// where projects.developer_companies_id = $1 and projects.status != 5 and projects.status != 6;
func (q *Queries) FilterDeveloperCompanies(ctx context.Context, arg FilterDeveloperCompaniesParams) ([]FilterDeveloperCompaniesRow, error) {
	rows, err := q.db.Query(ctx, filterDeveloperCompanies,
		arg.Limit,
		arg.Offset,
		arg.CountryID,
		arg.CompanyID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunity,
		arg.CompanyRank,
		arg.IsVerified,
		arg.Search,
		arg.CompanyType,
		arg.SortedBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterDeveloperCompaniesRow
	for rows.Next() {
		var i FilterDeveloperCompaniesRow
		if err := rows.Scan(
			&i.Company.ID,
			&i.Company.RefNo,
			&i.Company.CompanyName,
			&i.Company.CompanyActivitiesID,
			&i.Company.CompanyParentID,
			&i.Company.TagLine,
			&i.Company.Description,
			&i.Company.DescriptionAr,
			&i.Company.LogoUrl,
			&i.Company.Email,
			&i.Company.PhoneNumber,
			&i.Company.WhatsappNumber,
			&i.Company.IsVerified,
			&i.Company.WebsiteUrl,
			&i.Company.CoverImageUrl,
			&i.Company.NoOfEmployees,
			&i.Company.CompanyRank,
			&i.Company.Status,
			&i.Company.CompanyType,
			&i.Company.AddressesID,
			&i.Company.UsersID,
			&i.Company.CreatedBy,
			&i.Company.CreatedAt,
			&i.Company.UpdatedAt,
			&i.Company.UpdatedBy,
			&i.Company.LocationUrl,
			&i.Company.VatNo,
			&i.Company.VatStatus,
			&i.Company.VatFileUrl,
			&i.AverageRating,
			&i.ProjectCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
