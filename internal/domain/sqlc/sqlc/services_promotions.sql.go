// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: services_promotions.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createServicesPromotions = `-- name: CreateServicesPromotions :one
INSERT INTO service_promotions (
    service,
    promotion_name,
    promotion_name_ar,
    promotion_details,
    promotion_details_ar,
    price,
    tags_id,
    start_date,
    end_date,
    created_by
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5, 
    $6,
    $7,
    $8,
    $9,
    $10
)
RETURNING id, service, status, promotion_name, promotion_details, price, tags_id, start_date, end_date, created_by, created_at, updated_at, promotion_name_ar, promotion_details_ar
`

type CreateServicesPromotionsParams struct {
	Service            int64       `json:"service"`
	PromotionName      string      `json:"promotion_name"`
	PromotionNameAr    pgtype.Text `json:"promotion_name_ar"`
	PromotionDetails   string      `json:"promotion_details"`
	PromotionDetailsAr pgtype.Text `json:"promotion_details_ar"`
	Price              float64     `json:"price"`
	TagsID             int64       `json:"tags_id"`
	StartDate          time.Time   `json:"start_date"`
	EndDate            time.Time   `json:"end_date"`
	CreatedBy          int64       `json:"created_by"`
}

func (q *Queries) CreateServicesPromotions(ctx context.Context, arg CreateServicesPromotionsParams) (ServicePromotion, error) {
	row := q.db.QueryRow(ctx, createServicesPromotions,
		arg.Service,
		arg.PromotionName,
		arg.PromotionNameAr,
		arg.PromotionDetails,
		arg.PromotionDetailsAr,
		arg.Price,
		arg.TagsID,
		arg.StartDate,
		arg.EndDate,
		arg.CreatedBy,
	)
	var i ServicePromotion
	err := row.Scan(
		&i.ID,
		&i.Service,
		&i.Status,
		&i.PromotionName,
		&i.PromotionDetails,
		&i.Price,
		&i.TagsID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PromotionNameAr,
		&i.PromotionDetailsAr,
	)
	return i, err
}

const getAllServicesPromotionsByID = `-- name: GetAllServicesPromotionsByID :many
SELECT 
    sp.id,
    sp.service,
    sp.promotion_name,
    sp.promotion_details,
    sp.promotion_name_ar,
    sp.promotion_details_ar,
    sp.price,
    sp.tags_id,
    sp.start_date,
    sp.end_date,
    sp.created_by,
    sp.created_at,
    sp.updated_at
FROM service_promotions sp
`

type GetAllServicesPromotionsByIDRow struct {
	ID                 int64       `json:"id"`
	Service            int64       `json:"service"`
	PromotionName      string      `json:"promotion_name"`
	PromotionDetails   string      `json:"promotion_details"`
	PromotionNameAr    pgtype.Text `json:"promotion_name_ar"`
	PromotionDetailsAr pgtype.Text `json:"promotion_details_ar"`
	Price              float64     `json:"price"`
	TagsID             int64       `json:"tags_id"`
	StartDate          time.Time   `json:"start_date"`
	EndDate            time.Time   `json:"end_date"`
	CreatedBy          int64       `json:"created_by"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
}

func (q *Queries) GetAllServicesPromotionsByID(ctx context.Context) ([]GetAllServicesPromotionsByIDRow, error) {
	rows, err := q.db.Query(ctx, getAllServicesPromotionsByID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllServicesPromotionsByIDRow
	for rows.Next() {
		var i GetAllServicesPromotionsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Service,
			&i.PromotionName,
			&i.PromotionDetails,
			&i.PromotionNameAr,
			&i.PromotionDetailsAr,
			&i.Price,
			&i.TagsID,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishServicesPromotions = `-- name: GetPublishServicesPromotions :many
SELECT sp.id, sp.service, sp.status, sp.promotion_name, sp.promotion_details, sp.price, sp.tags_id, sp.start_date, sp.end_date, sp.created_by, sp.created_at, sp.updated_at, sp.promotion_name_ar, sp.promotion_details_ar,
COUNT(*) OVER() AS total_count 
FROM service_promotions sp
inner join publish_listing pl on pl.entity_id = sp.id and pl.entity_type_id = 11
LIMIT $1 OFFSET $2
`

type GetPublishServicesPromotionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPublishServicesPromotionsRow struct {
	ID                 int64       `json:"id"`
	Service            int64       `json:"service"`
	Status             int64       `json:"status"`
	PromotionName      string      `json:"promotion_name"`
	PromotionDetails   string      `json:"promotion_details"`
	Price              float64     `json:"price"`
	TagsID             int64       `json:"tags_id"`
	StartDate          time.Time   `json:"start_date"`
	EndDate            time.Time   `json:"end_date"`
	CreatedBy          int64       `json:"created_by"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
	PromotionNameAr    pgtype.Text `json:"promotion_name_ar"`
	PromotionDetailsAr pgtype.Text `json:"promotion_details_ar"`
	TotalCount         int64       `json:"total_count"`
}

func (q *Queries) GetPublishServicesPromotions(ctx context.Context, arg GetPublishServicesPromotionsParams) ([]GetPublishServicesPromotionsRow, error) {
	rows, err := q.db.Query(ctx, getPublishServicesPromotions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublishServicesPromotionsRow
	for rows.Next() {
		var i GetPublishServicesPromotionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Service,
			&i.Status,
			&i.PromotionName,
			&i.PromotionDetails,
			&i.Price,
			&i.TagsID,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PromotionNameAr,
			&i.PromotionDetailsAr,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesPromotionsByID = `-- name: GetServicesPromotionsByID :one
SELECT 
    sp.id,
    sp.service,
    sp.promotion_name,
    sp.promotion_details,
    sp.promotion_name_ar,
    sp.promotion_details_ar,
    sp.price,
    sp.tags_id,
    sp.start_date,
    sp.end_date,
    sp.created_by,
    sp.created_at,
    sp.updated_at
FROM service_promotions sp
WHERE sp.id = $1
`

type GetServicesPromotionsByIDRow struct {
	ID                 int64       `json:"id"`
	Service            int64       `json:"service"`
	PromotionName      string      `json:"promotion_name"`
	PromotionDetails   string      `json:"promotion_details"`
	PromotionNameAr    pgtype.Text `json:"promotion_name_ar"`
	PromotionDetailsAr pgtype.Text `json:"promotion_details_ar"`
	Price              float64     `json:"price"`
	TagsID             int64       `json:"tags_id"`
	StartDate          time.Time   `json:"start_date"`
	EndDate            time.Time   `json:"end_date"`
	CreatedBy          int64       `json:"created_by"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
}

func (q *Queries) GetServicesPromotionsByID(ctx context.Context, id int64) (GetServicesPromotionsByIDRow, error) {
	row := q.db.QueryRow(ctx, getServicesPromotionsByID, id)
	var i GetServicesPromotionsByIDRow
	err := row.Scan(
		&i.ID,
		&i.Service,
		&i.PromotionName,
		&i.PromotionDetails,
		&i.PromotionNameAr,
		&i.PromotionDetailsAr,
		&i.Price,
		&i.TagsID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getServicesPromotionsByServiceID = `-- name: GetServicesPromotionsByServiceID :many
SELECT 
    sp.id,
    sp.service,
    sp.promotion_name,
    sp.promotion_details,
    sp.promotion_name_ar,
    sp.promotion_details_ar,
    sp.price,
    sp.tags_id,
    sp.start_date,
    sp.end_date,
    sp.created_by,
    sp.created_at,
    sp.updated_at
FROM service_promotions sp
WHERE sp.service = $1
`

type GetServicesPromotionsByServiceIDRow struct {
	ID                 int64       `json:"id"`
	Service            int64       `json:"service"`
	PromotionName      string      `json:"promotion_name"`
	PromotionDetails   string      `json:"promotion_details"`
	PromotionNameAr    pgtype.Text `json:"promotion_name_ar"`
	PromotionDetailsAr pgtype.Text `json:"promotion_details_ar"`
	Price              float64     `json:"price"`
	TagsID             int64       `json:"tags_id"`
	StartDate          time.Time   `json:"start_date"`
	EndDate            time.Time   `json:"end_date"`
	CreatedBy          int64       `json:"created_by"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
}

func (q *Queries) GetServicesPromotionsByServiceID(ctx context.Context, service int64) ([]GetServicesPromotionsByServiceIDRow, error) {
	rows, err := q.db.Query(ctx, getServicesPromotionsByServiceID, service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServicesPromotionsByServiceIDRow
	for rows.Next() {
		var i GetServicesPromotionsByServiceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Service,
			&i.PromotionName,
			&i.PromotionDetails,
			&i.PromotionNameAr,
			&i.PromotionDetailsAr,
			&i.Price,
			&i.TagsID,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesPromotionsByStatusID = `-- name: GetServicesPromotionsByStatusID :many
SELECT 
    sp.id,
    sp.service,
    sp.status,
    sp.promotion_name,
    sp.promotion_details,
    sp.promotion_name_ar,
    sp.promotion_details_ar,
    sp.price,
    sp.tags_id,
    sp.start_date,
    sp.end_date,
    sp.created_by,
    sp.created_at,
    sp.updated_at
FROM service_promotions sp
WHERE sp.status = $1
`

type GetServicesPromotionsByStatusIDRow struct {
	ID                 int64       `json:"id"`
	Service            int64       `json:"service"`
	Status             int64       `json:"status"`
	PromotionName      string      `json:"promotion_name"`
	PromotionDetails   string      `json:"promotion_details"`
	PromotionNameAr    pgtype.Text `json:"promotion_name_ar"`
	PromotionDetailsAr pgtype.Text `json:"promotion_details_ar"`
	Price              float64     `json:"price"`
	TagsID             int64       `json:"tags_id"`
	StartDate          time.Time   `json:"start_date"`
	EndDate            time.Time   `json:"end_date"`
	CreatedBy          int64       `json:"created_by"`
	CreatedAt          time.Time   `json:"created_at"`
	UpdatedAt          time.Time   `json:"updated_at"`
}

func (q *Queries) GetServicesPromotionsByStatusID(ctx context.Context, status int64) ([]GetServicesPromotionsByStatusIDRow, error) {
	rows, err := q.db.Query(ctx, getServicesPromotionsByStatusID, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServicesPromotionsByStatusIDRow
	for rows.Next() {
		var i GetServicesPromotionsByStatusIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Service,
			&i.Status,
			&i.PromotionName,
			&i.PromotionDetails,
			&i.PromotionNameAr,
			&i.PromotionDetailsAr,
			&i.Price,
			&i.TagsID,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateServicePromotionStatus = `-- name: UpdateServicePromotionStatus :one
UPDATE service_promotions
SET status = $2, 
    updated_at = NOW() 
WHERE id = $1 RETURNING id, service, status, promotion_name, promotion_details, price, tags_id, start_date, end_date, created_by, created_at, updated_at, promotion_name_ar, promotion_details_ar
`

type UpdateServicePromotionStatusParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

func (q *Queries) UpdateServicePromotionStatus(ctx context.Context, arg UpdateServicePromotionStatusParams) (ServicePromotion, error) {
	row := q.db.QueryRow(ctx, updateServicePromotionStatus, arg.ID, arg.Status)
	var i ServicePromotion
	err := row.Scan(
		&i.ID,
		&i.Service,
		&i.Status,
		&i.PromotionName,
		&i.PromotionDetails,
		&i.Price,
		&i.TagsID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PromotionNameAr,
		&i.PromotionDetailsAr,
	)
	return i, err
}

const updateServicesPromotion = `-- name: UpdateServicesPromotion :one
UPDATE service_promotions
SET
    service=$2,
    promotion_name=$3,
    promotion_name_ar=$4,
    promotion_details=$5,
    promotion_details_ar=$6,
    price=$7,
    tags_id=$8,
    start_date=$9,
    end_date=$10
WHERE id=$1
RETURNING id, service, status, promotion_name, promotion_details, price, tags_id, start_date, end_date, created_by, created_at, updated_at, promotion_name_ar, promotion_details_ar
`

type UpdateServicesPromotionParams struct {
	ID                 int64       `json:"id"`
	Service            int64       `json:"service"`
	PromotionName      string      `json:"promotion_name"`
	PromotionNameAr    pgtype.Text `json:"promotion_name_ar"`
	PromotionDetails   string      `json:"promotion_details"`
	PromotionDetailsAr pgtype.Text `json:"promotion_details_ar"`
	Price              float64     `json:"price"`
	TagsID             int64       `json:"tags_id"`
	StartDate          time.Time   `json:"start_date"`
	EndDate            time.Time   `json:"end_date"`
}

func (q *Queries) UpdateServicesPromotion(ctx context.Context, arg UpdateServicesPromotionParams) (ServicePromotion, error) {
	row := q.db.QueryRow(ctx, updateServicesPromotion,
		arg.ID,
		arg.Service,
		arg.PromotionName,
		arg.PromotionNameAr,
		arg.PromotionDetails,
		arg.PromotionDetailsAr,
		arg.Price,
		arg.TagsID,
		arg.StartDate,
		arg.EndDate,
	)
	var i ServicePromotion
	err := row.Scan(
		&i.ID,
		&i.Service,
		&i.Status,
		&i.PromotionName,
		&i.PromotionDetails,
		&i.Price,
		&i.TagsID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PromotionNameAr,
		&i.PromotionDetailsAr,
	)
	return i, err
}
