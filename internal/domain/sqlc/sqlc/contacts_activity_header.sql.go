// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: contacts_activity_header.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createContactActivityHeader = `-- name: CreateContactActivityHeader :one
INSERT INTO contacts_activity_header (
    title,
    created_by,
    assigned_to,
    contacts_activity_type,
    reference_no,
    moving_date,
    phone_number,
    email,
    subject,
    comments,
    created_at,
    updated_at,
    status,
    contacts_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, title, created_by, assigned_to, contacts_activity_type, reference_no, moving_date, phone_number, email, subject, comments, status, created_at, updated_at, contacts_id
`

type CreateContactActivityHeaderParams struct {
	Title                string           `json:"title"`
	CreatedBy            int64            `json:"created_by"`
	AssignedTo           []int64          `json:"assigned_to"`
	ContactsActivityType int64            `json:"contacts_activity_type"`
	ReferenceNo          string           `json:"reference_no"`
	MovingDate           pgtype.Timestamp `json:"moving_date"`
	PhoneNumber          string           `json:"phone_number"`
	Email                string           `json:"email"`
	Subject              string           `json:"subject"`
	Comments             string           `json:"comments"`
	CreatedAt            time.Time        `json:"created_at"`
	UpdatedAt            time.Time        `json:"updated_at"`
	Status               int64            `json:"status"`
	ContactsID           pgtype.Int8      `json:"contacts_id"`
}

func (q *Queries) CreateContactActivityHeader(ctx context.Context, arg CreateContactActivityHeaderParams) (ContactsActivityHeader, error) {
	row := q.db.QueryRow(ctx, createContactActivityHeader,
		arg.Title,
		arg.CreatedBy,
		arg.AssignedTo,
		arg.ContactsActivityType,
		arg.ReferenceNo,
		arg.MovingDate,
		arg.PhoneNumber,
		arg.Email,
		arg.Subject,
		arg.Comments,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.ContactsID,
	)
	var i ContactsActivityHeader
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ContactsActivityType,
		&i.ReferenceNo,
		&i.MovingDate,
		&i.PhoneNumber,
		&i.Email,
		&i.Subject,
		&i.Comments,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactsID,
	)
	return i, err
}

const getAllContactActivityHeaderByContactId = `-- name: GetAllContactActivityHeaderByContactId :many
select cah.id, cah.title, cah.created_by, cah.assigned_to, cah.contacts_activity_type, cah.reference_no, cah.moving_date, cah.phone_number, cah.email, cah.subject, cah.comments, cah.status, cah.created_at, cah.updated_at, cah.contacts_id, l.id, l.ref_no, l.contacts_id, l.lead_source, l.media_name, l.lead_type, l.contact_type, l.languages, l.property_category, l.is_property, l.unit_category, l.property_type_id, l.is_luxury, l.property_unit_id, l.property_statuses_id, l.purpose_id, l.min_budget, l.max_budget, l.min_area, l.max_area, l.bedroom, l.bathroom, l.countries_id, l.states_id, l.cities_id, l.community_id, l.subcommunity_id, l.lat, l.lng, l.assigned_to, l.residential_status, l.referred_to, l.is_exclusive, l.priority_level, l.is_finance, l.mortgage_bank_id, l.mortgage_status, l.required_start, l.required_end, l.closing_remarks, l.internal_notes, l.created_at, l.leads_won, l.with_reference, l.is_property_branch, l.property_reference_name, l.social_media_name, l.section_type from contacts_activity_header cah 
left join leads l on l.ref_no = cah.reference_no where cah.contacts_id = $1 ORDER BY cah.id LIMIT $2 OFFSET $3
`

type GetAllContactActivityHeaderByContactIdParams struct {
	ContactsID pgtype.Int8 `json:"contacts_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetAllContactActivityHeaderByContactIdRow struct {
	ID                    int64              `json:"id"`
	Title                 string             `json:"title"`
	CreatedBy             int64              `json:"created_by"`
	AssignedTo            []int64            `json:"assigned_to"`
	ContactsActivityType  int64              `json:"contacts_activity_type"`
	ReferenceNo           string             `json:"reference_no"`
	MovingDate            pgtype.Timestamp   `json:"moving_date"`
	PhoneNumber           string             `json:"phone_number"`
	Email                 string             `json:"email"`
	Subject               string             `json:"subject"`
	Comments              string             `json:"comments"`
	Status                int64              `json:"status"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
	ContactsID            pgtype.Int8        `json:"contacts_id"`
	ID_2                  pgtype.Int8        `json:"id_2"`
	RefNo                 pgtype.Text        `json:"ref_no"`
	ContactsID_2          pgtype.Int8        `json:"contacts_id_2"`
	LeadSource            pgtype.Int8        `json:"lead_source"`
	MediaName             pgtype.Int8        `json:"media_name"`
	LeadType              pgtype.Int8        `json:"lead_type"`
	ContactType           pgtype.Int8        `json:"contact_type"`
	Languages             []int64            `json:"languages"`
	PropertyCategory      pgtype.Int8        `json:"property_category"`
	IsProperty            pgtype.Bool        `json:"is_property"`
	UnitCategory          pgtype.Text        `json:"unit_category"`
	PropertyTypeID        pgtype.Int8        `json:"property_type_id"`
	IsLuxury              pgtype.Bool        `json:"is_luxury"`
	PropertyUnitID        pgtype.Int8        `json:"property_unit_id"`
	PropertyStatusesID    pgtype.Int8        `json:"property_statuses_id"`
	PurposeID             pgtype.Int8        `json:"purpose_id"`
	MinBudget             pgtype.Float8      `json:"min_budget"`
	MaxBudget             pgtype.Float8      `json:"max_budget"`
	MinArea               pgtype.Float8      `json:"min_area"`
	MaxArea               pgtype.Float8      `json:"max_area"`
	Bedroom               pgtype.Int8        `json:"bedroom"`
	Bathroom              pgtype.Int8        `json:"bathroom"`
	CountriesID           pgtype.Int8        `json:"countries_id"`
	StatesID              pgtype.Int8        `json:"states_id"`
	CitiesID              pgtype.Int8        `json:"cities_id"`
	CommunityID           []int64            `json:"community_id"`
	SubcommunityID        []int64            `json:"subcommunity_id"`
	Lat                   pgtype.Text        `json:"lat"`
	Lng                   pgtype.Text        `json:"lng"`
	AssignedTo_2          pgtype.Int8        `json:"assigned_to_2"`
	ResidentialStatus     pgtype.Int8        `json:"residential_status"`
	ReferredTo            pgtype.Int8        `json:"referred_to"`
	IsExclusive           pgtype.Bool        `json:"is_exclusive"`
	PriorityLevel         pgtype.Int8        `json:"priority_level"`
	IsFinance             pgtype.Bool        `json:"is_finance"`
	MortgageBankID        pgtype.Int8        `json:"mortgage_bank_id"`
	MortgageStatus        pgtype.Int8        `json:"mortgage_status"`
	RequiredStart         pgtype.Timestamptz `json:"required_start"`
	RequiredEnd           pgtype.Timestamptz `json:"required_end"`
	ClosingRemarks        pgtype.Text        `json:"closing_remarks"`
	InternalNotes         pgtype.Text        `json:"internal_notes"`
	CreatedAt_2           pgtype.Timestamptz `json:"created_at_2"`
	LeadsWon              pgtype.Bool        `json:"leads_won"`
	WithReference         pgtype.Bool        `json:"with_reference"`
	IsPropertyBranch      pgtype.Bool        `json:"is_property_branch"`
	PropertyReferenceName pgtype.Text        `json:"property_reference_name"`
	SocialMediaName       pgtype.Text        `json:"social_media_name"`
	SectionType           []int64            `json:"section_type"`
}

func (q *Queries) GetAllContactActivityHeaderByContactId(ctx context.Context, arg GetAllContactActivityHeaderByContactIdParams) ([]GetAllContactActivityHeaderByContactIdRow, error) {
	rows, err := q.db.Query(ctx, getAllContactActivityHeaderByContactId, arg.ContactsID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllContactActivityHeaderByContactIdRow
	for rows.Next() {
		var i GetAllContactActivityHeaderByContactIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.ContactsActivityType,
			&i.ReferenceNo,
			&i.MovingDate,
			&i.PhoneNumber,
			&i.Email,
			&i.Subject,
			&i.Comments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactsID,
			&i.ID_2,
			&i.RefNo,
			&i.ContactsID_2,
			&i.LeadSource,
			&i.MediaName,
			&i.LeadType,
			&i.ContactType,
			&i.Languages,
			&i.PropertyCategory,
			&i.IsProperty,
			&i.UnitCategory,
			&i.PropertyTypeID,
			&i.IsLuxury,
			&i.PropertyUnitID,
			&i.PropertyStatusesID,
			&i.PurposeID,
			&i.MinBudget,
			&i.MaxBudget,
			&i.MinArea,
			&i.MaxArea,
			&i.Bedroom,
			&i.Bathroom,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunityID,
			&i.SubcommunityID,
			&i.Lat,
			&i.Lng,
			&i.AssignedTo_2,
			&i.ResidentialStatus,
			&i.ReferredTo,
			&i.IsExclusive,
			&i.PriorityLevel,
			&i.IsFinance,
			&i.MortgageBankID,
			&i.MortgageStatus,
			&i.RequiredStart,
			&i.RequiredEnd,
			&i.ClosingRemarks,
			&i.InternalNotes,
			&i.CreatedAt_2,
			&i.LeadsWon,
			&i.WithReference,
			&i.IsPropertyBranch,
			&i.PropertyReferenceName,
			&i.SocialMediaName,
			&i.SectionType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactActivityHeaderByContactIdWithoutPagination = `-- name: GetAllContactActivityHeaderByContactIdWithoutPagination :one
SELECT id, title, created_by, assigned_to, contacts_activity_type, reference_no, moving_date, phone_number, email, subject, comments, status, created_at, updated_at, contacts_id FROM contacts_activity_header WHERE contacts_id = $1
`

func (q *Queries) GetAllContactActivityHeaderByContactIdWithoutPagination(ctx context.Context, contactsID pgtype.Int8) (ContactsActivityHeader, error) {
	row := q.db.QueryRow(ctx, getAllContactActivityHeaderByContactIdWithoutPagination, contactsID)
	var i ContactsActivityHeader
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ContactsActivityType,
		&i.ReferenceNo,
		&i.MovingDate,
		&i.PhoneNumber,
		&i.Email,
		&i.Subject,
		&i.Comments,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactsID,
	)
	return i, err
}

const getCountAllContactActivityHeaderByContactId = `-- name: GetCountAllContactActivityHeaderByContactId :one
select count(*) from contacts_activity_header where contacts_id = $1
`

func (q *Queries) GetCountAllContactActivityHeaderByContactId(ctx context.Context, contactsID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllContactActivityHeaderByContactId, contactsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSingleActivityHeader = `-- name: GetSingleActivityHeader :one
SELECT id, title, created_by, assigned_to, contacts_activity_type, reference_no, moving_date, phone_number, email, subject, comments, status, created_at, updated_at, contacts_id FROM contacts_activity_header WHERE id = $1
`

func (q *Queries) GetSingleActivityHeader(ctx context.Context, id int64) (ContactsActivityHeader, error) {
	row := q.db.QueryRow(ctx, getSingleActivityHeader, id)
	var i ContactsActivityHeader
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ContactsActivityType,
		&i.ReferenceNo,
		&i.MovingDate,
		&i.PhoneNumber,
		&i.Email,
		&i.Subject,
		&i.Comments,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactsID,
	)
	return i, err
}

const updateContactActivityHeader = `-- name: UpdateContactActivityHeader :one
UPDATE contacts_activity_header
SET
    title = $2,
    created_by = $3,
    assigned_to = $4,
    contacts_activity_type = $5,
    reference_no = $6,
    moving_date = $7,
    phone_number = $8,
    email = $9,
    subject = $10,
    comments = $11,
    updated_at = $12,
    status = $13
WHERE
    contacts_id = $1 RETURNING id, title, created_by, assigned_to, contacts_activity_type, reference_no, moving_date, phone_number, email, subject, comments, status, created_at, updated_at, contacts_id
`

type UpdateContactActivityHeaderParams struct {
	ContactsID           pgtype.Int8      `json:"contacts_id"`
	Title                string           `json:"title"`
	CreatedBy            int64            `json:"created_by"`
	AssignedTo           []int64          `json:"assigned_to"`
	ContactsActivityType int64            `json:"contacts_activity_type"`
	ReferenceNo          string           `json:"reference_no"`
	MovingDate           pgtype.Timestamp `json:"moving_date"`
	PhoneNumber          string           `json:"phone_number"`
	Email                string           `json:"email"`
	Subject              string           `json:"subject"`
	Comments             string           `json:"comments"`
	UpdatedAt            time.Time        `json:"updated_at"`
	Status               int64            `json:"status"`
}

func (q *Queries) UpdateContactActivityHeader(ctx context.Context, arg UpdateContactActivityHeaderParams) (ContactsActivityHeader, error) {
	row := q.db.QueryRow(ctx, updateContactActivityHeader,
		arg.ContactsID,
		arg.Title,
		arg.CreatedBy,
		arg.AssignedTo,
		arg.ContactsActivityType,
		arg.ReferenceNo,
		arg.MovingDate,
		arg.PhoneNumber,
		arg.Email,
		arg.Subject,
		arg.Comments,
		arg.UpdatedAt,
		arg.Status,
	)
	var i ContactsActivityHeader
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ContactsActivityType,
		&i.ReferenceNo,
		&i.MovingDate,
		&i.PhoneNumber,
		&i.Email,
		&i.Subject,
		&i.Comments,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactsID,
	)
	return i, err
}

const updateMultipleContactActivityHeaderConactID = `-- name: UpdateMultipleContactActivityHeaderConactID :one
UPDATE contacts_activity_header SET contacts_id = $1 WHERE id = ANY($2::bigint[]) RETURNING id, title, created_by, assigned_to, contacts_activity_type, reference_no, moving_date, phone_number, email, subject, comments, status, created_at, updated_at, contacts_id
`

type UpdateMultipleContactActivityHeaderConactIDParams struct {
	ContactsID pgtype.Int8 `json:"contacts_id"`
	Column2    []int64     `json:"column_2"`
}

func (q *Queries) UpdateMultipleContactActivityHeaderConactID(ctx context.Context, arg UpdateMultipleContactActivityHeaderConactIDParams) (ContactsActivityHeader, error) {
	row := q.db.QueryRow(ctx, updateMultipleContactActivityHeaderConactID, arg.ContactsID, arg.Column2)
	var i ContactsActivityHeader
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ContactsActivityType,
		&i.ReferenceNo,
		&i.MovingDate,
		&i.PhoneNumber,
		&i.Email,
		&i.Subject,
		&i.Comments,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactsID,
	)
	return i, err
}

const updateSingleContactActivityHeaderContactID = `-- name: UpdateSingleContactActivityHeaderContactID :one
UPDATE contacts_activity_header SET contacts_id = $1 WHERE id = $2 RETURNING id, title, created_by, assigned_to, contacts_activity_type, reference_no, moving_date, phone_number, email, subject, comments, status, created_at, updated_at, contacts_id
`

type UpdateSingleContactActivityHeaderContactIDParams struct {
	ContactsID pgtype.Int8 `json:"contacts_id"`
	ID         int64       `json:"id"`
}

func (q *Queries) UpdateSingleContactActivityHeaderContactID(ctx context.Context, arg UpdateSingleContactActivityHeaderContactIDParams) (ContactsActivityHeader, error) {
	row := q.db.QueryRow(ctx, updateSingleContactActivityHeaderContactID, arg.ContactsID, arg.ID)
	var i ContactsActivityHeader
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.ContactsActivityType,
		&i.ReferenceNo,
		&i.MovingDate,
		&i.PhoneNumber,
		&i.Email,
		&i.Subject,
		&i.Comments,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactsID,
	)
	return i, err
}
