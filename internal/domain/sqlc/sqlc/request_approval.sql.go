// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: request_approval.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApprovalForRequest = `-- name: CreateApprovalForRequest :one
INSERT INTO
    approvals(
        request_id,
        workflow_step,
        department,
        approved_by,
        status,
        remarks,
        files,
        updated_at
    ) 
SELECT
    $1,workflows.id,$2,$3,$4,$5,$6,$7
FROM
    requests_verification
    INNER JOIN workflows ON workflows.request_type = requests_verification.request_type
    AND workflows.department = $2::BIGINT
WHERE
    requests_verification.id = $1
RETURNING workflow_step
`

type CreateApprovalForRequestParams struct {
	RequestID  int64              `json:"request_id"`
	Department int64              `json:"department"`
	ApprovedBy pgtype.Int8        `json:"approved_by"`
	Status     int64              `json:"status"`
	Remarks    string             `json:"remarks"`
	Files      []byte             `json:"files"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateApprovalForRequest(ctx context.Context, arg CreateApprovalForRequestParams) (int64, error) {
	row := q.db.QueryRow(ctx, createApprovalForRequest,
		arg.RequestID,
		arg.Department,
		arg.ApprovedBy,
		arg.Status,
		arg.Remarks,
		arg.Files,
		arg.UpdatedAt,
	)
	var workflow_step int64
	err := row.Scan(&workflow_step)
	return workflow_step, err
}

const createPendingApproval = `-- name: CreatePendingApproval :exec
INSERT INTO
    approvals(
        request_id,
        workflow_step,
        department,
        status,
        remarks, 
        user_ids
    ) 
SELECT rv.id,workflows.id,workflows.department,$2::BIGINT,$1,workflows.user_ids
	FROM
		requests_verification rv
		INNER JOIN workflows ON workflows.request_type= rv.request_type AND workflows.step= $3::BIGINT  
WHERE 
	rv.id= $4::BIGINT
`

type CreatePendingApprovalParams struct {
	Remarks       string `json:"remarks"`
	PendingStatus int64  `json:"pending_status"`
	WorkflowStep  int64  `json:"workflow_step"`
	RequestID     int64  `json:"request_id"`
}

func (q *Queries) CreatePendingApproval(ctx context.Context, arg CreatePendingApprovalParams) error {
	_, err := q.db.Exec(ctx, createPendingApproval,
		arg.Remarks,
		arg.PendingStatus,
		arg.WorkflowStep,
		arg.RequestID,
	)
	return err
}

const createPendingApprovalAfterRejection = `-- name: CreatePendingApprovalAfterRejection :exec
INSERT INTO
    approvals(
        request_id,
        workflow_step,
        department,
        approved_by,
        status,
        remarks, 
        user_ids
    )
SELECT approvals.request_id,approvals.workflow_step,approvals.department,approvals.approved_by, $2::BIGINT ,$1,workflows.user_ids
FROM
    approvals
INNER JOIN workflows ON approvals.workflow_step=workflows.id 
WHERE 
	approvals.request_id = $3::BIGINT 
ORDER BY approvals.id DESC 
LIMIT 1
`

type CreatePendingApprovalAfterRejectionParams struct {
	Remarks       string `json:"remarks"`
	PendingStatus int64  `json:"pending_status"`
	RequestID     int64  `json:"request_id"`
}

func (q *Queries) CreatePendingApprovalAfterRejection(ctx context.Context, arg CreatePendingApprovalAfterRejectionParams) error {
	_, err := q.db.Exec(ctx, createPendingApprovalAfterRejection, arg.Remarks, arg.PendingStatus, arg.RequestID)
	return err
}

const createRequestApproval = `-- name: CreateRequestApproval :one
INSERT INTO
    requests_verification(
        request_type,
        entity_type,
        entity_id,
        requested_by,
        status,
        created_at,
        updated_at
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7)RETURNING id
`

type CreateRequestApprovalParams struct {
	RequestType int64              `json:"request_type"`
	EntityType  int64              `json:"entity_type"`
	EntityID    int64              `json:"entity_id"`
	RequestedBy int64              `json:"requested_by"`
	Status      int64              `json:"status"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateRequestApproval(ctx context.Context, arg CreateRequestApprovalParams) (int64, error) {
	row := q.db.QueryRow(ctx, createRequestApproval,
		arg.RequestType,
		arg.EntityType,
		arg.EntityID,
		arg.RequestedBy,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createRequestApprovalData = `-- name: CreateRequestApprovalData :exec
INSERT INTO
    request_data(
        request_id,
        field_name,
        field_value,
        created_at, 
        field_type
    )
VALUES
    ($1, $2, $3, $4, $5)
`

type CreateRequestApprovalDataParams struct {
	RequestID  int64       `json:"request_id"`
	FieldName  string      `json:"field_name"`
	FieldValue string      `json:"field_value"`
	CreatedAt  time.Time   `json:"created_at"`
	FieldType  pgtype.Text `json:"field_type"`
}

func (q *Queries) CreateRequestApprovalData(ctx context.Context, arg CreateRequestApprovalDataParams) error {
	_, err := q.db.Exec(ctx, createRequestApprovalData,
		arg.RequestID,
		arg.FieldName,
		arg.FieldValue,
		arg.CreatedAt,
		arg.FieldType,
	)
	return err
}

const getAllRequestsForDepartment = `-- name: GetAllRequestsForDepartment :many
SELECT
    requests_verification.id, requests_verification.request_type, requests_verification.entity_type, requests_verification.entity_id, requests_verification.requested_by, requests_verification.status, requests_verification.created_at, requests_verification.updated_at, requests_verification.ref_no,requests_type.type,w.id AS "workflow_id"
FROM
    requests_verification
    INNER JOIN requests_type ON requests_type.id=requests_verification.request_type
    INNER JOIN workflows w ON requests_verification.request_type = w.request_type
    AND w.department = $1:: BIGINT
    AND(
        w.step = 1  
        OR EXISTS (
            SELECT
                1
            FROM
                approvals
            INNER JOIN workflows w2 ON w2.id=approvals.workflow_step
            WHERE
                approvals.request_id = requests_verification.id
                AND w.step = w2.step +1
                AND approvals.status = $2::VARCHAR
                AND requests_verification.status = $3::VARCHAR
        )
    ) AND requests_verification.status!= $2::VARCHAR
`

type GetAllRequestsForDepartmentParams struct {
	DepartmentID     int64  `json:"department_id"`
	ApprovalStatus   string `json:"approval_status"`
	ProcessingStatus string `json:"processing_status"`
}

type GetAllRequestsForDepartmentRow struct {
	ID          int64              `json:"id"`
	RequestType int64              `json:"request_type"`
	EntityType  int64              `json:"entity_type"`
	EntityID    int64              `json:"entity_id"`
	RequestedBy int64              `json:"requested_by"`
	Status      int64              `json:"status"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	RefNo       string             `json:"ref_no"`
	Type        string             `json:"type"`
	WorkflowID  int64              `json:"workflow_id"`
}

func (q *Queries) GetAllRequestsForDepartment(ctx context.Context, arg GetAllRequestsForDepartmentParams) ([]GetAllRequestsForDepartmentRow, error) {
	rows, err := q.db.Query(ctx, getAllRequestsForDepartment, arg.DepartmentID, arg.ApprovalStatus, arg.ProcessingStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRequestsForDepartmentRow
	for rows.Next() {
		var i GetAllRequestsForDepartmentRow
		if err := rows.Scan(
			&i.ID,
			&i.RequestType,
			&i.EntityType,
			&i.EntityID,
			&i.RequestedBy,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefNo,
			&i.Type,
			&i.WorkflowID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApprovalIdForRejectedRequest = `-- name: GetApprovalIdForRejectedRequest :one
SELECT
    COALESCE(MAX(a.id),0) :: BIGINT
FROM
    approvals a
    INNER JOIN requests_verification rv ON rv.id = $1 :: BIGINT
    AND rv.requested_by = $2 :: BIGINT
WHERE
    a.request_id = $1 :: BIGINT
    AND a.status = $3 :: BIGINT
`

type GetApprovalIdForRejectedRequestParams struct {
	RequestID      int64 `json:"request_id"`
	UserID         int64 `json:"user_id"`
	RejectedStatus int64 `json:"rejected_status"`
}

func (q *Queries) GetApprovalIdForRejectedRequest(ctx context.Context, arg GetApprovalIdForRejectedRequestParams) (int64, error) {
	row := q.db.QueryRow(ctx, getApprovalIdForRejectedRequest, arg.RequestID, arg.UserID, arg.RejectedStatus)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getNumberRequestsByStatus = `-- name: GetNumberRequestsByStatus :one
SELECT
    COUNT(*)
FROM
    approvals a
INNER JOIN requests_verification rv ON rv.id = a.request_id
INNER JOIN requests_type ON requests_type.id=rv.request_type

WHERE
 a.status = ANY( $1::BIGINT[]) AND $2::BIGINT =ANY(a.user_ids)
`

type GetNumberRequestsByStatusParams struct {
	Statuses []int64 `json:"statuses"`
	UserID   int64   `json:"user_id"`
}

// INNER JOIN workflows ON a.workflow_step=workflows.id AND @user_id::BIGINT =ANY(workflows.user_ids)
func (q *Queries) GetNumberRequestsByStatus(ctx context.Context, arg GetNumberRequestsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberRequestsByStatus, arg.Statuses, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRejectedData = `-- name: GetRejectedData :many
SELECT
    rd.id,
    rd.field_name,
    rd.field_value,
    rd.field_type
FROM
    approvals a
    JOIN LATERAL UNNEST(a.required_fields) AS rf(request_id) ON true
    JOIN request_data rd ON rd.id = rf.request_id
    JOIN requests_verification rv ON rv.id= $1 :: BIGINT AND rv.requested_by= $2::BIGINT
WHERE
    a.request_id = $1 :: BIGINT
    AND a.status = $3 :: BIGINT
    AND a.id =(
        SELECT
            MAX(id)
        FROM
            approvals
        WHERE
            request_id = $1 :: BIGINT
            AND status = $3 :: BIGINT
    )
`

type GetRejectedDataParams struct {
	RequestID      int64 `json:"request_id"`
	UserID         int64 `json:"user_id"`
	RejectedStatus int64 `json:"rejected_status"`
}

type GetRejectedDataRow struct {
	ID         int64       `json:"id"`
	FieldName  string      `json:"field_name"`
	FieldValue string      `json:"field_value"`
	FieldType  pgtype.Text `json:"field_type"`
}

func (q *Queries) GetRejectedData(ctx context.Context, arg GetRejectedDataParams) ([]GetRejectedDataRow, error) {
	rows, err := q.db.Query(ctx, getRejectedData, arg.RequestID, arg.UserID, arg.RejectedStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRejectedDataRow
	for rows.Next() {
		var i GetRejectedDataRow
		if err := rows.Scan(
			&i.ID,
			&i.FieldName,
			&i.FieldValue,
			&i.FieldType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestByID = `-- name: GetRequestByID :one
WITH requestData as (
    SELECT
        request_data.request_id AS request_id,
        jsonb_agg(
            jsonb_build_object(
                'id',
                request_data.id,
                'name',
                request_data.field_name,
                'value',
                request_data.field_value, 
                'field_type',request_data.field_type
            )
        ) AS requests_data_json
    FROM
        request_data
    WHERE
        request_data.request_id = $1 :: BIGINT
    GROUP BY
        request_data.request_id
),
approvalsHistory as(
    SELECT
        approvals.request_id AS request_id,
        jsonb_agg(
            jsonb_build_object(
                'id', 
                approvals.id,
                'department_id',
                department.id,
                'department_name',
                department.department,
                'files',
                approvals.files, 
                'status', 
                approvals.status, 
                'remarks', 
                approvals.remarks
            )
        ) AS approvals_history_json
    FROM
        approvals
        INNER JOIN department ON approvals.department = department.id
    WHERE
        approvals.request_id = $1 :: BIGINT
   -- ORDER BY approvals.updated_at DESC
    GROUP BY
        approvals.request_id
), 
department_remark as(
     SELECT approvals.remarks,department.department,$1::BIGINT as request_id
        FROM
            approvals
        INNER JOIN department ON department.id=approvals.department
        WHERE
            approvals.request_id = $1
        ORDER BY approvals.id DESC
        LIMIT 1 
)
SELECT
    rv.id, rv.request_type, rv.entity_type, rv.entity_id, rv.requested_by, rv.status, rv.created_at, rv.updated_at, rv.ref_no,
    rt.type,
    requestdata.request_id, requestdata.requests_data_json ,
    approvalshistory.request_id, approvalshistory.approvals_history_json, 
    dr.remarks, 
    dr.department
FROM
    requests_verification rv
    INNER JOIN requests_type rt ON rv.request_type = rt.id
    INNER JOIN requestData ON requestData.request_id = rv.id
    INNER JOIN approvalsHistory ON approvalsHistory.request_id = rv.id
    INNER JOIN department_remark as dr ON dr.request_id=rv.id
WHERE
    rv.id = $1 :: BIGINT AND rv.requested_by= $2::BIGINT
`

type GetRequestByIDParams struct {
	RequestID int64 `json:"request_id"`
	UserID    int64 `json:"user_id"`
}

type GetRequestByIDRow struct {
	ID                   int64              `json:"id"`
	RequestType          int64              `json:"request_type"`
	EntityType           int64              `json:"entity_type"`
	EntityID             int64              `json:"entity_id"`
	RequestedBy          int64              `json:"requested_by"`
	Status               int64              `json:"status"`
	CreatedAt            time.Time          `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	RefNo                string             `json:"ref_no"`
	Type                 string             `json:"type"`
	RequestID            int64              `json:"request_id"`
	RequestsDataJson     []byte             `json:"requests_data_json"`
	RequestID_2          int64              `json:"request_id_2"`
	ApprovalsHistoryJson []byte             `json:"approvals_history_json"`
	Remarks              string             `json:"remarks"`
	Department           string             `json:"department"`
}

func (q *Queries) GetRequestByID(ctx context.Context, arg GetRequestByIDParams) (GetRequestByIDRow, error) {
	row := q.db.QueryRow(ctx, getRequestByID, arg.RequestID, arg.UserID)
	var i GetRequestByIDRow
	err := row.Scan(
		&i.ID,
		&i.RequestType,
		&i.EntityType,
		&i.EntityID,
		&i.RequestedBy,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
		&i.Type,
		&i.RequestID,
		&i.RequestsDataJson,
		&i.RequestID_2,
		&i.ApprovalsHistoryJson,
		&i.Remarks,
		&i.Department,
	)
	return i, err
}

const getRequestCountWithEntity = `-- name: GetRequestCountWithEntity :one
SELECT COUNT(rv.id) AS total 
FROM 
    requests_verification rv
WHERE rv.request_type = $1 AND rv.entity_type = $2 AND rv.entity_id = $3 AND rv.status NOT IN ('3','4')
`

type GetRequestCountWithEntityParams struct {
	RequestType int64 `json:"request_type"`
	EntityType  int64 `json:"entity_type"`
	EntityID    int64 `json:"entity_id"`
}

func (q *Queries) GetRequestCountWithEntity(ctx context.Context, arg GetRequestCountWithEntityParams) (int64, error) {
	row := q.db.QueryRow(ctx, getRequestCountWithEntity, arg.RequestType, arg.EntityType, arg.EntityID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getRequestData = `-- name: GetRequestData :many
SELECT id, request_id, field_name, field_value, field_type, created_at FROM request_data WHERE request_id= $1::BIGINT
`

func (q *Queries) GetRequestData(ctx context.Context, requestID int64) ([]RequestDatum, error) {
	rows, err := q.db.Query(ctx, getRequestData, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestDatum
	for rows.Next() {
		var i RequestDatum
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.FieldName,
			&i.FieldValue,
			&i.FieldType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestEntity = `-- name: GetRequestEntity :one
SELECT id, request_type, entity_type, entity_id, requested_by, status, created_at, updated_at, ref_no FROM requests_verification WHERE id= $1::BIGINT
`

func (q *Queries) GetRequestEntity(ctx context.Context, requestID int64) (RequestsVerification, error) {
	row := q.db.QueryRow(ctx, getRequestEntity, requestID)
	var i RequestsVerification
	err := row.Scan(
		&i.ID,
		&i.RequestType,
		&i.EntityType,
		&i.EntityID,
		&i.RequestedBy,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RefNo,
	)
	return i, err
}

const getRequestsByStatus = `-- name: GetRequestsByStatus :many
WITH requestData as (
    SELECT 
        request_data.request_id AS request_id,
        jsonb_agg(
        jsonb_build_object(
			'id', request_data.id,
            'name', request_data.field_name,
            'value', request_data.field_value, 
            'field_type',request_data.field_type
        )) AS requests

    FROM request_data
    GROUP BY  request_data.request_id 

)
SELECT
    a.id, a.request_id, a.workflow_step, a.department, a.approved_by, a.status, a.remarks, a.files, a.required_fields, a.updated_at, a.user_ids,
    rv.id, rv.request_type, rv.entity_type, rv.entity_id, rv.requested_by, rv.status, rv.created_at, rv.updated_at, rv.ref_no, 
    requestData.requests,
    requests_type.type
FROM
    approvals a
INNER JOIN requests_verification rv ON rv.id = a.request_id
INNER JOIN requests_type ON requests_type.id=rv.request_type
JOIN requestData ON requestData.request_id=a.request_id
WHERE
     a.status = ANY( $1::BIGINT[])  AND $2::BIGINT =ANY(a.user_ids)
ORDER BY a.id DESC
LIMIT
    $4 OFFSET $3
`

type GetRequestsByStatusParams struct {
	Statuses []int64     `json:"statuses"`
	UserID   int64       `json:"user_id"`
	Offset   pgtype.Int4 `json:"offset"`
	Limit    pgtype.Int4 `json:"limit"`
}

type GetRequestsByStatusRow struct {
	Approval             Approval             `json:"approval"`
	RequestsVerification RequestsVerification `json:"requests_verification"`
	Requests             []byte               `json:"requests"`
	Type                 string               `json:"type"`
}

// INNER JOIN workflows ON a.workflow_step=workflows.id AND @user_id::BIGINT =ANY(workflows.user_ids)
func (q *Queries) GetRequestsByStatus(ctx context.Context, arg GetRequestsByStatusParams) ([]GetRequestsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getRequestsByStatus,
		arg.Statuses,
		arg.UserID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestsByStatusRow
	for rows.Next() {
		var i GetRequestsByStatusRow
		if err := rows.Scan(
			&i.Approval.ID,
			&i.Approval.RequestID,
			&i.Approval.WorkflowStep,
			&i.Approval.Department,
			&i.Approval.ApprovedBy,
			&i.Approval.Status,
			&i.Approval.Remarks,
			&i.Approval.Files,
			&i.Approval.RequiredFields,
			&i.Approval.UpdatedAt,
			&i.Approval.UserIds,
			&i.RequestsVerification.ID,
			&i.RequestsVerification.RequestType,
			&i.RequestsVerification.EntityType,
			&i.RequestsVerification.EntityID,
			&i.RequestsVerification.RequestedBy,
			&i.RequestsVerification.Status,
			&i.RequestsVerification.CreatedAt,
			&i.RequestsVerification.UpdatedAt,
			&i.RequestsVerification.RefNo,
			&i.Requests,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestsForUser = `-- name: GetRequestsForUser :many
SELECT rv.id, rv.request_type, rv.entity_type, rv.entity_id, rv.requested_by, rv.status, rv.created_at, rv.updated_at, rv.ref_no, rt."type"
FROM 
	requests_verification rv 
INNER JOIN 
	requests_type rt ON rv.request_type=rt.id 
WHERE rv.status= ANY( $1::BIGINT[]) AND rv.requested_by = $2::BIGINT 
ORDER BY rv.updated_at DESC 
LIMIT $4
OFFSET $3
`

type GetRequestsForUserParams struct {
	Status []int64     `json:"status"`
	UserID int64       `json:"user_id"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetRequestsForUserRow struct {
	ID          int64              `json:"id"`
	RequestType int64              `json:"request_type"`
	EntityType  int64              `json:"entity_type"`
	EntityID    int64              `json:"entity_id"`
	RequestedBy int64              `json:"requested_by"`
	Status      int64              `json:"status"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	RefNo       string             `json:"ref_no"`
	Type        string             `json:"type"`
}

func (q *Queries) GetRequestsForUser(ctx context.Context, arg GetRequestsForUserParams) ([]GetRequestsForUserRow, error) {
	rows, err := q.db.Query(ctx, getRequestsForUser,
		arg.Status,
		arg.UserID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestsForUserRow
	for rows.Next() {
		var i GetRequestsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.RequestType,
			&i.EntityType,
			&i.EntityID,
			&i.RequestedBy,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefNo,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestsUserCount = `-- name: GetRequestsUserCount :one
SELECT COUNT(*)
FROM 
	requests_verification rv 
INNER JOIN 
	requests_type rt ON rv.request_type=rt.id 
WHERE rv.status= ANY( $1::BIGINT[]) AND rv.requested_by = $2::BIGINT
`

type GetRequestsUserCountParams struct {
	Status []int64 `json:"status"`
	UserID int64   `json:"user_id"`
}

func (q *Queries) GetRequestsUserCount(ctx context.Context, arg GetRequestsUserCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getRequestsUserCount, arg.Status, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRequiredFieldsForRejectedRequest = `-- name: GetRequiredFieldsForRejectedRequest :many
SELECT 
    rd.id, rd.request_id, rd.field_name, rd.field_value, rd.field_type, rd.created_at
FROM 
    approvals a
JOIN 
    LATERAL UNNEST(a.required_fields) AS rf(request_id)
    ON true
JOIN 
    request_data rd
    ON rd.id = rf.request_id
WHERE 
    a.id = $1::BIGINT
`

func (q *Queries) GetRequiredFieldsForRejectedRequest(ctx context.Context, approvalID int64) ([]RequestDatum, error) {
	rows, err := q.db.Query(ctx, getRequiredFieldsForRejectedRequest, approvalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RequestDatum
	for rows.Next() {
		var i RequestDatum
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.FieldName,
			&i.FieldValue,
			&i.FieldType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTheStepForWorkFlow = `-- name: GetTheStepForWorkFlow :one
SELECT step
FROM 
    workflows
WHERE id=$1
`

func (q *Queries) GetTheStepForWorkFlow(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getTheStepForWorkFlow, id)
	var step int64
	err := row.Scan(&step)
	return step, err
}

const isEligibleForRequestResponse = `-- name: IsEligibleForRequestResponse :one
SELECT true::BOOLEAN
FROM 
	approvals
WHERE id= $1::BIGINT AND $2::BIGINT=ANY(user_ids)
`

type IsEligibleForRequestResponseParams struct {
	ApprovalID int64 `json:"approval_id"`
	UserID     int64 `json:"user_id"`
}

// INNER JOIN workflows ON workflows.id=approvals.workflow_step AND @user_id::BIGINT =ANY(workflows.user_ids)
func (q *Queries) IsEligibleForRequestResponse(ctx context.Context, arg IsEligibleForRequestResponseParams) (bool, error) {
	row := q.db.QueryRow(ctx, isEligibleForRequestResponse, arg.ApprovalID, arg.UserID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const isRequestActiveOrValid = `-- name: IsRequestActiveOrValid :one
SELECT
    TRUE :: BOOLEAN
FROM
    requests_verification rv
INNER JOIN request_data rd_start ON
    rd_start.request_id = rv.id
    AND rd_start.field_name = $1 :: VARCHAR
    AND rd_start.field_type = $2 :: VARCHAR
INNER JOIN request_data rd_end ON
    rd_end.request_id = rv.id
    AND rd_end.field_name = $3 :: VARCHAR
    AND rd_end.field_type = $2 :: VARCHAR
WHERE
    rv.entity_type = $4 :: BIGINT
    AND rv.entity_id = $5 :: BIGINT
    AND rv.request_type = $6 :: BIGINT
    AND (
        rv.status IN ($7 :: BIGINT, $8 :: BIGINT)
        OR (
            NOW() BETWEEN CAST(rd_start.field_value AS TIMESTAMP) AND CAST(rd_end.field_value AS TIMESTAMP)
            AND rv.status = $9 :: BIGINT
        )
    )
`

type IsRequestActiveOrValidParams struct {
	StartDateName    string `json:"start_date_name"`
	DataFiledType    string `json:"data_filed_type"`
	EndDateName      string `json:"end_date_name"`
	EntityTypeID     int64  `json:"entity_type_id"`
	EntityID         int64  `json:"entity_id"`
	RequestType      int64  `json:"request_type"`
	PendingStatus    int64  `json:"pending_status"`
	ProcessingStatus int64  `json:"processing_status"`
	ApprovedStatus   int64  `json:"approved_status"`
}

func (q *Queries) IsRequestActiveOrValid(ctx context.Context, arg IsRequestActiveOrValidParams) (bool, error) {
	row := q.db.QueryRow(ctx, isRequestActiveOrValid,
		arg.StartDateName,
		arg.DataFiledType,
		arg.EndDateName,
		arg.EntityTypeID,
		arg.EntityID,
		arg.RequestType,
		arg.PendingStatus,
		arg.ProcessingStatus,
		arg.ApprovedStatus,
	)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const lastStepForRequestType = `-- name: LastStepForRequestType :one
SELECT MAX(workflows.step)::BIGINT
FROM 
    workflows
WHERE workflows.request_type= (SELECT requests_verification.request_type FROM requests_verification WHERE requests_verification.id= $1::BIGINT)
`

func (q *Queries) LastStepForRequestType(ctx context.Context, requestID int64) (int64, error) {
	row := q.db.QueryRow(ctx, lastStepForRequestType, requestID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const retrieveApprovedExclusiveWithData = `-- name: RetrieveApprovedExclusiveWithData :one
SELECT rv.id,rd_start.field_name,rd_start.field_value,rd_end.field_name,rd_end.field_value
FROM
    requests_verification rv
    INNER JOIN request_data rd_start ON rd_start.request_id = rv.id
    AND rd_start.field_name = $1 :: VARCHAR
    AND rd_start.field_type = $2 :: VARCHAR
    INNER JOIN request_data rd_end ON rd_end.request_id = rv.id
    AND rd_end.field_name = $3 :: VARCHAR
    AND rd_end.field_type = $2 :: VARCHAR
WHERE
    rv.status = $4 :: BIGINT
    AND rv.entity_type = $5 :: BIGINT
    AND rv.entity_id = $6 :: BIGINT
    AND rv.request_type = $7 :: BIGINT
    AND NOW() BETWEEN CAST(rd_start.field_value AS TIMESTAMP)
    AND CAST(rd_end.field_value AS TIMESTAMP)
`

type RetrieveApprovedExclusiveWithDataParams struct {
	StartDateName  string `json:"start_date_name"`
	DataFiledType  string `json:"data_filed_type"`
	EndDateName    string `json:"end_date_name"`
	ApprovedStatus int64  `json:"approved_status"`
	EntityTypeID   int64  `json:"entity_type_id"`
	EntityID       int64  `json:"entity_id"`
	RequestType    int64  `json:"request_type"`
}

type RetrieveApprovedExclusiveWithDataRow struct {
	ID           int64  `json:"id"`
	FieldName    string `json:"field_name"`
	FieldValue   string `json:"field_value"`
	FieldName_2  string `json:"field_name_2"`
	FieldValue_2 string `json:"field_value_2"`
}

func (q *Queries) RetrieveApprovedExclusiveWithData(ctx context.Context, arg RetrieveApprovedExclusiveWithDataParams) (RetrieveApprovedExclusiveWithDataRow, error) {
	row := q.db.QueryRow(ctx, retrieveApprovedExclusiveWithData,
		arg.StartDateName,
		arg.DataFiledType,
		arg.EndDateName,
		arg.ApprovedStatus,
		arg.EntityTypeID,
		arg.EntityID,
		arg.RequestType,
	)
	var i RetrieveApprovedExclusiveWithDataRow
	err := row.Scan(
		&i.ID,
		&i.FieldName,
		&i.FieldValue,
		&i.FieldName_2,
		&i.FieldValue_2,
	)
	return i, err
}

const updateApprovalStatus = `-- name: UpdateApprovalStatus :one
UPDATE 
	approvals
SET 
	status=$1, 
	remarks=$2,
	files=$3, 
	updated_at=$4, 
	required_fields=$5, 
    approved_by=$6
FROM workflows 
WHERE 
	approvals.id= $7::BIGINT AND workflows.id=approvals.workflow_step
RETURNING workflows.step
`

type UpdateApprovalStatusParams struct {
	Status         int64              `json:"status"`
	Remarks        string             `json:"remarks"`
	Files          []byte             `json:"files"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	RequiredFields []int64            `json:"required_fields"`
	ApprovedBy     pgtype.Int8        `json:"approved_by"`
	ApprovalID     int64              `json:"approval_id"`
}

func (q *Queries) UpdateApprovalStatus(ctx context.Context, arg UpdateApprovalStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateApprovalStatus,
		arg.Status,
		arg.Remarks,
		arg.Files,
		arg.UpdatedAt,
		arg.RequiredFields,
		arg.ApprovedBy,
		arg.ApprovalID,
	)
	var step int64
	err := row.Scan(&step)
	return step, err
}

const updateRequestData = `-- name: UpdateRequestData :exec
WITH request AS (
    SELECT jsonb_array_elements( $1 ::JSONB) AS data
)
UPDATE request_data
SET field_value = request.data->>'value'::VARCHAR
FROM request
WHERE request_data.id = (request.data->>'id')::BIGINT
`

func (q *Queries) UpdateRequestData(ctx context.Context, data []byte) error {
	_, err := q.db.Exec(ctx, updateRequestData, data)
	return err
}

const updateStatusRequestsVerification = `-- name: UpdateStatusRequestsVerification :exec
UPDATE 
    requests_verification
SET 
    status=$2, 
    updated_at=$3
WHERE id=$1 AND requested_by=$4
`

type UpdateStatusRequestsVerificationParams struct {
	ID          int64              `json:"id"`
	Status      int64              `json:"status"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	RequestedBy int64              `json:"requested_by"`
}

func (q *Queries) UpdateStatusRequestsVerification(ctx context.Context, arg UpdateStatusRequestsVerificationParams) error {
	_, err := q.db.Exec(ctx, updateStatusRequestsVerification,
		arg.ID,
		arg.Status,
		arg.UpdatedAt,
		arg.RequestedBy,
	)
	return err
}
