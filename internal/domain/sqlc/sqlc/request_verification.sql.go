// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: request_verification.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRequestType = `-- name: CreateRequestType :one
INSERT INTO "requests_type" ("type", "status", "created_at", "updated_at")
VALUES ($1, $2, now(), $3)
RETURNING "id", "type", "status", "created_at", "updated_at"
`

type CreateRequestTypeParams struct {
	Type      string             `json:"type"`
	Status    bool               `json:"status"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateRequestType(ctx context.Context, arg CreateRequestTypeParams) (RequestsType, error) {
	row := q.db.QueryRow(ctx, createRequestType, arg.Type, arg.Status, arg.UpdatedAt)
	var i RequestsType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWorkflow = `-- name: CreateWorkflow :one
INSERT INTO "workflows" ("request_type", "step", "department", "created_at","user_ids")
VALUES ($1, $2, $3, now(),$4)
RETURNING "id", "request_type", "step", "department", "created_at","user_ids"
`

type CreateWorkflowParams struct {
	RequestType int64   `json:"request_type"`
	Step        int64   `json:"step"`
	Department  int64   `json:"department"`
	UserIds     []int64 `json:"user_ids"`
}

func (q *Queries) CreateWorkflow(ctx context.Context, arg CreateWorkflowParams) (Workflow, error) {
	row := q.db.QueryRow(ctx, createWorkflow,
		arg.RequestType,
		arg.Step,
		arg.Department,
		arg.UserIds,
	)
	var i Workflow
	err := row.Scan(
		&i.ID,
		&i.RequestType,
		&i.Step,
		&i.Department,
		&i.CreatedAt,
		&i.UserIds,
	)
	return i, err
}

const deleteRequestType = `-- name: DeleteRequestType :exec
DELETE FROM "requests_type"
WHERE "id" = $1
`

func (q *Queries) DeleteRequestType(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRequestType, id)
	return err
}

const deleteWorkflow = `-- name: DeleteWorkflow :exec
DELETE FROM "workflows"
WHERE "id" = $1
`

func (q *Queries) DeleteWorkflow(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteWorkflow, id)
	return err
}

const getAqaryManagementByDepartment = `-- name: GetAqaryManagementByDepartment :many
SELECT
    users.id,
    users.username
FROM
    roles
    INNER JOIN users ON users.status != 6
    AND users.user_types_id = $1 :: BIGINT
    AND users.roles_id = roles.id
    AND (
        $2 :: VARCHAR = ''
        OR users.username ILIKE '%' || $2 :: VARCHAR || '%'
    )
WHERE
    roles.department_id = $3 :: BIGINT
ORDER BY
    users.id
LIMIT
    $5 OFFSET $4
`

type GetAqaryManagementByDepartmentParams struct {
	AqaryMangmentID int64       `json:"aqary_mangment_id"`
	Username        string      `json:"username"`
	DepartmentID    int64       `json:"department_id"`
	Offset          pgtype.Int4 `json:"offset"`
	Limit           pgtype.Int4 `json:"limit"`
}

type GetAqaryManagementByDepartmentRow struct {
	ID       int64  `json:"id"`
	Username string `json:"username"`
}

func (q *Queries) GetAqaryManagementByDepartment(ctx context.Context, arg GetAqaryManagementByDepartmentParams) ([]GetAqaryManagementByDepartmentRow, error) {
	rows, err := q.db.Query(ctx, getAqaryManagementByDepartment,
		arg.AqaryMangmentID,
		arg.Username,
		arg.DepartmentID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAqaryManagementByDepartmentRow
	for rows.Next() {
		var i GetAqaryManagementByDepartmentRow
		if err := rows.Scan(&i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAqaryManagementDepartment = `-- name: GetAqaryManagementDepartment :many
SELECT
   distinct department.id,
    department.department,
    department.department_ar
FROM
    users
    INNER JOIN roles ON roles.id = users.roles_id
    INNER JOIN department ON department.id = roles.department_id
    AND (
        $1 :: VARCHAR = ''
        OR department.department ILIKE '%' || $1 :: VARCHAR || '%'
        OR department.department_ar ILIKE '%' || $1 :: VARCHAR || '%'
    )
WHERE
    users.status != 6
    AND users.user_types_id = $2 :: BIGINT
ORDER BY
    department.id
LIMIT
    $4 OFFSET $3
`

type GetAqaryManagementDepartmentParams struct {
	Department      string      `json:"department"`
	AqaryMangmentID int64       `json:"aqary_mangment_id"`
	Offset          pgtype.Int4 `json:"offset"`
	Limit           pgtype.Int4 `json:"limit"`
}

type GetAqaryManagementDepartmentRow struct {
	ID           int64       `json:"id"`
	Department   string      `json:"department"`
	DepartmentAr pgtype.Text `json:"department_ar"`
}

func (q *Queries) GetAqaryManagementDepartment(ctx context.Context, arg GetAqaryManagementDepartmentParams) ([]GetAqaryManagementDepartmentRow, error) {
	rows, err := q.db.Query(ctx, getAqaryManagementDepartment,
		arg.Department,
		arg.AqaryMangmentID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAqaryManagementDepartmentRow
	for rows.Next() {
		var i GetAqaryManagementDepartmentRow
		if err := rows.Scan(&i.ID, &i.Department, &i.DepartmentAr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestTypeByID = `-- name: GetRequestTypeByID :one
SELECT "id", "type", "status", "created_at", "updated_at"
FROM "requests_type"
WHERE "id" = $1
`

func (q *Queries) GetRequestTypeByID(ctx context.Context, id int64) (RequestsType, error) {
	row := q.db.QueryRow(ctx, getRequestTypeByID, id)
	var i RequestsType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkflowByID = `-- name: GetWorkflowByID :one
SELECT 
    w.id,
    rt.id AS request_type_id,
    rt.type AS request_type,
    d.id AS department_id,
    d.department AS department,
    w.step,
    w.created_at,
    w.user_ids,
    (
        SELECT 
            json_agg(
                json_build_object(
                    'id', users.id,
                    'name', profiles.first_name||' '||profiles.last_name
                )
            )
        FROM users 
        JOIN profiles ON profiles.users_id=users.id
        JOIN LATERAL UNNEST(w.user_ids) AS user_id ON users.id = user_id
    ) AS workflow_users
FROM workflows w
LEFT JOIN requests_type rt ON w.request_type = rt.id
LEFT JOIN department d ON w.department = d.id
WHERE w.id = $1
`

type GetWorkflowByIDRow struct {
	ID            int64       `json:"id"`
	RequestTypeID pgtype.Int8 `json:"request_type_id"`
	RequestType   pgtype.Text `json:"request_type"`
	DepartmentID  pgtype.Int8 `json:"department_id"`
	Department    pgtype.Text `json:"department"`
	Step          int64       `json:"step"`
	CreatedAt     time.Time   `json:"created_at"`
	UserIds       []int64     `json:"user_ids"`
	WorkflowUsers []byte      `json:"workflow_users"`
}

func (q *Queries) GetWorkflowByID(ctx context.Context, id int64) (GetWorkflowByIDRow, error) {
	row := q.db.QueryRow(ctx, getWorkflowByID, id)
	var i GetWorkflowByIDRow
	err := row.Scan(
		&i.ID,
		&i.RequestTypeID,
		&i.RequestType,
		&i.DepartmentID,
		&i.Department,
		&i.Step,
		&i.CreatedAt,
		&i.UserIds,
		&i.WorkflowUsers,
	)
	return i, err
}

const listRequestTypes = `-- name: ListRequestTypes :many
WITH total_count_cte AS (
    SELECT COUNT(*) AS total_count
    FROM "requests_type"
)
SELECT 
    rt."id",
    rt."type",
    rt."status",
    rt."created_at",
    rt."updated_at",
    (SELECT total_count FROM total_count_cte) AS total_count
FROM "requests_type" rt
ORDER BY rt."created_at" DESC
LIMIT COALESCE(NULLIF($1, 0), NULL) OFFSET COALESCE(NULLIF($2, 0), 0)
`

type ListRequestTypesParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

type ListRequestTypesRow struct {
	ID         int64              `json:"id"`
	Type       string             `json:"type"`
	Status     bool               `json:"status"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	TotalCount int64              `json:"total_count"`
}

func (q *Queries) ListRequestTypes(ctx context.Context, arg ListRequestTypesParams) ([]ListRequestTypesRow, error) {
	rows, err := q.db.Query(ctx, listRequestTypes, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRequestTypesRow
	for rows.Next() {
		var i ListRequestTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflows = `-- name: ListWorkflows :many
WITH total_count_cte AS (
    SELECT
        COUNT(*) AS total_count
    FROM
        "workflows"
)
SELECT
    w.id,
    rt.id AS request_type_id,
    rt.type AS request_type,
    d.id AS department_id,
    d.department AS department,
    w.step,
    w.created_at,
    (
        SELECT
            total_count
        FROM
            total_count_cte
    ) AS total_count,
    (
                SELECT
                    jsonb_agg(
                        jsonb_build_object(
                            'id',
                            users.id,
                            'name',
                            profiles.first_name||' '||profiles.last_name
                        )
                    ) AS aqary_management
                FROM
                    users
                INNER JOIN profiles ON profiles.users_id=users.id
                WHERE
                    users.id = ANY(w.user_ids)
    )
FROM
    workflows w
    LEFT JOIN "requests_type" rt ON w.request_type = rt.id
    LEFT JOIN department d ON w.department = d.id
ORDER BY
    w."created_at" DESC
LIMIT
    COALESCE(NULLIF($1, 0), NULL) OFFSET COALESCE(NULLIF($2, 0), 0)
`

type ListWorkflowsParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

type ListWorkflowsRow struct {
	ID              int64       `json:"id"`
	RequestTypeID   pgtype.Int8 `json:"request_type_id"`
	RequestType     pgtype.Text `json:"request_type"`
	DepartmentID    pgtype.Int8 `json:"department_id"`
	Department      pgtype.Text `json:"department"`
	Step            int64       `json:"step"`
	CreatedAt       time.Time   `json:"created_at"`
	TotalCount      int64       `json:"total_count"`
	AqaryManagement []byte      `json:"aqary_management"`
}

func (q *Queries) ListWorkflows(ctx context.Context, arg ListWorkflowsParams) ([]ListWorkflowsRow, error) {
	rows, err := q.db.Query(ctx, listWorkflows, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkflowsRow
	for rows.Next() {
		var i ListWorkflowsRow
		if err := rows.Scan(
			&i.ID,
			&i.RequestTypeID,
			&i.RequestType,
			&i.DepartmentID,
			&i.Department,
			&i.Step,
			&i.CreatedAt,
			&i.TotalCount,
			&i.AqaryManagement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequestType = `-- name: UpdateRequestType :one
UPDATE "requests_type"
SET "type" = $2, "status" = $3, "updated_at" = now()
WHERE "id" = $1
RETURNING "id", "type", "status", "created_at", "updated_at"
`

type UpdateRequestTypeParams struct {
	ID     int64  `json:"id"`
	Type   string `json:"type"`
	Status bool   `json:"status"`
}

func (q *Queries) UpdateRequestType(ctx context.Context, arg UpdateRequestTypeParams) (RequestsType, error) {
	row := q.db.QueryRow(ctx, updateRequestType, arg.ID, arg.Type, arg.Status)
	var i RequestsType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWorkflow = `-- name: UpdateWorkflow :one
UPDATE "workflows"
SET "request_type" = $2, "step" = $3, "department" = $4, "user_ids" = $5
WHERE "id" = $1
RETURNING "id", "user_ids", "request_type", "step", "department", "created_at"
`

type UpdateWorkflowParams struct {
	ID          int64   `json:"id"`
	RequestType int64   `json:"request_type"`
	Step        int64   `json:"step"`
	Department  int64   `json:"department"`
	UserIds     []int64 `json:"user_ids"`
}

type UpdateWorkflowRow struct {
	ID          int64     `json:"id"`
	UserIds     []int64   `json:"user_ids"`
	RequestType int64     `json:"request_type"`
	Step        int64     `json:"step"`
	Department  int64     `json:"department"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) UpdateWorkflow(ctx context.Context, arg UpdateWorkflowParams) (UpdateWorkflowRow, error) {
	row := q.db.QueryRow(ctx, updateWorkflow,
		arg.ID,
		arg.RequestType,
		arg.Step,
		arg.Department,
		arg.UserIds,
	)
	var i UpdateWorkflowRow
	err := row.Scan(
		&i.ID,
		&i.UserIds,
		&i.RequestType,
		&i.Step,
		&i.Department,
		&i.CreatedAt,
	)
	return i, err
}
