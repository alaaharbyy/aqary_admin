// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: contact.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createContact = `-- name: CreateContact :one
INSERT INTO contacts (
    ref_no,
    salutation,
    firstname,
    lastname,
    status,
    created_by,
    created_at,
    updated_at,
    updated_by,
    entity_id,
    entity_type_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, ref_no, salutation, firstname, lastname, status, created_by, created_at, updated_at, updated_by, entity_id, entity_type_id
`

type CreateContactParams struct {
	RefNo        string      `json:"ref_no"`
	Salutation   string      `json:"salutation"`
	Firstname    string      `json:"firstname"`
	Lastname     string      `json:"lastname"`
	Status       int64       `json:"status"`
	CreatedBy    int64       `json:"created_by"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	UpdatedBy    pgtype.Int8 `json:"updated_by"`
	EntityID     int64       `json:"entity_id"`
	EntityTypeID int64       `json:"entity_type_id"`
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (Contact, error) {
	row := q.db.QueryRow(ctx, createContact,
		arg.RefNo,
		arg.Salutation,
		arg.Firstname,
		arg.Lastname,
		arg.Status,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.EntityID,
		arg.EntityTypeID,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Salutation,
		&i.Firstname,
		&i.Lastname,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.EntityID,
		&i.EntityTypeID,
	)
	return i, err
}

const createContactShareableDetails = `-- name: CreateContactShareableDetails :one
INSERT INTO shareable_contact_details (
    contacts_id,
    mobile,
    mobile_share,
    mobile2,
    mobile2_share,
    landline,
    landline_share,
    fax,
    fax_share,
    email,
    email_share,
    second_email,
    second_email_share,
    added_by,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16
) RETURNING id, contacts_id, mobile, mobile_share, mobile2, mobile2_share, landline, landline_share, fax, fax_share, email, email_share, second_email, second_email_share, added_by, created_at, updated_at
`

type CreateContactShareableDetailsParams struct {
	ContactsID       int64     `json:"contacts_id"`
	Mobile           string    `json:"mobile"`
	MobileShare      bool      `json:"mobile_share"`
	Mobile2          string    `json:"mobile2"`
	Mobile2Share     bool      `json:"mobile2_share"`
	Landline         string    `json:"landline"`
	LandlineShare    bool      `json:"landline_share"`
	Fax              string    `json:"fax"`
	FaxShare         bool      `json:"fax_share"`
	Email            string    `json:"email"`
	EmailShare       bool      `json:"email_share"`
	SecondEmail      string    `json:"second_email"`
	SecondEmailShare bool      `json:"second_email_share"`
	AddedBy          int64     `json:"added_by"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

func (q *Queries) CreateContactShareableDetails(ctx context.Context, arg CreateContactShareableDetailsParams) (ShareableContactDetail, error) {
	row := q.db.QueryRow(ctx, createContactShareableDetails,
		arg.ContactsID,
		arg.Mobile,
		arg.MobileShare,
		arg.Mobile2,
		arg.Mobile2Share,
		arg.Landline,
		arg.LandlineShare,
		arg.Fax,
		arg.FaxShare,
		arg.Email,
		arg.EmailShare,
		arg.SecondEmail,
		arg.SecondEmailShare,
		arg.AddedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ShareableContactDetail
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.Mobile,
		&i.MobileShare,
		&i.Mobile2,
		&i.Mobile2Share,
		&i.Landline,
		&i.LandlineShare,
		&i.Fax,
		&i.FaxShare,
		&i.Email,
		&i.EmailShare,
		&i.SecondEmail,
		&i.SecondEmailShare,
		&i.AddedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createContactsAddress = `-- name: CreateContactsAddress :one
INSERT INTO contacts_address (
    contacts_id,
    address_type_id,
    address1,
    address2,
    countries_id,
    states_id,
    cities_id,
    community_id,
    sub_community_id,
    postal_code
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) RETURNING id, contacts_id, address_type_id, address1, address2, countries_id, states_id, cities_id, community_id, sub_community_id, postal_code
`

type CreateContactsAddressParams struct {
	ContactsID     int64       `json:"contacts_id"`
	AddressTypeID  int64       `json:"address_type_id"`
	Address1       string      `json:"address1"`
	Address2       string      `json:"address2"`
	CountriesID    int64       `json:"countries_id"`
	StatesID       pgtype.Int8 `json:"states_id"`
	CitiesID       pgtype.Int8 `json:"cities_id"`
	CommunityID    pgtype.Int8 `json:"community_id"`
	SubCommunityID pgtype.Int8 `json:"sub_community_id"`
	PostalCode     int64       `json:"postal_code"`
}

func (q *Queries) CreateContactsAddress(ctx context.Context, arg CreateContactsAddressParams) (ContactsAddress, error) {
	row := q.db.QueryRow(ctx, createContactsAddress,
		arg.ContactsID,
		arg.AddressTypeID,
		arg.Address1,
		arg.Address2,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.PostalCode,
	)
	var i ContactsAddress
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.AddressTypeID,
		&i.Address1,
		&i.Address2,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubCommunityID,
		&i.PostalCode,
	)
	return i, err
}

const createContactsDocument = `-- name: CreateContactsDocument :one
INSERT INTO contacts_document (
    contacts_id,
    document_category_id, 
    expiry_date,
    is_private,  
    document_url,
    created_at,
    description,
    updated_at,
    created_by,
    title
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) RETURNING id, contacts_id, document_category_id, expiry_date, is_private, document_url, created_at, created_by, description, updated_at, title
`

type CreateContactsDocumentParams struct {
	ContactsID         pgtype.Int8 `json:"contacts_id"`
	DocumentCategoryID int64       `json:"document_category_id"`
	ExpiryDate         time.Time   `json:"expiry_date"`
	IsPrivate          bool        `json:"is_private"`
	DocumentUrl        string      `json:"document_url"`
	CreatedAt          time.Time   `json:"created_at"`
	Description        pgtype.Text `json:"description"`
	UpdatedAt          time.Time   `json:"updated_at"`
	CreatedBy          int64       `json:"created_by"`
	Title              string      `json:"title"`
}

func (q *Queries) CreateContactsDocument(ctx context.Context, arg CreateContactsDocumentParams) (ContactsDocument, error) {
	row := q.db.QueryRow(ctx, createContactsDocument,
		arg.ContactsID,
		arg.DocumentCategoryID,
		arg.ExpiryDate,
		arg.IsPrivate,
		arg.DocumentUrl,
		arg.CreatedAt,
		arg.Description,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.Title,
	)
	var i ContactsDocument
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.DocumentCategoryID,
		&i.ExpiryDate,
		&i.IsPrivate,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Description,
		&i.UpdatedAt,
		&i.Title,
	)
	return i, err
}

const createContactsIndividualDetail = `-- name: CreateContactsIndividualDetail :one
INSERT INTO contacts_individual_details (
    contacts_id,
    comapanies_id,
    company_category,
    is_branch,
    date_of_birth,
    professions_id,
    gender,
    marital_status,
    nationality,
    id_type,
    id_number,
    id_country_id,
    id_issued_date,
    id_expiry_date,
    passport_number,
    passport_country_id,
    passport_issued_date,
    passport_expiry_date,
    interests
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19
) RETURNING id, contacts_id, comapanies_id, company_category, is_branch, date_of_birth, professions_id, gender, marital_status, nationality, id_type, id_number, id_country_id, id_issued_date, id_expiry_date, passport_number, passport_country_id, passport_issued_date, passport_expiry_date, interests
`

type CreateContactsIndividualDetailParams struct {
	ContactsID         int64              `json:"contacts_id"`
	ComapaniesID       int64              `json:"comapanies_id"`
	CompanyCategory    int64              `json:"company_category"`
	IsBranch           pgtype.Bool        `json:"is_branch"`
	DateOfBirth        pgtype.Timestamptz `json:"date_of_birth"`
	ProfessionsID      pgtype.Int8        `json:"professions_id"`
	Gender             pgtype.Text        `json:"gender"`
	MaritalStatus      pgtype.Int8        `json:"marital_status"`
	Nationality        pgtype.Int8        `json:"nationality"`
	IDType             pgtype.Int8        `json:"id_type"`
	IDNumber           pgtype.Text        `json:"id_number"`
	IDCountryID        pgtype.Int8        `json:"id_country_id"`
	IDIssuedDate       pgtype.Timestamptz `json:"id_issued_date"`
	IDExpiryDate       pgtype.Timestamptz `json:"id_expiry_date"`
	PassportNumber     pgtype.Text        `json:"passport_number"`
	PassportCountryID  pgtype.Int8        `json:"passport_country_id"`
	PassportIssuedDate pgtype.Timestamptz `json:"passport_issued_date"`
	PassportExpiryDate pgtype.Timestamptz `json:"passport_expiry_date"`
	Interests          pgtype.Text        `json:"interests"`
}

func (q *Queries) CreateContactsIndividualDetail(ctx context.Context, arg CreateContactsIndividualDetailParams) (ContactsIndividualDetail, error) {
	row := q.db.QueryRow(ctx, createContactsIndividualDetail,
		arg.ContactsID,
		arg.ComapaniesID,
		arg.CompanyCategory,
		arg.IsBranch,
		arg.DateOfBirth,
		arg.ProfessionsID,
		arg.Gender,
		arg.MaritalStatus,
		arg.Nationality,
		arg.IDType,
		arg.IDNumber,
		arg.IDCountryID,
		arg.IDIssuedDate,
		arg.IDExpiryDate,
		arg.PassportNumber,
		arg.PassportCountryID,
		arg.PassportIssuedDate,
		arg.PassportExpiryDate,
		arg.Interests,
	)
	var i ContactsIndividualDetail
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.ComapaniesID,
		&i.CompanyCategory,
		&i.IsBranch,
		&i.DateOfBirth,
		&i.ProfessionsID,
		&i.Gender,
		&i.MaritalStatus,
		&i.Nationality,
		&i.IDType,
		&i.IDNumber,
		&i.IDCountryID,
		&i.IDIssuedDate,
		&i.IDExpiryDate,
		&i.PassportNumber,
		&i.PassportCountryID,
		&i.PassportIssuedDate,
		&i.PassportExpiryDate,
		&i.Interests,
	)
	return i, err
}

const createContactsOtherContact = `-- name: CreateContactsOtherContact :one
INSERT INTO contacts_other_contact (
    contacts_id,
    other_contacts_id,
    date_added,
    relationship
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, contacts_id, relationship, other_contacts_id, date_added
`

type CreateContactsOtherContactParams struct {
	ContactsID      int64     `json:"contacts_id"`
	OtherContactsID int64     `json:"other_contacts_id"`
	DateAdded       time.Time `json:"date_added"`
	Relationship    string    `json:"relationship"`
}

func (q *Queries) CreateContactsOtherContact(ctx context.Context, arg CreateContactsOtherContactParams) (ContactsOtherContact, error) {
	row := q.db.QueryRow(ctx, createContactsOtherContact,
		arg.ContactsID,
		arg.OtherContactsID,
		arg.DateAdded,
		arg.Relationship,
	)
	var i ContactsOtherContact
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.Relationship,
		&i.OtherContactsID,
		&i.DateAdded,
	)
	return i, err
}

const createContactsTransaction = `-- name: CreateContactsTransaction :one
INSERT INTO contacts_transaction (
    contacts_id,
    leads_id,
    contact_type,
    category,
    property_ref_no, 
    unit_ref_no,
    transaction_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, contacts_id, leads_id, contact_type, category, property_ref_no, unit_ref_no, transaction_date
`

type CreateContactsTransactionParams struct {
	ContactsID      pgtype.Int8 `json:"contacts_id"`
	LeadsID         int64       `json:"leads_id"`
	ContactType     int64       `json:"contact_type"`
	Category        string      `json:"category"`
	PropertyRefNo   string      `json:"property_ref_no"`
	UnitRefNo       string      `json:"unit_ref_no"`
	TransactionDate time.Time   `json:"transaction_date"`
}

func (q *Queries) CreateContactsTransaction(ctx context.Context, arg CreateContactsTransactionParams) (ContactsTransaction, error) {
	row := q.db.QueryRow(ctx, createContactsTransaction,
		arg.ContactsID,
		arg.LeadsID,
		arg.ContactType,
		arg.Category,
		arg.PropertyRefNo,
		arg.UnitRefNo,
		arg.TransactionDate,
	)
	var i ContactsTransaction
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.LeadsID,
		&i.ContactType,
		&i.Category,
		&i.PropertyRefNo,
		&i.UnitRefNo,
		&i.TransactionDate,
	)
	return i, err
}

const createIndustry = `-- name: CreateIndustry :one
INSERT INTO "public"."industry" (
    "title",
    "title_ar"
) VALUES (
    $1, $2
)
RETURNING id, title, title_ar
`

type CreateIndustryParams struct {
	Title   string `json:"title"`
	TitleAr string `json:"title_ar"`
}

func (q *Queries) CreateIndustry(ctx context.Context, arg CreateIndustryParams) (Industry, error) {
	row := q.db.QueryRow(ctx, createIndustry, arg.Title, arg.TitleAr)
	var i Industry
	err := row.Scan(&i.ID, &i.Title, &i.TitleAr)
	return i, err
}

const createProfession = `-- name: CreateProfession :one
INSERT INTO "public"."professions" (
    "title",
    "title_ar"
) VALUES (
    $1, $2
)
RETURNING id, title, title_ar
`

type CreateProfessionParams struct {
	Title   string `json:"title"`
	TitleAr string `json:"title_ar"`
}

func (q *Queries) CreateProfession(ctx context.Context, arg CreateProfessionParams) (Profession, error) {
	row := q.db.QueryRow(ctx, createProfession, arg.Title, arg.TitleAr)
	var i Profession
	err := row.Scan(&i.ID, &i.Title, &i.TitleAr)
	return i, err
}

const deleteSingleContactsOtherContact = `-- name: DeleteSingleContactsOtherContact :exec
DELETE FROM contacts_other_contact WHERE id = $1
`

func (q *Queries) DeleteSingleContactsOtherContact(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSingleContactsOtherContact, id)
	return err
}

const editContactsOtherContact = `-- name: EditContactsOtherContact :exec
UPDATE contacts_other_contact
SET
    contacts_id = $2,
    other_contacts_id = $3,
    date_added = $4,
    relationship = $5
WHERE id = $1
RETURNING id, contacts_id, relationship, other_contacts_id, date_added
`

type EditContactsOtherContactParams struct {
	ID              int64     `json:"id"`
	ContactsID      int64     `json:"contacts_id"`
	OtherContactsID int64     `json:"other_contacts_id"`
	DateAdded       time.Time `json:"date_added"`
	Relationship    string    `json:"relationship"`
}

func (q *Queries) EditContactsOtherContact(ctx context.Context, arg EditContactsOtherContactParams) error {
	_, err := q.db.Exec(ctx, editContactsOtherContact,
		arg.ID,
		arg.ContactsID,
		arg.OtherContactsID,
		arg.DateAdded,
		arg.Relationship,
	)
	return err
}

const getActiveContactById = `-- name: GetActiveContactById :one
SELECT id, ref_no, salutation, firstname, lastname, status, created_by, created_at, updated_at, updated_by, entity_id, entity_type_id FROM contacts WHERE status = 2 AND id = $1
`

func (q *Queries) GetActiveContactById(ctx context.Context, id int64) (Contact, error) {
	row := q.db.QueryRow(ctx, getActiveContactById, id)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Salutation,
		&i.Firstname,
		&i.Lastname,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.EntityID,
		&i.EntityTypeID,
	)
	return i, err
}

const getAllActiveContactsByCompanyId = `-- name: GetAllActiveContactsByCompanyId :many


SELECT id,TRIM(CONCAT(firstname,' ',lastname)) AS full_name
FROM contacts
WHERE status = 2 AND ($2::BIGINT = 0 OR (entity_id = $2::BIGINT AND entity_type_id = $1))
`

type GetAllActiveContactsByCompanyIdParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
}

type GetAllActiveContactsByCompanyIdRow struct {
	ID       int64  `json:"id"`
	FullName string `json:"full_name"`
}

// -- name: GetAllContacts :many
// select c.id, c.users_id, c.ref_no, c.contact_category_id, c.salutation, c.name, c.lastname, c.all_languages_id, c.ejari, c.assigned_to, c.shared_with, c.remarks, c.is_blockedlisted, c.is_vip, c.correspondence, c.direct_markerting, c.status, c.created_by, c.contact_platform, c.created_at, c.updated_at, c.updated_by,
//
//	scd.id, scd.contacts_id, scd.mobile, scd.mobile_share, scd.mobile2, scd.mobile2_share, scd.landline, scd.landline_share, scd.fax, scd.fax_share, scd.email, scd.email_share, scd.second_email, scd.second_email_share, scd.added_by, scd.created_at, scd.updated_at,
//	 COALESCE(ra.id, 0) AS ra_id, COALESCE(ra.contacts_id, 0) AS ra_contacts_id, COALESCE(ra.address_type_id, 0) AS ra_address_type_id, COALESCE(ra.address1, '') AS ra_address1, COALESCE(ra.address2, '') AS ra_address2, COALESCE(ra.countries_id, 0) AS ra_countries_id, COALESCE(ra.states_id, 0) AS ra_states_id, COALESCE(ra.cities_id, 0) AS ra_cities_id, COALESCE(ra.community_id, 0) AS ra_community_id, COALESCE(ra.sub_community_id, 0) AS ra_sub_community_id, COALESCE(ra.postal_code, 0) AS ra_postal_code,
//	COALESCE(ca.id, 0) AS ca_id, COALESCE(ca.contacts_id, 0) AS ca_contacts_id, COALESCE(ca.address_type_id, 0) AS ca_address_type_id, COALESCE(ca.address1, '') AS ca_address1, COALESCE(ca.address2, '') AS ca_address2, COALESCE(ca.countries_id, 0) AS ca_countries_id, COALESCE(ca.states_id, 0) AS ca_states_id, COALESCE(ca.cities_id, 0) AS ca_cities_id, COALESCE(ca.community_id, 0) AS ca_community_id, COALESCE(ca.sub_community_id, 0) AS ca_sub_community_id, COALESCE(ca.postal_code, 0) AS ca_postal_code,ccd.id, ccd.contacts_id, ccd.companies_id, ccd.company_category, ccd.is_branch, ccd.no_of_employees, ccd.industry_id, ccd.no_local_business, ccd.retail_category_id, ccd.no_remote_business, ccd.nationality, ccd.license, ccd.issued_date, ccd.expiry_date, ccd.external_id,
//	cid.id, cid.contacts_id, cid.comapanies_id, cid.company_category, cid.is_branch, cid.date_of_birth, cid.professions_id, cid.gender, cid.marital_status, cid.nationality, cid.id_type, cid.id_number, cid.id_country_id, cid.id_issued_date, cid.id_expiry_date, cid.passport_number, cid.passport_country_id, cid.passport_issued_date, cid.passport_expiry_date, cid.interests,
//	cn1.country as resident_country,ci1.city as resident_city,
//	st1."state" as resident_state, com1.community as resident_community,
//	scom1.sub_community as resident_sub_community,
//	cn2.country as company_country,ci2.city as company_city,
//	st2."state" as company_state, com2.community as company_community,
//	scom2.sub_community as company_sub_community,
//	c.id AS contact_id,
//	c.created_by AS contact_created_by,
//	c.updated_by AS contact_updated_by,
//	u_created_by.username AS created_by_username,
//	u_updated_by.username AS updated_by_username,
//	c.all_languages_id AS contact_all_languages_id,
//	COALESCE(languages, '{}') AS languages,
//	c.assigned_to AS contact_assigned_to,
//	COALESCE(assigned_usernames, '{}') AS assigned_usernames,
//	c.shared_with AS contact_shared_with,
//	COALESCE(shared_usernames, '{}') AS shared_usernames,
//	    i.title as company_industry,
//	n1.country as company_nationality,
//	rct.title as company_retail_cateogry,
//	p.title as individual_profession,
//	n2.country as individual_nationality,
//	idci.country as individual_country_id,
//	pci.country as individual_passport_country
//
// FROM "public"."contacts" c
// LEFT JOIN "public"."shareable_contact_details" scd ON c.id = scd.contacts_id
// LEFT JOIN contacts_address ra ON c.id = ra.contacts_id AND ra.address_type_id = 1
// left join countries cn1 on ra.countries_id = cn1.id
// left join cities ci1 on ra.cities_id = ci1.id
// left join states st1 on ra.states_id = st1.id
// left join communities com1 on ra.community_id = com1.id
// LEFT join sub_communities scom1 on ra.sub_community_id = scom1.id
// LEFT JOIN contacts_address ca ON c.id = ca.contacts_id AND ca.address_type_id = 2
// left join countries cn2 on ra.countries_id = cn2.id
// left join cities ci2 on ra.cities_id = ci2.id
// left join states st2 on ra.states_id = st2.id
// left join communities com2 on ra.community_id = com2.id
// LEFT join sub_communities scom2 on ra.sub_community_id = scom2.id
// LEFT JOIN contacts_company_details ccd ON c.id = ccd.contacts_id AND c.contact_category_id = 1
// left join industry i on ccd.industry_id = i.id
// left join countries n1 on ccd.nationality = n1.id
// left join retail_category rct on ccd.retail_category_id = rct.id
// LEFT JOIN contacts_individual_details cid ON c.id = cid.contacts_id AND c.contact_category_id = 2
// left join professions p on cid.professions_id = p.id
// left join countries n2 on cid.nationality = n2.id
// left join countries idci on cid.id_country_id = idci.id
// left join countries pci on cid.passport_country_id = pci.id
//
//	LEFT JOIN "public"."users" u_created_by ON c.created_by = u_created_by.id
//	LEFT JOIN "public"."users" u_updated_by ON c.updated_by = u_updated_by.id
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(al.language)::varchar[] AS languages
//	    FROM unnest(c.all_languages_id) AS lang_id
//	    JOIN "public"."all_languages" al ON lang_id = al.id
//	) AS languages ON TRUE
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(au.username)::varchar[] AS assigned_usernames
//	    FROM unnest(c.assigned_to) AS assigned_id
//	    JOIN "public"."users" au ON assigned_id = au.id
//	) AS assigned_usernames ON TRUE
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(su.username)::varchar[] AS shared_usernames
//	    FROM unnest(c.shared_with) AS shared_id
//	    JOIN "public"."users" su ON shared_id = su.id
//	) AS shared_usernames ON TRUE
//
// WHERE c.status != 5 AND c.status != 6
// ORDER BY c.updated_at DESC LIMIT $1 OFFSET $2;
func (q *Queries) GetAllActiveContactsByCompanyId(ctx context.Context, arg GetAllActiveContactsByCompanyIdParams) ([]GetAllActiveContactsByCompanyIdRow, error) {
	rows, err := q.db.Query(ctx, getAllActiveContactsByCompanyId, arg.EntityTypeID, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllActiveContactsByCompanyIdRow
	for rows.Next() {
		var i GetAllActiveContactsByCompanyIdRow
		if err := rows.Scan(&i.ID, &i.FullName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBrokerCompaniesBranchesWithoutPagination = `-- name: GetAllBrokerCompaniesBranchesWithoutPagination :many
SELECT id, broker_companies_id, company_name, description, logo_url, addresses_id, email, phone_number, whatsapp_number, commercial_license_no, commercial_license_file_url, commercial_license_expiry, rera_no, rera_file_url, rera_expiry, is_verified, website_url, cover_image_url, tag_line, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, twitter_profile_url, no_of_employees, users_id, linkedin_profile_url, bank_account_details_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, rera_registration_date, rera_issue_date, commercial_license_registration_date, commercial_license_issue_date, extra_license_names, extra_license_files, extra_license_nos, extra_license_issue_date, extra_license_expiry_date, youtube_profile_url, orn_license_no, orn_license_file_url, orn_registration_date, orn_license_expiry, created_by, trakhees_permit_no, license_dcci_no, register_no, other_social_media FROM broker_companies_branches
WHERE status != 5 AND status != 6 ORDER BY id
`

func (q *Queries) GetAllBrokerCompaniesBranchesWithoutPagination(ctx context.Context) ([]BrokerCompaniesBranch, error) {
	rows, err := q.db.Query(ctx, getAllBrokerCompaniesBranchesWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BrokerCompaniesBranch
	for rows.Next() {
		var i BrokerCompaniesBranch
		if err := rows.Scan(
			&i.ID,
			&i.BrokerCompaniesID,
			&i.CompanyName,
			&i.Description,
			&i.LogoUrl,
			&i.AddressesID,
			&i.Email,
			&i.PhoneNumber,
			&i.WhatsappNumber,
			&i.CommercialLicenseNo,
			&i.CommercialLicenseFileUrl,
			&i.CommercialLicenseExpiry,
			&i.ReraNo,
			&i.ReraFileUrl,
			&i.ReraExpiry,
			&i.IsVerified,
			&i.WebsiteUrl,
			&i.CoverImageUrl,
			&i.TagLine,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
			&i.FacebookProfileUrl,
			&i.InstagramProfileUrl,
			&i.TwitterProfileUrl,
			&i.NoOfEmployees,
			&i.UsersID,
			&i.LinkedinProfileUrl,
			&i.BankAccountDetailsID,
			&i.CompanyRank,
			&i.Status,
			&i.CountryID,
			&i.CompanyType,
			&i.IsBranch,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefNo,
			&i.ReraRegistrationDate,
			&i.ReraIssueDate,
			&i.CommercialLicenseRegistrationDate,
			&i.CommercialLicenseIssueDate,
			&i.ExtraLicenseNames,
			&i.ExtraLicenseFiles,
			&i.ExtraLicenseNos,
			&i.ExtraLicenseIssueDate,
			&i.ExtraLicenseExpiryDate,
			&i.YoutubeProfileUrl,
			&i.OrnLicenseNo,
			&i.OrnLicenseFileUrl,
			&i.OrnRegistrationDate,
			&i.OrnLicenseExpiry,
			&i.CreatedBy,
			&i.TrakheesPermitNo,
			&i.LicenseDcciNo,
			&i.RegisterNo,
			&i.OtherSocialMedia,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBrokerCompaniesWithoutPagination = `-- name: GetAllBrokerCompaniesWithoutPagination :many
SELECT id, company_name, description, logo_url, addresses_id, email, phone_number, whatsapp_number, commercial_license_no, commercial_license_file_url, commercial_license_expiry, rera_no, rera_file_url, rera_expiry, is_verified, website_url, cover_image_url, tag_line, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, twitter_profile_url, no_of_employees, users_id, linkedin_profile_url, bank_account_details_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, rera_registration_date, rera_issue_date, commercial_license_registration_date, commercial_license_issue_date, extra_license_nos, extra_license_files, extra_license_names, extra_license_issue_date, extra_license_expiry_date, license_dcci_no, register_no, other_social_media, youtube_profile_url, orn_license_no, orn_license_file_url, orn_registration_date, orn_license_expiry, created_by, trakhees_permit_no FROM broker_companies
WHERE status != 5 AND status != 6 ORDER BY id
`

func (q *Queries) GetAllBrokerCompaniesWithoutPagination(ctx context.Context) ([]BrokerCompany, error) {
	rows, err := q.db.Query(ctx, getAllBrokerCompaniesWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BrokerCompany
	for rows.Next() {
		var i BrokerCompany
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.Description,
			&i.LogoUrl,
			&i.AddressesID,
			&i.Email,
			&i.PhoneNumber,
			&i.WhatsappNumber,
			&i.CommercialLicenseNo,
			&i.CommercialLicenseFileUrl,
			&i.CommercialLicenseExpiry,
			&i.ReraNo,
			&i.ReraFileUrl,
			&i.ReraExpiry,
			&i.IsVerified,
			&i.WebsiteUrl,
			&i.CoverImageUrl,
			&i.TagLine,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
			&i.FacebookProfileUrl,
			&i.InstagramProfileUrl,
			&i.TwitterProfileUrl,
			&i.NoOfEmployees,
			&i.UsersID,
			&i.LinkedinProfileUrl,
			&i.BankAccountDetailsID,
			&i.CompanyRank,
			&i.Status,
			&i.CountryID,
			&i.CompanyType,
			&i.IsBranch,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefNo,
			&i.ReraRegistrationDate,
			&i.ReraIssueDate,
			&i.CommercialLicenseRegistrationDate,
			&i.CommercialLicenseIssueDate,
			&i.ExtraLicenseNos,
			&i.ExtraLicenseFiles,
			&i.ExtraLicenseNames,
			&i.ExtraLicenseIssueDate,
			&i.ExtraLicenseExpiryDate,
			&i.LicenseDcciNo,
			&i.RegisterNo,
			&i.OtherSocialMedia,
			&i.YoutubeProfileUrl,
			&i.OrnLicenseNo,
			&i.OrnLicenseFileUrl,
			&i.OrnRegistrationDate,
			&i.OrnLicenseExpiry,
			&i.CreatedBy,
			&i.TrakheesPermitNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyName = `-- name: GetAllCompanyName :many
SELECT
    "company_name",
    "id",
    'services_companies' AS category
FROM
    "public"."services_companies"
UNION
SELECT
    "company_name",
    "id",
    'service_company_branches' AS category
FROM
    "public"."service_company_branches"
UNION
SELECT
    "company_name",
    "id",
    'broker_companies_branches' AS category
FROM
    "public"."broker_companies_branches"
UNION
SELECT
    "company_name",
    "id",
    'broker_companies' AS category
FROM
    "public"."broker_companies"
UNION
SELECT
    "company_name",
    "id",
    'developer_company_branches' AS category
FROM
    "public"."developer_company_branches"
UNION
SELECT
    "company_name",
    "id",
    'developer_companies' AS category
FROM
    "public"."developer_companies"
`

type GetAllCompanyNameRow struct {
	CompanyName string `json:"company_name"`
	ID          int64  `json:"id"`
	Category    string `json:"category"`
}

func (q *Queries) GetAllCompanyName(ctx context.Context) ([]GetAllCompanyNameRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyNameRow
	for rows.Next() {
		var i GetAllCompanyNameRow
		if err := rows.Scan(&i.CompanyName, &i.ID, &i.Category); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactDocumentsCustom = `-- name: GetAllContactDocumentsCustom :many
SELECT
    cd.id AS document_id,
    c.updated_at AS updated_date,
    cd.document_url AS title,
    c.created_at AS entered_on,
    c.created_by AS entered_by
FROM
    public.contacts_document cd
JOIN
    public.contacts c ON cd.contacts_id = c.id
LIMIT $1
OFFSET $2
`

type GetAllContactDocumentsCustomParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllContactDocumentsCustomRow struct {
	DocumentID  int64     `json:"document_id"`
	UpdatedDate time.Time `json:"updated_date"`
	Title       string    `json:"title"`
	EnteredOn   time.Time `json:"entered_on"`
	EnteredBy   int64     `json:"entered_by"`
}

func (q *Queries) GetAllContactDocumentsCustom(ctx context.Context, arg GetAllContactDocumentsCustomParams) ([]GetAllContactDocumentsCustomRow, error) {
	rows, err := q.db.Query(ctx, getAllContactDocumentsCustom, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllContactDocumentsCustomRow
	for rows.Next() {
		var i GetAllContactDocumentsCustomRow
		if err := rows.Scan(
			&i.DocumentID,
			&i.UpdatedDate,
			&i.Title,
			&i.EnteredOn,
			&i.EnteredBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactsDocuments = `-- name: GetAllContactsDocuments :many
SELECT id, contacts_id, document_category_id, expiry_date, is_private, document_url, created_at, created_by, description, updated_at, title FROM public.contacts_document ORDER BY id LIMIT $1 OFFSET $2
`

type GetAllContactsDocumentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllContactsDocuments(ctx context.Context, arg GetAllContactsDocumentsParams) ([]ContactsDocument, error) {
	rows, err := q.db.Query(ctx, getAllContactsDocuments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContactsDocument
	for rows.Next() {
		var i ContactsDocument
		if err := rows.Scan(
			&i.ID,
			&i.ContactsID,
			&i.DocumentCategoryID,
			&i.ExpiryDate,
			&i.IsPrivate,
			&i.DocumentUrl,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Description,
			&i.UpdatedAt,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactsOtherContact = `-- name: GetAllContactsOtherContact :many
SELECT
    coc.id AS id,
    coc.contacts_id AS contact_id,
    -- c1.firstname AS contact_name,
    coc.other_contacts_id AS other_contact_id,
    -- c2.firstname AS other_contact_name,
    coc.date_added
FROM
    contacts_other_contact coc
JOIN
    contacts c1 ON coc.contacts_id = c1.id
JOIN
    contacts c2 ON coc.other_contacts_id = c2.id
`

type GetAllContactsOtherContactRow struct {
	ID             int64     `json:"id"`
	ContactID      int64     `json:"contact_id"`
	OtherContactID int64     `json:"other_contact_id"`
	DateAdded      time.Time `json:"date_added"`
}

func (q *Queries) GetAllContactsOtherContact(ctx context.Context) ([]GetAllContactsOtherContactRow, error) {
	rows, err := q.db.Query(ctx, getAllContactsOtherContact)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllContactsOtherContactRow
	for rows.Next() {
		var i GetAllContactsOtherContactRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.OtherContactID,
			&i.DateAdded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactsOtherContactByContactsId = `-- name: GetAllContactsOtherContactByContactsId :many
SELECT c.id, c.ref_no, c.salutation, c.firstname, c.lastname, c.status, c.created_by, c.created_at, c.updated_at, c.updated_by, c.entity_id, c.entity_type_id, coc.id, coc.contacts_id, coc.relationship, coc.other_contacts_id, coc.date_added, 
    u_created_by.username AS created_by_username,
    u_updated_by.username AS updated_by_username,
    COALESCE(languages, '{}') AS languages,
    COALESCE(assigned_usernames, '{}') AS assigned_usernames,
    COALESCE(shared_usernames, '{}') AS shared_usernames
FROM contacts_other_contact coc JOIN contacts c on c.id = coc.other_contacts_id    LEFT JOIN "public"."users" u_created_by ON c.created_by = u_created_by.id
    LEFT JOIN "public"."users" u_updated_by ON c.updated_by = u_updated_by.id
    LEFT JOIN LATERAL (
        SELECT array_agg(al.language)::varchar[] AS languages
        FROM unnest(c.all_languages_id) AS lang_id
        JOIN "public"."all_languages" al ON lang_id = al.id
    ) AS languages ON TRUE
    LEFT JOIN LATERAL (
        SELECT array_agg(au.username)::varchar[] AS assigned_usernames
        FROM unnest(c.assigned_to) AS assigned_id
        JOIN "public"."users" au ON assigned_id = au.id
    ) AS assigned_usernames ON TRUE
    LEFT JOIN LATERAL (
        SELECT array_agg(su.username)::varchar[] AS shared_usernames
        FROM unnest(c.shared_with) AS shared_id
        JOIN "public"."users" su ON shared_id = su.id
    ) AS shared_usernames ON TRUE
WHERE coc.contacts_id = $1 AND c.status != 5 AND c.status != 6 LIMIT $2 OFFSET $3
`

type GetAllContactsOtherContactByContactsIdParams struct {
	ContactsID int64 `json:"contacts_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetAllContactsOtherContactByContactsIdRow struct {
	ID                int64       `json:"id"`
	RefNo             string      `json:"ref_no"`
	Salutation        string      `json:"salutation"`
	Firstname         string      `json:"firstname"`
	Lastname          string      `json:"lastname"`
	Status            int64       `json:"status"`
	CreatedBy         int64       `json:"created_by"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	UpdatedBy         pgtype.Int8 `json:"updated_by"`
	EntityID          int64       `json:"entity_id"`
	EntityTypeID      int64       `json:"entity_type_id"`
	ID_2              int64       `json:"id_2"`
	ContactsID        int64       `json:"contacts_id"`
	Relationship      string      `json:"relationship"`
	OtherContactsID   int64       `json:"other_contacts_id"`
	DateAdded         time.Time   `json:"date_added"`
	CreatedByUsername pgtype.Text `json:"created_by_username"`
	UpdatedByUsername pgtype.Text `json:"updated_by_username"`
	Languages         []string    `json:"languages"`
	AssignedUsernames []string    `json:"assigned_usernames"`
	SharedUsernames   []string    `json:"shared_usernames"`
}

func (q *Queries) GetAllContactsOtherContactByContactsId(ctx context.Context, arg GetAllContactsOtherContactByContactsIdParams) ([]GetAllContactsOtherContactByContactsIdRow, error) {
	rows, err := q.db.Query(ctx, getAllContactsOtherContactByContactsId, arg.ContactsID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllContactsOtherContactByContactsIdRow
	for rows.Next() {
		var i GetAllContactsOtherContactByContactsIdRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.Salutation,
			&i.Firstname,
			&i.Lastname,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.EntityID,
			&i.EntityTypeID,
			&i.ID_2,
			&i.ContactsID,
			&i.Relationship,
			&i.OtherContactsID,
			&i.DateAdded,
			&i.CreatedByUsername,
			&i.UpdatedByUsername,
			&i.Languages,
			&i.AssignedUsernames,
			&i.SharedUsernames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactsOtherContactByContactsIdWithoutPagination = `-- name: GetAllContactsOtherContactByContactsIdWithoutPagination :many
SELECT id, contacts_id, relationship, other_contacts_id, date_added FROM contacts_other_contact
WHERE contacts_id = $1
`

func (q *Queries) GetAllContactsOtherContactByContactsIdWithoutPagination(ctx context.Context, contactsID int64) ([]ContactsOtherContact, error) {
	rows, err := q.db.Query(ctx, getAllContactsOtherContactByContactsIdWithoutPagination, contactsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContactsOtherContact
	for rows.Next() {
		var i ContactsOtherContact
		if err := rows.Scan(
			&i.ID,
			&i.ContactsID,
			&i.Relationship,
			&i.OtherContactsID,
			&i.DateAdded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactsOtherContactWithPagination = `-- name: GetAllContactsOtherContactWithPagination :many
SELECT
    coc.id AS id,
    coc.contacts_id AS contact_id,
    -- c1.firstname AS contact_name,
    coc.other_contacts_id AS other_contact_id,
    -- c2.firstname AS other_contact_name,
    coc.date_added
FROM
    contacts_other_contact coc
JOIN
    contacts c1 ON coc.contacts_id = c1.id
JOIN
    contacts c2 ON coc.other_contacts_id = c2.id
    ORDER BY coc.id LIMIT $1 OFFSET $2
`

type GetAllContactsOtherContactWithPaginationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllContactsOtherContactWithPaginationRow struct {
	ID             int64     `json:"id"`
	ContactID      int64     `json:"contact_id"`
	OtherContactID int64     `json:"other_contact_id"`
	DateAdded      time.Time `json:"date_added"`
}

func (q *Queries) GetAllContactsOtherContactWithPagination(ctx context.Context, arg GetAllContactsOtherContactWithPaginationParams) ([]GetAllContactsOtherContactWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllContactsOtherContactWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllContactsOtherContactWithPaginationRow
	for rows.Next() {
		var i GetAllContactsOtherContactWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.OtherContactID,
			&i.DateAdded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactsWithoutOffset = `-- name: GetAllContactsWithoutOffset :many
SELECT id, ref_no, salutation, firstname, lastname, status, created_by, created_at, updated_at, updated_by, entity_id, entity_type_id FROM contacts WHERE status != 6
ORDER BY id
`

func (q *Queries) GetAllContactsWithoutOffset(ctx context.Context) ([]Contact, error) {
	rows, err := q.db.Query(ctx, getAllContactsWithoutOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contact
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.Salutation,
			&i.Firstname,
			&i.Lastname,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.EntityID,
			&i.EntityTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllContactsWithoutPagination = `-- name: GetAllContactsWithoutPagination :many
SELECT
    c.id, c.ref_no, c.salutation, c.firstname, c.lastname, c.status, c.created_by, c.created_at, c.updated_at, c.updated_by, c.entity_id, c.entity_type_id,
    scd.mobile,
    scd.mobile_share,
    scd.mobile2,
    scd.mobile2_share,
    scd.landline,
    scd.landline_share,
    scd.fax,
    scd.fax_share,
    scd.email,
    scd.email_share,
    scd.second_email,
    scd.second_email_share
FROM "public"."contacts" c
LEFT JOIN "public"."shareable_contact_details" scd ON c.id = scd.contacts_id
`

type GetAllContactsWithoutPaginationRow struct {
	ID               int64       `json:"id"`
	RefNo            string      `json:"ref_no"`
	Salutation       string      `json:"salutation"`
	Firstname        string      `json:"firstname"`
	Lastname         string      `json:"lastname"`
	Status           int64       `json:"status"`
	CreatedBy        int64       `json:"created_by"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	UpdatedBy        pgtype.Int8 `json:"updated_by"`
	EntityID         int64       `json:"entity_id"`
	EntityTypeID     int64       `json:"entity_type_id"`
	Mobile           pgtype.Text `json:"mobile"`
	MobileShare      pgtype.Bool `json:"mobile_share"`
	Mobile2          pgtype.Text `json:"mobile2"`
	Mobile2Share     pgtype.Bool `json:"mobile2_share"`
	Landline         pgtype.Text `json:"landline"`
	LandlineShare    pgtype.Bool `json:"landline_share"`
	Fax              pgtype.Text `json:"fax"`
	FaxShare         pgtype.Bool `json:"fax_share"`
	Email            pgtype.Text `json:"email"`
	EmailShare       pgtype.Bool `json:"email_share"`
	SecondEmail      pgtype.Text `json:"second_email"`
	SecondEmailShare pgtype.Bool `json:"second_email_share"`
}

func (q *Queries) GetAllContactsWithoutPagination(ctx context.Context) ([]GetAllContactsWithoutPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllContactsWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllContactsWithoutPaginationRow
	for rows.Next() {
		var i GetAllContactsWithoutPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.Salutation,
			&i.Firstname,
			&i.Lastname,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.EntityID,
			&i.EntityTypeID,
			&i.Mobile,
			&i.MobileShare,
			&i.Mobile2,
			&i.Mobile2Share,
			&i.Landline,
			&i.LandlineShare,
			&i.Fax,
			&i.FaxShare,
			&i.Email,
			&i.EmailShare,
			&i.SecondEmail,
			&i.SecondEmailShare,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDeveloperCompaniesBranchesWithoutPagination = `-- name: GetAllDeveloperCompaniesBranchesWithoutPagination :many
SELECT id, developer_companies_id, company_name, tag_line, commercial_license_no, commercial_license_file_url, commercial_license_expiry, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, linkedin_profile_url, twitter_profile_url, users_id, bank_account_details_id, no_of_employees, logo_url, cover_image_url, description, is_verified, website_url, phone_number, email, whatsapp_number, addresses_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, commercial_license_registration_date, commercial_license_issue_date, extra_license_names, extra_license_files, extra_license_nos, extra_license_issue_date, extra_license_expiry_date, youtube_profile_url, created_by, license_dcci_no, register_no, other_social_media FROM developer_company_branches
WHERE status != 5 AND status != 6 ORDER BY id
`

func (q *Queries) GetAllDeveloperCompaniesBranchesWithoutPagination(ctx context.Context) ([]DeveloperCompanyBranch, error) {
	rows, err := q.db.Query(ctx, getAllDeveloperCompaniesBranchesWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeveloperCompanyBranch
	for rows.Next() {
		var i DeveloperCompanyBranch
		if err := rows.Scan(
			&i.ID,
			&i.DeveloperCompaniesID,
			&i.CompanyName,
			&i.TagLine,
			&i.CommercialLicenseNo,
			&i.CommercialLicenseFileUrl,
			&i.CommercialLicenseExpiry,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
			&i.FacebookProfileUrl,
			&i.InstagramProfileUrl,
			&i.LinkedinProfileUrl,
			&i.TwitterProfileUrl,
			&i.UsersID,
			&i.BankAccountDetailsID,
			&i.NoOfEmployees,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.Description,
			&i.IsVerified,
			&i.WebsiteUrl,
			&i.PhoneNumber,
			&i.Email,
			&i.WhatsappNumber,
			&i.AddressesID,
			&i.CompanyRank,
			&i.Status,
			&i.CountryID,
			&i.CompanyType,
			&i.IsBranch,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefNo,
			&i.CommercialLicenseRegistrationDate,
			&i.CommercialLicenseIssueDate,
			&i.ExtraLicenseNames,
			&i.ExtraLicenseFiles,
			&i.ExtraLicenseNos,
			&i.ExtraLicenseIssueDate,
			&i.ExtraLicenseExpiryDate,
			&i.YoutubeProfileUrl,
			&i.CreatedBy,
			&i.LicenseDcciNo,
			&i.RegisterNo,
			&i.OtherSocialMedia,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDeveloperCompaniesWithoutPagination = `-- name: GetAllDeveloperCompaniesWithoutPagination :many
SELECT id, company_name, tag_line, commercial_license_no, commercial_license_file_url, commercial_license_expiry, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, linkedin_profile_url, twitter_profile_url, users_id, bank_account_details_id, no_of_employees, logo_url, cover_image_url, description, is_verified, website_url, phone_number, email, whatsapp_number, addresses_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, commercial_license_registration_date, commercial_license_issue_date, extra_license_nos, extra_license_files, extra_license_names, extra_license_issue_date, extra_license_expiry_date, license_dcci_no, register_no, other_social_media, youtube_profile_url, created_by FROM developer_companies
WHERE status != 5 AND status != 6 ORDER BY id
`

func (q *Queries) GetAllDeveloperCompaniesWithoutPagination(ctx context.Context) ([]DeveloperCompany, error) {
	rows, err := q.db.Query(ctx, getAllDeveloperCompaniesWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeveloperCompany
	for rows.Next() {
		var i DeveloperCompany
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.TagLine,
			&i.CommercialLicenseNo,
			&i.CommercialLicenseFileUrl,
			&i.CommercialLicenseExpiry,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
			&i.FacebookProfileUrl,
			&i.InstagramProfileUrl,
			&i.LinkedinProfileUrl,
			&i.TwitterProfileUrl,
			&i.UsersID,
			&i.BankAccountDetailsID,
			&i.NoOfEmployees,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.Description,
			&i.IsVerified,
			&i.WebsiteUrl,
			&i.PhoneNumber,
			&i.Email,
			&i.WhatsappNumber,
			&i.AddressesID,
			&i.CompanyRank,
			&i.Status,
			&i.CountryID,
			&i.CompanyType,
			&i.IsBranch,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefNo,
			&i.CommercialLicenseRegistrationDate,
			&i.CommercialLicenseIssueDate,
			&i.ExtraLicenseNos,
			&i.ExtraLicenseFiles,
			&i.ExtraLicenseNames,
			&i.ExtraLicenseIssueDate,
			&i.ExtraLicenseExpiryDate,
			&i.LicenseDcciNo,
			&i.RegisterNo,
			&i.OtherSocialMedia,
			&i.YoutubeProfileUrl,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllIndustry = `-- name: GetAllIndustry :many
SELECT id, title, title_ar FROM "public"."industry"
LIMIT $1
OFFSET $2
`

type GetAllIndustryParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllIndustry(ctx context.Context, arg GetAllIndustryParams) ([]Industry, error) {
	rows, err := q.db.Query(ctx, getAllIndustry, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Industry
	for rows.Next() {
		var i Industry
		if err := rows.Scan(&i.ID, &i.Title, &i.TitleAr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllIndustryWithoutPagination = `-- name: GetAllIndustryWithoutPagination :many
SELECT id, title, title_ar FROM "public"."industry"
`

func (q *Queries) GetAllIndustryWithoutPagination(ctx context.Context) ([]Industry, error) {
	rows, err := q.db.Query(ctx, getAllIndustryWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Industry
	for rows.Next() {
		var i Industry
		if err := rows.Scan(&i.ID, &i.Title, &i.TitleAr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProfessions = `-- name: GetAllProfessions :many
SELECT id, title, title_ar FROM "public"."professions"
LIMIT $1
OFFSET $2
`

type GetAllProfessionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProfessions(ctx context.Context, arg GetAllProfessionsParams) ([]Profession, error) {
	rows, err := q.db.Query(ctx, getAllProfessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Profession
	for rows.Next() {
		var i Profession
		if err := rows.Scan(&i.ID, &i.Title, &i.TitleAr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProfessionsWithoutPagination = `-- name: GetAllProfessionsWithoutPagination :many
SELECT id, title, title_ar FROM "public"."professions"
`

func (q *Queries) GetAllProfessionsWithoutPagination(ctx context.Context) ([]Profession, error) {
	rows, err := q.db.Query(ctx, getAllProfessionsWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Profession
	for rows.Next() {
		var i Profession
		if err := rows.Scan(&i.ID, &i.Title, &i.TitleAr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllServiceCompaniesBranchesWithoutPagination = `-- name: GetAllServiceCompaniesBranchesWithoutPagination :many
SELECT id, services_companies_id, company_name, description, logo_url, addresses_id, email, phone_number, whatsapp_number, commercial_license_no, commercial_license_file_url, commercial_license_expiry, is_verified, website_url, cover_image_url, tag_line, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, twitter_profile_url, no_of_employees, users_id, linkedin_profile_url, bank_account_details_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, commercial_license_registration_date, commercial_license_issue_date, extra_license_names, extra_license_files, extra_license_nos, extra_license_issue_date, extra_license_expiry_date, youtube_profile_url, created_by, license_dcci_no, register_no, other_social_media FROM service_company_branches
WHERE status != 5 AND status != 6 ORDER BY id
`

func (q *Queries) GetAllServiceCompaniesBranchesWithoutPagination(ctx context.Context) ([]ServiceCompanyBranch, error) {
	rows, err := q.db.Query(ctx, getAllServiceCompaniesBranchesWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceCompanyBranch
	for rows.Next() {
		var i ServiceCompanyBranch
		if err := rows.Scan(
			&i.ID,
			&i.ServicesCompaniesID,
			&i.CompanyName,
			&i.Description,
			&i.LogoUrl,
			&i.AddressesID,
			&i.Email,
			&i.PhoneNumber,
			&i.WhatsappNumber,
			&i.CommercialLicenseNo,
			&i.CommercialLicenseFileUrl,
			&i.CommercialLicenseExpiry,
			&i.IsVerified,
			&i.WebsiteUrl,
			&i.CoverImageUrl,
			&i.TagLine,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
			&i.FacebookProfileUrl,
			&i.InstagramProfileUrl,
			&i.TwitterProfileUrl,
			&i.NoOfEmployees,
			&i.UsersID,
			&i.LinkedinProfileUrl,
			&i.BankAccountDetailsID,
			&i.CompanyRank,
			&i.Status,
			&i.CountryID,
			&i.CompanyType,
			&i.IsBranch,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefNo,
			&i.CommercialLicenseRegistrationDate,
			&i.CommercialLicenseIssueDate,
			&i.ExtraLicenseNames,
			&i.ExtraLicenseFiles,
			&i.ExtraLicenseNos,
			&i.ExtraLicenseIssueDate,
			&i.ExtraLicenseExpiryDate,
			&i.YoutubeProfileUrl,
			&i.CreatedBy,
			&i.LicenseDcciNo,
			&i.RegisterNo,
			&i.OtherSocialMedia,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllServiceCompaniesWithoutPagination = `-- name: GetAllServiceCompaniesWithoutPagination :many
SELECT id, company_name, description, logo_url, addresses_id, email, phone_number, whatsapp_number, commercial_license_no, commercial_license_file_url, commercial_license_expiry, is_verified, website_url, cover_image_url, tag_line, vat_no, vat_status, vat_file_url, facebook_profile_url, instagram_profile_url, twitter_profile_url, no_of_employees, users_id, linkedin_profile_url, bank_account_details_id, company_rank, status, country_id, company_type, is_branch, created_at, updated_at, ref_no, commercial_license_registration_date, commercial_license_issue_date, youtube_profile_url, created_by, extra_license_nos, extra_license_files, extra_license_names, extra_license_issue_date, extra_license_expiry_date, license_dcci_no, register_no, other_social_media FROM services_companies
WHERE status != 5 AND status != 6 ORDER BY id
`

func (q *Queries) GetAllServiceCompaniesWithoutPagination(ctx context.Context) ([]ServicesCompany, error) {
	rows, err := q.db.Query(ctx, getAllServiceCompaniesWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServicesCompany
	for rows.Next() {
		var i ServicesCompany
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.Description,
			&i.LogoUrl,
			&i.AddressesID,
			&i.Email,
			&i.PhoneNumber,
			&i.WhatsappNumber,
			&i.CommercialLicenseNo,
			&i.CommercialLicenseFileUrl,
			&i.CommercialLicenseExpiry,
			&i.IsVerified,
			&i.WebsiteUrl,
			&i.CoverImageUrl,
			&i.TagLine,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
			&i.FacebookProfileUrl,
			&i.InstagramProfileUrl,
			&i.TwitterProfileUrl,
			&i.NoOfEmployees,
			&i.UsersID,
			&i.LinkedinProfileUrl,
			&i.BankAccountDetailsID,
			&i.CompanyRank,
			&i.Status,
			&i.CountryID,
			&i.CompanyType,
			&i.IsBranch,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RefNo,
			&i.CommercialLicenseRegistrationDate,
			&i.CommercialLicenseIssueDate,
			&i.YoutubeProfileUrl,
			&i.CreatedBy,
			&i.ExtraLicenseNos,
			&i.ExtraLicenseFiles,
			&i.ExtraLicenseNames,
			&i.ExtraLicenseIssueDate,
			&i.ExtraLicenseExpiryDate,
			&i.LicenseDcciNo,
			&i.RegisterNo,
			&i.OtherSocialMedia,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSingleContactDocuments = `-- name: GetAllSingleContactDocuments :many
SELECT
    cd.id, cd.contacts_id, cd.document_category_id, cd.expiry_date, cd.is_private, cd.document_url, cd.created_at, cd.created_by, cd.description, cd.updated_at, cd.title,
    dc.title as document_category,
    dc.title_ar as document_category_ar,
    u.username as uploaded_by
FROM
    public.contacts c
JOIN
    public.contacts_document cd ON c.id = cd.contacts_id
JOIN
    public.document_categories dc ON cd.document_category_id = dc.id 
LEFT JOIN users u on cd.created_by = u.id   WHERE cd.contacts_id = $1  ORDER BY cd.id  LIMIT $2 OFFSET $3
`

type GetAllSingleContactDocumentsParams struct {
	ContactsID pgtype.Int8 `json:"contacts_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetAllSingleContactDocumentsRow struct {
	ID                 int64       `json:"id"`
	ContactsID         pgtype.Int8 `json:"contacts_id"`
	DocumentCategoryID int64       `json:"document_category_id"`
	ExpiryDate         time.Time   `json:"expiry_date"`
	IsPrivate          bool        `json:"is_private"`
	DocumentUrl        string      `json:"document_url"`
	CreatedAt          time.Time   `json:"created_at"`
	CreatedBy          int64       `json:"created_by"`
	Description        pgtype.Text `json:"description"`
	UpdatedAt          time.Time   `json:"updated_at"`
	Title              string      `json:"title"`
	DocumentCategory   string      `json:"document_category"`
	DocumentCategoryAr string      `json:"document_category_ar"`
	UploadedBy         pgtype.Text `json:"uploaded_by"`
}

func (q *Queries) GetAllSingleContactDocuments(ctx context.Context, arg GetAllSingleContactDocumentsParams) ([]GetAllSingleContactDocumentsRow, error) {
	rows, err := q.db.Query(ctx, getAllSingleContactDocuments, arg.ContactsID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSingleContactDocumentsRow
	for rows.Next() {
		var i GetAllSingleContactDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactsID,
			&i.DocumentCategoryID,
			&i.ExpiryDate,
			&i.IsPrivate,
			&i.DocumentUrl,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Description,
			&i.UpdatedAt,
			&i.Title,
			&i.DocumentCategory,
			&i.DocumentCategoryAr,
			&i.UploadedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAqaryUserAgents = `-- name: GetAqaryUserAgents :many
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE user_types_id = 2 and status != 5 and status != 6
`

func (q *Queries) GetAqaryUserAgents(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAqaryUserAgents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAqaryUserAgentsAndCompany = `-- name: GetAqaryUserAgentsAndCompany :many
SELECT id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views FROM users
WHERE user_types_id = 2 and user_types_id = 7 and status != 5 and status != 6
`

func (q *Queries) GetAqaryUserAgentsAndCompany(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAqaryUserAgentsAndCompany)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.RolesID,
			&i.UserTypesID,
			&i.SocialLogin,
			&i.ShowHideDetails,
			&i.ExperienceSince,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.IsPhoneVerified,
			&i.IsEmailVerified,
			&i.ActiveCompany,
			&i.CountryCode,
			&i.ProfileViews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactStatus = `-- name: GetContactStatus :one
SELECT status
FROM contacts
WHERE id = $1
`

func (q *Queries) GetContactStatus(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getContactStatus, id)
	var status int64
	err := row.Scan(&status)
	return status, err
}

const getContactsDocumentByContactsIdAndCategoryId = `-- name: GetContactsDocumentByContactsIdAndCategoryId :one
SELECT
    id,
    contacts_id,
    document_category_id,
    is_private,
    document_url
FROM
    contacts_document
WHERE
    contacts_id = $1
    AND document_category_id = $2
`

type GetContactsDocumentByContactsIdAndCategoryIdParams struct {
	ContactsID         pgtype.Int8 `json:"contacts_id"`
	DocumentCategoryID int64       `json:"document_category_id"`
}

type GetContactsDocumentByContactsIdAndCategoryIdRow struct {
	ID                 int64       `json:"id"`
	ContactsID         pgtype.Int8 `json:"contacts_id"`
	DocumentCategoryID int64       `json:"document_category_id"`
	IsPrivate          bool        `json:"is_private"`
	DocumentUrl        string      `json:"document_url"`
}

func (q *Queries) GetContactsDocumentByContactsIdAndCategoryId(ctx context.Context, arg GetContactsDocumentByContactsIdAndCategoryIdParams) (GetContactsDocumentByContactsIdAndCategoryIdRow, error) {
	row := q.db.QueryRow(ctx, getContactsDocumentByContactsIdAndCategoryId, arg.ContactsID, arg.DocumentCategoryID)
	var i GetContactsDocumentByContactsIdAndCategoryIdRow
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.DocumentCategoryID,
		&i.IsPrivate,
		&i.DocumentUrl,
	)
	return i, err
}

const getContactsDocumentById = `-- name: GetContactsDocumentById :one
SELECT id, contacts_id, document_category_id, expiry_date, is_private, document_url, created_at, created_by, description, updated_at, title FROM contacts_document WHERE id = $1 LIMIT $1
`

func (q *Queries) GetContactsDocumentById(ctx context.Context, limit int32) (ContactsDocument, error) {
	row := q.db.QueryRow(ctx, getContactsDocumentById, limit)
	var i ContactsDocument
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.DocumentCategoryID,
		&i.ExpiryDate,
		&i.IsPrivate,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Description,
		&i.UpdatedAt,
		&i.Title,
	)
	return i, err
}

const getContactsDocumentByIdAndDocCategory = `-- name: GetContactsDocumentByIdAndDocCategory :one

 

SELECT id, contacts_id, document_category_id, expiry_date, is_private, document_url, created_at, created_by, description, updated_at, title FROM contacts_document WHERE id = $1 AND document_category_id = $2
`

type GetContactsDocumentByIdAndDocCategoryParams struct {
	ID                 int64 `json:"id"`
	DocumentCategoryID int64 `json:"document_category_id"`
}

// -- name: GetSingleContact :one
// select c.id, c.users_id, c.ref_no, c.contact_category_id, c.salutation, c.name, c.lastname, c.all_languages_id, c.ejari, c.assigned_to, c.shared_with, c.remarks, c.is_blockedlisted, c.is_vip, c.correspondence, c.direct_markerting, c.status, c.created_by, c.contact_platform, c.created_at, c.updated_at, c.updated_by,
//
//	scd.id, scd.contacts_id, scd.mobile, scd.mobile_share, scd.mobile2, scd.mobile2_share, scd.landline, scd.landline_share, scd.fax, scd.fax_share, scd.email, scd.email_share, scd.second_email, scd.second_email_share, scd.added_by, scd.created_at, scd.updated_at,
//	 COALESCE(ra.id, 0) AS ra_id, COALESCE(ra.contacts_id, 0) AS ra_contacts_id, COALESCE(ra.address_type_id, 0) AS ra_address_type_id, COALESCE(ra.address1, '') AS ra_address1, COALESCE(ra.address2, '') AS ra_address2, COALESCE(ra.countries_id, 0) AS ra_countries_id, COALESCE(ra.states_id, 0) AS ra_states_id, COALESCE(ra.cities_id, 0) AS ra_cities_id, COALESCE(ra.community_id, 0) AS ra_community_id, COALESCE(ra.sub_community_id, 0) AS ra_sub_community_id, COALESCE(ra.postal_code, 0) AS ra_postal_code,
//	COALESCE(ca.id, 0) AS ca_id, COALESCE(ca.contacts_id, 0) AS ca_contacts_id, COALESCE(ca.address_type_id, 0) AS ca_address_type_id, COALESCE(ca.address1, '') AS ca_address1, COALESCE(ca.address2, '') AS ca_address2, COALESCE(ca.countries_id, 0) AS ca_countries_id, COALESCE(ca.states_id, 0) AS ca_states_id, COALESCE(ca.cities_id, 0) AS ca_cities_id, COALESCE(ca.community_id, 0) AS ca_community_id, COALESCE(ca.sub_community_id, 0) AS ca_sub_community_id, COALESCE(ca.postal_code, 0) AS ca_postal_code,ccd.id, ccd.contacts_id, ccd.companies_id, ccd.company_category, ccd.is_branch, ccd.no_of_employees, ccd.industry_id, ccd.no_local_business, ccd.retail_category_id, ccd.no_remote_business, ccd.nationality, ccd.license, ccd.issued_date, ccd.expiry_date, ccd.external_id,
//	cid.id, cid.contacts_id, cid.comapanies_id, cid.company_category, cid.is_branch, cid.date_of_birth, cid.professions_id, cid.gender, cid.marital_status, cid.nationality, cid.id_type, cid.id_number, cid.id_country_id, cid.id_issued_date, cid.id_expiry_date, cid.passport_number, cid.passport_country_id, cid.passport_issued_date, cid.passport_expiry_date, cid.interests,
//	cn1.country as resident_country,ci1.city as resident_city,
//	st1."state" as resident_state, com1.community as resident_community,
//	scom1.sub_community as resident_sub_community,
//	cn2.country as company_country,ci2.city as company_city,
//	st2."state" as company_state, com2.community as company_community,
//	scom2.sub_community as company_sub_community,
//	c.id AS contact_id,
//	c.created_by AS contact_created_by,
//	c.updated_by AS contact_updated_by,
//	u_created_by.username AS created_by_username,
//	u_updated_by.username AS updated_by_username,
//	c.all_languages_id AS contact_all_languages_id,
//	COALESCE(languages, '{}') AS languages,
//	c.assigned_to AS contact_assigned_to,
//	COALESCE(assigned_usernames, '{}') AS assigned_usernames,
//	c.shared_with AS contact_shared_with,
//	COALESCE(shared_usernames, '{}') AS shared_usernames,
//	    i.title as company_industry,
//	n1.country as company_nationality,
//	rct.title as company_retail_cateogry,
//	p.title as individual_profession,
//	n2.country as individual_nationality,
//	idci.country as individual_country_id,
//	pci.country as individual_passport_country
//
// FROM "public"."contacts" c
// LEFT JOIN "public"."shareable_contact_details" scd ON c.id = scd.contacts_id
// LEFT JOIN contacts_address ra ON c.id = ra.contacts_id AND ra.address_type_id = 1
// left join countries cn1 on ra.countries_id = cn1.id
// left join cities ci1 on ra.cities_id = ci1.id
// left join states st1 on ra.states_id = st1.id
// left join communities com1 on ra.community_id = com1.id
// LEFT join sub_communities scom1 on ra.sub_community_id = scom1.id
// LEFT JOIN contacts_address ca ON c.id = ca.contacts_id AND ca.address_type_id = 2
// left join countries cn2 on ra.countries_id = cn2.id
// left join cities ci2 on ra.cities_id = ci2.id
// left join states st2 on ra.states_id = st2.id
// left join communities com2 on ra.community_id = com2.id
// LEFT join sub_communities scom2 on ra.sub_community_id = scom2.id
// LEFT JOIN contacts_company_details ccd ON c.id = ccd.contacts_id AND c.contact_category_id = 1
// left join industry i on ccd.industry_id = i.id
// left join countries n1 on ccd.nationality = n1.id
// left join retail_category rct on ccd.retail_category_id = rct.id
// LEFT JOIN contacts_individual_details cid ON c.id = cid.contacts_id AND c.contact_category_id = 2
// left join professions p on cid.professions_id = p.id
// left join countries n2 on cid.nationality = n2.id
// left join countries idci on cid.id_country_id = idci.id
// left join countries pci on cid.passport_country_id = pci.id
//
//	LEFT JOIN "public"."users" u_created_by ON c.created_by = u_created_by.id
//	LEFT JOIN "public"."users" u_updated_by ON c.updated_by = u_updated_by.id
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(al.language)::varchar[] AS languages
//	    FROM unnest(c.all_languages_id) AS lang_id
//	    JOIN "public"."all_languages" al ON lang_id = al.id
//	) AS languages ON TRUE
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(au.username)::varchar[] AS assigned_usernames
//	    FROM unnest(c.assigned_to) AS assigned_id
//	    JOIN "public"."users" au ON assigned_id = au.id
//	) AS assigned_usernames ON TRUE
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(su.username)::varchar[] AS shared_usernames
//	    FROM unnest(c.shared_with) AS shared_id
//	    JOIN "public"."users" su ON shared_id = su.id
//	) AS shared_usernames ON TRUE WHERE c.status != 5 AND c.status != 6 AND c.id = $1;
//
// -- name: GetSingleContactByMobile :one
// select c.id, c.users_id, c.ref_no, c.contact_category_id, c.salutation, c.name, c.lastname, c.all_languages_id, c.ejari, c.assigned_to, c.shared_with, c.remarks, c.is_blockedlisted, c.is_vip, c.correspondence, c.direct_markerting, c.status, c.created_by, c.contact_platform, c.created_at, c.updated_at, c.updated_by,
//
//	scd.id, scd.contacts_id, scd.mobile, scd.mobile_share, scd.mobile2, scd.mobile2_share, scd.landline, scd.landline_share, scd.fax, scd.fax_share, scd.email, scd.email_share, scd.second_email, scd.second_email_share, scd.added_by, scd.created_at, scd.updated_at,
//	 COALESCE(ra.id, 0) AS ra_id, COALESCE(ra.contacts_id, 0) AS ra_contacts_id, COALESCE(ra.address_type_id, 0) AS ra_address_type_id, COALESCE(ra.address1, '') AS ra_address1, COALESCE(ra.address2, '') AS ra_address2, COALESCE(ra.countries_id, 0) AS ra_countries_id, COALESCE(ra.states_id, 0) AS ra_states_id, COALESCE(ra.cities_id, 0) AS ra_cities_id, COALESCE(ra.community_id, 0) AS ra_community_id, COALESCE(ra.sub_community_id, 0) AS ra_sub_community_id, COALESCE(ra.postal_code, 0) AS ra_postal_code,
//	COALESCE(ca.id, 0) AS ca_id, COALESCE(ca.contacts_id, 0) AS ca_contacts_id, COALESCE(ca.address_type_id, 0) AS ca_address_type_id, COALESCE(ca.address1, '') AS ca_address1, COALESCE(ca.address2, '') AS ca_address2, COALESCE(ca.countries_id, 0) AS ca_countries_id, COALESCE(ca.states_id, 0) AS ca_states_id, COALESCE(ca.cities_id, 0) AS ca_cities_id, COALESCE(ca.community_id, 0) AS ca_community_id, COALESCE(ca.sub_community_id, 0) AS ca_sub_community_id, COALESCE(ca.postal_code, 0) AS ca_postal_code,ccd.id, ccd.contacts_id, ccd.companies_id, ccd.company_category, ccd.is_branch, ccd.no_of_employees, ccd.industry_id, ccd.no_local_business, ccd.retail_category_id, ccd.no_remote_business, ccd.nationality, ccd.license, ccd.issued_date, ccd.expiry_date, ccd.external_id,
//	cid.id, cid.contacts_id, cid.comapanies_id, cid.company_category, cid.is_branch, cid.date_of_birth, cid.professions_id, cid.gender, cid.marital_status, cid.nationality, cid.id_type, cid.id_number, cid.id_country_id, cid.id_issued_date, cid.id_expiry_date, cid.passport_number, cid.passport_country_id, cid.passport_issued_date, cid.passport_expiry_date, cid.interests,
//	cn1.country as resident_country,ci1.city as resident_city,
//	st1."state" as resident_state, com1.community as resident_community,
//	scom1.sub_community as resident_sub_community,
//	cn2.country as company_country,ci2.city as company_city,
//	st2."state" as company_state, com2.community as company_community,
//	scom2.sub_community as company_sub_community,
//	c.id AS contact_id,
//	c.created_by AS contact_created_by,
//	c.updated_by AS contact_updated_by,
//	u_created_by.username AS created_by_username,
//	u_updated_by.username AS updated_by_username,
//	c.all_languages_id AS contact_all_languages_id,
//	COALESCE(languages, '{}') AS languages,
//	c.assigned_to AS contact_assigned_to,
//	COALESCE(assigned_usernames, '{}') AS assigned_usernames,
//	c.shared_with AS contact_shared_with,
//	COALESCE(shared_usernames, '{}') AS shared_usernames,
//	    i.title as company_industry,
//	n1.country as company_nationality,
//	rct.title as company_retail_cateogry,
//	p.title as individual_profession,
//	n2.country as individual_nationality,
//	idci.country as individual_country_id,
//	pci.country as individual_passport_country
//
// FROM "public"."contacts" c
// LEFT JOIN "public"."shareable_contact_details" scd ON c.id = scd.contacts_id
// LEFT JOIN contacts_address ra ON c.id = ra.contacts_id AND ra.address_type_id = 1
// left join countries cn1 on ra.countries_id = cn1.id
// left join cities ci1 on ra.cities_id = ci1.id
// left join states st1 on ra.states_id = st1.id
// left join communities com1 on ra.community_id = com1.id
// LEFT join sub_communities scom1 on ra.sub_community_id = scom1.id
// LEFT JOIN contacts_address ca ON c.id = ca.contacts_id AND ca.address_type_id = 2
// left join countries cn2 on ra.countries_id = cn2.id
// left join cities ci2 on ra.cities_id = ci2.id
// left join states st2 on ra.states_id = st2.id
// left join communities com2 on ra.community_id = com2.id
// LEFT join sub_communities scom2 on ra.sub_community_id = scom2.id
// LEFT JOIN contacts_company_details ccd ON c.id = ccd.contacts_id AND c.contact_category_id = 1
// left join industry i on ccd.industry_id = i.id
// left join countries n1 on ccd.nationality = n1.id
// left join retail_category rct on ccd.retail_category_id = rct.id
// LEFT JOIN contacts_individual_details cid ON c.id = cid.contacts_id AND c.contact_category_id = 2
// left join professions p on cid.professions_id = p.id
// left join countries n2 on cid.nationality = n2.id
// left join countries idci on cid.id_country_id = idci.id
// left join countries pci on cid.passport_country_id = pci.id
//
//	LEFT JOIN "public"."users" u_created_by ON c.created_by = u_created_by.id
//	LEFT JOIN "public"."users" u_updated_by ON c.updated_by = u_updated_by.id
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(al.language)::varchar[] AS languages
//	    FROM unnest(c.all_languages_id) AS lang_id
//	    JOIN "public"."all_languages" al ON lang_id = al.id
//	) AS languages ON TRUE
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(au.username)::varchar[] AS assigned_usernames
//	    FROM unnest(c.assigned_to) AS assigned_id
//	    JOIN "public"."users" au ON assigned_id = au.id
//	) AS assigned_usernames ON TRUE
//	LEFT JOIN LATERAL (
//	    SELECT array_agg(su.username)::varchar[] AS shared_usernames
//	    FROM unnest(c.shared_with) AS shared_id
//	    JOIN "public"."users" su ON shared_id = su.id
//	) AS shared_usernames ON TRUE
//
// WHERE c.status != 5 AND c.status != 6 AND scd.mobile = $1;
func (q *Queries) GetContactsDocumentByIdAndDocCategory(ctx context.Context, arg GetContactsDocumentByIdAndDocCategoryParams) (ContactsDocument, error) {
	row := q.db.QueryRow(ctx, getContactsDocumentByIdAndDocCategory, arg.ID, arg.DocumentCategoryID)
	var i ContactsDocument
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.DocumentCategoryID,
		&i.ExpiryDate,
		&i.IsPrivate,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Description,
		&i.UpdatedAt,
		&i.Title,
	)
	return i, err
}

const getContactsRefNo = `-- name: GetContactsRefNo :many
select ref_no from  contacts
`

func (q *Queries) GetContactsRefNo(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getContactsRefNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var ref_no string
		if err := rows.Scan(&ref_no); err != nil {
			return nil, err
		}
		items = append(items, ref_no)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllContacts = `-- name: GetCountAllContacts :one


SELECT COUNT(*) FROM contacts WHERE status != 5 AND status != 6
`

// -- name: GetSingleContactByUserId :one
// select * from contacts where users_id = $1;
// -- name: GetSingleContactDetailsByPhoneNumber :one
// SELECT
//
//	c.id AS contact_id,
//	c.users_id,
//	c.ref_no,
//	c.contact_category_id,
//	c.salutation,
//	c.name,
//	c.lastname,
//	c.all_languages_id,
//	c.ejari,
//	c.assigned_to,
//	c.shared_with,
//	c.remarks,
//	c.is_blockedlisted,
//	c.is_vip,
//	c.status,
//	c.created_by,
//	c.contact_platform,
//	c.created_at AS contact_created_at,
//	c.updated_at AS contact_updated_at,
//	c.updated_by AS contact_updated_by,
//	scd.id AS shareable_details_id,
//	scd.mobile,
//	scd.mobile_share,
//	scd.mobile2,
//	scd.mobile2_share,
//	scd.landline,
//	scd.landline_share,
//	scd.fax,
//	scd.fax_share,
//	scd.email,
//	scd.email_share,
//	scd.second_email,
//	scd.second_email_share,
//	scd.added_by AS shareable_added_by,
//	scd.created_at AS shareable_created_at,
//	scd.updated_at AS shareable_updated_at
//
// FROM
//
//	contacts c
//
// JOIN
//
//	shareable_contact_details scd ON c.id = scd.contacts_id
//
// WHERE
//
//	scd.mobile = $1 LIMIT 1;
func (q *Queries) GetCountAllContacts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllContacts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllContactsOtherContactByContactsId = `-- name: GetCountAllContactsOtherContactByContactsId :one
SELECT COUNT(*) FROM contacts_other_contact JOIN contacts on contacts.id = contacts_other_contact.other_contacts_id
WHERE contacts_id = $1 AND contacts.status != 5 AND contacts.status != 6
`

func (q *Queries) GetCountAllContactsOtherContactByContactsId(ctx context.Context, contactsID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllContactsOtherContactByContactsId, contactsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllSingleContactDocuments = `-- name: GetCountAllSingleContactDocuments :one
SELECT
    COUNT(*)
FROM
    contacts_document
WHERE contacts_id = $1
`

func (q *Queries) GetCountAllSingleContactDocuments(ctx context.Context, contactsID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllSingleContactDocuments, contactsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountContactsOtherContactCountByContactsId = `-- name: GetCountContactsOtherContactCountByContactsId :one








SELECT COUNT(*)
FROM contacts_other_contact
WHERE contacts_id = $1
`

// -- name: GetContactDetailsByUserId :one
// SELECT
//
//	c.id AS contact_id,
//	c.users_id,
//	c.ref_no,
//	c.contact_category_id,
//	c.salutation,
//	c.name,
//	c.lastname,
//	c.all_languages_id,
//	c.ejari,
//	c.assigned_to,
//	c.shared_with,
//	c.remarks,
//	c.is_blockedlisted,
//	c.is_vip,
//	c.status,
//	c.created_by,
//	c.contact_platform,
//	c.created_at AS contact_created_at,
//	c.updated_at AS contact_updated_at,
//	c.updated_by AS contact_updated_by,
//	c.direct_markerting,
//	scd.id AS shareable_details_id,
//	scd.contacts_id,
//	scd.mobile,
//	scd.mobile_share,
//	scd.mobile2,
//	scd.mobile2_share,
//	scd.landline,
//	scd.landline_share,
//	scd.fax,
//	scd.fax_share,
//	scd.email,
//	scd.email_share,
//	scd.second_email,
//	scd.second_email_share,
//	scd.added_by AS shareable_added_by,
//	scd.created_at AS shareable_created_at,
//	scd.updated_at AS shareable_updated_at
//
// FROM
//
//	contacts c
//
// JOIN
//
//	shareable_contact_details scd ON c.id = scd.contacts_id
//
// WHERE
//
//	c.users_id = $1 LIMIT 1;
//
// -- name: GetContactDetailsByPhoneNumber :one
// SELECT
//
//	c.id AS contact_id,
//	c.users_id,
//	c.ref_no,
//	c.contact_category_id,
//	c.salutation,
//	c.name,
//	c.lastname,
//	c.all_languages_id,
//	c.ejari,
//	c.assigned_to,
//	c.shared_with,
//	c.remarks,
//	c.is_blockedlisted,
//	c.is_vip,
//	c.status,
//	c.created_by,
//	c.contact_platform,
//	c.created_at AS contact_created_at,
//	c.updated_at AS contact_updated_at,
//	c.updated_by AS contact_updated_by,
//	c.direct_markerting,
//	scd.id AS shareable_details_id,
//	scd.contacts_id,
//	scd.mobile,
//	scd.mobile_share,
//	scd.mobile2,
//	scd.mobile2_share,
//	scd.landline,
//	scd.landline_share,
//	scd.fax,
//	scd.fax_share,
//	scd.email,
//	scd.email_share,
//	scd.second_email,
//	scd.second_email_share,
//	scd.added_by AS shareable_added_by,
//	scd.created_at AS shareable_created_at,
//	scd.updated_at AS shareable_updated_at
//
// FROM
//
//	contacts c
//
// JOIN
//
//	shareable_contact_details scd ON c.id = scd.contacts_id
//
// WHERE
//
//	scd.mobile = $1 AND c.status != 6 LIMIT 1;
//
// -- name: GetContactsIdFromUserId :one
// SELECT
//
//	c.id AS contacts_id
//
// FROM
//
//	contacts c
//
// WHERE
//
//	c.users_id = $1;
//
// -- name: GetSingleContactDetails :one
// SELECT
//
//	c.id AS contact_id,
//	c.users_id,
//	c.ref_no,
//	c.contact_category_id,
//	c.salutation,
//	c.name,
//	c.lastname,
//	c.all_languages_id,
//	c.ejari,
//	c.assigned_to,
//	c.shared_with,
//	c.remarks,
//	c.is_blockedlisted,
//	c.is_vip,
//	c.status,
//	c.created_by,
//	c.contact_platform,
//	c.created_at AS contact_created_at,
//	c.updated_at AS contact_updated_at,
//	c.updated_by AS contact_updated_by,
//	scd.id AS shareable_details_id,
//	scd.mobile,
//	scd.mobile_share,
//	scd.mobile2,
//	scd.mobile2_share,
//	scd.landline,
//	scd.landline_share,
//	scd.fax,
//	scd.fax_share,
//	scd.email,
//	scd.email_share,
//	scd.second_email,
//	scd.second_email_share,
//	scd.added_by AS shareable_added_by,
//	scd.created_at AS shareable_created_at,
//	scd.updated_at AS shareable_updated_at
//
// FROM
//
//	contacts c
//
// JOIN
//
//	shareable_contact_details scd ON c.id = scd.contacts_id
//
// WHERE
//
//	c.id = $1;
//
// -- name: GetContactNamesByIdsExcludingStatus6 :many
// SELECT
//
//	id AS contact_id,
//	name,
//	lastname
//
// FROM
//
//	contacts
//
// WHERE
//
//	id IN ($1)
//	AND status != 6;
//
// -- name: GetSingleContactNameById :one
// SELECT
//
//	id AS contact_id,
//	name,
//	lastname
//
// FROM
//
//	contacts
//
// WHERE
//
//	id = $1;
func (q *Queries) GetCountContactsOtherContactCountByContactsId(ctx context.Context, contactsID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountContactsOtherContactCountByContactsId, contactsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSingleContactDocument = `-- name: GetSingleContactDocument :many
SELECT id, contacts_id, document_category_id, expiry_date, is_private, document_url, created_at, created_by, description, updated_at, title FROM public.contacts_document WHERE id = $1 LIMIT $2
`

type GetSingleContactDocumentParams struct {
	ID    int64 `json:"id"`
	Limit int32 `json:"limit"`
}

func (q *Queries) GetSingleContactDocument(ctx context.Context, arg GetSingleContactDocumentParams) ([]ContactsDocument, error) {
	rows, err := q.db.Query(ctx, getSingleContactDocument, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContactsDocument
	for rows.Next() {
		var i ContactsDocument
		if err := rows.Scan(
			&i.ID,
			&i.ContactsID,
			&i.DocumentCategoryID,
			&i.ExpiryDate,
			&i.IsPrivate,
			&i.DocumentUrl,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Description,
			&i.UpdatedAt,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserIdFromContactsId = `-- name: GetUserIdFromContactsId :one
SELECT
    u.id AS user_id
FROM
    contacts c
JOIN
    profiles p ON c.all_languages_id = p.id
JOIN
    users u ON p.id = u.profiles_id
WHERE
    c.id = $1
`

func (q *Queries) GetUserIdFromContactsId(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIdFromContactsId, id)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const updateContactStatus = `-- name: UpdateContactStatus :one
UPDATE contacts
SET
    status = $2,
    updated_by = $3,
    updated_at = $4
WHERE
    id = $1
RETURNING id, ref_no, salutation, firstname, lastname, status, created_by, created_at, updated_at, updated_by, entity_id, entity_type_id
`

type UpdateContactStatusParams struct {
	ID        int64       `json:"id"`
	Status    int64       `json:"status"`
	UpdatedBy pgtype.Int8 `json:"updated_by"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateContactStatus(ctx context.Context, arg UpdateContactStatusParams) (Contact, error) {
	row := q.db.QueryRow(ctx, updateContactStatus,
		arg.ID,
		arg.Status,
		arg.UpdatedBy,
		arg.UpdatedAt,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Salutation,
		&i.Firstname,
		&i.Lastname,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.EntityID,
		&i.EntityTypeID,
	)
	return i, err
}

const updateContacts = `-- name: UpdateContacts :one
UPDATE contacts
SET ref_no = $2,
    salutation = $3,
    firstname = $4,
    lastname = $5,
    updated_at = $6,
    updated_by = $7
WHERE
    id = $1
RETURNING id, ref_no, salutation, firstname, lastname, status, created_by, created_at, updated_at, updated_by, entity_id, entity_type_id
`

type UpdateContactsParams struct {
	ID         int64       `json:"id"`
	RefNo      string      `json:"ref_no"`
	Salutation string      `json:"salutation"`
	Firstname  string      `json:"firstname"`
	Lastname   string      `json:"lastname"`
	UpdatedAt  time.Time   `json:"updated_at"`
	UpdatedBy  pgtype.Int8 `json:"updated_by"`
}

func (q *Queries) UpdateContacts(ctx context.Context, arg UpdateContactsParams) (Contact, error) {
	row := q.db.QueryRow(ctx, updateContacts,
		arg.ID,
		arg.RefNo,
		arg.Salutation,
		arg.Firstname,
		arg.Lastname,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.Salutation,
		&i.Firstname,
		&i.Lastname,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.EntityID,
		&i.EntityTypeID,
	)
	return i, err
}

const updateContactsAddress = `-- name: UpdateContactsAddress :one
UPDATE contacts_address
SET
    address1 = $3,
    address2 = $4,
    countries_id = $5,
    states_id = $6,
    cities_id = $7,
    community_id = $8,
    sub_community_id = $9,
    postal_code = $10
WHERE
    contacts_id = $1
    AND address_type_id = $2
RETURNING id, contacts_id, address_type_id, address1, address2, countries_id, states_id, cities_id, community_id, sub_community_id, postal_code
`

type UpdateContactsAddressParams struct {
	ContactsID     int64       `json:"contacts_id"`
	AddressTypeID  int64       `json:"address_type_id"`
	Address1       string      `json:"address1"`
	Address2       string      `json:"address2"`
	CountriesID    int64       `json:"countries_id"`
	StatesID       pgtype.Int8 `json:"states_id"`
	CitiesID       pgtype.Int8 `json:"cities_id"`
	CommunityID    pgtype.Int8 `json:"community_id"`
	SubCommunityID pgtype.Int8 `json:"sub_community_id"`
	PostalCode     int64       `json:"postal_code"`
}

func (q *Queries) UpdateContactsAddress(ctx context.Context, arg UpdateContactsAddressParams) (ContactsAddress, error) {
	row := q.db.QueryRow(ctx, updateContactsAddress,
		arg.ContactsID,
		arg.AddressTypeID,
		arg.Address1,
		arg.Address2,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.CommunityID,
		arg.SubCommunityID,
		arg.PostalCode,
	)
	var i ContactsAddress
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.AddressTypeID,
		&i.Address1,
		&i.Address2,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubCommunityID,
		&i.PostalCode,
	)
	return i, err
}

const updateContactsAddressByContactsId = `-- name: UpdateContactsAddressByContactsId :exec
UPDATE contacts_address
SET
    address_type_id = $2,
    address1 = $3,
    address2 = $4,
    countries_id = $5,
    states_id = $6,
    cities_id = $7,
    postal_code = $8
WHERE
    contacts_id = $1
`

type UpdateContactsAddressByContactsIdParams struct {
	ContactsID    int64       `json:"contacts_id"`
	AddressTypeID int64       `json:"address_type_id"`
	Address1      string      `json:"address1"`
	Address2      string      `json:"address2"`
	CountriesID   int64       `json:"countries_id"`
	StatesID      pgtype.Int8 `json:"states_id"`
	CitiesID      pgtype.Int8 `json:"cities_id"`
	PostalCode    int64       `json:"postal_code"`
}

func (q *Queries) UpdateContactsAddressByContactsId(ctx context.Context, arg UpdateContactsAddressByContactsIdParams) error {
	_, err := q.db.Exec(ctx, updateContactsAddressByContactsId,
		arg.ContactsID,
		arg.AddressTypeID,
		arg.Address1,
		arg.Address2,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.PostalCode,
	)
	return err
}

const updateContactsDocument = `-- name: UpdateContactsDocument :one
UPDATE contacts_document
SET
    contacts_id = $2,
    document_category_id = $3,
    document_url = $4,
    is_private = $5
WHERE
    id = $1
RETURNING id, contacts_id, document_category_id, is_private, document_url
`

type UpdateContactsDocumentParams struct {
	ID                 int64       `json:"id"`
	ContactsID         pgtype.Int8 `json:"contacts_id"`
	DocumentCategoryID int64       `json:"document_category_id"`
	DocumentUrl        string      `json:"document_url"`
	IsPrivate          bool        `json:"is_private"`
}

type UpdateContactsDocumentRow struct {
	ID                 int64       `json:"id"`
	ContactsID         pgtype.Int8 `json:"contacts_id"`
	DocumentCategoryID int64       `json:"document_category_id"`
	IsPrivate          bool        `json:"is_private"`
	DocumentUrl        string      `json:"document_url"`
}

func (q *Queries) UpdateContactsDocument(ctx context.Context, arg UpdateContactsDocumentParams) (UpdateContactsDocumentRow, error) {
	row := q.db.QueryRow(ctx, updateContactsDocument,
		arg.ID,
		arg.ContactsID,
		arg.DocumentCategoryID,
		arg.DocumentUrl,
		arg.IsPrivate,
	)
	var i UpdateContactsDocumentRow
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.DocumentCategoryID,
		&i.IsPrivate,
		&i.DocumentUrl,
	)
	return i, err
}

const updateContactsDocumentPrivacy = `-- name: UpdateContactsDocumentPrivacy :one

UPDATE contacts_document
SET
    is_private = $2
WHERE
    id = $1
RETURNING id, contacts_id, document_category_id, is_private, document_url
`

type UpdateContactsDocumentPrivacyParams struct {
	ID        int64 `json:"id"`
	IsPrivate bool  `json:"is_private"`
}

type UpdateContactsDocumentPrivacyRow struct {
	ID                 int64       `json:"id"`
	ContactsID         pgtype.Int8 `json:"contacts_id"`
	DocumentCategoryID int64       `json:"document_category_id"`
	IsPrivate          bool        `json:"is_private"`
	DocumentUrl        string      `json:"document_url"`
}

// -- name: UpdateContactsAddressCD :exec
// UPDATE contacts_address
// SET
//
//	correspondence = $3,
//	direct_markerting = $4
//
// WHERE
//
//	contacts_id = $1
//	AND address_type_id = $2
//
// RETURNING *;
func (q *Queries) UpdateContactsDocumentPrivacy(ctx context.Context, arg UpdateContactsDocumentPrivacyParams) (UpdateContactsDocumentPrivacyRow, error) {
	row := q.db.QueryRow(ctx, updateContactsDocumentPrivacy, arg.ID, arg.IsPrivate)
	var i UpdateContactsDocumentPrivacyRow
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.DocumentCategoryID,
		&i.IsPrivate,
		&i.DocumentUrl,
	)
	return i, err
}

const updateContactsIndividualDetail = `-- name: UpdateContactsIndividualDetail :one
UPDATE contacts_individual_details
SET
    comapanies_id = $2,
    company_category = $3,
    is_branch = $4,
    date_of_birth = $5,
    professions_id = $6,
    gender = $7,
    marital_status = $8,
    nationality = $9,
    id_type = $10,
    id_number = $11,
    id_country_id = $12,
    id_issued_date = $13,
    id_expiry_date = $14,
    passport_number = $15,
    passport_country_id = $16,
    passport_issued_date = $17,
    passport_expiry_date = $18,
    interests = $19
WHERE
    contacts_id = $1
RETURNING id, contacts_id, comapanies_id, company_category, is_branch, date_of_birth, professions_id, gender, marital_status, nationality, id_type, id_number, id_country_id, id_issued_date, id_expiry_date, passport_number, passport_country_id, passport_issued_date, passport_expiry_date, interests
`

type UpdateContactsIndividualDetailParams struct {
	ContactsID         int64              `json:"contacts_id"`
	ComapaniesID       int64              `json:"comapanies_id"`
	CompanyCategory    int64              `json:"company_category"`
	IsBranch           pgtype.Bool        `json:"is_branch"`
	DateOfBirth        pgtype.Timestamptz `json:"date_of_birth"`
	ProfessionsID      pgtype.Int8        `json:"professions_id"`
	Gender             pgtype.Text        `json:"gender"`
	MaritalStatus      pgtype.Int8        `json:"marital_status"`
	Nationality        pgtype.Int8        `json:"nationality"`
	IDType             pgtype.Int8        `json:"id_type"`
	IDNumber           pgtype.Text        `json:"id_number"`
	IDCountryID        pgtype.Int8        `json:"id_country_id"`
	IDIssuedDate       pgtype.Timestamptz `json:"id_issued_date"`
	IDExpiryDate       pgtype.Timestamptz `json:"id_expiry_date"`
	PassportNumber     pgtype.Text        `json:"passport_number"`
	PassportCountryID  pgtype.Int8        `json:"passport_country_id"`
	PassportIssuedDate pgtype.Timestamptz `json:"passport_issued_date"`
	PassportExpiryDate pgtype.Timestamptz `json:"passport_expiry_date"`
	Interests          pgtype.Text        `json:"interests"`
}

func (q *Queries) UpdateContactsIndividualDetail(ctx context.Context, arg UpdateContactsIndividualDetailParams) (ContactsIndividualDetail, error) {
	row := q.db.QueryRow(ctx, updateContactsIndividualDetail,
		arg.ContactsID,
		arg.ComapaniesID,
		arg.CompanyCategory,
		arg.IsBranch,
		arg.DateOfBirth,
		arg.ProfessionsID,
		arg.Gender,
		arg.MaritalStatus,
		arg.Nationality,
		arg.IDType,
		arg.IDNumber,
		arg.IDCountryID,
		arg.IDIssuedDate,
		arg.IDExpiryDate,
		arg.PassportNumber,
		arg.PassportCountryID,
		arg.PassportIssuedDate,
		arg.PassportExpiryDate,
		arg.Interests,
	)
	var i ContactsIndividualDetail
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.ComapaniesID,
		&i.CompanyCategory,
		&i.IsBranch,
		&i.DateOfBirth,
		&i.ProfessionsID,
		&i.Gender,
		&i.MaritalStatus,
		&i.Nationality,
		&i.IDType,
		&i.IDNumber,
		&i.IDCountryID,
		&i.IDIssuedDate,
		&i.IDExpiryDate,
		&i.PassportNumber,
		&i.PassportCountryID,
		&i.PassportIssuedDate,
		&i.PassportExpiryDate,
		&i.Interests,
	)
	return i, err
}

const updateShareableDetails = `-- name: UpdateShareableDetails :one
UPDATE shareable_contact_details
SET
    mobile = $2,
    mobile_share = $3,
    mobile2 = $4,
    mobile2_share = $5,
    landline = $6,
    landline_share = $7,
    fax = $8,
    fax_share = $9,
    email = $10,
    email_share = $11,
    second_email = $12,
    second_email_share = $13,
    updated_at = $14
WHERE contacts_id = $1
RETURNING id, contacts_id, mobile, mobile_share, mobile2, mobile2_share, landline, landline_share, fax, fax_share, email, email_share, second_email, second_email_share, added_by, created_at, updated_at
`

type UpdateShareableDetailsParams struct {
	ContactsID       int64     `json:"contacts_id"`
	Mobile           string    `json:"mobile"`
	MobileShare      bool      `json:"mobile_share"`
	Mobile2          string    `json:"mobile2"`
	Mobile2Share     bool      `json:"mobile2_share"`
	Landline         string    `json:"landline"`
	LandlineShare    bool      `json:"landline_share"`
	Fax              string    `json:"fax"`
	FaxShare         bool      `json:"fax_share"`
	Email            string    `json:"email"`
	EmailShare       bool      `json:"email_share"`
	SecondEmail      string    `json:"second_email"`
	SecondEmailShare bool      `json:"second_email_share"`
	UpdatedAt        time.Time `json:"updated_at"`
}

func (q *Queries) UpdateShareableDetails(ctx context.Context, arg UpdateShareableDetailsParams) (ShareableContactDetail, error) {
	row := q.db.QueryRow(ctx, updateShareableDetails,
		arg.ContactsID,
		arg.Mobile,
		arg.MobileShare,
		arg.Mobile2,
		arg.Mobile2Share,
		arg.Landline,
		arg.LandlineShare,
		arg.Fax,
		arg.FaxShare,
		arg.Email,
		arg.EmailShare,
		arg.SecondEmail,
		arg.SecondEmailShare,
		arg.UpdatedAt,
	)
	var i ShareableContactDetail
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.Mobile,
		&i.MobileShare,
		&i.Mobile2,
		&i.Mobile2Share,
		&i.Landline,
		&i.LandlineShare,
		&i.Fax,
		&i.FaxShare,
		&i.Email,
		&i.EmailShare,
		&i.SecondEmail,
		&i.SecondEmailShare,
		&i.AddedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSingleContactsOtherContact = `-- name: UpdateSingleContactsOtherContact :one


UPDATE contacts_other_contact SET other_contacts_id = $2, relationship = $3
WHERE id = $1 RETURNING id, contacts_id, relationship, other_contacts_id, date_added
`

type UpdateSingleContactsOtherContactParams struct {
	ID              int64  `json:"id"`
	OtherContactsID int64  `json:"other_contacts_id"`
	Relationship    string `json:"relationship"`
}

// -- name: GetSingleContactNamesByIdExcludingStatus6 :one
// SELECT
//
//	id AS contact_id,
//	name,
//	lastname
//
// FROM
//
//	contacts
//
// WHERE
//
//	id = $1
//	AND status != 6;
//
// -- name: GetListOfContactNamesByIdsExcludingStatus6 :many
// SELECT
//
//	id AS contact_id,
//	name,
//	lastname
//
// FROM
//
//	contacts
//
// WHERE
//
//	id = ANY($1::bigint[])
//	AND status != 6;
func (q *Queries) UpdateSingleContactsOtherContact(ctx context.Context, arg UpdateSingleContactsOtherContactParams) (ContactsOtherContact, error) {
	row := q.db.QueryRow(ctx, updateSingleContactsOtherContact, arg.ID, arg.OtherContactsID, arg.Relationship)
	var i ContactsOtherContact
	err := row.Scan(
		&i.ID,
		&i.ContactsID,
		&i.Relationship,
		&i.OtherContactsID,
		&i.DateAdded,
	)
	return i, err
}
