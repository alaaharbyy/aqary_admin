// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: company_types.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompanyType = `-- name: CreateCompanyType :one
INSERT INTO company_types (
    title,
    title_ar
)VALUES (
    $1,$2
) RETURNING id, title, image_url, created_at, updated_at, title_ar
`

type CreateCompanyTypeParams struct {
	Title   string      `json:"title"`
	TitleAr pgtype.Text `json:"title_ar"`
}

func (q *Queries) CreateCompanyType(ctx context.Context, arg CreateCompanyTypeParams) (CompanyType, error) {
	row := q.db.QueryRow(ctx, createCompanyType, arg.Title, arg.TitleAr)
	var i CompanyType
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const deleteCompanyType = `-- name: DeleteCompanyType :exec
DELETE FROM company_types
Where id = $1
`

func (q *Queries) DeleteCompanyType(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCompanyType, id)
	return err
}

const getACompanyMainInfo = `-- name: GetACompanyMainInfo :one






SELECT users_id, c.id AS company_id, c.users_id, 1 AS company_type, false AS is_branch
FROM companies c
WHERE  c.id =  $1
`

type GetACompanyMainInfoRow struct {
	UsersID     int64       `json:"users_id"`
	CompanyID   int64       `json:"company_id"`
	UsersID_2   int64       `json:"users_id_2"`
	CompanyType pgtype.Int8 `json:"company_type"`
	IsBranch    pgtype.Bool `json:"is_branch"`
}

// -- name: UpdateTypesRelatedCompanies :one
//
//	WITH bc AS (
//	UPDATE broker_companies
//	SET main_services_id = null
//	WHERE broker_companies.main_services_id = $1
//	RETURNING *
//
// ),
//
//	dc AS (
//
// UPDATE developer_companies
//
//	SET  main_services_id = null
//	WHERE developer_companies.main_services_id = $1
//	RETURNING *
//
// ),
//
//	sc AS (
//
// UPDATE services_companies
//
//	SET  main_services_id = null
//	WHERE services_companies.main_services_id = $1
//	RETURNING *
//
// ),
//
//	bcb AS (
//
// UPDATE broker_companies_branches
//
//	SET main_services_id = null
//	WHERE broker_companies_branches.main_services_id = $1
//	RETURNING *
//
// ),
//
//	dcb AS (
//
// UPDATE developer_company_branches
//
//	SET  main_services_id = null
//	WHERE developer_company_branches.main_services_id = $1
//	RETURNING *
//
// ),
//
//	scb AS (
//
// UPDATE service_company_branches
//
//	SET   main_services_id = null
//	WHERE  service_company_branches.main_services_id = $1
//	RETURNING *
//
// )
// SELECT id, main_services_id FROM bc
// UNION ALL
// SELECT id, main_services_id FROM dc
// UNION ALL
// SELECT id, main_services_id FROM sc
// UNION ALL
// SELECT id, main_services_id FROM bcb
// UNION ALL
// SELECT id, main_services_id FROM dcb
// UNION ALL
// SELECT id, main_services_id FROM scb;
func (q *Queries) GetACompanyMainInfo(ctx context.Context, companyID int64) (GetACompanyMainInfoRow, error) {
	row := q.db.QueryRow(ctx, getACompanyMainInfo, companyID)
	var i GetACompanyMainInfoRow
	err := row.Scan(
		&i.UsersID,
		&i.CompanyID,
		&i.UsersID_2,
		&i.CompanyType,
		&i.IsBranch,
	)
	return i, err
}

const getAllCompanyType = `-- name: GetAllCompanyType :many
SELECT 
    COUNT(*) OVER() AS total_count,
    company_types.id, company_types.title, company_types.image_url, company_types.created_at, company_types.updated_at, company_types.title_ar
FROM company_types
ORDER BY company_types.updated_at DESC 
LIMIT COALESCE(NULLIF($1, 0), NULL) 
OFFSET COALESCE(NULLIF($2, 0), 0)
`

type GetAllCompanyTypeParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

type GetAllCompanyTypeRow struct {
	TotalCount int64       `json:"total_count"`
	ID         int64       `json:"id"`
	Title      string      `json:"title"`
	ImageUrl   pgtype.Text `json:"image_url"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	TitleAr    pgtype.Text `json:"title_ar"`
}

func (q *Queries) GetAllCompanyType(ctx context.Context, arg GetAllCompanyTypeParams) ([]GetAllCompanyTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyType, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyTypeRow
	for rows.Next() {
		var i GetAllCompanyTypeRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.Title,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyTypeWithoutPagination = `-- name: GetAllCompanyTypeWithoutPagination :many
SELECT 
    id,
    image_url,
    CASE 
        WHEN $1::varchar = 'ar' THEN COALESCE(title_ar,title)
    ELSE COALESCE(title, '') END::varchar AS title
FROM company_types
`

type GetAllCompanyTypeWithoutPaginationRow struct {
	ID       int64       `json:"id"`
	ImageUrl pgtype.Text `json:"image_url"`
	Title    string      `json:"title"`
}

func (q *Queries) GetAllCompanyTypeWithoutPagination(ctx context.Context, lang string) ([]GetAllCompanyTypeWithoutPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyTypeWithoutPagination, lang)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyTypeWithoutPaginationRow
	for rows.Next() {
		var i GetAllCompanyTypeWithoutPaginationRow
		if err := rows.Scan(&i.ID, &i.ImageUrl, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyType = `-- name: GetCompanyType :one
SELECT id, title, image_url, created_at, updated_at, title_ar FROM company_types 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCompanyType(ctx context.Context, id int64) (CompanyType, error) {
	row := q.db.QueryRow(ctx, getCompanyType, id)
	var i CompanyType
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const getCompanyTypeByTitle = `-- name: GetCompanyTypeByTitle :one
SELECT id, title, image_url, created_at, updated_at, title_ar FROM company_types 
WHERE title = $1 LIMIT 1
`

func (q *Queries) GetCompanyTypeByTitle(ctx context.Context, title string) (CompanyType, error) {
	row := q.db.QueryRow(ctx, getCompanyTypeByTitle, title)
	var i CompanyType
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const getCountCompanyTypes = `-- name: GetCountCompanyTypes :one
SELECT COUNT(*) FROM company_types
`

func (q *Queries) GetCountCompanyTypes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountCompanyTypes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateCompanyType = `-- name: UpdateCompanyType :one
UPDATE company_types
SET 
title = $2,
title_ar=$3,
updated_at=now()
Where id = $1
RETURNING id, title, image_url, created_at, updated_at, title_ar
`

type UpdateCompanyTypeParams struct {
	ID      int64       `json:"id"`
	Title   string      `json:"title"`
	TitleAr pgtype.Text `json:"title_ar"`
}

func (q *Queries) UpdateCompanyType(ctx context.Context, arg UpdateCompanyTypeParams) (CompanyType, error) {
	row := q.db.QueryRow(ctx, updateCompanyType, arg.ID, arg.Title, arg.TitleAr)
	var i CompanyType
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}
