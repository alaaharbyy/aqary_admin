// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: units.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkIfUnitExistByRefNo = `-- name: CheckIfUnitExistByRefNo :one
SELECT EXISTS(
SELECT 1 FROM units
INNER JOIN unit_versions ON unit_versions.unit_id = units.id AND unit_versions.is_main IS TRUE
WHERE unit_versions.ref_no = $1
)::boolean AS is_unit_exist
`

func (q *Queries) CheckIfUnitExistByRefNo(ctx context.Context, refNo string) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfUnitExistByRefNo, refNo)
	var is_unit_exist bool
	err := row.Scan(&is_unit_exist)
	return is_unit_exist, err
}

const deleteXMLUnitVersions = `-- name: DeleteXMLUnitVersions :exec
DELETE FROM unit_versions
USING units
WHERE units.id = unit_versions.unit_id
  AND units.from_xml IS TRUE
  AND unit_versions.id = ANY($1::bigint[])
`

func (q *Queries) DeleteXMLUnitVersions(ctx context.Context, idsToDelete []int64) error {
	_, err := q.db.Exec(ctx, deleteXMLUnitVersions, idsToDelete)
	return err
}

const deleteXMLUnits = `-- name: DeleteXMLUnits :exec
DELETE FROM units
WHERE id = ANY($1::bigint[]) AND from_xml IS TRUE
`

func (q *Queries) DeleteXMLUnits(ctx context.Context, idsToDelete []int64) error {
	_, err := q.db.Exec(ctx, deleteXMLUnits, idsToDelete)
	return err
}

const disableExpiredExclusiveUnitVersions = `-- name: DisableExpiredExclusiveUnitVersions :exec
UPDATE unit_versions
SET "exclusive" = FALSE
WHERE "exclusive" IS TRUE AND end_date < now()
`

func (q *Queries) DisableExpiredExclusiveUnitVersions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, disableExpiredExclusiveUnitVersions)
	return err
}

const getActiveUnitTypeByTypeAndUsage = `-- name: GetActiveUnitTypeByTypeAndUsage :one
SELECT id, type, code, facts, listing_facts, usage, created_at, updated_at, status, icon, type_ar FROM unit_type 
WHERE LOWER(TRIM("type")) = LOWER(TRIM($1::text)) AND usage = $2::bigint AND status = 2
`

type GetActiveUnitTypeByTypeAndUsageParams struct {
	UnitType string `json:"unit_type"`
	Usage    int64  `json:"usage"`
}

func (q *Queries) GetActiveUnitTypeByTypeAndUsage(ctx context.Context, arg GetActiveUnitTypeByTypeAndUsageParams) (UnitType, error) {
	row := q.db.QueryRow(ctx, getActiveUnitTypeByTypeAndUsage, arg.UnitType, arg.Usage)
	var i UnitType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.Facts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.TypeAr,
	)
	return i, err
}

const getUnitByRefNo = `-- name: GetUnitByRefNo :one
SELECT units.id, unit_no, unitno_is_public, notes, unit_title, units.description, units.description_arabic, unit_title_arabic, notes_arabic, notes_public, units.is_verified, entity_type_id, entity_id, units.created_at, units.updated_at, addresses_id, unit_type_id, units.created_by, units.updated_by, type_name_id, owner_users_id, from_xml, company_id, units.status, units.facts, is_project_unit, units.exclusive, units.start_date, units.end_date, unit_versions.id, title, views_count, title_arabic, unit_versions.description, unit_versions.description_arabic, unit_id, ref_no, unit_versions.status, type, unit_rank, unit_versions.created_at, unit_versions.updated_at, unit_versions.created_by, unit_versions.updated_by, unit_versions.facts, listed_by, has_gallery, has_plans, is_main, unit_versions.is_verified, unit_versions.exclusive, unit_versions.start_date, unit_versions.end_date, slug, is_hotdeal, refreshed_at FROM units
INNER JOIN unit_versions ON unit_versions.unit_id = units.id AND unit_versions.is_main IS TRUE
WHERE unit_versions.ref_no = $1
`

type GetUnitByRefNoRow struct {
	ID                  int64              `json:"id"`
	UnitNo              string             `json:"unit_no"`
	UnitnoIsPublic      pgtype.Bool        `json:"unitno_is_public"`
	Notes               string             `json:"notes"`
	UnitTitle           string             `json:"unit_title"`
	Description         string             `json:"description"`
	DescriptionArabic   string             `json:"description_arabic"`
	UnitTitleArabic     string             `json:"unit_title_arabic"`
	NotesArabic         string             `json:"notes_arabic"`
	NotesPublic         pgtype.Bool        `json:"notes_public"`
	IsVerified          pgtype.Bool        `json:"is_verified"`
	EntityTypeID        pgtype.Int8        `json:"entity_type_id"`
	EntityID            pgtype.Int8        `json:"entity_id"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	AddressesID         int64              `json:"addresses_id"`
	UnitTypeID          int64              `json:"unit_type_id"`
	CreatedBy           int64              `json:"created_by"`
	UpdatedBy           int64              `json:"updated_by"`
	TypeNameID          pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	Status              int64              `json:"status"`
	Facts               []byte             `json:"facts"`
	IsProjectUnit       pgtype.Bool        `json:"is_project_unit"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	ID_2                int64              `json:"id_2"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	UnitID              int64              `json:"unit_id"`
	RefNo               string             `json:"ref_no"`
	Status_2            int64              `json:"status_2"`
	Type                int64              `json:"type"`
	UnitRank            int64              `json:"unit_rank"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	CreatedBy_2         int64              `json:"created_by_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	Facts_2             []byte             `json:"facts_2"`
	ListedBy            int64              `json:"listed_by"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified_2        bool               `json:"is_verified_2"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
}

func (q *Queries) GetUnitByRefNo(ctx context.Context, refNo string) (GetUnitByRefNoRow, error) {
	row := q.db.QueryRow(ctx, getUnitByRefNo, refNo)
	var i GetUnitByRefNoRow
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.UnitTitle,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitTitleArabic,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.EntityTypeID,
		&i.EntityID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressesID,
		&i.UnitTypeID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.TypeNameID,
		&i.OwnerUsersID,
		&i.FromXml,
		&i.CompanyID,
		&i.Status,
		&i.Facts,
		&i.IsProjectUnit,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.ID_2,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description_2,
		&i.DescriptionArabic_2,
		&i.UnitID,
		&i.RefNo,
		&i.Status_2,
		&i.Type,
		&i.UnitRank,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.CreatedBy_2,
		&i.UpdatedBy_2,
		&i.Facts_2,
		&i.ListedBy,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified_2,
		&i.Exclusive_2,
		&i.StartDate_2,
		&i.EndDate_2,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const getUnitDetailsForQualityScore = `-- name: GetUnitDetailsForQualityScore :one
SELECT unit_versions.title, unit_versions.description, unit_versions.unit_id, unit_versions.type, units.addresses_id FROM unit_versions
INNER JOIN units ON units.id = unit_versions.unit_id WHERE units.id = $1 AND unit_versions.type = $2
`

type GetUnitDetailsForQualityScoreParams struct {
	UnitID int64 `json:"unit_id"`
	Type   int64 `json:"type"`
}

type GetUnitDetailsForQualityScoreRow struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	UnitID      int64  `json:"unit_id"`
	Type        int64  `json:"type"`
	AddressesID int64  `json:"addresses_id"`
}

func (q *Queries) GetUnitDetailsForQualityScore(ctx context.Context, arg GetUnitDetailsForQualityScoreParams) (GetUnitDetailsForQualityScoreRow, error) {
	row := q.db.QueryRow(ctx, getUnitDetailsForQualityScore, arg.UnitID, arg.Type)
	var i GetUnitDetailsForQualityScoreRow
	err := row.Scan(
		&i.Title,
		&i.Description,
		&i.UnitID,
		&i.Type,
		&i.AddressesID,
	)
	return i, err
}

const getUnitTypeByTypeAndUsage = `-- name: GetUnitTypeByTypeAndUsage :one
SELECT id, type, code, facts, listing_facts, usage, created_at, updated_at, status, icon, type_ar FROM unit_type 
WHERE LOWER(TRIM("type")) = LOWER(TRIM($1::text)) AND usage = $2::bigint
`

type GetUnitTypeByTypeAndUsageParams struct {
	UnitType string `json:"unit_type"`
	Usage    int64  `json:"usage"`
}

func (q *Queries) GetUnitTypeByTypeAndUsage(ctx context.Context, arg GetUnitTypeByTypeAndUsageParams) (UnitType, error) {
	row := q.db.QueryRow(ctx, getUnitTypeByTypeAndUsage, arg.UnitType, arg.Usage)
	var i UnitType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.Facts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.TypeAr,
	)
	return i, err
}

const getUnits = `-- name: GetUnits :one
SELECT id, unit_no, unitno_is_public, notes, unit_title, description, description_arabic, unit_title_arabic, notes_arabic, notes_public, is_verified, entity_type_id, entity_id, created_at, updated_at, addresses_id, unit_type_id, created_by, updated_by, type_name_id, owner_users_id, from_xml, company_id, status, facts, is_project_unit, exclusive, start_date, end_date FROM units
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUnits(ctx context.Context, id int64) (Unit, error) {
	row := q.db.QueryRow(ctx, getUnits, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.UnitNo,
		&i.UnitnoIsPublic,
		&i.Notes,
		&i.UnitTitle,
		&i.Description,
		&i.DescriptionArabic,
		&i.UnitTitleArabic,
		&i.NotesArabic,
		&i.NotesPublic,
		&i.IsVerified,
		&i.EntityTypeID,
		&i.EntityID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressesID,
		&i.UnitTypeID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.TypeNameID,
		&i.OwnerUsersID,
		&i.FromXml,
		&i.CompanyID,
		&i.Status,
		&i.Facts,
		&i.IsProjectUnit,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getXMLUnitIDsToDeleteByEntity = `-- name: GetXMLUnitIDsToDeleteByEntity :one
SELECT 
array_agg(units.id)::bigint[] AS unit_ids,
array_agg(unit_versions.id)::bigint[] AS unit_version_ids
FROM units
INNER JOIN unit_versions ON unit_versions.unit_id = units.id
WHERE from_xml IS TRUE
AND units.entity_id = ANY($1::bigint[])
AND units.entity_type_id = $2::bigint
`

type GetXMLUnitIDsToDeleteByEntityParams struct {
	EntityIds    []int64 `json:"entity_ids"`
	EntityTypeID int64   `json:"entity_type_id"`
}

type GetXMLUnitIDsToDeleteByEntityRow struct {
	UnitIds        []int64 `json:"unit_ids"`
	UnitVersionIds []int64 `json:"unit_version_ids"`
}

func (q *Queries) GetXMLUnitIDsToDeleteByEntity(ctx context.Context, arg GetXMLUnitIDsToDeleteByEntityParams) (GetXMLUnitIDsToDeleteByEntityRow, error) {
	row := q.db.QueryRow(ctx, getXMLUnitIDsToDeleteByEntity, arg.EntityIds, arg.EntityTypeID)
	var i GetXMLUnitIDsToDeleteByEntityRow
	err := row.Scan(&i.UnitIds, &i.UnitVersionIds)
	return i, err
}

const getXMLUnitIDsToDeleteByRefNoAndEntity = `-- name: GetXMLUnitIDsToDeleteByRefNoAndEntity :one
SELECT 
array_agg(units.id)::bigint[] AS unit_ids,
array_agg(unit_versions.id)::bigint[] AS unit_version_ids
FROM units
INNER JOIN unit_versions ON unit_versions.unit_id = units.id
WHERE from_xml IS TRUE 
AND unit_versions.ref_no != ALL($1::varchar[])
AND units.entity_id = $2::bigint
AND units.entity_type_id = $3::bigint
`

type GetXMLUnitIDsToDeleteByRefNoAndEntityParams struct {
	IgnoreRefNos []string `json:"ignore_ref_nos"`
	EntityID     int64    `json:"entity_id"`
	EntityTypeID int64    `json:"entity_type_id"`
}

type GetXMLUnitIDsToDeleteByRefNoAndEntityRow struct {
	UnitIds        []int64 `json:"unit_ids"`
	UnitVersionIds []int64 `json:"unit_version_ids"`
}

func (q *Queries) GetXMLUnitIDsToDeleteByRefNoAndEntity(ctx context.Context, arg GetXMLUnitIDsToDeleteByRefNoAndEntityParams) (GetXMLUnitIDsToDeleteByRefNoAndEntityRow, error) {
	row := q.db.QueryRow(ctx, getXMLUnitIDsToDeleteByRefNoAndEntity, arg.IgnoreRefNos, arg.EntityID, arg.EntityTypeID)
	var i GetXMLUnitIDsToDeleteByRefNoAndEntityRow
	err := row.Scan(&i.UnitIds, &i.UnitVersionIds)
	return i, err
}

const makeUnitVersionVerified = `-- name: MakeUnitVersionVerified :exec
UPDATE
    unit_versions
SET
    is_verified = true, 
    updated_at=$1, 
    updated_by=$2 
WHERE
    id = $3 :: BIGINT AND status!=6
`

type MakeUnitVersionVerifiedParams struct {
	UpdatedAt     time.Time `json:"updated_at"`
	UpdatedBy     int64     `json:"updated_by"`
	UnitVersionID int64     `json:"unit_version_id"`
}

func (q *Queries) MakeUnitVersionVerified(ctx context.Context, arg MakeUnitVersionVerifiedParams) error {
	_, err := q.db.Exec(ctx, makeUnitVersionVerified, arg.UpdatedAt, arg.UpdatedBy, arg.UnitVersionID)
	return err
}
