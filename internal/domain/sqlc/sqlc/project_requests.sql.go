// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_requests.sql

package sqlc

import (
	"context"
	"time"
)

const createProjectRequests = `-- name: CreateProjectRequests :one
INSERT INTO project_requests (
    request_type,
    profiles_id,
    projects_id,
    created_at,
    updated_at,
    status,
    ref_no,
    users_id
)VALUES (
    $1, $2, $3, $4, $5, $6, $7 , $8
) RETURNING id, request_type, profiles_id, projects_id, created_at, updated_at, status, ref_no, users_id
`

type CreateProjectRequestsParams struct {
	RequestType int64     `json:"request_type"`
	ProfilesID  int64     `json:"profiles_id"`
	ProjectsID  int64     `json:"projects_id"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Status      int64     `json:"status"`
	RefNo       string    `json:"ref_no"`
	UsersID     int64     `json:"users_id"`
}

func (q *Queries) CreateProjectRequests(ctx context.Context, arg CreateProjectRequestsParams) (ProjectRequest, error) {
	row := q.db.QueryRow(ctx, createProjectRequests,
		arg.RequestType,
		arg.ProfilesID,
		arg.ProjectsID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.RefNo,
		arg.UsersID,
	)
	var i ProjectRequest
	err := row.Scan(
		&i.ID,
		&i.RequestType,
		&i.ProfilesID,
		&i.ProjectsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.RefNo,
		&i.UsersID,
	)
	return i, err
}

const deleteProjectRequests = `-- name: DeleteProjectRequests :exec
DELETE FROM project_requests
Where id = $1
`

func (q *Queries) DeleteProjectRequests(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectRequests, id)
	return err
}

const getAllProjectRequests = `-- name: GetAllProjectRequests :many
SELECT id, request_type, profiles_id, projects_id, created_at, updated_at, status, ref_no, users_id FROM project_requests
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllProjectRequestsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProjectRequests(ctx context.Context, arg GetAllProjectRequestsParams) ([]ProjectRequest, error) {
	rows, err := q.db.Query(ctx, getAllProjectRequests, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectRequest
	for rows.Next() {
		var i ProjectRequest
		if err := rows.Scan(
			&i.ID,
			&i.RequestType,
			&i.ProfilesID,
			&i.ProjectsID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.RefNo,
			&i.UsersID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRequests = `-- name: GetProjectRequests :one
SELECT id, request_type, profiles_id, projects_id, created_at, updated_at, status, ref_no, users_id FROM project_requests
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetProjectRequests(ctx context.Context, limit int32) (ProjectRequest, error) {
	row := q.db.QueryRow(ctx, getProjectRequests, limit)
	var i ProjectRequest
	err := row.Scan(
		&i.ID,
		&i.RequestType,
		&i.ProfilesID,
		&i.ProjectsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.RefNo,
		&i.UsersID,
	)
	return i, err
}

const updateProjectRequests = `-- name: UpdateProjectRequests :one
UPDATE project_requests
SET     request_type = $2,
    profiles_id = $3,
    projects_id = $4,
    created_at = $5,
    updated_at = $6,
     status = $7,
    ref_no = $8,
    users_id = $9
Where id = $1
RETURNING id, request_type, profiles_id, projects_id, created_at, updated_at, status, ref_no, users_id
`

type UpdateProjectRequestsParams struct {
	ID          int64     `json:"id"`
	RequestType int64     `json:"request_type"`
	ProfilesID  int64     `json:"profiles_id"`
	ProjectsID  int64     `json:"projects_id"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Status      int64     `json:"status"`
	RefNo       string    `json:"ref_no"`
	UsersID     int64     `json:"users_id"`
}

func (q *Queries) UpdateProjectRequests(ctx context.Context, arg UpdateProjectRequestsParams) (ProjectRequest, error) {
	row := q.db.QueryRow(ctx, updateProjectRequests,
		arg.ID,
		arg.RequestType,
		arg.ProfilesID,
		arg.ProjectsID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.RefNo,
		arg.UsersID,
	)
	var i ProjectRequest
	err := row.Scan(
		&i.ID,
		&i.RequestType,
		&i.ProfilesID,
		&i.ProjectsID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.RefNo,
		&i.UsersID,
	)
	return i, err
}
