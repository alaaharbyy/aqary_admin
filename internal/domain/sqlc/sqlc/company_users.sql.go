// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: company_users.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllCompanyUsersByStatus = `-- name: CountAllCompanyUsersByStatus :one
SELECT
	COUNT(company_users.id)
	FROM
	company_users
	LEFT JOIN users ON company_users.users_id = users.id
	LEFT JOIN profiles ON profiles.users_id = users.id 
	LEFT JOIN companies ON companies.id = company_users.company_id 
WHERE
    ($2 = '%%'
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $2
    --  OR companies.company_type ILIKE @search
    --   OR company_users.designation ILIKE @search
      OR users.phone_number ILIKE $2
      OR users.email ILIKE $2
    )
	AND (case when $3::bigint = 0 then true else  companies.id= $3::bigint end)
AND users.status = $1
`

type CountAllCompanyUsersByStatusParams struct {
	Status    int64       `json:"status"`
	Search    interface{} `json:"search"`
	CompanyID int64       `json:"company_id"`
}

func (q *Queries) CountAllCompanyUsersByStatus(ctx context.Context, arg CountAllCompanyUsersByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllCompanyUsersByStatus, arg.Status, arg.Search, arg.CompanyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCompanyUser = `-- name: CreateCompanyUser :one
INSERT INTO company_users (
    users_id,
    company_id,
	company_department,
	company_roles,
	user_rank,
	is_verified,
    created_by,
    created_at,
    updated_at,
	leader_id
)VALUES (
    $1, $2, $3,$4, $5, $6,$7,$8,$9, $10
) RETURNING id, users_id, company_id, company_department, company_roles, user_rank, leader_id, is_verified, created_by, created_at, updated_at, active_listings
`

type CreateCompanyUserParams struct {
	UsersID           int64       `json:"users_id"`
	CompanyID         int64       `json:"company_id"`
	CompanyDepartment pgtype.Int8 `json:"company_department"`
	CompanyRoles      pgtype.Int8 `json:"company_roles"`
	UserRank          int64       `json:"user_rank"`
	IsVerified        pgtype.Bool `json:"is_verified"`
	CreatedBy         int64       `json:"created_by"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	LeaderID          pgtype.Int8 `json:"leader_id"`
}

func (q *Queries) CreateCompanyUser(ctx context.Context, arg CreateCompanyUserParams) (CompanyUser, error) {
	row := q.db.QueryRow(ctx, createCompanyUser,
		arg.UsersID,
		arg.CompanyID,
		arg.CompanyDepartment,
		arg.CompanyRoles,
		arg.UserRank,
		arg.IsVerified,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LeaderID,
	)
	var i CompanyUser
	err := row.Scan(
		&i.ID,
		&i.UsersID,
		&i.CompanyID,
		&i.CompanyDepartment,
		&i.CompanyRoles,
		&i.UserRank,
		&i.LeaderID,
		&i.IsVerified,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveListings,
	)
	return i, err
}

const deleteCompanyUser = `-- name: DeleteCompanyUser :exec

DELETE FROM company_users
Where id = $1
`

// -- name: UpdateCompanyUserStatus :one
// UPDATE company_users
// SET
//
//	status = $2
//
// Where id = $1
// RETURNING *;
func (q *Queries) DeleteCompanyUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCompanyUser, id)
	return err
}

const getACompanyByUserID = `-- name: GetACompanyByUserID :one
SELECT companies.id AS company_id, companies.users_id, 1 AS company_type, false AS is_branch, is_verified, company_name FROM companies where users_id = $1
`

type GetACompanyByUserIDRow struct {
	CompanyID   int64       `json:"company_id"`
	UsersID     int64       `json:"users_id"`
	CompanyType pgtype.Int8 `json:"company_type"`
	IsBranch    pgtype.Bool `json:"is_branch"`
	IsVerified  pgtype.Bool `json:"is_verified"`
	CompanyName string      `json:"company_name"`
}

func (q *Queries) GetACompanyByUserID(ctx context.Context, usersID int64) (GetACompanyByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getACompanyByUserID, usersID)
	var i GetACompanyByUserIDRow
	err := row.Scan(
		&i.CompanyID,
		&i.UsersID,
		&i.CompanyType,
		&i.IsBranch,
		&i.IsVerified,
		&i.CompanyName,
	)
	return i, err
}

const getASingleUserFromCompanies = `-- name: GetASingleUserFromCompanies :one
SELECT
    CASE
        WHEN broker_companies.id IS NOT NULL THEN broker_companies.id
        WHEN broker_companies_branches.id IS NOT NULL THEN broker_companies_branches.id
        WHEN developer_companies.id IS NOT NULL THEN developer_companies.id
        WHEN developer_company_branches.id IS NOT NULL THEN developer_company_branches.id
        WHEN services_companies.id IS NOT NULL THEN services_companies.id
        WHEN service_company_branches.id IS NOT NULL THEN service_company_branches.id
    END AS company_id,
    CASE
        WHEN broker_companies.users_id IS NOT NULL THEN broker_companies.users_id
        WHEN broker_companies_branches.users_id IS NOT NULL THEN broker_companies_branches.users_id
        WHEN developer_companies.users_id IS NOT NULL THEN developer_companies.users_id
        WHEN developer_company_branches.users_id IS NOT NULL THEN developer_company_branches.users_id
        WHEN services_companies.users_id IS NOT NULL THEN services_companies.users_id
        WHEN service_company_branches.users_id IS NOT NULL THEN service_company_branches.users_id
    END AS users_id,
    CASE
        WHEN broker_companies.id IS NOT NULL THEN 1
        WHEN broker_companies_branches.id IS NOT NULL THEN 1
        WHEN developer_companies.id IS NOT NULL THEN 2
        WHEN developer_company_branches.id IS NOT NULL THEN 2
        WHEN services_companies.id IS NOT NULL THEN 3
        WHEN service_company_branches.id IS NOT NULL THEN 3
    END AS company_type,
    CASE
        WHEN broker_companies.id IS NOT NULL THEN false
        WHEN broker_companies_branches.id IS NOT NULL THEN true
        WHEN developer_companies.id IS NOT NULL THEN false
        WHEN developer_company_branches.id IS NOT NULL THEN true
        WHEN services_companies.id IS NOT NULL THEN false
        WHEN service_company_branches.id IS NOT NULL THEN true
    END AS is_branch
FROM
    broker_companies
    FULL OUTER JOIN broker_companies_branches ON true
    FULL OUTER JOIN developer_companies ON true
    FULL OUTER JOIN developer_company_branches ON true
    FULL OUTER JOIN services_companies ON true
    FULL OUTER JOIN service_company_branches ON true
WHERE
    (
        CASE
            WHEN broker_companies.id IS NOT NULL THEN broker_companies.id
            WHEN broker_companies_branches.id IS NOT NULL THEN broker_companies_branches.id
            WHEN developer_companies.id IS NOT NULL THEN developer_companies.id
            WHEN developer_company_branches.id IS NOT NULL THEN developer_company_branches.id
            WHEN services_companies.id IS NOT NULL THEN services_companies.id
            WHEN service_company_branches.id IS NOT NULL THEN service_company_branches.id
        END = $1::bigint
    )
    AND (
        CASE
            WHEN broker_companies.id IS NOT NULL THEN 1
            WHEN broker_companies_branches.id IS NOT NULL THEN 1
            WHEN developer_companies.id IS NOT NULL THEN 2
            WHEN developer_company_branches.id IS NOT NULL THEN 2
            WHEN services_companies.id IS NOT NULL THEN 3
            WHEN service_company_branches.id IS NOT NULL THEN 3
        END = $2::bigint
    )
    AND (
        CASE
            WHEN broker_companies.id IS NOT NULL THEN false
            WHEN broker_companies_branches.id IS NOT NULL THEN true
            WHEN developer_companies.id IS NOT NULL THEN false
            WHEN developer_company_branches.id IS NOT NULL THEN true
            WHEN services_companies.id IS NOT NULL THEN false
            WHEN service_company_branches.id IS NOT NULL THEN true
        END = $3::BOOLEAN
    )
`

type GetASingleUserFromCompaniesParams struct {
	CompanyType int64 `json:"company_type"`
	CompanyID   int64 `json:"company_id"`
	IsBranch    bool  `json:"is_branch"`
}

type GetASingleUserFromCompaniesRow struct {
	CompanyID   interface{} `json:"company_id"`
	UsersID     interface{} `json:"users_id"`
	CompanyType interface{} `json:"company_type"`
	IsBranch    interface{} `json:"is_branch"`
}

func (q *Queries) GetASingleUserFromCompanies(ctx context.Context, arg GetASingleUserFromCompaniesParams) (GetASingleUserFromCompaniesRow, error) {
	row := q.db.QueryRow(ctx, getASingleUserFromCompanies, arg.CompanyType, arg.CompanyID, arg.IsBranch)
	var i GetASingleUserFromCompaniesRow
	err := row.Scan(
		&i.CompanyID,
		&i.UsersID,
		&i.CompanyType,
		&i.IsBranch,
	)
	return i, err
}

const getAllCompanyUser = `-- name: GetAllCompanyUser :many
SELECT id, users_id, company_id, company_department, company_roles, user_rank, leader_id, is_verified, created_by, created_at, updated_at, active_listings FROM company_users
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllCompanyUserParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllCompanyUser(ctx context.Context, arg GetAllCompanyUserParams) ([]CompanyUser, error) {
	rows, err := q.db.Query(ctx, getAllCompanyUser, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyUser
	for rows.Next() {
		var i CompanyUser
		if err := rows.Scan(
			&i.ID,
			&i.UsersID,
			&i.CompanyID,
			&i.CompanyDepartment,
			&i.CompanyRoles,
			&i.UserRank,
			&i.LeaderID,
			&i.IsVerified,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ActiveListings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyUsers = `-- name: GetAllCompanyUsers :many
SELECT
    company_users.company_id,
	company_users.id AS company_user_id,
	profiles.id AS profile_id,
	profiles.first_name,
	profiles.last_name,
	profiles.profile_image_url,
	users.phone_number,
	users.id AS user_id,
	users.email,
	companies.company_name,
	department.department,
	roles."role",
	company_users.is_verified,
	license.license_no,
	companies.company_type,
	users.status
FROM
	company_users
	LEFT JOIN users ON company_users.users_id = users.id
	LEFT JOIN profiles ON profiles.users_id = users.id
	LEFT JOIN companies ON company_users.company_id = companies.id

    LEFT JOIN roles ON users.roles_id = roles.id
	LEFT JOIN department ON roles.department_id = department.id
	LEFT JOIN license ON  users.id = license.entity_id  AND license.license_type_id = 5
	
	------------------------------------------------------------@search---------------------
WHERE
    ($3 = '%%'
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $3
     OR companies.company_name ILIKE $3 
      OR users.phone_number ILIKE $3
      OR users.email ILIKE $3
    )
	AND users.status NOT IN (5,6) AND CASE WHEN $4::bigint = 0 THEN TRUE ELSE company_users.company_id = $4::bigint END
ORDER BY
	company_users.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAllCompanyUsersParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	Search    interface{} `json:"search"`
	CompanyID int64       `json:"company_id"`
}

type GetAllCompanyUsersRow struct {
	CompanyID       int64       `json:"company_id"`
	CompanyUserID   int64       `json:"company_user_id"`
	ProfileID       pgtype.Int8 `json:"profile_id"`
	FirstName       pgtype.Text `json:"first_name"`
	LastName        pgtype.Text `json:"last_name"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
	PhoneNumber     pgtype.Text `json:"phone_number"`
	UserID          pgtype.Int8 `json:"user_id"`
	Email           pgtype.Text `json:"email"`
	CompanyName     pgtype.Text `json:"company_name"`
	Department      pgtype.Text `json:"department"`
	Role            pgtype.Text `json:"role"`
	IsVerified      pgtype.Bool `json:"is_verified"`
	LicenseNo       pgtype.Text `json:"license_no"`
	CompanyType     pgtype.Int8 `json:"company_type"`
	Status          pgtype.Int8 `json:"status"`
}

func (q *Queries) GetAllCompanyUsers(ctx context.Context, arg GetAllCompanyUsersParams) ([]GetAllCompanyUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyUsers,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.CompanyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyUsersRow
	for rows.Next() {
		var i GetAllCompanyUsersRow
		if err := rows.Scan(
			&i.CompanyID,
			&i.CompanyUserID,
			&i.ProfileID,
			&i.FirstName,
			&i.LastName,
			&i.ProfileImageUrl,
			&i.PhoneNumber,
			&i.UserID,
			&i.Email,
			&i.CompanyName,
			&i.Department,
			&i.Role,
			&i.IsVerified,
			&i.LicenseNo,
			&i.CompanyType,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyUsersByStatus = `-- name: GetAllCompanyUsersByStatus :many
SELECT
	company_users.id, company_users.users_id, company_users.company_id, company_users.company_department, company_users.company_roles, company_users.user_rank, company_users.leader_id, company_users.is_verified, company_users.created_by, company_users.created_at, company_users.updated_at, company_users.active_listings,
	profiles.first_name,
	profiles.last_name,
	users.phone_number,
	users.email,
	profiles.profile_image_url,
	users.user_types_id,
	companies.company_name
	FROM
	company_users
	LEFT JOIN users ON company_users.users_id = users.id
	LEFT JOIN profiles ON profiles.users_id = users.id 
	LEFT JOIN companies ON companies.id = company_users.company_id
	---------------------------------------------------------------------------------
WHERE
    ($4 = '%%'
      OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $4
    --   OR companies.company_type ILIKE @search
    --   OR company_users.designation ILIKE @search
      OR users.phone_number ILIKE $4
      OR users.email ILIKE $4
    )
	AND users.status = $3
	AND (case when $5::bigint = 0 then true else  companies.id= $5::bigint end)
ORDER BY
	company_users.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAllCompanyUsersByStatusParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	Status    int64       `json:"status"`
	Search    interface{} `json:"search"`
	CompanyID int64       `json:"company_id"`
}

type GetAllCompanyUsersByStatusRow struct {
	ID                int64       `json:"id"`
	UsersID           int64       `json:"users_id"`
	CompanyID         int64       `json:"company_id"`
	CompanyDepartment pgtype.Int8 `json:"company_department"`
	CompanyRoles      pgtype.Int8 `json:"company_roles"`
	UserRank          int64       `json:"user_rank"`
	LeaderID          pgtype.Int8 `json:"leader_id"`
	IsVerified        pgtype.Bool `json:"is_verified"`
	CreatedBy         int64       `json:"created_by"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	ActiveListings    pgtype.Int8 `json:"active_listings"`
	FirstName         pgtype.Text `json:"first_name"`
	LastName          pgtype.Text `json:"last_name"`
	PhoneNumber       pgtype.Text `json:"phone_number"`
	Email             pgtype.Text `json:"email"`
	ProfileImageUrl   pgtype.Text `json:"profile_image_url"`
	UserTypesID       pgtype.Int8 `json:"user_types_id"`
	CompanyName       pgtype.Text `json:"company_name"`
}

func (q *Queries) GetAllCompanyUsersByStatus(ctx context.Context, arg GetAllCompanyUsersByStatusParams) ([]GetAllCompanyUsersByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyUsersByStatus,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.Search,
		arg.CompanyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyUsersByStatusRow
	for rows.Next() {
		var i GetAllCompanyUsersByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UsersID,
			&i.CompanyID,
			&i.CompanyDepartment,
			&i.CompanyRoles,
			&i.UserRank,
			&i.LeaderID,
			&i.IsVerified,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ActiveListings,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.Email,
			&i.ProfileImageUrl,
			&i.UserTypesID,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompany = `-- name: GetCompany :one
SELECT id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url FROM companies
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCompany(ctx context.Context, id int64) (Company, error) {
	row := q.db.QueryRow(ctx, getCompany, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email,
		&i.PhoneNumber,
		&i.WhatsappNumber,
		&i.IsVerified,
		&i.WebsiteUrl,
		&i.CoverImageUrl,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status,
		&i.CompanyType,
		&i.AddressesID,
		&i.UsersID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const getCompanyUser = `-- name: GetCompanyUser :one
SELECT id, users_id, company_id, company_department, company_roles, user_rank, leader_id, is_verified, created_by, created_at, updated_at, active_listings FROM company_users 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetCompanyUser(ctx context.Context, limit int32) (CompanyUser, error) {
	row := q.db.QueryRow(ctx, getCompanyUser, limit)
	var i CompanyUser
	err := row.Scan(
		&i.ID,
		&i.UsersID,
		&i.CompanyID,
		&i.CompanyDepartment,
		&i.CompanyRoles,
		&i.UserRank,
		&i.LeaderID,
		&i.IsVerified,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveListings,
	)
	return i, err
}

const getCompanyUserByCompanyId = `-- name: GetCompanyUserByCompanyId :many
SELECT id, users_id, company_id, company_department, company_roles, user_rank, leader_id, is_verified, created_by, created_at, updated_at, active_listings FROM company_users 
WHERE company_id = $1
`

func (q *Queries) GetCompanyUserByCompanyId(ctx context.Context, companyID int64) ([]CompanyUser, error) {
	rows, err := q.db.Query(ctx, getCompanyUserByCompanyId, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyUser
	for rows.Next() {
		var i CompanyUser
		if err := rows.Scan(
			&i.ID,
			&i.UsersID,
			&i.CompanyID,
			&i.CompanyDepartment,
			&i.CompanyRoles,
			&i.UserRank,
			&i.LeaderID,
			&i.IsVerified,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ActiveListings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyUserByCompanyUserId = `-- name: GetCompanyUserByCompanyUserId :one
SELECT 
   id, users_id, company_id, company_department, company_roles, user_rank, leader_id, is_verified, created_by, created_at, updated_at, active_listings
 FROM
	company_users 
WHERE
	company_users.id = $1
`

func (q *Queries) GetCompanyUserByCompanyUserId(ctx context.Context, companyUserID int64) (CompanyUser, error) {
	row := q.db.QueryRow(ctx, getCompanyUserByCompanyUserId, companyUserID)
	var i CompanyUser
	err := row.Scan(
		&i.ID,
		&i.UsersID,
		&i.CompanyID,
		&i.CompanyDepartment,
		&i.CompanyRoles,
		&i.UserRank,
		&i.LeaderID,
		&i.IsVerified,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveListings,
	)
	return i, err
}

const getCompanyUserById = `-- name: GetCompanyUserById :one
SELECT company_users.id, company_users.users_id, company_users.company_id, company_users.company_department, company_users.company_roles, company_users.user_rank, company_users.leader_id, company_users.is_verified, company_users.created_by, company_users.created_at, company_users.updated_at, company_users.active_listings, users.id, users.email, users.username, users.password, users.status, users.roles_id, users.user_types_id, users.social_login, users.show_hide_details, users.experience_since, users.is_verified, users.created_at, users.updated_at, users.phone_number, users.is_phone_verified, users.is_email_verified, users.active_company, users.country_code, users.profile_views, profiles.id, profiles.first_name, profiles.last_name, profiles.addresses_id, profiles.profile_image_url, profiles.secondary_number, profiles.whatsapp_number, profiles.show_whatsapp_number, profiles.botim_number, profiles.show_botim_number, profiles.tawasal_number, profiles.show_tawasal_number, profiles.gender, profiles.created_at, profiles.updated_at, profiles.ref_no, profiles.cover_image_url, profiles.passport_no, profiles.passport_image_url, profiles.passport_expiry_date, profiles.about, profiles.about_arabic, profiles.users_id, profiles.telegram_number, companies.id, companies.ref_no, companies.company_name, companies.company_activities_id, companies.company_parent_id, companies.tag_line, companies.description, companies.description_ar, companies.logo_url, companies.email, companies.phone_number, companies.whatsapp_number, companies.is_verified, companies.website_url, companies.cover_image_url, companies.no_of_employees, companies.company_rank, companies.status, companies.company_type, companies.addresses_id, companies.users_id, companies.created_by, companies.created_at, companies.updated_at, companies.updated_by, companies.location_url, companies.vat_no, companies.vat_status, companies.vat_file_url  FROM
	company_users
	LEFT JOIN users ON company_users.users_id = users.id
	LEFT JOIN profiles ON profiles.users_id = users.id
	LEFT JOIN companies ON company_users.company_id = companies.id
WHERE
	company_users.id = $1
`

type GetCompanyUserByIdRow struct {
	ID                  int64              `json:"id"`
	UsersID             int64              `json:"users_id"`
	CompanyID           int64              `json:"company_id"`
	CompanyDepartment   pgtype.Int8        `json:"company_department"`
	CompanyRoles        pgtype.Int8        `json:"company_roles"`
	UserRank            int64              `json:"user_rank"`
	LeaderID            pgtype.Int8        `json:"leader_id"`
	IsVerified          pgtype.Bool        `json:"is_verified"`
	CreatedBy           int64              `json:"created_by"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	ActiveListings      pgtype.Int8        `json:"active_listings"`
	ID_2                pgtype.Int8        `json:"id_2"`
	Email               pgtype.Text        `json:"email"`
	Username            pgtype.Text        `json:"username"`
	Password            pgtype.Text        `json:"password"`
	Status              pgtype.Int8        `json:"status"`
	RolesID             pgtype.Int8        `json:"roles_id"`
	UserTypesID         pgtype.Int8        `json:"user_types_id"`
	SocialLogin         pgtype.Text        `json:"social_login"`
	ShowHideDetails     pgtype.Bool        `json:"show_hide_details"`
	ExperienceSince     pgtype.Timestamptz `json:"experience_since"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	CreatedAt_2         pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2         pgtype.Timestamptz `json:"updated_at_2"`
	PhoneNumber         pgtype.Text        `json:"phone_number"`
	IsPhoneVerified     pgtype.Bool        `json:"is_phone_verified"`
	IsEmailVerified     pgtype.Bool        `json:"is_email_verified"`
	ActiveCompany       pgtype.Int8        `json:"active_company"`
	CountryCode         pgtype.Int8        `json:"country_code"`
	ProfileViews        pgtype.Int8        `json:"profile_views"`
	ID_3                pgtype.Int8        `json:"id_3"`
	FirstName           pgtype.Text        `json:"first_name"`
	LastName            pgtype.Text        `json:"last_name"`
	AddressesID         pgtype.Int8        `json:"addresses_id"`
	ProfileImageUrl     pgtype.Text        `json:"profile_image_url"`
	SecondaryNumber     pgtype.Text        `json:"secondary_number"`
	WhatsappNumber      pgtype.Text        `json:"whatsapp_number"`
	ShowWhatsappNumber  pgtype.Bool        `json:"show_whatsapp_number"`
	BotimNumber         pgtype.Text        `json:"botim_number"`
	ShowBotimNumber     pgtype.Bool        `json:"show_botim_number"`
	TawasalNumber       pgtype.Text        `json:"tawasal_number"`
	ShowTawasalNumber   pgtype.Bool        `json:"show_tawasal_number"`
	Gender              pgtype.Int8        `json:"gender"`
	CreatedAt_3         pgtype.Timestamptz `json:"created_at_3"`
	UpdatedAt_3         pgtype.Timestamptz `json:"updated_at_3"`
	RefNo               pgtype.Text        `json:"ref_no"`
	CoverImageUrl       pgtype.Text        `json:"cover_image_url"`
	PassportNo          pgtype.Text        `json:"passport_no"`
	PassportImageUrl    pgtype.Text        `json:"passport_image_url"`
	PassportExpiryDate  pgtype.Timestamptz `json:"passport_expiry_date"`
	About               pgtype.Text        `json:"about"`
	AboutArabic         pgtype.Text        `json:"about_arabic"`
	UsersID_2           pgtype.Int8        `json:"users_id_2"`
	TelegramNumber      pgtype.Text        `json:"telegram_number"`
	ID_4                pgtype.Int8        `json:"id_4"`
	RefNo_2             pgtype.Text        `json:"ref_no_2"`
	CompanyName         pgtype.Text        `json:"company_name"`
	CompanyActivitiesID []int64            `json:"company_activities_id"`
	CompanyParentID     pgtype.Int8        `json:"company_parent_id"`
	TagLine             pgtype.Text        `json:"tag_line"`
	Description         pgtype.Text        `json:"description"`
	DescriptionAr       pgtype.Text        `json:"description_ar"`
	LogoUrl             pgtype.Text        `json:"logo_url"`
	Email_2             pgtype.Text        `json:"email_2"`
	PhoneNumber_2       pgtype.Text        `json:"phone_number_2"`
	WhatsappNumber_2    pgtype.Text        `json:"whatsapp_number_2"`
	IsVerified_3        pgtype.Bool        `json:"is_verified_3"`
	WebsiteUrl          pgtype.Text        `json:"website_url"`
	CoverImageUrl_2     pgtype.Text        `json:"cover_image_url_2"`
	NoOfEmployees       pgtype.Int8        `json:"no_of_employees"`
	CompanyRank         pgtype.Int8        `json:"company_rank"`
	Status_2            pgtype.Int8        `json:"status_2"`
	CompanyType         pgtype.Int8        `json:"company_type"`
	AddressesID_2       pgtype.Int8        `json:"addresses_id_2"`
	UsersID_3           pgtype.Int8        `json:"users_id_3"`
	CreatedBy_2         pgtype.Int8        `json:"created_by_2"`
	CreatedAt_4         pgtype.Timestamptz `json:"created_at_4"`
	UpdatedAt_4         pgtype.Timestamptz `json:"updated_at_4"`
	UpdatedBy           pgtype.Int8        `json:"updated_by"`
	LocationUrl         pgtype.Text        `json:"location_url"`
	VatNo               pgtype.Text        `json:"vat_no"`
	VatStatus           pgtype.Int8        `json:"vat_status"`
	VatFileUrl          pgtype.Text        `json:"vat_file_url"`
}

func (q *Queries) GetCompanyUserById(ctx context.Context, companyID int64) (GetCompanyUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getCompanyUserById, companyID)
	var i GetCompanyUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.UsersID,
		&i.CompanyID,
		&i.CompanyDepartment,
		&i.CompanyRoles,
		&i.UserRank,
		&i.LeaderID,
		&i.IsVerified,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveListings,
		&i.ID_2,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
		&i.ID_3,
		&i.FirstName,
		&i.LastName,
		&i.AddressesID,
		&i.ProfileImageUrl,
		&i.SecondaryNumber,
		&i.WhatsappNumber,
		&i.ShowWhatsappNumber,
		&i.BotimNumber,
		&i.ShowBotimNumber,
		&i.TawasalNumber,
		&i.ShowTawasalNumber,
		&i.Gender,
		&i.CreatedAt_3,
		&i.UpdatedAt_3,
		&i.RefNo,
		&i.CoverImageUrl,
		&i.PassportNo,
		&i.PassportImageUrl,
		&i.PassportExpiryDate,
		&i.About,
		&i.AboutArabic,
		&i.UsersID_2,
		&i.TelegramNumber,
		&i.ID_4,
		&i.RefNo_2,
		&i.CompanyName,
		&i.CompanyActivitiesID,
		&i.CompanyParentID,
		&i.TagLine,
		&i.Description,
		&i.DescriptionAr,
		&i.LogoUrl,
		&i.Email_2,
		&i.PhoneNumber_2,
		&i.WhatsappNumber_2,
		&i.IsVerified_3,
		&i.WebsiteUrl,
		&i.CoverImageUrl_2,
		&i.NoOfEmployees,
		&i.CompanyRank,
		&i.Status_2,
		&i.CompanyType,
		&i.AddressesID_2,
		&i.UsersID_3,
		&i.CreatedBy_2,
		&i.CreatedAt_4,
		&i.UpdatedAt_4,
		&i.UpdatedBy,
		&i.LocationUrl,
		&i.VatNo,
		&i.VatStatus,
		&i.VatFileUrl,
	)
	return i, err
}

const getCompanyUserByUserId = `-- name: GetCompanyUserByUserId :one
SELECT id, users_id, company_id, company_department, company_roles, user_rank, leader_id, is_verified, created_by, created_at, updated_at, active_listings FROM company_users 
WHERE 
 CASE WHEN  $1=0 THEN true ELSE company_id = $1 END
 AND users_id = $2
`

type GetCompanyUserByUserIdParams struct {
	CompanyID interface{} `json:"company_id"`
	UserID    int64       `json:"user_id"`
}

func (q *Queries) GetCompanyUserByUserId(ctx context.Context, arg GetCompanyUserByUserIdParams) (CompanyUser, error) {
	row := q.db.QueryRow(ctx, getCompanyUserByUserId, arg.CompanyID, arg.UserID)
	var i CompanyUser
	err := row.Scan(
		&i.ID,
		&i.UsersID,
		&i.CompanyID,
		&i.CompanyDepartment,
		&i.CompanyRoles,
		&i.UserRank,
		&i.LeaderID,
		&i.IsVerified,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveListings,
	)
	return i, err
}

const getCompanyUserCountByUserAndCompanyId = `-- name: GetCompanyUserCountByUserAndCompanyId :one























SELECT COUNT(company_users.id)
FROM company_users
WHERE company_users.user_id = $1::bigint
AND company_users.company_id = $2::bigint
GROUP BY company_users.id
ORDER BY company_users.id
`

type GetCompanyUserCountByUserAndCompanyIdParams struct {
	ID        int64 `json:"id"`
	Companyid int64 `json:"companyid"`
}

// -------------------
// With x AS(
//
//	SELECT broker_companies.id AS company_id, users_id, 1 AS company_type, false AS is_branch  FROM broker_companies
//	UNION ALL
//	SELECT broker_companies_branches.id AS company_id, users_id, 1 AS company_type, true AS is_branch FROM broker_companies_branches
//	UNION
//	SELECT developer_companies.id AS company_id, users_id, 2 AS company_type, false AS is_branch FROM developer_companies
//	UNION ALL
//	SELECT developer_company_branches.id AS company_id, users_id, 2 AS company_type, true AS is_branch FROM developer_company_branches
//	UNION ALL
//	SELECT services_companies.id AS company_id, users_id, 3 AS company_type, false AS is_branch FROM services_companies
//	UNION ALL
//	SELECT service_company_branches.id AS company_id, users_id, 3 AS company_type, true AS is_branch FROM service_company_branches
//
// )
// SELECT users_id, company_id FROM x WHERE company_id = 1 and company_type = @company_type and is_branch = @is_branch;
// SELECT users_id, bc.id AS company_id, bc.users_id, 1 AS company_type, false AS is_branch
// FROM broker_companies bc
// WHERE bc.company_type = @company_type AND bc.id =  @id AND bc.is_branch = @is_branch
// UNION ALL
// SELECT  users_id, bcb.id AS company_id, bcb.users_id, 1 AS company_type, true AS is_branch
// FROM broker_companies_branches bcb
// WHERE bcb.company_type = @company_type AND bcb.id =  @id AND bcb.is_branch =  @is_branch
// UNION ALL
// SELECT  users_id, dc.id AS company_id, dc.users_id, 2 AS company_type, false AS is_branch
// FROM developer_companies dc
// WHERE dc.company_type = @company_type AND dc.id =  @id AND dc.is_branch =   @is_branch
// UNION ALL
// SELECT   users_id, dcb.id AS company_id, dcb.users_id, 2 AS company_type, true AS is_branch
// FROM developer_company_branches dcb
// WHERE dcb.company_type = @company_type AND dcb.id =  @id AND dcb.is_branch =  @is_branch
// UNION ALL
// SELECT   users_id, sc.id AS company_id, sc.users_id, 3 AS company_type, false AS is_branch
// FROM services_companies sc
// WHERE sc.company_type = @company_type AND sc.id =  @id AND sc.is_branch =   @is_branch
// UNION ALL
// SELECT   users_id, scb.id AS company_id, scb.users_id, 3 AS company_type, true AS is_branch
// FROM service_company_branches scb
// WHERE scb.company_type = @company_type AND scb.id =  @id AND scb.is_branch =  @is_branch;
// SELECT company_id, users_id, company_type, is_branch, is_verified
// FROM (
//
//	SELECT broker_companies.id AS company_id, broker_companies.users_id, 1 AS company_type, false AS is_branch, is_verified
//	FROM broker_companies
//	WHERE broker_companies.users_id = $1
//	UNION ALL
//	SELECT broker_companies_branches.id AS company_id, broker_companies_branches.users_id, 1 AS company_type, true AS is_branch, is_verified
//	FROM broker_companies_branches
//	WHERE broker_companies_branches.users_id = $1
//	UNION
//	SELECT developer_companies.id AS company_id, developer_companies.users_id, 2 AS company_type, false AS is_branch, is_verified
//	FROM developer_companies
//	WHERE developer_companies.users_id = $1
//	UNION ALL
//	SELECT developer_company_branches.id AS company_id, developer_company_branches.users_id, 2 AS company_type, true AS is_branch, is_verified
//	FROM developer_company_branches
//	WHERE developer_company_branches.users_id = $1
//	UNION ALL
//	SELECT services_companies.id AS company_id, services_companies.users_id, 3 AS company_type, false AS is_branch, is_verified
//	FROM services_companies
//	WHERE services_companies.users_id = $1
//	UNION ALL
//	SELECT service_company_branches.id AS company_id, service_company_branches.users_id, 3 AS company_type, true AS is_branch, is_verified
//	FROM service_company_branches
//	WHERE service_company_branches.users_id = $1
//
// ) AS subquery;
func (q *Queries) GetCompanyUserCountByUserAndCompanyId(ctx context.Context, arg GetCompanyUserCountByUserAndCompanyIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCompanyUserCountByUserAndCompanyId, arg.ID, arg.Companyid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCompanyUserIDFromUserID = `-- name: GetCompanyUserIDFromUserID :one
SELECT id
FROM 
	company_users 
WHERE 	
	users_id=$1
`

func (q *Queries) GetCompanyUserIDFromUserID(ctx context.Context, usersID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCompanyUserIDFromUserID, usersID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getCountAllCompanyUsers = `-- name: GetCountAllCompanyUsers :one
SELECT
	COUNT(*)
FROM
	company_users
	LEFT JOIN users ON company_users.users_id = users.id
	LEFT JOIN profiles ON profiles.users_id = users.id
	LEFT JOIN companies ON company_users.company_id = companies.id

    LEFT JOIN roles ON users.roles_id = roles.id
	LEFT JOIN department ON roles.department_id = department.id
	LEFT JOIN license ON  users.id = license.entity_id  AND license.license_type_id = 5
	
	------------------------------------------------------------@search---------------------
WHERE
    ($1 = '%%'
     OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE $1
     OR companies.company_name ILIKE $1 
      OR users.phone_number ILIKE $1
      OR users.email ILIKE $1
    )
AND users.status NOT IN (5,6) AND CASE WHEN $2::bigint = 0 THEN TRUE ELSE company_users.company_id = $2::bigint END
`

type GetCountAllCompanyUsersParams struct {
	Search    interface{} `json:"search"`
	CompanyID int64       `json:"company_id"`
}

func (q *Queries) GetCountAllCompanyUsers(ctx context.Context, arg GetCountAllCompanyUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllCompanyUsers, arg.Search, arg.CompanyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountCompanyUsersByStatuses = `-- name: GetCountCompanyUsersByStatuses :one
SELECT COUNT(company_users.id) FROM company_users LEFT JOIN users ON company_users.users_id = users.id WHERE users.status = ANY($1::bigint[])
`

func (q *Queries) GetCountCompanyUsersByStatuses(ctx context.Context, dollar_1 []int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountCompanyUsersByStatuses, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserAssociatedCompanies = `-- name: GetUserAssociatedCompanies :many

SELECT id,company_name 
FROM companies
WHERE users_id = $1
ORDER BY id ASC
`

type GetUserAssociatedCompaniesRow struct {
	ID          int64  `json:"id"`
	CompanyName string `json:"company_name"`
}

// -- name: VerifyingCompanyUser :one
// Update users
// SET is_verified = true,
// status = 8
// WHERE id = $1
// RETURNING *;
func (q *Queries) GetUserAssociatedCompanies(ctx context.Context, usersID int64) ([]GetUserAssociatedCompaniesRow, error) {
	rows, err := q.db.Query(ctx, getUserAssociatedCompanies, usersID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAssociatedCompaniesRow
	for rows.Next() {
		var i GetUserAssociatedCompaniesRow
		if err := rows.Scan(&i.ID, &i.CompanyName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFromCompany = `-- name: GetUserFromCompany :one





SELECT
	CASE WHEN company_users.company_type = 1
		AND company_users.is_branch = FALSE THEN
		broker_companies.company_name
	WHEN company_users.company_type = 1
		AND company_users.is_branch = TRUE THEN
		broker_companies_branches.company_name
	WHEN company_users.company_type = 2
		AND company_users.is_branch = FALSE THEN
		developer_companies.company_name
	WHEN company_users.company_type = 2
		AND company_users.is_branch = TRUE THEN
		developer_company_branches.company_name
	WHEN company_users.company_type = 3
		AND company_users.is_branch = FALSE THEN
		services_companies.company_name
	WHEN company_users.company_type = 3
		AND company_users.is_branch = TRUE THEN
		service_company_branches.company_name
	ELSE
		NULL
	END AS company_name,
	profiles.id AS profile_id,
	profiles.first_name,
	profiles.last_name,
	users.phone_number,
	-- profiles.all_languages_id,
	profiles.addresses_id,
	-- profiles.company_number,
	profiles.whatsapp_number,
	profiles.gender,
	profiles.profile_image_url,
	-- profiles.tawasal,
	-- profiles.botim,
	users.user_types_id,
	users.email
	-- users.permissions_id,
	-- users.sub_section_permission
FROM
	company_users
	LEFT JOIN users ON company_users.users_id = users.id
	LEFT JOIN profiles ON profiles.users_id = users.id
	LEFT JOIN broker_companies ON broker_companies.id = company_users.company_id
		AND company_users.is_branch = FALSE
	LEFT JOIN broker_companies_branches ON broker_companies_branches.id = company_users.company_id
		AND company_users.is_branch = TRUE
	LEFT JOIN developer_companies ON developer_companies.id = company_users.company_id
		AND company_users.is_branch = FALSE
	LEFT JOIN developer_company_branches ON developer_company_branches.id = company_users.company_id
		AND company_users.is_branch = TRUE
	LEFT JOIN services_companies ON services_companies.id = company_users.company_id
		AND company_users.is_branch = FALSE
	LEFT JOIN service_company_branches ON service_company_branches.id = company_users.company_id
		AND company_users.is_branch = TRUE
WHERE
	company_users.id = $1
`

type GetUserFromCompanyRow struct {
	CompanyName     interface{} `json:"company_name"`
	ProfileID       pgtype.Int8 `json:"profile_id"`
	FirstName       pgtype.Text `json:"first_name"`
	LastName        pgtype.Text `json:"last_name"`
	PhoneNumber     pgtype.Text `json:"phone_number"`
	AddressesID     pgtype.Int8 `json:"addresses_id"`
	WhatsappNumber  pgtype.Text `json:"whatsapp_number"`
	Gender          pgtype.Int8 `json:"gender"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
	UserTypesID     pgtype.Int8 `json:"user_types_id"`
	Email           pgtype.Text `json:"email"`
}

// SELECT * FROM company_users
// WHERE users_id = $1;
// -- name: GetCompanyByCompanyUser :one
// SELECT
//
//	COALESCE(
//	    bc.id,
//	    bcb.id,
//	    dc.id,
//	    dcb.id,
//	    sc.id,
//	    dc.id
//	) AS company_id,
//	COALESCE(
//	    bc.is_branch,
//	    bcb.is_branch,
//	    dc.is_branch,
//	    dcb.is_branch,
//	    sc.is_branch,
//	    dc.is_branch
//	) AS is_branch,
//	COALESCE(
//	    bc.company_type,
//	    bcb.company_type,
//	    dc.company_type,
//	    dcb.company_type,
//	    sc.company_type,
//	    dc.company_type
//	) AS company_type,
//	COALESCE(
//	    bc.company_name,
//	    bcb.company_name,
//	    dc.company_name,
//	    dcb.company_name,
//	    sc.company_name,
//	    dc.company_name,
//	    'no company'
//	) AS company_name,
//	cu.designation
//
// FROM company_users AS cu
// LEFT JOIN broker_companies bc ON cu.company_id = bc.id AND cu.is_branch = false AND cu.company_type = 1
// LEFT JOIN broker_companies_branches bcb ON cu.company_id = bcb.id AND cu.is_branch = true AND cu.company_type = 1
// LEFT JOIN developer_companies dc ON cu.company_id = dc.id AND cu.is_branch = false AND cu.company_type = 2
// LEFT JOIN developer_company_branches dcb ON cu.company_id = dcb.id AND cu.is_branch = true AND cu.company_type = 2
// LEFT JOIN services_companies sc ON cu.company_id = sc.id AND cu.is_branch = false AND cu.company_type = 3
// LEFT JOIN product_companies pc ON cu.company_id = pc.id AND cu.is_branch = false AND cu.company_type = 4
// WHERE cu.users_id = $1
// limit 1;
func (q *Queries) GetUserFromCompany(ctx context.Context, id int64) (GetUserFromCompanyRow, error) {
	row := q.db.QueryRow(ctx, getUserFromCompany, id)
	var i GetUserFromCompanyRow
	err := row.Scan(
		&i.CompanyName,
		&i.ProfileID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.AddressesID,
		&i.WhatsappNumber,
		&i.Gender,
		&i.ProfileImageUrl,
		&i.UserTypesID,
		&i.Email,
	)
	return i, err
}

const updateAgentActiveListing = `-- name: UpdateAgentActiveListing :one
UPDATE 
	company_users
SET 
	active_listings=$2
WHERE 
	id=$1 RETURNING 1
`

type UpdateAgentActiveListingParams struct {
	ID             int64       `json:"id"`
	ActiveListings pgtype.Int8 `json:"active_listings"`
}

func (q *Queries) UpdateAgentActiveListing(ctx context.Context, arg UpdateAgentActiveListingParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, updateAgentActiveListing, arg.ID, arg.ActiveListings)
	var column_1 pgtype.Int8
	err := row.Scan(&column_1)
	return column_1, err
}

const updateCompanyUser = `-- name: UpdateCompanyUser :one
UPDATE company_users
SET users_id = $2,
    company_id = $3,
	leader_id = $4
    -- company_type = $4,
    -- is_branch = $5,
    -- designation = $6,
    -- created_by = $7,
    -- updated_at = $8
Where id = $1
RETURNING id, users_id, company_id, company_department, company_roles, user_rank, leader_id, is_verified, created_by, created_at, updated_at, active_listings
`

type UpdateCompanyUserParams struct {
	ID        int64       `json:"id"`
	UsersID   int64       `json:"users_id"`
	CompanyID int64       `json:"company_id"`
	LeaderID  pgtype.Int8 `json:"leader_id"`
}

func (q *Queries) UpdateCompanyUser(ctx context.Context, arg UpdateCompanyUserParams) (CompanyUser, error) {
	row := q.db.QueryRow(ctx, updateCompanyUser,
		arg.ID,
		arg.UsersID,
		arg.CompanyID,
		arg.LeaderID,
	)
	var i CompanyUser
	err := row.Scan(
		&i.ID,
		&i.UsersID,
		&i.CompanyID,
		&i.CompanyDepartment,
		&i.CompanyRoles,
		&i.UserRank,
		&i.LeaderID,
		&i.IsVerified,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveListings,
	)
	return i, err
}

const updateCompanyUserByUserID = `-- name: UpdateCompanyUserByUserID :one
UPDATE company_users
SET  leader_id = $2 
Where users_id = $1
RETURNING id, users_id, company_id, company_department, company_roles, user_rank, leader_id, is_verified, created_by, created_at, updated_at, active_listings
`

type UpdateCompanyUserByUserIDParams struct {
	UsersID  int64       `json:"users_id"`
	LeaderID pgtype.Int8 `json:"leader_id"`
}

func (q *Queries) UpdateCompanyUserByUserID(ctx context.Context, arg UpdateCompanyUserByUserIDParams) (CompanyUser, error) {
	row := q.db.QueryRow(ctx, updateCompanyUserByUserID, arg.UsersID, arg.LeaderID)
	var i CompanyUser
	err := row.Scan(
		&i.ID,
		&i.UsersID,
		&i.CompanyID,
		&i.CompanyDepartment,
		&i.CompanyRoles,
		&i.UserRank,
		&i.LeaderID,
		&i.IsVerified,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveListings,
	)
	return i, err
}

const verifyCompanyUserByUserId = `-- name: VerifyCompanyUserByUserId :exec
Update company_users
SET is_verified = $2
WHERE users_id = $1
`

type VerifyCompanyUserByUserIdParams struct {
	UsersID    int64       `json:"users_id"`
	IsVerified pgtype.Bool `json:"is_verified"`
}

func (q *Queries) VerifyCompanyUserByUserId(ctx context.Context, arg VerifyCompanyUserByUserIdParams) error {
	_, err := q.db.Exec(ctx, verifyCompanyUserByUserId, arg.UsersID, arg.IsVerified)
	return err
}

const verifyUser = `-- name: VerifyUser :one
Update users
SET is_verified = $2
WHERE id = $1
RETURNING id, email, username, password, status, roles_id, user_types_id, social_login, show_hide_details, experience_since, is_verified, created_at, updated_at, phone_number, is_phone_verified, is_email_verified, active_company, country_code, profile_views
`

type VerifyUserParams struct {
	ID         int64       `json:"id"`
	IsVerified pgtype.Bool `json:"is_verified"`
}

func (q *Queries) VerifyUser(ctx context.Context, arg VerifyUserParams) (User, error) {
	row := q.db.QueryRow(ctx, verifyUser, arg.ID, arg.IsVerified)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.RolesID,
		&i.UserTypesID,
		&i.SocialLogin,
		&i.ShowHideDetails,
		&i.ExperienceSince,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.IsPhoneVerified,
		&i.IsEmailVerified,
		&i.ActiveCompany,
		&i.CountryCode,
		&i.ProfileViews,
	)
	return i, err
}
