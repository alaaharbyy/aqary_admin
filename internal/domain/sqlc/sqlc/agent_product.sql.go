// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: agent_product.sql

package sqlc

import (
	"context"
	"time"
)

const createAgentProducts = `-- name: CreateAgentProducts :one
INSERT INTO agent_products( 
   company_user_id, -- the current registered user 
   product, -- subscription_products
   no_of_products, -- how many units 
   created_by,
   created_at,
   updated_at    
)VALUES(
   $1,$2, $3, $4, $5, $6
) RETURNING id, company_user_id, product, no_of_products, created_by, created_at, updated_at
`

type CreateAgentProductsParams struct {
	CompanyUserID int64     `json:"company_user_id"`
	Product       int64     `json:"product"`
	NoOfProducts  int32     `json:"no_of_products"`
	CreatedBy     int64     `json:"created_by"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

func (q *Queries) CreateAgentProducts(ctx context.Context, arg CreateAgentProductsParams) (AgentProduct, error) {
	row := q.db.QueryRow(ctx, createAgentProducts,
		arg.CompanyUserID,
		arg.Product,
		arg.NoOfProducts,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AgentProduct
	err := row.Scan(
		&i.ID,
		&i.CompanyUserID,
		&i.Product,
		&i.NoOfProducts,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAssignCreditByAgentIdAndProduct = `-- name: GetAssignCreditByAgentIdAndProduct :one
 SELECT
        ap.no_of_products AS assigned
    FROM agent_products ap
    INNER JOIN subscription_products sp ON sp.id = ap.product
    INNER JOIN company_users cu ON cu.id = ap.company_user_id
    WHERE ap.company_user_id = $1 AND sp.id = $2
`

type GetAssignCreditByAgentIdAndProductParams struct {
	CompanyUserID int64 `json:"company_user_id"`
	ID            int64 `json:"id"`
}

func (q *Queries) GetAssignCreditByAgentIdAndProduct(ctx context.Context, arg GetAssignCreditByAgentIdAndProductParams) (int32, error) {
	row := q.db.QueryRow(ctx, getAssignCreditByAgentIdAndProduct, arg.CompanyUserID, arg.ID)
	var assigned int32
	err := row.Scan(&assigned)
	return assigned, err
}

const getRemainingCreditToAssignAgentByCompany = `-- name: GetRemainingCreditToAssignAgentByCompany :many



WITH AssignedProducts AS (
    SELECT 
        sp.id AS product_id,
        SUM(ap.no_of_products) AS assigned
    FROM agent_products ap
    INNER JOIN subscription_products sp ON sp.id = ap.product
    INNER JOIN company_users cu ON cu.id = ap.company_user_id
    WHERE cu.company_id = $1
    GROUP BY sp.id
),
SubscribedProducts AS (
    SELECT 
        sp.id AS product_id,
        SUM(spk.no_of_products) AS total_no_of_products
    FROM subscription_order so
    INNER JOIN subscription_package spk ON so.id = spk.subscription_order_id
    INNER JOIN subscription_products sp ON spk.product = sp.id
    WHERE so.subscriber_id = $1
        AND so.subscriber_type = 1
        AND so.status = 2
    GROUP BY sp.id
)
SELECT 
    sp.id AS product_id,
    sp.product,
    COALESCE(spd.total_no_of_products, 0)::bigint AS total,
    (COALESCE(spd.total_no_of_products, 0) - COALESCE(ap.assigned, 0))::bigint AS remaining
FROM subscription_products sp
LEFT JOIN AssignedProducts ap ON sp.id = ap.product_id
INNER JOIN SubscribedProducts spd ON sp.id = spd.product_id
ORDER BY sp.id
`

type GetRemainingCreditToAssignAgentByCompanyRow struct {
	ProductID int64  `json:"product_id"`
	Product   string `json:"product"`
	Total     int64  `json:"total"`
	Remaining int64  `json:"remaining"`
}

// -- name: UpdateRemainingSubscriptionPackage :one
// Update subscription_package
// SET remained_units = $1
// WHERE id = @package_id
// RETURNING *;
// -- name: GetRemainingCompanyQuota :many
// SELECT DISTINCT ON (subscription_products.id)
//
//	   subscription_products.id, subscription_products.product,
//	   SUM(subscription_package.remained_units) OVER (PARTITION BY subscription_products.id) AS total_no_of_products
//	FROM
//	   subscription_order
//
// INNER JOIN
//
//	subscription_package ON subscription_order.id = subscription_package.subscription_order_id
//
// INNER JOIN
//
//	subscription_products ON subscription_package.product = subscription_products.id
//
// WHERE
//
//	subscriber_id = @company_id
//	AND subscriber_type = 1
//	AND subscription_order.status = 1
//
// ORDER BY
//
//	subscription_products.id,
//	subscription_products.product;
func (q *Queries) GetRemainingCreditToAssignAgentByCompany(ctx context.Context, companyID int64) ([]GetRemainingCreditToAssignAgentByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getRemainingCreditToAssignAgentByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRemainingCreditToAssignAgentByCompanyRow
	for rows.Next() {
		var i GetRemainingCreditToAssignAgentByCompanyRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Product,
			&i.Total,
			&i.Remaining,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAgentProductsByCompUserID = `-- name: UpdateAgentProductsByCompUserID :one
Update agent_products
SET no_of_products = $2
WHERE company_user_id = $1 And agent_products.product =  $3
RETURNING id, company_user_id, product, no_of_products, created_by, created_at, updated_at
`

type UpdateAgentProductsByCompUserIDParams struct {
	CompanyUserID int64 `json:"company_user_id"`
	NoOfProducts  int32 `json:"no_of_products"`
	ProductID     int64 `json:"product_id"`
}

func (q *Queries) UpdateAgentProductsByCompUserID(ctx context.Context, arg UpdateAgentProductsByCompUserIDParams) (AgentProduct, error) {
	row := q.db.QueryRow(ctx, updateAgentProductsByCompUserID, arg.CompanyUserID, arg.NoOfProducts, arg.ProductID)
	var i AgentProduct
	err := row.Scan(
		&i.ID,
		&i.CompanyUserID,
		&i.Product,
		&i.NoOfProducts,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
