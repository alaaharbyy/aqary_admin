// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payment_plans.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPaymentPlan = `-- name: CreatePaymentPlan :one
INSERT INTO payment_plans (reference_no, payment_plan_title, no_of_installments, is_enabled)
VALUES ($1, $2, $3, $4)
RETURNING id, reference_no, payment_plan_title, no_of_installments, is_enabled
`

type CreatePaymentPlanParams struct {
	ReferenceNo      string      `json:"reference_no"`
	PaymentPlanTitle string      `json:"payment_plan_title"`
	NoOfInstallments int64       `json:"no_of_installments"`
	IsEnabled        pgtype.Bool `json:"is_enabled"`
}

func (q *Queries) CreatePaymentPlan(ctx context.Context, arg CreatePaymentPlanParams) (PaymentPlan, error) {
	row := q.db.QueryRow(ctx, createPaymentPlan,
		arg.ReferenceNo,
		arg.PaymentPlanTitle,
		arg.NoOfInstallments,
		arg.IsEnabled,
	)
	var i PaymentPlan
	err := row.Scan(
		&i.ID,
		&i.ReferenceNo,
		&i.PaymentPlanTitle,
		&i.NoOfInstallments,
		&i.IsEnabled,
	)
	return i, err
}

const createPaymentPlanPackages = `-- name: CreatePaymentPlanPackages :one
INSERT INTO payment_plans_packages (no_of_plans, entity_type_id, entity_id, payment_plans_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW()) RETURNING id, no_of_plans, entity_type_id, entity_id, payment_plans_id, created_at, updated_at
`

type CreatePaymentPlanPackagesParams struct {
	NoOfPlans      int64   `json:"no_of_plans"`
	EntityTypeID   int64   `json:"entity_type_id"`
	EntityID       int64   `json:"entity_id"`
	PaymentPlansID []int64 `json:"payment_plans_id"`
}

func (q *Queries) CreatePaymentPlanPackages(ctx context.Context, arg CreatePaymentPlanPackagesParams) (PaymentPlansPackage, error) {
	row := q.db.QueryRow(ctx, createPaymentPlanPackages,
		arg.NoOfPlans,
		arg.EntityTypeID,
		arg.EntityID,
		arg.PaymentPlansID,
	)
	var i PaymentPlansPackage
	err := row.Scan(
		&i.ID,
		&i.NoOfPlans,
		&i.EntityTypeID,
		&i.EntityID,
		&i.PaymentPlansID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlanInstallment = `-- name: CreatePlanInstallment :one
INSERT INTO plan_installments (payment_plans, percentage, date, milestone)
VALUES ($1, $2, $3, $4)
RETURNING id, payment_plans, percentage, date, milestone
`

type CreatePlanInstallmentParams struct {
	PaymentPlans int64              `json:"payment_plans"`
	Percentage   string             `json:"percentage"`
	Date         pgtype.Timestamptz `json:"date"`
	Milestone    string             `json:"milestone"`
}

func (q *Queries) CreatePlanInstallment(ctx context.Context, arg CreatePlanInstallmentParams) (PlanInstallment, error) {
	row := q.db.QueryRow(ctx, createPlanInstallment,
		arg.PaymentPlans,
		arg.Percentage,
		arg.Date,
		arg.Milestone,
	)
	var i PlanInstallment
	err := row.Scan(
		&i.ID,
		&i.PaymentPlans,
		&i.Percentage,
		&i.Date,
		&i.Milestone,
	)
	return i, err
}

const deleteAllPlanInstallmentsByIDs = `-- name: DeleteAllPlanInstallmentsByIDs :exec
DELETE FROM plan_installments
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteAllPlanInstallmentsByIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteAllPlanInstallmentsByIDs, dollar_1)
	return err
}

const deletePaymentPlanByID = `-- name: DeletePaymentPlanByID :exec
DELETE FROM payment_plans
WHERE id = $1
`

func (q *Queries) DeletePaymentPlanByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePaymentPlanByID, id)
	return err
}

const deletePaymentPlanPackagesByID = `-- name: DeletePaymentPlanPackagesByID :exec
DELETE FROM payment_plans_packages
WHERE id = $1
`

func (q *Queries) DeletePaymentPlanPackagesByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePaymentPlanPackagesByID, id)
	return err
}

const deletePlanInstallmentByID = `-- name: DeletePlanInstallmentByID :exec
DELETE FROM plan_installments
WHERE id = $1
`

func (q *Queries) DeletePlanInstallmentByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePlanInstallmentByID, id)
	return err
}

const getAllGlobalPropertyByEntity = `-- name: GetAllGlobalPropertyByEntity :one
select id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date from property where entity_id = $1 and entity_type_id = $2
`

type GetAllGlobalPropertyByEntityParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
}

func (q *Queries) GetAllGlobalPropertyByEntity(ctx context.Context, arg GetAllGlobalPropertyByEntityParams) (Property, error) {
	row := q.db.QueryRow(ctx, getAllGlobalPropertyByEntity, arg.EntityID, arg.EntityTypeID)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getAllGlobalPropertyById = `-- name: GetAllGlobalPropertyById :one
select id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date from property where id = $1
`

func (q *Queries) GetAllGlobalPropertyById(ctx context.Context, id int64) (Property, error) {
	row := q.db.QueryRow(ctx, getAllGlobalPropertyById, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getAllPaymentPlanPackages = `-- name: GetAllPaymentPlanPackages :many
SELECT id, no_of_plans, entity_type_id, entity_id, payment_plans_id, created_at, updated_at FROM payment_plans_packages
`

func (q *Queries) GetAllPaymentPlanPackages(ctx context.Context) ([]PaymentPlansPackage, error) {
	rows, err := q.db.Query(ctx, getAllPaymentPlanPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentPlansPackage
	for rows.Next() {
		var i PaymentPlansPackage
		if err := rows.Scan(
			&i.ID,
			&i.NoOfPlans,
			&i.EntityTypeID,
			&i.EntityID,
			&i.PaymentPlansID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPlanInstallmentIDsByPaymentPlansID = `-- name: GetAllPlanInstallmentIDsByPaymentPlansID :one
SELECT ARRAY(
    SELECT id FROM plan_installments
    WHERE payment_plans = $1
)::bigint[] AS ids
`

func (q *Queries) GetAllPlanInstallmentIDsByPaymentPlansID(ctx context.Context, paymentPlans int64) ([]int64, error) {
	row := q.db.QueryRow(ctx, getAllPlanInstallmentIDsByPaymentPlansID, paymentPlans)
	var ids []int64
	err := row.Scan(&ids)
	return ids, err
}

const getCountPaymentPlanInstallmentByPropertyVersionsID = `-- name: GetCountPaymentPlanInstallmentByPropertyVersionsID :one
SELECT count(pi.*)
FROM payment_plans_packages p
INNER JOIN payment_plans pp ON pp.id = ANY (p.payment_plans_id)
LEFT JOIN plan_installments pi ON pi.payment_plans = pp.id
WHERE p.entity_type_id = 3 and entity_id=$1
`

func (q *Queries) GetCountPaymentPlanInstallmentByPropertyVersionsID(ctx context.Context, entityID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountPaymentPlanInstallmentByPropertyVersionsID, entityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountPaymentPlanPackagesByEntityID = `-- name: GetCountPaymentPlanPackagesByEntityID :one
SELECT count(*) FROM payment_plans_packages
WHERE entity_id = $1 AND entity_type_id= $2
`

type GetCountPaymentPlanPackagesByEntityIDParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
}

func (q *Queries) GetCountPaymentPlanPackagesByEntityID(ctx context.Context, arg GetCountPaymentPlanPackagesByEntityIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountPaymentPlanPackagesByEntityID, arg.EntityID, arg.EntityTypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountPaymentPlanPackagesByEntityType = `-- name: GetCountPaymentPlanPackagesByEntityType :one
SELECT count(*) FROM payment_plans_packages
WHERE entity_type_id = $1
`

func (q *Queries) GetCountPaymentPlanPackagesByEntityType(ctx context.Context, entityTypeID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountPaymentPlanPackagesByEntityType, entityTypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPaymentPlan = `-- name: GetPaymentPlan :many
SELECT id, reference_no, payment_plan_title, no_of_installments, is_enabled FROM payment_plans
`

func (q *Queries) GetPaymentPlan(ctx context.Context) ([]PaymentPlan, error) {
	rows, err := q.db.Query(ctx, getPaymentPlan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentPlan
	for rows.Next() {
		var i PaymentPlan
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceNo,
			&i.PaymentPlanTitle,
			&i.NoOfInstallments,
			&i.IsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentPlanByID = `-- name: GetPaymentPlanByID :one
SELECT id, reference_no, payment_plan_title, no_of_installments, is_enabled FROM payment_plans
WHERE id = $1
`

func (q *Queries) GetPaymentPlanByID(ctx context.Context, id int64) (PaymentPlan, error) {
	row := q.db.QueryRow(ctx, getPaymentPlanByID, id)
	var i PaymentPlan
	err := row.Scan(
		&i.ID,
		&i.ReferenceNo,
		&i.PaymentPlanTitle,
		&i.NoOfInstallments,
		&i.IsEnabled,
	)
	return i, err
}

const getPaymentPlanInstallmentByID = `-- name: GetPaymentPlanInstallmentByID :many
SELECT DISTINCT pi.id, pi.payment_plans, pi.percentage, pi.date, pi.milestone, pp.is_enabled, pp.payment_plan_title
FROM payment_plans_packages p
INNER JOIN payment_plans pp ON pp.id = ANY (p.payment_plans_id)
LEFT JOIN plan_installments pi ON pi.payment_plans = pp.id
WHERE pp.id = $1
`

type GetPaymentPlanInstallmentByIDRow struct {
	ID               pgtype.Int8        `json:"id"`
	PaymentPlans     pgtype.Int8        `json:"payment_plans"`
	Percentage       pgtype.Text        `json:"percentage"`
	Date             pgtype.Timestamptz `json:"date"`
	Milestone        pgtype.Text        `json:"milestone"`
	IsEnabled        pgtype.Bool        `json:"is_enabled"`
	PaymentPlanTitle string             `json:"payment_plan_title"`
}

func (q *Queries) GetPaymentPlanInstallmentByID(ctx context.Context, id int64) ([]GetPaymentPlanInstallmentByIDRow, error) {
	rows, err := q.db.Query(ctx, getPaymentPlanInstallmentByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaymentPlanInstallmentByIDRow
	for rows.Next() {
		var i GetPaymentPlanInstallmentByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PaymentPlans,
			&i.Percentage,
			&i.Date,
			&i.Milestone,
			&i.IsEnabled,
			&i.PaymentPlanTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentPlanInstallmentByPropertyVersionsID = `-- name: GetPaymentPlanInstallmentByPropertyVersionsID :many
SELECT pi.id, pi.payment_plans, pi.percentage, pi.date, pi.milestone,pp.is_enabled, pp.payment_plan_title
FROM payment_plans_packages p
INNER JOIN payment_plans pp ON pp.id = ANY (p.payment_plans_id)
INNER JOIN plan_installments pi ON pi.payment_plans = pp.id
WHERE p.entity_type_id = $2 and entity_id=$1
`

type GetPaymentPlanInstallmentByPropertyVersionsIDParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
}

type GetPaymentPlanInstallmentByPropertyVersionsIDRow struct {
	ID               int64              `json:"id"`
	PaymentPlans     int64              `json:"payment_plans"`
	Percentage       string             `json:"percentage"`
	Date             pgtype.Timestamptz `json:"date"`
	Milestone        string             `json:"milestone"`
	IsEnabled        pgtype.Bool        `json:"is_enabled"`
	PaymentPlanTitle string             `json:"payment_plan_title"`
}

func (q *Queries) GetPaymentPlanInstallmentByPropertyVersionsID(ctx context.Context, arg GetPaymentPlanInstallmentByPropertyVersionsIDParams) ([]GetPaymentPlanInstallmentByPropertyVersionsIDRow, error) {
	rows, err := q.db.Query(ctx, getPaymentPlanInstallmentByPropertyVersionsID, arg.EntityID, arg.EntityTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaymentPlanInstallmentByPropertyVersionsIDRow
	for rows.Next() {
		var i GetPaymentPlanInstallmentByPropertyVersionsIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PaymentPlans,
			&i.Percentage,
			&i.Date,
			&i.Milestone,
			&i.IsEnabled,
			&i.PaymentPlanTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentPlanPackagesByEntityID = `-- name: GetPaymentPlanPackagesByEntityID :one
SELECT id, no_of_plans, entity_type_id, entity_id, payment_plans_id, created_at, updated_at FROM payment_plans_packages
WHERE entity_id = $1  AND entity_type_id= $2
`

type GetPaymentPlanPackagesByEntityIDParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
}

func (q *Queries) GetPaymentPlanPackagesByEntityID(ctx context.Context, arg GetPaymentPlanPackagesByEntityIDParams) (PaymentPlansPackage, error) {
	row := q.db.QueryRow(ctx, getPaymentPlanPackagesByEntityID, arg.EntityID, arg.EntityTypeID)
	var i PaymentPlansPackage
	err := row.Scan(
		&i.ID,
		&i.NoOfPlans,
		&i.EntityTypeID,
		&i.EntityID,
		&i.PaymentPlansID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentPlanPackagesByEntityType = `-- name: GetPaymentPlanPackagesByEntityType :one
SELECT id, no_of_plans, entity_type_id, entity_id, payment_plans_id, created_at, updated_at FROM payment_plans_packages
WHERE entity_type_id = $1
`

func (q *Queries) GetPaymentPlanPackagesByEntityType(ctx context.Context, entityTypeID int64) (PaymentPlansPackage, error) {
	row := q.db.QueryRow(ctx, getPaymentPlanPackagesByEntityType, entityTypeID)
	var i PaymentPlansPackage
	err := row.Scan(
		&i.ID,
		&i.NoOfPlans,
		&i.EntityTypeID,
		&i.EntityID,
		&i.PaymentPlansID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentPlanPackagesByID = `-- name: GetPaymentPlanPackagesByID :one
SELECT id, no_of_plans, entity_type_id, entity_id, payment_plans_id, created_at, updated_at FROM payment_plans_packages
WHERE id = $1
`

func (q *Queries) GetPaymentPlanPackagesByID(ctx context.Context, id int64) (PaymentPlansPackage, error) {
	row := q.db.QueryRow(ctx, getPaymentPlanPackagesByID, id)
	var i PaymentPlansPackage
	err := row.Scan(
		&i.ID,
		&i.NoOfPlans,
		&i.EntityTypeID,
		&i.EntityID,
		&i.PaymentPlansID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlanInstallmentByID = `-- name: GetPlanInstallmentByID :one
SELECT id, payment_plans, percentage, date, milestone FROM plan_installments
WHERE id = $1
`

func (q *Queries) GetPlanInstallmentByID(ctx context.Context, id int64) (PlanInstallment, error) {
	row := q.db.QueryRow(ctx, getPlanInstallmentByID, id)
	var i PlanInstallment
	err := row.Scan(
		&i.ID,
		&i.PaymentPlans,
		&i.Percentage,
		&i.Date,
		&i.Milestone,
	)
	return i, err
}

const getPlanInstallmentByPaymentPlanID = `-- name: GetPlanInstallmentByPaymentPlanID :many
SELECT id, payment_plans, percentage, date, milestone FROM plan_installments
WHERE payment_plans = $1
`

func (q *Queries) GetPlanInstallmentByPaymentPlanID(ctx context.Context, paymentPlans int64) ([]PlanInstallment, error) {
	rows, err := q.db.Query(ctx, getPlanInstallmentByPaymentPlanID, paymentPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanInstallment
	for rows.Next() {
		var i PlanInstallment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentPlans,
			&i.Percentage,
			&i.Date,
			&i.Milestone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanInstallments = `-- name: GetPlanInstallments :many
SELECT id, payment_plans, percentage, date, milestone FROM plan_installments
`

func (q *Queries) GetPlanInstallments(ctx context.Context) ([]PlanInstallment, error) {
	rows, err := q.db.Query(ctx, getPlanInstallments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanInstallment
	for rows.Next() {
		var i PlanInstallment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentPlans,
			&i.Percentage,
			&i.Date,
			&i.Milestone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEnablePaymentPlanPackagesByID = `-- name: UpdateEnablePaymentPlanPackagesByID :one
UPDATE payment_plans
SET is_enabled = $1
WHERE id = $2
RETURNING id, reference_no, payment_plan_title, no_of_installments, is_enabled
`

type UpdateEnablePaymentPlanPackagesByIDParams struct {
	IsEnabled pgtype.Bool `json:"is_enabled"`
	ID        int64       `json:"id"`
}

func (q *Queries) UpdateEnablePaymentPlanPackagesByID(ctx context.Context, arg UpdateEnablePaymentPlanPackagesByIDParams) (PaymentPlan, error) {
	row := q.db.QueryRow(ctx, updateEnablePaymentPlanPackagesByID, arg.IsEnabled, arg.ID)
	var i PaymentPlan
	err := row.Scan(
		&i.ID,
		&i.ReferenceNo,
		&i.PaymentPlanTitle,
		&i.NoOfInstallments,
		&i.IsEnabled,
	)
	return i, err
}

const updatePaymentPlanByID = `-- name: UpdatePaymentPlanByID :one
UPDATE payment_plans
SET payment_plan_title= $1,
    no_of_installments = $2
WHERE id = $3
RETURNING id, reference_no, payment_plan_title, no_of_installments, is_enabled
`

type UpdatePaymentPlanByIDParams struct {
	PaymentPlanTitle string `json:"payment_plan_title"`
	NoOfInstallments int64  `json:"no_of_installments"`
	ID               int64  `json:"id"`
}

func (q *Queries) UpdatePaymentPlanByID(ctx context.Context, arg UpdatePaymentPlanByIDParams) (PaymentPlan, error) {
	row := q.db.QueryRow(ctx, updatePaymentPlanByID, arg.PaymentPlanTitle, arg.NoOfInstallments, arg.ID)
	var i PaymentPlan
	err := row.Scan(
		&i.ID,
		&i.ReferenceNo,
		&i.PaymentPlanTitle,
		&i.NoOfInstallments,
		&i.IsEnabled,
	)
	return i, err
}

const updatePaymentPlanPackagesByID = `-- name: UpdatePaymentPlanPackagesByID :one
UPDATE payment_plans_packages
SET no_of_plans= $1,
    entity_type_id = $2,
    entity_id = $3,
    payment_plans_id = $4,
    updated_at = $5
WHERE id = $6
RETURNING id, no_of_plans, entity_type_id, entity_id, payment_plans_id, created_at, updated_at
`

type UpdatePaymentPlanPackagesByIDParams struct {
	NoOfPlans      int64     `json:"no_of_plans"`
	EntityTypeID   int64     `json:"entity_type_id"`
	EntityID       int64     `json:"entity_id"`
	PaymentPlansID []int64   `json:"payment_plans_id"`
	UpdatedAt      time.Time `json:"updated_at"`
	ID             int64     `json:"id"`
}

func (q *Queries) UpdatePaymentPlanPackagesByID(ctx context.Context, arg UpdatePaymentPlanPackagesByIDParams) (PaymentPlansPackage, error) {
	row := q.db.QueryRow(ctx, updatePaymentPlanPackagesByID,
		arg.NoOfPlans,
		arg.EntityTypeID,
		arg.EntityID,
		arg.PaymentPlansID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i PaymentPlansPackage
	err := row.Scan(
		&i.ID,
		&i.NoOfPlans,
		&i.EntityTypeID,
		&i.EntityID,
		&i.PaymentPlansID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlanInstallmentByID = `-- name: UpdatePlanInstallmentByID :one
UPDATE plan_installments
SET payment_plans= $1,
    percentage = $2, 
    milestone = $3,
    date = $4
WHERE id = $5
RETURNING id, payment_plans, percentage, date, milestone
`

type UpdatePlanInstallmentByIDParams struct {
	PaymentPlans int64              `json:"payment_plans"`
	Percentage   string             `json:"percentage"`
	Milestone    string             `json:"milestone"`
	Date         pgtype.Timestamptz `json:"date"`
	ID           int64              `json:"id"`
}

func (q *Queries) UpdatePlanInstallmentByID(ctx context.Context, arg UpdatePlanInstallmentByIDParams) (PlanInstallment, error) {
	row := q.db.QueryRow(ctx, updatePlanInstallmentByID,
		arg.PaymentPlans,
		arg.Percentage,
		arg.Milestone,
		arg.Date,
		arg.ID,
	)
	var i PlanInstallment
	err := row.Scan(
		&i.ID,
		&i.PaymentPlans,
		&i.Percentage,
		&i.Date,
		&i.Milestone,
	)
	return i, err
}
