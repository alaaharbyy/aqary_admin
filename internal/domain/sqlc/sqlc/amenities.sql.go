// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: amenities.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkIfAllFacilitiesAmenitiesAreCorrect = `-- name: CheckIfAllFacilitiesAmenitiesAreCorrect :many
SELECT 1::BIGINT
FROM facilities_amenities fa 
WHERE fa.id= ANY($1::BIGINT[])
`

func (q *Queries) CheckIfAllFacilitiesAmenitiesAreCorrect(ctx context.Context, facilitiesAmenitiesList []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, checkIfAllFacilitiesAmenitiesAreCorrect, facilitiesAmenitiesList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var column_1 int64
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkIfFacilityAmenityIsInUse = `-- name: CheckIfFacilityAmenityIsInUse :one
SELECT EXISTS(SELECT 1 FROM facilities_amenities_entity WHERE facility_amenity_id = $1)::boolean
`

func (q *Queries) CheckIfFacilityAmenityIsInUse(ctx context.Context, facilityAmenityID int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfFacilityAmenityIsInUse, facilityAmenityID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createBulkFacilityAmenityForEntity = `-- name: CreateBulkFacilityAmenityForEntity :exec
INSERT INTO facilities_amenities_entity (
 entity_type_id,
 entity_id,
 facility_amenity_id
) VALUES (
  $1, $2, unnest($3::bigint[])
) ON CONFLICT (entity_type_id,entity_id,facility_amenity_id) DO NOTHING
`

type CreateBulkFacilityAmenityForEntityParams struct {
	EntityTypeID       int64   `json:"entity_type_id"`
	EntityID           int64   `json:"entity_id"`
	FacilityAmenityIds []int64 `json:"facility_amenity_ids"`
}

func (q *Queries) CreateBulkFacilityAmenityForEntity(ctx context.Context, arg CreateBulkFacilityAmenityForEntityParams) error {
	_, err := q.db.Exec(ctx, createBulkFacilityAmenityForEntity, arg.EntityTypeID, arg.EntityID, arg.FacilityAmenityIds)
	return err
}

const createFacilityAmenity = `-- name: CreateFacilityAmenity :one
INSERT INTO facilities_amenities(
  icon_url,
  title,
  title_ar,
  "type",
  created_at,
  updated_at,
  categories,
  updated_by
)VALUES($1,$2,$3,$4,$5,$6,$7,$8)
RETURNING id, icon_url, title, type, created_at, updated_at, categories, updated_by, title_ar
`

type CreateFacilityAmenityParams struct {
	IconUrl    string      `json:"icon_url"`
	Title      string      `json:"title"`
	TitleAr    pgtype.Text `json:"title_ar"`
	Type       int64       `json:"type"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	Categories int64       `json:"categories"`
	UpdatedBy  int64       `json:"updated_by"`
}

func (q *Queries) CreateFacilityAmenity(ctx context.Context, arg CreateFacilityAmenityParams) (FacilitiesAmenity, error) {
	row := q.db.QueryRow(ctx, createFacilityAmenity,
		arg.IconUrl,
		arg.Title,
		arg.TitleAr,
		arg.Type,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Categories,
		arg.UpdatedBy,
	)
	var i FacilitiesAmenity
	err := row.Scan(
		&i.ID,
		&i.IconUrl,
		&i.Title,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Categories,
		&i.UpdatedBy,
		&i.TitleAr,
	)
	return i, err
}

const createFacilityAmenityForEntity = `-- name: CreateFacilityAmenityForEntity :one
  



INSERT INTO facilities_amenities_entity (
 entity_type_id,
 entity_id,
 facility_amenity_id
) VALUES (
  $1, $2, $3
)RETURNING id, entity_type_id, entity_id, facility_amenity_id
`

type CreateFacilityAmenityForEntityParams struct {
	EntityTypeID      int64 `json:"entity_type_id"`
	EntityID          int64 `json:"entity_id"`
	FacilityAmenityID int64 `json:"facility_amenity_id"`
}

// unit id
func (q *Queries) CreateFacilityAmenityForEntity(ctx context.Context, arg CreateFacilityAmenityForEntityParams) (FacilitiesAmenitiesEntity, error) {
	row := q.db.QueryRow(ctx, createFacilityAmenityForEntity, arg.EntityTypeID, arg.EntityID, arg.FacilityAmenityID)
	var i FacilitiesAmenitiesEntity
	err := row.Scan(
		&i.ID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.FacilityAmenityID,
	)
	return i, err
}

const deleteFacilityAmenity = `-- name: DeleteFacilityAmenity :exec
DELETE FROM facilities_amenities
WHERE id = $1
`

func (q *Queries) DeleteFacilityAmenity(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteFacilityAmenity, id)
	return err
}

const deleteFacilityAmenityEntityRecord = `-- name: DeleteFacilityAmenityEntityRecord :exec
DELETE FROM facilities_amenities_entity
WHERE id=$1
`

func (q *Queries) DeleteFacilityAmenityEntityRecord(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteFacilityAmenityEntityRecord, id)
	return err
}

const deleteFacilityAmenityForEntity = `-- name: DeleteFacilityAmenityForEntity :exec
DELETE FROM facilities_amenities_entity
WHERE entity_type_id = $1
  AND entity_id = $2
  AND facility_amenity_id NOT IN (
    SELECT facility_amenity_id
    FROM unnest($3::bigint[]) AS facility_amenity_id
  )
`

type DeleteFacilityAmenityForEntityParams struct {
	EntityTypeID             int64   `json:"entity_type_id"`
	EntityID                 int64   `json:"entity_id"`
	IgnoreFacilityAmenityIds []int64 `json:"ignore_facility_amenity_ids"`
}

func (q *Queries) DeleteFacilityAmenityForEntity(ctx context.Context, arg DeleteFacilityAmenityForEntityParams) error {
	_, err := q.db.Exec(ctx, deleteFacilityAmenityForEntity, arg.EntityTypeID, arg.EntityID, arg.IgnoreFacilityAmenityIds)
	return err
}

const deleteXMLFacilityAmenityForEntity = `-- name: DeleteXMLFacilityAmenityForEntity :exec
DELETE FROM facilities_amenities_entity
WHERE entity_type_id = $1
  AND entity_id = ANY($2::bigint[])
`

type DeleteXMLFacilityAmenityForEntityParams struct {
	EntityTypeID int64   `json:"entity_type_id"`
	EntityIds    []int64 `json:"entity_ids"`
}

func (q *Queries) DeleteXMLFacilityAmenityForEntity(ctx context.Context, arg DeleteXMLFacilityAmenityForEntityParams) error {
	_, err := q.db.Exec(ctx, deleteXMLFacilityAmenityForEntity, arg.EntityTypeID, arg.EntityIds)
	return err
}

const getAllAmenitiesById = `-- name: GetAllAmenitiesById :many









SELECT facilities_amenities.title,facilities_amenities.icon_url, facilities_amenities.categories, categories.category, facilities_amenities.type FROM facilities_amenities  
INNER JOIN categories ON categories.id = facilities_amenities.categories
INNER JOIN facilities_amenities_entity ON facilities_amenities_entity.facility_amenity_id = facilities_amenities.id
WHERE facilities_amenities_entity.entity_id = $1 AND facilities_amenities_entity.entity_type_id = $2 AND facilities_amenities.type = 2
`

type GetAllAmenitiesByIdParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
}

type GetAllAmenitiesByIdRow struct {
	Title      string `json:"title"`
	IconUrl    string `json:"icon_url"`
	Categories int64  `json:"categories"`
	Category   string `json:"category"`
	Type       int64  `json:"type"`
}

// -- name: CreateAmenities :one
// INSERT INTO amenities (
//
//	icon_url,
//	title,
//	created_at,
//	updated_at,
//	category_id
//
// )VALUES (
//
//	$1 ,$2, $3, $4, $5
//
// ) RETURNING *;
// -- name: GetAmenities :one
// SELECT * FROM amenities
// WHERE id = $1 LIMIT $1;
// -- name: GetAmenitiesWithoutPagination :one
// SELECT * FROM amenities ORDER BY id;
// -- name: UpdateAmenities :one
// UPDATE amenities
// SET    icon_url = $2,
//
//	title = $3,
//	created_at = $4,
//	updated_at = $5,
//	category_id = $6
//
// Where id = $1
// RETURNING *;
// -- name: DeleteAmenities :exec
// DELETE FROM amenities
// Where id = $1;
// -- name: GetAllAmenitiesOrderByCat :many
// SELECT amenities.*,facilities_amenities_categories.category FROM amenities LEFT JOIN facilities_amenities_categories ON facilities_amenities_categories.id = amenities.category_id
// ORDER BY category_id LIMIT $1 OFFSET $2;
// -- name: GetAllAmenitiesOrderByCatWithoutPagination :many
// SELECT amenities.*,facilities_amenities_categories.category FROM amenities LEFT JOIN facilities_amenities_categories ON facilities_amenities_categories.id = amenities.category_id
// ORDER BY category_id;
func (q *Queries) GetAllAmenitiesById(ctx context.Context, arg GetAllAmenitiesByIdParams) ([]GetAllAmenitiesByIdRow, error) {
	rows, err := q.db.Query(ctx, getAllAmenitiesById, arg.EntityID, arg.EntityTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAmenitiesByIdRow
	for rows.Next() {
		var i GetAllAmenitiesByIdRow
		if err := rows.Scan(
			&i.Title,
			&i.IconUrl,
			&i.Categories,
			&i.Category,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFacilitiesAmenitiesByCategoryWithoutPagination = `-- name: GetAllFacilitiesAmenitiesByCategoryWithoutPagination :many











 




SELECT 
    ca.category,
    jsonb_agg(
        jsonb_build_object(
            'id', fa.id,
            'title', 
            CASE WHEN $2::varchar = 'ar' THEN COALESCE(fa.title_ar,fa.title)
            ELSE COALESCE(fa.title, '') END,
            'icon_url', fa.icon_url,
            'type', fa.type::bigint,
            'created_at', fa.created_at
        )
        ORDER BY fa.created_at
    ) AS fac_ame
FROM categories ca
LEFT JOIN facilities_amenities fa ON ca.id = fa.categories
WHERE fa."type" = $1
GROUP BY ca.category
ORDER BY ca.category
`

type GetAllFacilitiesAmenitiesByCategoryWithoutPaginationParams struct {
	Type int64  `json:"type"`
	Lang string `json:"lang"`
}

type GetAllFacilitiesAmenitiesByCategoryWithoutPaginationRow struct {
	Category string `json:"category"`
	FacAme   []byte `json:"fac_ame"`
}

// -- name: GetAllAmenitiesWithoutPagenation :many
// SELECT * FROM amenities
// ORDER BY id;
// -- name: GetAmenityByTitleAndCategory :one
// SELECT * FROM amenities WHERE LOWER(title) = LOWER($1) AND category_id = $2;
// -- name: GetCountAllAmenities :one
// SELECT COUNT(*) FROM amenities;
// -- name: GetAllAmenitiesByCategoryIdWithoutPagenation :many
// SELECT * FROM amenities
// WHERE category_id = $1;
// -- name: DeleteAmenitiesByCategoryId :exec
// DELETE FROM amenities WHERE category_id = $1;
// -- name: GetAllAmenitiesByProjectID :many
// SELECT amenities.*,facilities_amenities_categories.category
// FROM amenities
// LEFT JOIN facilities_amenities_categories ON facilities_amenities_categories.id = amenities.category_id
// WHERE
//
//	amenities.id IN
//	(
//	    SELECT
//	        UNNEST(amenities_id)
//	    FROM
//	        projects
//	    WHERE
//	       projects.id = $1
//	);
//
// -- name: GetAllAmenitiesByPhaseID :many
// SELECT amenities.*,facilities_amenities_categories.category
// FROM amenities
// LEFT JOIN facilities_amenities_categories ON facilities_amenities_categories.id = amenities.category_id
// WHERE
//
//	amenities.id IN
//	(
//	    SELECT
//	        UNNEST(amenities)
//	    FROM
//	        phases
//	    WHERE
//	        phases.id = $1
//	);
//
// -- name: GetAllAmenitiesForProjectProperty :many
// SELECT amenities.*,facilities_amenities_categories.category
// FROM amenities
// LEFT JOIN facilities_amenities_categories ON facilities_amenities_categories.id = amenities.category_id
// WHERE
//
//	amenities.id IN
//	(
//	    SELECT
//	        UNNEST(amenities_id)
//	    FROM
//	        project_properties
//	    WHERE
//	        project_properties.id = $1
//	);
//
// -- name: GetAllFacilitiesAmenitiesByCategoryWithoutPagination :many
// SELECT facilities_amenities.*,categories.category FROM facilities_amenities LEFT JOIN categories ON facilities_amenities.categories = categories.id
// WHERE facilities_amenities."type"=$1
// ORDER BY facilities_amenities.categories;
func (q *Queries) GetAllFacilitiesAmenitiesByCategoryWithoutPagination(ctx context.Context, arg GetAllFacilitiesAmenitiesByCategoryWithoutPaginationParams) ([]GetAllFacilitiesAmenitiesByCategoryWithoutPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllFacilitiesAmenitiesByCategoryWithoutPagination, arg.Type, arg.Lang)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFacilitiesAmenitiesByCategoryWithoutPaginationRow
	for rows.Next() {
		var i GetAllFacilitiesAmenitiesByCategoryWithoutPaginationRow
		if err := rows.Scan(&i.Category, &i.FacAme); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFacilitiesAmenitiesWithoutPagination = `-- name: GetAllFacilitiesAmenitiesWithoutPagination :many
select 
  id,
  icon_url,
  CASE WHEN $2::varchar = 'ar' THEN COALESCE(fa.title_ar::varchar,fa.title::varchar)::varchar
  ELSE COALESCE(fa.title::varchar, '')::varchar END as title,
  type,
  created_at,
  updated_at,
  categories,
  updated_by
from facilities_amenities fa 
where fa.type = $1
`

type GetAllFacilitiesAmenitiesWithoutPaginationParams struct {
	Type int64  `json:"type"`
	Lang string `json:"lang"`
}

type GetAllFacilitiesAmenitiesWithoutPaginationRow struct {
	ID         int64     `json:"id"`
	IconUrl    string    `json:"icon_url"`
	Title      string    `json:"title"`
	Type       int64     `json:"type"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	Categories int64     `json:"categories"`
	UpdatedBy  int64     `json:"updated_by"`
}

func (q *Queries) GetAllFacilitiesAmenitiesWithoutPagination(ctx context.Context, arg GetAllFacilitiesAmenitiesWithoutPaginationParams) ([]GetAllFacilitiesAmenitiesWithoutPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllFacilitiesAmenitiesWithoutPagination, arg.Type, arg.Lang)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFacilitiesAmenitiesWithoutPaginationRow
	for rows.Next() {
		var i GetAllFacilitiesAmenitiesWithoutPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.IconUrl,
			&i.Title,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Categories,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFacilitiesAndAmenities = `-- name: GetAllFacilitiesAndAmenities :many
SELECT facilities_amenities_entity.id as record_id,facilities_amenities.id, facilities_amenities.icon_url, facilities_amenities.title, facilities_amenities.type, facilities_amenities.created_at, facilities_amenities.updated_at, facilities_amenities.categories, facilities_amenities.updated_by, facilities_amenities.title_ar FROM facilities_amenities_entity
LEFT JOIN facilities_amenities ON facilities_amenities_entity.facility_amenity_id = facilities_amenities.id
WHERE entity_type_id = $1 -- for units
AND entity_id = $2
`

type GetAllFacilitiesAndAmenitiesParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
}

type GetAllFacilitiesAndAmenitiesRow struct {
	RecordID   int64              `json:"record_id"`
	ID         pgtype.Int8        `json:"id"`
	IconUrl    pgtype.Text        `json:"icon_url"`
	Title      pgtype.Text        `json:"title"`
	Type       pgtype.Int8        `json:"type"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	Categories pgtype.Int8        `json:"categories"`
	UpdatedBy  pgtype.Int8        `json:"updated_by"`
	TitleAr    pgtype.Text        `json:"title_ar"`
}

func (q *Queries) GetAllFacilitiesAndAmenities(ctx context.Context, arg GetAllFacilitiesAndAmenitiesParams) ([]GetAllFacilitiesAndAmenitiesRow, error) {
	rows, err := q.db.Query(ctx, getAllFacilitiesAndAmenities, arg.EntityTypeID, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFacilitiesAndAmenitiesRow
	for rows.Next() {
		var i GetAllFacilitiesAndAmenitiesRow
		if err := rows.Scan(
			&i.RecordID,
			&i.ID,
			&i.IconUrl,
			&i.Title,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Categories,
			&i.UpdatedBy,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFacilityAmenity = `-- name: GetAllFacilityAmenity :many
SELECT facilities_amenities.id,facilities_amenities.title,facilities_amenities.title_ar,facilities_amenities."type",icon_url,categories.id AS category_id,categories.category, COUNT(facilities_amenities.id) OVER() AS total_count
FROM facilities_amenities
INNER JOIN categories ON categories.id = facilities_amenities.categories
WHERE facilities_amenities."type" = $1
ORDER BY id DESC
LIMIT $3 OFFSET $2
`

type GetAllFacilityAmenityParams struct {
	Type   int64       `json:"type"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllFacilityAmenityRow struct {
	ID         int64       `json:"id"`
	Title      string      `json:"title"`
	TitleAr    pgtype.Text `json:"title_ar"`
	Type       int64       `json:"type"`
	IconUrl    string      `json:"icon_url"`
	CategoryID int64       `json:"category_id"`
	Category   string      `json:"category"`
	TotalCount int64       `json:"total_count"`
}

func (q *Queries) GetAllFacilityAmenity(ctx context.Context, arg GetAllFacilityAmenityParams) ([]GetAllFacilityAmenityRow, error) {
	rows, err := q.db.Query(ctx, getAllFacilityAmenity, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFacilityAmenityRow
	for rows.Next() {
		var i GetAllFacilityAmenityRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TitleAr,
			&i.Type,
			&i.IconUrl,
			&i.CategoryID,
			&i.Category,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFacilityAmenityForEntity = `-- name: GetAllFacilityAmenityForEntity :many
SELECT facility_amenity_id FROM facilities_amenities_entity
WHERE entity_type_id = $1 AND entity_id = $2
`

type GetAllFacilityAmenityForEntityParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
}

func (q *Queries) GetAllFacilityAmenityForEntity(ctx context.Context, arg GetAllFacilityAmenityForEntityParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllFacilityAmenityForEntity, arg.EntityTypeID, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var facility_amenity_id int64
		if err := rows.Scan(&facility_amenity_id); err != nil {
			return nil, err
		}
		items = append(items, facility_amenity_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFacilityAmenityIdsByTitle = `-- name: GetAllFacilityAmenityIdsByTitle :many
SELECT id
FROM facilities_amenities 
WHERE TRIM(LOWER(title)) IN (
    SELECT TRIM(LOWER(unnest($2::varchar[])))
) AND type = $1
`

type GetAllFacilityAmenityIdsByTitleParams struct {
	Type  int64    `json:"type"`
	Title []string `json:"title"`
}

func (q *Queries) GetAllFacilityAmenityIdsByTitle(ctx context.Context, arg GetAllFacilityAmenityIdsByTitleParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllFacilityAmenityIdsByTitle, arg.Type, arg.Title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFacilitiesAmenities = `-- name: GetFacilitiesAmenities :many
SELECT id, icon_url, title, type, created_at, updated_at, categories, updated_by, title_ar FROM facilities_amenities where id=ANY($1::BIGINT[])
`

func (q *Queries) GetFacilitiesAmenities(ctx context.Context, dollar_1 []int64) ([]FacilitiesAmenity, error) {
	rows, err := q.db.Query(ctx, getFacilitiesAmenities, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FacilitiesAmenity
	for rows.Next() {
		var i FacilitiesAmenity
		if err := rows.Scan(
			&i.ID,
			&i.IconUrl,
			&i.Title,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Categories,
			&i.UpdatedBy,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFacilitiesAmenitiesByType = `-- name: GetFacilitiesAmenitiesByType :many
SELECT id, icon_url, title, type, created_at, updated_at, categories, updated_by, title_ar FROM facilities_amenities where id=ANY($1::BIGINT[]) and type=$2
`

type GetFacilitiesAmenitiesByTypeParams struct {
	Column1 []int64 `json:"column_1"`
	Type    int64   `json:"type"`
}

func (q *Queries) GetFacilitiesAmenitiesByType(ctx context.Context, arg GetFacilitiesAmenitiesByTypeParams) ([]FacilitiesAmenity, error) {
	rows, err := q.db.Query(ctx, getFacilitiesAmenitiesByType, arg.Column1, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FacilitiesAmenity
	for rows.Next() {
		var i FacilitiesAmenity
		if err := rows.Scan(
			&i.ID,
			&i.IconUrl,
			&i.Title,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Categories,
			&i.UpdatedBy,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFacilityAmenity = `-- name: GetFacilityAmenity :one
SELECT id, icon_url, title, type, created_at, updated_at, categories, updated_by, title_ar FROM facilities_amenities
WHERE id = $1
`

func (q *Queries) GetFacilityAmenity(ctx context.Context, id int64) (FacilitiesAmenity, error) {
	row := q.db.QueryRow(ctx, getFacilityAmenity, id)
	var i FacilitiesAmenity
	err := row.Scan(
		&i.ID,
		&i.IconUrl,
		&i.Title,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Categories,
		&i.UpdatedBy,
		&i.TitleAr,
	)
	return i, err
}

const getFaclitiesAmenitiesForEntityIDAndType = `-- name: GetFaclitiesAmenitiesForEntityIDAndType :many
select facilities_amenities.id, facilities_amenities.icon_url, facilities_amenities.title, facilities_amenities.type, facilities_amenities.created_at, facilities_amenities.updated_at, facilities_amenities.categories, facilities_amenities.updated_by, facilities_amenities.title_ar,categories.category from facilities_amenities_entity
inner join facilities_amenities on facilities_amenities_entity.facility_amenity_id = facilities_amenities.id
inner join categories on facilities_amenities.categories = categories.id
 where entity_type_id=$1 and entity_id=$2
`

type GetFaclitiesAmenitiesForEntityIDAndTypeParams struct {
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
}

type GetFaclitiesAmenitiesForEntityIDAndTypeRow struct {
	ID         int64       `json:"id"`
	IconUrl    string      `json:"icon_url"`
	Title      string      `json:"title"`
	Type       int64       `json:"type"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	Categories int64       `json:"categories"`
	UpdatedBy  int64       `json:"updated_by"`
	TitleAr    pgtype.Text `json:"title_ar"`
	Category   string      `json:"category"`
}

func (q *Queries) GetFaclitiesAmenitiesForEntityIDAndType(ctx context.Context, arg GetFaclitiesAmenitiesForEntityIDAndTypeParams) ([]GetFaclitiesAmenitiesForEntityIDAndTypeRow, error) {
	rows, err := q.db.Query(ctx, getFaclitiesAmenitiesForEntityIDAndType, arg.EntityTypeID, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFaclitiesAmenitiesForEntityIDAndTypeRow
	for rows.Next() {
		var i GetFaclitiesAmenitiesForEntityIDAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.IconUrl,
			&i.Title,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Categories,
			&i.UpdatedBy,
			&i.TitleAr,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleFacilityAmenity = `-- name: GetSingleFacilityAmenity :one
SELECT id, icon_url, title, type, created_at, updated_at, categories, updated_by, title_ar FROM facilities_amenities where id=$1
`

func (q *Queries) GetSingleFacilityAmenity(ctx context.Context, id int64) (FacilitiesAmenity, error) {
	row := q.db.QueryRow(ctx, getSingleFacilityAmenity, id)
	var i FacilitiesAmenity
	err := row.Scan(
		&i.ID,
		&i.IconUrl,
		&i.Title,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Categories,
		&i.UpdatedBy,
		&i.TitleAr,
	)
	return i, err
}

const updateFacilityAmenity = `-- name: UpdateFacilityAmenity :one
UPDATE facilities_amenities
  SET icon_url = $2,
  title = $3,
  title_ar = $8,
  "type" = $4,
  updated_at = $5,
  categories = $6,
  updated_by = $7
  WHERE id = $1
RETURNING id, icon_url, title, type, created_at, updated_at, categories, updated_by, title_ar
`

type UpdateFacilityAmenityParams struct {
	ID         int64       `json:"id"`
	IconUrl    string      `json:"icon_url"`
	Title      string      `json:"title"`
	Type       int64       `json:"type"`
	UpdatedAt  time.Time   `json:"updated_at"`
	Categories int64       `json:"categories"`
	UpdatedBy  int64       `json:"updated_by"`
	TitleAr    pgtype.Text `json:"title_ar"`
}

func (q *Queries) UpdateFacilityAmenity(ctx context.Context, arg UpdateFacilityAmenityParams) (FacilitiesAmenity, error) {
	row := q.db.QueryRow(ctx, updateFacilityAmenity,
		arg.ID,
		arg.IconUrl,
		arg.Title,
		arg.Type,
		arg.UpdatedAt,
		arg.Categories,
		arg.UpdatedBy,
		arg.TitleAr,
	)
	var i FacilitiesAmenity
	err := row.Scan(
		&i.ID,
		&i.IconUrl,
		&i.Title,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Categories,
		&i.UpdatedBy,
		&i.TitleAr,
	)
	return i, err
}
