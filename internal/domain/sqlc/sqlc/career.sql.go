// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: career.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNewCareer = `-- name: CreateNewCareer :one
INSERT INTO careers (
ref_no,
job_title,
job_title_ar,
employment_types,
employment_mode,
job_style,
job_categories,
career_level,
addresses_id,
is_urgent,
job_description,
job_image,
number_of_positions,
years_of_experience,
gender,
nationality_id,
min_salary,
max_salary,
languages,
uploaded_by,
date_expired,
career_status,
education_level,
specialization,
skills,
global_tagging_id,
created_at,
updated_at,
field_of_study,
status,
rank
) VALUES (
$1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
$11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
$21, $22, $23, $24,$25,$26,$27,$28,$29,$30,$31
) RETURNING id, ref_no, job_title, job_title_ar, employment_types, employment_mode, job_style, job_categories, career_level, addresses_id, is_urgent, job_description, job_image, number_of_positions, years_of_experience, gender, nationality_id, min_salary, max_salary, languages, uploaded_by, date_expired, career_status, education_level, specialization, skills, global_tagging_id, created_at, updated_at, field_of_study, status, rank
`

type CreateNewCareerParams struct {
	RefNo             string        `json:"ref_no"`
	JobTitle          string        `json:"job_title"`
	JobTitleAr        pgtype.Text   `json:"job_title_ar"`
	EmploymentTypes   int64         `json:"employment_types"`
	EmploymentMode    pgtype.Int8   `json:"employment_mode"`
	JobStyle          pgtype.Int8   `json:"job_style"`
	JobCategories     int64         `json:"job_categories"`
	CareerLevel       pgtype.Int8   `json:"career_level"`
	AddressesID       int64         `json:"addresses_id"`
	IsUrgent          bool          `json:"is_urgent"`
	JobDescription    string        `json:"job_description"`
	JobImage          pgtype.Text   `json:"job_image"`
	NumberOfPositions pgtype.Int8   `json:"number_of_positions"`
	YearsOfExperience pgtype.Int8   `json:"years_of_experience"`
	Gender            int64         `json:"gender"`
	NationalityID     []int64       `json:"nationality_id"`
	MinSalary         pgtype.Float8 `json:"min_salary"`
	MaxSalary         pgtype.Float8 `json:"max_salary"`
	Languages         []int64       `json:"languages"`
	UploadedBy        int64         `json:"uploaded_by"`
	DateExpired       time.Time     `json:"date_expired"`
	CareerStatus      int64         `json:"career_status"`
	EducationLevel    pgtype.Int8   `json:"education_level"`
	Specialization    []int64       `json:"specialization"`
	Skills            []int64       `json:"skills"`
	GlobalTaggingID   []int64       `json:"global_tagging_id"`
	CreatedAt         time.Time     `json:"created_at"`
	UpdatedAt         time.Time     `json:"updated_at"`
	FieldOfStudy      int64         `json:"field_of_study"`
	Status            int64         `json:"status"`
	Rank              int64         `json:"rank"`
}

func (q *Queries) CreateNewCareer(ctx context.Context, arg CreateNewCareerParams) (Career, error) {
	row := q.db.QueryRow(ctx, createNewCareer,
		arg.RefNo,
		arg.JobTitle,
		arg.JobTitleAr,
		arg.EmploymentTypes,
		arg.EmploymentMode,
		arg.JobStyle,
		arg.JobCategories,
		arg.CareerLevel,
		arg.AddressesID,
		arg.IsUrgent,
		arg.JobDescription,
		arg.JobImage,
		arg.NumberOfPositions,
		arg.YearsOfExperience,
		arg.Gender,
		arg.NationalityID,
		arg.MinSalary,
		arg.MaxSalary,
		arg.Languages,
		arg.UploadedBy,
		arg.DateExpired,
		arg.CareerStatus,
		arg.EducationLevel,
		arg.Specialization,
		arg.Skills,
		arg.GlobalTaggingID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.FieldOfStudy,
		arg.Status,
		arg.Rank,
	)
	var i Career
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.JobTitle,
		&i.JobTitleAr,
		&i.EmploymentTypes,
		&i.EmploymentMode,
		&i.JobStyle,
		&i.JobCategories,
		&i.CareerLevel,
		&i.AddressesID,
		&i.IsUrgent,
		&i.JobDescription,
		&i.JobImage,
		&i.NumberOfPositions,
		&i.YearsOfExperience,
		&i.Gender,
		&i.NationalityID,
		&i.MinSalary,
		&i.MaxSalary,
		&i.Languages,
		&i.UploadedBy,
		&i.DateExpired,
		&i.CareerStatus,
		&i.EducationLevel,
		&i.Specialization,
		&i.Skills,
		&i.GlobalTaggingID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FieldOfStudy,
		&i.Status,
		&i.Rank,
	)
	return i, err
}

const deleteCareerByID = `-- name: DeleteCareerByID :exec
UPDATE
    careers
SET
    updated_at=$2,
    career_status = 6
WHERE
    id = $1
`

type DeleteCareerByIDParams struct {
	ID        int64     `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) DeleteCareerByID(ctx context.Context, arg DeleteCareerByIDParams) error {
	_, err := q.db.Exec(ctx, deleteCareerByID, arg.ID, arg.UpdatedAt)
	return err
}

const deleteJobCategory = `-- name: DeleteJobCategory :one
UPDATE job_categories
SET
    status = 6
WHERE
    id = $1
RETURNING id, parent_category_id, category_name, description, category_image, created_at, status, updated_at
`

func (q *Queries) DeleteJobCategory(ctx context.Context, id int64) (JobCategory, error) {
	row := q.db.QueryRow(ctx, deleteJobCategory, id)
	var i JobCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.CategoryName,
		&i.Description,
		&i.CategoryImage,
		&i.CreatedAt,
		&i.Status,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllCareersForCatg = `-- name: GetAllCareersForCatg :many
SELECT id, ref_no, job_title, job_title_ar, employment_types, employment_mode, job_style, job_categories, career_level, addresses_id, is_urgent, job_description, job_image, number_of_positions, years_of_experience, gender, nationality_id, min_salary, max_salary, languages, uploaded_by, date_expired, career_status, education_level, specialization, skills, global_tagging_id, created_at, updated_at, field_of_study, status, rank FROM careers 
WHERE job_categories=$1 AND career_status!=6
LIMIT $2 OFFSET $3
`

type GetAllCareersForCatgParams struct {
	JobCategories int64 `json:"job_categories"`
	Limit         int32 `json:"limit"`
	Offset        int32 `json:"offset"`
}

func (q *Queries) GetAllCareersForCatg(ctx context.Context, arg GetAllCareersForCatgParams) ([]Career, error) {
	rows, err := q.db.Query(ctx, getAllCareersForCatg, arg.JobCategories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Career
	for rows.Next() {
		var i Career
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.JobTitle,
			&i.JobTitleAr,
			&i.EmploymentTypes,
			&i.EmploymentMode,
			&i.JobStyle,
			&i.JobCategories,
			&i.CareerLevel,
			&i.AddressesID,
			&i.IsUrgent,
			&i.JobDescription,
			&i.JobImage,
			&i.NumberOfPositions,
			&i.YearsOfExperience,
			&i.Gender,
			&i.NationalityID,
			&i.MinSalary,
			&i.MaxSalary,
			&i.Languages,
			&i.UploadedBy,
			&i.DateExpired,
			&i.CareerStatus,
			&i.EducationLevel,
			&i.Specialization,
			&i.Skills,
			&i.GlobalTaggingID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FieldOfStudy,
			&i.Status,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCareerByID = `-- name: GetCareerByID :one
SELECT
    cr.id, cr.ref_no, cr.job_title, cr.job_title_ar, cr.employment_types, cr.employment_mode, cr.job_style, cr.job_categories, cr.career_level, cr.addresses_id, cr.is_urgent, cr.job_description, cr.job_image, cr.number_of_positions, cr.years_of_experience, cr.gender, cr.nationality_id, cr.min_salary, cr.max_salary, cr.languages, cr.uploaded_by, cr.date_expired, cr.career_status, cr.education_level, cr.specialization, cr.skills, cr.global_tagging_id, cr.created_at, cr.updated_at, cr.field_of_study, cr.status, cr.rank,
    companies.id, companies.ref_no, companies.company_name, companies.company_activities_id, companies.company_parent_id, companies.tag_line, companies.description, companies.description_ar, companies.logo_url, companies.email, companies.phone_number, companies.whatsapp_number, companies.is_verified, companies.website_url, companies.cover_image_url, companies.no_of_employees, companies.company_rank, companies.status, companies.company_type, companies.addresses_id, companies.users_id, companies.created_by, companies.created_at, companies.updated_at, companies.updated_by, companies.location_url, companies.vat_no, companies.vat_status, companies.vat_file_url
FROM
    careers cr
JOIN company_users u ON cr.uploaded_by=u.users_id
JOIN companies ON u.company_id= companies.id
WHERE
    cr.id = $1
`

type GetCareerByIDRow struct {
	Career  Career  `json:"career"`
	Company Company `json:"company"`
}

func (q *Queries) GetCareerByID(ctx context.Context, id int64) (GetCareerByIDRow, error) {
	row := q.db.QueryRow(ctx, getCareerByID, id)
	var i GetCareerByIDRow
	err := row.Scan(
		&i.Career.ID,
		&i.Career.RefNo,
		&i.Career.JobTitle,
		&i.Career.JobTitleAr,
		&i.Career.EmploymentTypes,
		&i.Career.EmploymentMode,
		&i.Career.JobStyle,
		&i.Career.JobCategories,
		&i.Career.CareerLevel,
		&i.Career.AddressesID,
		&i.Career.IsUrgent,
		&i.Career.JobDescription,
		&i.Career.JobImage,
		&i.Career.NumberOfPositions,
		&i.Career.YearsOfExperience,
		&i.Career.Gender,
		&i.Career.NationalityID,
		&i.Career.MinSalary,
		&i.Career.MaxSalary,
		&i.Career.Languages,
		&i.Career.UploadedBy,
		&i.Career.DateExpired,
		&i.Career.CareerStatus,
		&i.Career.EducationLevel,
		&i.Career.Specialization,
		&i.Career.Skills,
		&i.Career.GlobalTaggingID,
		&i.Career.CreatedAt,
		&i.Career.UpdatedAt,
		&i.Career.FieldOfStudy,
		&i.Career.Status,
		&i.Career.Rank,
		&i.Company.ID,
		&i.Company.RefNo,
		&i.Company.CompanyName,
		&i.Company.CompanyActivitiesID,
		&i.Company.CompanyParentID,
		&i.Company.TagLine,
		&i.Company.Description,
		&i.Company.DescriptionAr,
		&i.Company.LogoUrl,
		&i.Company.Email,
		&i.Company.PhoneNumber,
		&i.Company.WhatsappNumber,
		&i.Company.IsVerified,
		&i.Company.WebsiteUrl,
		&i.Company.CoverImageUrl,
		&i.Company.NoOfEmployees,
		&i.Company.CompanyRank,
		&i.Company.Status,
		&i.Company.CompanyType,
		&i.Company.AddressesID,
		&i.Company.UsersID,
		&i.Company.CreatedBy,
		&i.Company.CreatedAt,
		&i.Company.UpdatedAt,
		&i.Company.UpdatedBy,
		&i.Company.LocationUrl,
		&i.Company.VatNo,
		&i.Company.VatStatus,
		&i.Company.VatFileUrl,
	)
	return i, err
}

const getCareerCount = `-- name: GetCareerCount :one
SELECT
count(*)
FROM
    careers cr
JOIN
    countries co ON cr.countries_id = co.id
JOIN
    cities ci ON cr.city_id = ci.id
JOIN
    communities com ON cr.community_id = com.id
WHERE
   
     ($1 = '%%' OR 
     cr.job_title % $1 OR
     cr.job_title_ar % $1 OR
     cr.ref_no % $1 OR
     co.country % $1 OR
     ci.city % $1 OR 
     com.community % $1)
     OR 
     (CASE
        WHEN 'draft' ILIKE $1 THEN cr.career_status = 1
        WHEN 'active' ILIKE $1 THEN cr.career_status = 2
        WHEN 'reposted' ILIKE $1 THEN cr.career_status = 7
        WHEN 'closed' ILIKE $1 THEN cr.career_status = 8
        WHEN 'male' ILIKE $1 THEN cr.gender=1
        WHEN 'female' ILIKE $1 THEN cr.gender=2
        WHEN 'urgent' ILIKE $1 THEN cr.is_urgent = true
        ELSE FALSE
      END)
     AND cr.career_status NOT IN (5,6)
`

// JOIN
//
//	employers e ON cr.employers_id = e.id
func (q *Queries) GetCareerCount(ctx context.Context, dollar_1 interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, getCareerCount, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCareers = `-- name: GetCareers :many
SELECT
    cr.id, cr.ref_no, cr.job_title, cr.job_title_ar, cr.employment_types, cr.employment_mode, cr.job_style, cr.job_categories, cr.career_level, cr.addresses_id, cr.is_urgent, cr.job_description, cr.job_image, cr.number_of_positions, cr.years_of_experience, cr.gender, cr.nationality_id, cr.min_salary, cr.max_salary, cr.languages, cr.uploaded_by, cr.date_expired, cr.career_status, cr.education_level, cr.specialization, cr.skills, cr.global_tagging_id, cr.created_at, cr.updated_at, cr.field_of_study, cr.status, cr.rank,
    companies.id, companies.ref_no, companies.company_name, companies.company_activities_id, companies.company_parent_id, companies.tag_line, companies.description, companies.description_ar, companies.logo_url, companies.email, companies.phone_number, companies.whatsapp_number, companies.is_verified, companies.website_url, companies.cover_image_url, companies.no_of_employees, companies.company_rank, companies.status, companies.company_type, companies.addresses_id, companies.users_id, companies.created_by, companies.created_at, companies.updated_at, companies.updated_by, companies.location_url, companies.vat_no, companies.vat_status, companies.vat_file_url
FROM
    careers cr
JOIN addresses a ON cr.addresses_id=a.id
JOIN company_users u ON cr.uploaded_by=u.users_id
JOIN companies ON u.company_id= companies.id
WHERE
	 (CASE WHEN $3::BIGINT=0 THEN TRUE ELSE u.company_id= $3::BIGINT end)
AND
    (ARRAY_LENGTH($4::bigint [],1) IS NULL OR cr."rank" = ANY ($4::bigint []))
AND
    (CASE WHEN  $5::bigint=0 THEN TRUE ELSE a.countries_id = $5::bigint end) 
AND   
    (CASE WHEN $6::bigint=0 THEN TRUE ELSE a.cities_id= $6::bigint END)
AND
     (CASE WHEN $7::bigint=0 THEN TRUE ELSE a.communities_id= $7::bigint END)
AND
     (CASE WHEN $8::bigint=0 THEN TRUE ELSE a.sub_communities_id= $8::bigint END)
AND  
	 cr.status= $9::bigint
AND 
    (ARRAY_LENGTH($10::bigint [],1) IS NULL OR cr.career_status = ANY ($10::bigint []))
ORDER BY
	CASE
        WHEN $11::bigint = 1 THEN cr.updated_at END DESC,
    CASE
        WHEN $11::bigint = 2 THEN cr.max_salary::FLOAT END DESC,
    CASE
        WHEN $11::bigint = 3 THEN cr.max_salary::FLOAT END ASC,
     CASE
        WHEN $11::bigint = 4 THEN cr."rank"::BIGINT END DESC
OFFSET $1
LIMIT $2
`

type GetCareersParams struct {
	Offset           int32   `json:"offset"`
	Limit            int32   `json:"limit"`
	CompanyID        int64   `json:"company_id"`
	CareerRank       []int64 `json:"career_rank"`
	CountryID        int64   `json:"country_id"`
	CityID           int64   `json:"city_id"`
	CommunitiesID    int64   `json:"communities_id"`
	SubCommunitiesID int64   `json:"sub_communities_id"`
	Status           int64   `json:"status"`
	CareerStatus     []int64 `json:"career_status"`
	SortBy           int64   `json:"sort_by"`
}

type GetCareersRow struct {
	Career  Career  `json:"career"`
	Company Company `json:"company"`
}

func (q *Queries) GetCareers(ctx context.Context, arg GetCareersParams) ([]GetCareersRow, error) {
	rows, err := q.db.Query(ctx, getCareers,
		arg.Offset,
		arg.Limit,
		arg.CompanyID,
		arg.CareerRank,
		arg.CountryID,
		arg.CityID,
		arg.CommunitiesID,
		arg.SubCommunitiesID,
		arg.Status,
		arg.CareerStatus,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCareersRow
	for rows.Next() {
		var i GetCareersRow
		if err := rows.Scan(
			&i.Career.ID,
			&i.Career.RefNo,
			&i.Career.JobTitle,
			&i.Career.JobTitleAr,
			&i.Career.EmploymentTypes,
			&i.Career.EmploymentMode,
			&i.Career.JobStyle,
			&i.Career.JobCategories,
			&i.Career.CareerLevel,
			&i.Career.AddressesID,
			&i.Career.IsUrgent,
			&i.Career.JobDescription,
			&i.Career.JobImage,
			&i.Career.NumberOfPositions,
			&i.Career.YearsOfExperience,
			&i.Career.Gender,
			&i.Career.NationalityID,
			&i.Career.MinSalary,
			&i.Career.MaxSalary,
			&i.Career.Languages,
			&i.Career.UploadedBy,
			&i.Career.DateExpired,
			&i.Career.CareerStatus,
			&i.Career.EducationLevel,
			&i.Career.Specialization,
			&i.Career.Skills,
			&i.Career.GlobalTaggingID,
			&i.Career.CreatedAt,
			&i.Career.UpdatedAt,
			&i.Career.FieldOfStudy,
			&i.Career.Status,
			&i.Career.Rank,
			&i.Company.ID,
			&i.Company.RefNo,
			&i.Company.CompanyName,
			&i.Company.CompanyActivitiesID,
			&i.Company.CompanyParentID,
			&i.Company.TagLine,
			&i.Company.Description,
			&i.Company.DescriptionAr,
			&i.Company.LogoUrl,
			&i.Company.Email,
			&i.Company.PhoneNumber,
			&i.Company.WhatsappNumber,
			&i.Company.IsVerified,
			&i.Company.WebsiteUrl,
			&i.Company.CoverImageUrl,
			&i.Company.NoOfEmployees,
			&i.Company.CompanyRank,
			&i.Company.Status,
			&i.Company.CompanyType,
			&i.Company.AddressesID,
			&i.Company.UsersID,
			&i.Company.CreatedBy,
			&i.Company.CreatedAt,
			&i.Company.UpdatedAt,
			&i.Company.UpdatedBy,
			&i.Company.LocationUrl,
			&i.Company.VatNo,
			&i.Company.VatStatus,
			&i.Company.VatFileUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCareersByUserId = `-- name: GetCareersByUserId :many
SELECT 
id, ref_no, job_title, job_title_ar, employment_types, employment_mode, job_style, job_categories, career_level, addresses_id, is_urgent, job_description, job_image, number_of_positions, years_of_experience, gender, nationality_id, min_salary, max_salary, languages, uploaded_by, date_expired, career_status, education_level, specialization, skills, global_tagging_id, created_at, updated_at, field_of_study, status, rank
FROM careers
WHERE uploaded_by = $1
`

func (q *Queries) GetCareersByUserId(ctx context.Context, uploadedBy int64) ([]Career, error) {
	rows, err := q.db.Query(ctx, getCareersByUserId, uploadedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Career
	for rows.Next() {
		var i Career
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.JobTitle,
			&i.JobTitleAr,
			&i.EmploymentTypes,
			&i.EmploymentMode,
			&i.JobStyle,
			&i.JobCategories,
			&i.CareerLevel,
			&i.AddressesID,
			&i.IsUrgent,
			&i.JobDescription,
			&i.JobImage,
			&i.NumberOfPositions,
			&i.YearsOfExperience,
			&i.Gender,
			&i.NationalityID,
			&i.MinSalary,
			&i.MaxSalary,
			&i.Languages,
			&i.UploadedBy,
			&i.DateExpired,
			&i.CareerStatus,
			&i.EducationLevel,
			&i.Specialization,
			&i.Skills,
			&i.GlobalTaggingID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FieldOfStudy,
			&i.Status,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCareersTotalCount = `-- name: GetCareersTotalCount :one
SELECT
    count(cr.id)
FROM
    careers cr
JOIN addresses a ON cr.addresses_id=a.id
JOIN company_users u ON cr.uploaded_by=u.users_id
WHERE
	 (CASE WHEN $1::BIGINT=0 THEN TRUE ELSE u.company_id= $1::BIGINT end)
AND
    (ARRAY_LENGTH($2::bigint [],1) IS NULL OR cr."rank" = ANY ($2::bigint []))
AND
    (CASE WHEN  $3::bigint=0 THEN TRUE ELSE a.countries_id = $3::bigint end) 
AND   
    (CASE WHEN $4::bigint=0 THEN TRUE ELSE a.cities_id= $4::bigint END)
AND
    (CASE WHEN $5::bigint=0 THEN TRUE ELSE a.communities_id= $5::bigint END)
AND
    (CASE WHEN $6::bigint=0 THEN TRUE ELSE a.sub_communities_id= $6::bigint END)
AND  
	cr.status= $7::bigint
AND 
    (ARRAY_LENGTH($8::bigint [],1) IS NULL OR cr.career_status = ANY($8::bigint []))
`

type GetCareersTotalCountParams struct {
	CompanyID        int64   `json:"company_id"`
	CareerRank       []int64 `json:"career_rank"`
	CountryID        int64   `json:"country_id"`
	CityID           int64   `json:"city_id"`
	CommunitiesID    int64   `json:"communities_id"`
	SubCommunitiesID int64   `json:"sub_communities_id"`
	Status           int64   `json:"status"`
	CareerStatus     []int64 `json:"career_status"`
}

func (q *Queries) GetCareersTotalCount(ctx context.Context, arg GetCareersTotalCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCareersTotalCount,
		arg.CompanyID,
		arg.CareerRank,
		arg.CountryID,
		arg.CityID,
		arg.CommunitiesID,
		arg.SubCommunitiesID,
		arg.Status,
		arg.CareerStatus,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getJobCategoryByID = `-- name: GetJobCategoryByID :one
SELECT id, parent_category_id, category_name, description, category_image, created_at, status, updated_at FROM job_categories WHERE id = $1
`

func (q *Queries) GetJobCategoryByID(ctx context.Context, id int64) (JobCategory, error) {
	row := q.db.QueryRow(ctx, getJobCategoryByID, id)
	var i JobCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.CategoryName,
		&i.Description,
		&i.CategoryImage,
		&i.CreatedAt,
		&i.Status,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaginatedActiveCareers = `-- name: GetPaginatedActiveCareers :many
WITH 
Nationalities AS (
    SELECT id, UNNEST(nationality_id) AS nat_id 
    FROM careers
),
FieldsOfStudy AS (
    SELECT id, UNNEST(field_of_studies) AS fields_id 
    FROM careers
),
nationalities_agg AS (
    SELECT 
        c.id AS career_id, 
        json_agg(
            json_build_object(
                'id', n.nat_id,
                'name', co.country
            )
        ) AS nationalities
    FROM careers c
    JOIN Nationalities n ON c.id = n.id
    JOIN countries co ON co.id = n.nat_id
    GROUP BY c.id
),
fields_agg AS (
    SELECT 
        c.id AS career_id, 
        json_agg(
            json_build_object(
                'id', n.fields_id,
                'name', f.title
            )
        ) AS fields
    FROM careers c
    JOIN FieldsOfStudy n ON c.id = n.id
    JOIN field_of_studies f ON f.id = n.fields_id
    GROUP BY c.id
)
SELECT
	-- COALESCE(cc.count, 0) AS candidate_count,
    COALESCE(na.nationalities, '[]'::json) AS nationalities,
    COALESCE(fs.fields, '[]'::json) AS field_of_studies,
    cr.id, cr.ref_no, cr.job_title, cr.job_title_ar, cr.employment_types, cr.employment_mode, cr.job_style, cr.job_categories, cr.career_level, cr.addresses_id, cr.is_urgent, cr.job_description, cr.job_image, cr.number_of_positions, cr.years_of_experience, cr.gender, cr.nationality_id, cr.min_salary, cr.max_salary, cr.languages, cr.uploaded_by, cr.date_expired, cr.career_status, cr.education_level, cr.specialization, cr.skills, cr.global_tagging_id, cr.created_at, cr.updated_at, cr.field_of_study, cr.status, cr.rank,
    -- sqlc.embed(e),
    co.id, co.country, co.flag, co.created_at, co.updated_at, co.alpha2_code, co.alpha3_code, co.country_code, co.lat, co.lng, co.name, co.numcode, co.default_settings, co.status, co.deleted_at, co.updated_by, co.country_ar,
    ci.id, ci.city, ci.states_id, ci.created_at, ci.updated_at, ci.lat, ci.lng, ci.status, ci.deleted_at, ci.updated_by, ci.city_ar, ci.cover_image, ci.description,
    com.id, com.community, com.cities_id, com.created_at, com.updated_at, com.lat, com.lng, com.status, com.deleted_at, com.updated_by, com.community_ar
FROM
    careers cr
LEFT JOIN
    nationalities_agg na ON cr.id = na.career_id
LEFT JOIN
    fields_agg fs ON cr.id = fs.career_id
JOIN
    countries co ON cr.countries_id = co.id
JOIN
    cities ci ON cr.city_id = ci.id
JOIN
    communities com ON cr.community_id = com.id
WHERE
     ($3 = '%%' OR 
     cr.job_title % $3 OR
     cr.job_title_ar % $3 OR
     cr.ref_no % $3 OR
     co.country % $3 OR
     ci.city % $3 OR 
     com.community % $3)
     OR 
     (CASE
        WHEN 'draft' ILIKE $3 THEN cr.career_status = 1
        WHEN 'active' ILIKE $3 THEN cr.career_status = 2
        WHEN 'reposted' ILIKE $3 THEN cr.career_status = 7
        WHEN 'closed' ILIKE $3 THEN cr.career_status = 8
        WHEN 'male' ILIKE $3 THEN cr.gender=1
        WHEN 'female' ILIKE $3 THEN cr.gender=2
        WHEN 'urgent' ILIKE $3 THEN cr.is_urgent = true
        ELSE FALSE
      END)
     AND cr.career_status NOT IN (5,6) 
ORDER BY
    cr.updated_at DESC
OFFSET $1
LIMIT $2
`

type GetPaginatedActiveCareersParams struct {
	Offset  int32       `json:"offset"`
	Limit   int32       `json:"limit"`
	Column3 interface{} `json:"column_3"`
}

type GetPaginatedActiveCareersRow struct {
	Nationalities  []byte    `json:"nationalities"`
	FieldOfStudies []byte    `json:"field_of_studies"`
	Career         Career    `json:"career"`
	Country        Country   `json:"country"`
	City           City      `json:"city"`
	Community      Community `json:"community"`
}

// employerIds AS(
//
//	SELECT
//	e.company_id as company,
//	e.id AS emp_id
//	FROM employers e
//	WHERE e.company_id=$4
//
// ),
// candidate_count AS (
//
//	SELECT
//	    c.careers_id,
//	    COUNT(c.id) AS count
//	FROM
//	    candidates c
//	JOIN
//	    applicants a ON c.applicants_id = a.id
//	JOIN
//	    careers car ON c.careers_id = car.id
//	WHERE
//	    c.application_status != 6 AND (car.career_status != 6 AND car.career_status != 5)
//	GROUP BY
//	    c.careers_id
//
// ),
// LEFT JOIN
//
//	candidate_count cc ON cr.id = cc.careers_id
//
// JOIN
//
//	employers e ON cr.employers_id = e.id
//
// JOIN
//
//	employerIds empIds ON cr.employers_id=empIds.emp_id
func (q *Queries) GetPaginatedActiveCareers(ctx context.Context, arg GetPaginatedActiveCareersParams) ([]GetPaginatedActiveCareersRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedActiveCareers, arg.Offset, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedActiveCareersRow
	for rows.Next() {
		var i GetPaginatedActiveCareersRow
		if err := rows.Scan(
			&i.Nationalities,
			&i.FieldOfStudies,
			&i.Career.ID,
			&i.Career.RefNo,
			&i.Career.JobTitle,
			&i.Career.JobTitleAr,
			&i.Career.EmploymentTypes,
			&i.Career.EmploymentMode,
			&i.Career.JobStyle,
			&i.Career.JobCategories,
			&i.Career.CareerLevel,
			&i.Career.AddressesID,
			&i.Career.IsUrgent,
			&i.Career.JobDescription,
			&i.Career.JobImage,
			&i.Career.NumberOfPositions,
			&i.Career.YearsOfExperience,
			&i.Career.Gender,
			&i.Career.NationalityID,
			&i.Career.MinSalary,
			&i.Career.MaxSalary,
			&i.Career.Languages,
			&i.Career.UploadedBy,
			&i.Career.DateExpired,
			&i.Career.CareerStatus,
			&i.Career.EducationLevel,
			&i.Career.Specialization,
			&i.Career.Skills,
			&i.Career.GlobalTaggingID,
			&i.Career.CreatedAt,
			&i.Career.UpdatedAt,
			&i.Career.FieldOfStudy,
			&i.Career.Status,
			&i.Career.Rank,
			&i.Country.ID,
			&i.Country.Country,
			&i.Country.Flag,
			&i.Country.CreatedAt,
			&i.Country.UpdatedAt,
			&i.Country.Alpha2Code,
			&i.Country.Alpha3Code,
			&i.Country.CountryCode,
			&i.Country.Lat,
			&i.Country.Lng,
			&i.Country.Name,
			&i.Country.Numcode,
			&i.Country.DefaultSettings,
			&i.Country.Status,
			&i.Country.DeletedAt,
			&i.Country.UpdatedBy,
			&i.Country.CountryAr,
			&i.City.ID,
			&i.City.City,
			&i.City.StatesID,
			&i.City.CreatedAt,
			&i.City.UpdatedAt,
			&i.City.Lat,
			&i.City.Lng,
			&i.City.Status,
			&i.City.DeletedAt,
			&i.City.UpdatedBy,
			&i.City.CityAr,
			&i.City.CoverImage,
			&i.City.Description,
			&i.Community.ID,
			&i.Community.Community,
			&i.Community.CitiesID,
			&i.Community.CreatedAt,
			&i.Community.UpdatedAt,
			&i.Community.Lat,
			&i.Community.Lng,
			&i.Community.Status,
			&i.Community.DeletedAt,
			&i.Community.UpdatedBy,
			&i.Community.CommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedJobCategories = `-- name: GetPaginatedJobCategories :many
select a.id,
	(case when a.parent_category_id = 0 then 'Parent Category' else b.category_name end) as parent,
    (case when a.parent_category_id = 0 then true else false end) as is_parent,
	a.category_name,
	a.category_image
	-- a.ref_no
from job_categories as a
left join
(
	select id, category_name,category_image from job_categories
) as b
on a.parent_category_id = b.id
WHERE
   a.status!=6 and a.status!=5
ORDER BY
    a.updated_at DESC
OFFSET $1 LIMIT $2
`

type GetPaginatedJobCategoriesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type GetPaginatedJobCategoriesRow struct {
	ID            int64       `json:"id"`
	Parent        interface{} `json:"parent"`
	IsParent      pgtype.Bool `json:"is_parent"`
	CategoryName  string      `json:"category_name"`
	CategoryImage string      `json:"category_image"`
}

func (q *Queries) GetPaginatedJobCategories(ctx context.Context, arg GetPaginatedJobCategoriesParams) ([]GetPaginatedJobCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedJobCategories, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedJobCategoriesRow
	for rows.Next() {
		var i GetPaginatedJobCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Parent,
			&i.IsParent,
			&i.CategoryName,
			&i.CategoryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertJobCategory = `-- name: InsertJobCategory :one
INSERT INTO job_categories (
    parent_category_id,
    category_name,
    description,
    category_image,
    created_at,
    status,
    updated_at
 ) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, parent_category_id, category_name, description, category_image, created_at, status, updated_at
`

type InsertJobCategoryParams struct {
	ParentCategoryID pgtype.Int8        `json:"parent_category_id"`
	CategoryName     string             `json:"category_name"`
	Description      string             `json:"description"`
	CategoryImage    string             `json:"category_image"`
	CreatedAt        time.Time          `json:"created_at"`
	Status           int64              `json:"status"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) InsertJobCategory(ctx context.Context, arg InsertJobCategoryParams) (JobCategory, error) {
	row := q.db.QueryRow(ctx, insertJobCategory,
		arg.ParentCategoryID,
		arg.CategoryName,
		arg.Description,
		arg.CategoryImage,
		arg.CreatedAt,
		arg.Status,
		arg.UpdatedAt,
	)
	var i JobCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.CategoryName,
		&i.Description,
		&i.CategoryImage,
		&i.CreatedAt,
		&i.Status,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCareerByID = `-- name: UpdateCareerByID :one
UPDATE careers SET
ref_no = $1,
job_title = $2,
job_title_ar = $3,
employment_types = $4,
employment_mode = $5,
job_style = $6,
job_categories=$7,
career_level=$8,
addresses_id=$9,
is_urgent=$10,
skills=$11,
is_urgent = $12,
job_description = $13,
number_of_positions = $14,
years_of_experience = $15,
gender = $16,
nationality_id = $17,
min_salary = $18,
max_salary = $19,
languages = $20,
date_expired = $21,
career_status = $22, 
education_level = $23,
specialization=$24,
skills = $25,
global_tagging_id = $26,
field_of_study = $27,
status=$28,
job_image=$30,
updated_at=$31,
rank=$32
WHERE id = $29
RETURNING id, ref_no, job_title, job_title_ar, employment_types, employment_mode, job_style, job_categories, career_level, addresses_id, is_urgent, job_description, job_image, number_of_positions, years_of_experience, gender, nationality_id, min_salary, max_salary, languages, uploaded_by, date_expired, career_status, education_level, specialization, skills, global_tagging_id, created_at, updated_at, field_of_study, status, rank
`

type UpdateCareerByIDParams struct {
	RefNo             string        `json:"ref_no"`
	JobTitle          string        `json:"job_title"`
	JobTitleAr        pgtype.Text   `json:"job_title_ar"`
	EmploymentTypes   int64         `json:"employment_types"`
	EmploymentMode    pgtype.Int8   `json:"employment_mode"`
	JobStyle          pgtype.Int8   `json:"job_style"`
	JobCategories     int64         `json:"job_categories"`
	CareerLevel       pgtype.Int8   `json:"career_level"`
	AddressesID       int64         `json:"addresses_id"`
	IsUrgent          bool          `json:"is_urgent"`
	Skills            []int64       `json:"skills"`
	IsUrgent_2        bool          `json:"is_urgent_2"`
	JobDescription    string        `json:"job_description"`
	NumberOfPositions pgtype.Int8   `json:"number_of_positions"`
	YearsOfExperience pgtype.Int8   `json:"years_of_experience"`
	Gender            int64         `json:"gender"`
	NationalityID     []int64       `json:"nationality_id"`
	MinSalary         pgtype.Float8 `json:"min_salary"`
	MaxSalary         pgtype.Float8 `json:"max_salary"`
	Languages         []int64       `json:"languages"`
	DateExpired       time.Time     `json:"date_expired"`
	CareerStatus      int64         `json:"career_status"`
	EducationLevel    pgtype.Int8   `json:"education_level"`
	Specialization    []int64       `json:"specialization"`
	Skills_2          []int64       `json:"skills_2"`
	GlobalTaggingID   []int64       `json:"global_tagging_id"`
	FieldOfStudy      int64         `json:"field_of_study"`
	Status            int64         `json:"status"`
	ID                int64         `json:"id"`
	JobImage          pgtype.Text   `json:"job_image"`
	UpdatedAt         time.Time     `json:"updated_at"`
	Rank              int64         `json:"rank"`
}

func (q *Queries) UpdateCareerByID(ctx context.Context, arg UpdateCareerByIDParams) (Career, error) {
	row := q.db.QueryRow(ctx, updateCareerByID,
		arg.RefNo,
		arg.JobTitle,
		arg.JobTitleAr,
		arg.EmploymentTypes,
		arg.EmploymentMode,
		arg.JobStyle,
		arg.JobCategories,
		arg.CareerLevel,
		arg.AddressesID,
		arg.IsUrgent,
		arg.Skills,
		arg.IsUrgent_2,
		arg.JobDescription,
		arg.NumberOfPositions,
		arg.YearsOfExperience,
		arg.Gender,
		arg.NationalityID,
		arg.MinSalary,
		arg.MaxSalary,
		arg.Languages,
		arg.DateExpired,
		arg.CareerStatus,
		arg.EducationLevel,
		arg.Specialization,
		arg.Skills_2,
		arg.GlobalTaggingID,
		arg.FieldOfStudy,
		arg.Status,
		arg.ID,
		arg.JobImage,
		arg.UpdatedAt,
		arg.Rank,
	)
	var i Career
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.JobTitle,
		&i.JobTitleAr,
		&i.EmploymentTypes,
		&i.EmploymentMode,
		&i.JobStyle,
		&i.JobCategories,
		&i.CareerLevel,
		&i.AddressesID,
		&i.IsUrgent,
		&i.JobDescription,
		&i.JobImage,
		&i.NumberOfPositions,
		&i.YearsOfExperience,
		&i.Gender,
		&i.NationalityID,
		&i.MinSalary,
		&i.MaxSalary,
		&i.Languages,
		&i.UploadedBy,
		&i.DateExpired,
		&i.CareerStatus,
		&i.EducationLevel,
		&i.Specialization,
		&i.Skills,
		&i.GlobalTaggingID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FieldOfStudy,
		&i.Status,
		&i.Rank,
	)
	return i, err
}

const updateCareerUrgency = `-- name: UpdateCareerUrgency :one

UPDATE careers
SET
is_urgent=$1,
updated_at=$3
WHERE id=$2
RETURNING id, ref_no, job_title, job_title_ar, employment_types, employment_mode, job_style, job_categories, career_level, addresses_id, is_urgent, job_description, job_image, number_of_positions, years_of_experience, gender, nationality_id, min_salary, max_salary, languages, uploaded_by, date_expired, career_status, education_level, specialization, skills, global_tagging_id, created_at, updated_at, field_of_study, status, rank
`

type UpdateCareerUrgencyParams struct {
	IsUrgent  bool      `json:"is_urgent"`
	ID        int64     `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

// AND cr.employers_id=$1;
func (q *Queries) UpdateCareerUrgency(ctx context.Context, arg UpdateCareerUrgencyParams) (Career, error) {
	row := q.db.QueryRow(ctx, updateCareerUrgency, arg.IsUrgent, arg.ID, arg.UpdatedAt)
	var i Career
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.JobTitle,
		&i.JobTitleAr,
		&i.EmploymentTypes,
		&i.EmploymentMode,
		&i.JobStyle,
		&i.JobCategories,
		&i.CareerLevel,
		&i.AddressesID,
		&i.IsUrgent,
		&i.JobDescription,
		&i.JobImage,
		&i.NumberOfPositions,
		&i.YearsOfExperience,
		&i.Gender,
		&i.NationalityID,
		&i.MinSalary,
		&i.MaxSalary,
		&i.Languages,
		&i.UploadedBy,
		&i.DateExpired,
		&i.CareerStatus,
		&i.EducationLevel,
		&i.Specialization,
		&i.Skills,
		&i.GlobalTaggingID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FieldOfStudy,
		&i.Status,
		&i.Rank,
	)
	return i, err
}

const updateCareersStatus = `-- name: UpdateCareersStatus :one
UPDATE careers
SET
    career_status = $1,
   updated_at=$3
WHERE
    id = $2
RETURNING id, ref_no, job_title, job_title_ar, employment_types, employment_mode, job_style, job_categories, career_level, addresses_id, is_urgent, job_description, job_image, number_of_positions, years_of_experience, gender, nationality_id, min_salary, max_salary, languages, uploaded_by, date_expired, career_status, education_level, specialization, skills, global_tagging_id, created_at, updated_at, field_of_study, status, rank
`

type UpdateCareersStatusParams struct {
	CareerStatus int64     `json:"career_status"`
	ID           int64     `json:"id"`
	UpdatedAt    time.Time `json:"updated_at"`
}

func (q *Queries) UpdateCareersStatus(ctx context.Context, arg UpdateCareersStatusParams) (Career, error) {
	row := q.db.QueryRow(ctx, updateCareersStatus, arg.CareerStatus, arg.ID, arg.UpdatedAt)
	var i Career
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.JobTitle,
		&i.JobTitleAr,
		&i.EmploymentTypes,
		&i.EmploymentMode,
		&i.JobStyle,
		&i.JobCategories,
		&i.CareerLevel,
		&i.AddressesID,
		&i.IsUrgent,
		&i.JobDescription,
		&i.JobImage,
		&i.NumberOfPositions,
		&i.YearsOfExperience,
		&i.Gender,
		&i.NationalityID,
		&i.MinSalary,
		&i.MaxSalary,
		&i.Languages,
		&i.UploadedBy,
		&i.DateExpired,
		&i.CareerStatus,
		&i.EducationLevel,
		&i.Specialization,
		&i.Skills,
		&i.GlobalTaggingID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FieldOfStudy,
		&i.Status,
		&i.Rank,
	)
	return i, err
}

const updateJobCategory = `-- name: UpdateJobCategory :one
UPDATE job_categories
SET
    category_name = $1,
    category_image = $2,
   updated_at=$3
WHERE
    id = $4
RETURNING id, parent_category_id, category_name, description, category_image, created_at, status, updated_at
`

type UpdateJobCategoryParams struct {
	CategoryName  string             `json:"category_name"`
	CategoryImage string             `json:"category_image"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	ID            int64              `json:"id"`
}

func (q *Queries) UpdateJobCategory(ctx context.Context, arg UpdateJobCategoryParams) (JobCategory, error) {
	row := q.db.QueryRow(ctx, updateJobCategory,
		arg.CategoryName,
		arg.CategoryImage,
		arg.UpdatedAt,
		arg.ID,
	)
	var i JobCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.CategoryName,
		&i.Description,
		&i.CategoryImage,
		&i.CreatedAt,
		&i.Status,
		&i.UpdatedAt,
	)
	return i, err
}
