// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sub_section.sql

package sqlc

import (
	"context"
	"time"
)

const countAllSubSection = `-- name: CountAllSubSection :one
SELECT COUNT(id) FROM sub_section
`

func (q *Queries) CountAllSubSection(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllSubSection)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubSection = `-- name: CreateSubSection :one
INSERT INTO sub_section (
  sub_section_name,
  sub_section_name_constant,   
  permissions_id,  
  indicator,  
  sub_section_button_id,  
  sub_section_button_action,  
  created_at
) VALUES
 ($1, $2, $3, $4, $5, $6, $7)
 RETURNING id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at
`

type CreateSubSectionParams struct {
	SubSectionName         string    `json:"sub_section_name"`
	SubSectionNameConstant string    `json:"sub_section_name_constant"`
	PermissionsID          int64     `json:"permissions_id"`
	Indicator              int64     `json:"indicator"`
	SubSectionButtonID     int64     `json:"sub_section_button_id"`
	SubSectionButtonAction string    `json:"sub_section_button_action"`
	CreatedAt              time.Time `json:"created_at"`
}

func (q *Queries) CreateSubSection(ctx context.Context, arg CreateSubSectionParams) (SubSection, error) {
	row := q.db.QueryRow(ctx, createSubSection,
		arg.SubSectionName,
		arg.SubSectionNameConstant,
		arg.PermissionsID,
		arg.Indicator,
		arg.SubSectionButtonID,
		arg.SubSectionButtonAction,
		arg.CreatedAt,
	)
	var i SubSection
	err := row.Scan(
		&i.ID,
		&i.SubSectionName,
		&i.SubSectionNameConstant,
		&i.PermissionsID,
		&i.Indicator,
		&i.SubSectionButtonID,
		&i.SubSectionButtonAction,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllSubSection = `-- name: DeleteAllSubSection :exec
DELETE FROM sub_section
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteAllSubSection(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteAllSubSection, dollar_1)
	return err
}

const deleteSubSection = `-- name: DeleteSubSection :exec
DELETE FROM sub_section
Where id =$1
`

func (q *Queries) DeleteSubSection(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSubSection, id)
	return err
}

const fetchbuttonPermissionForSubSectionsForUser = `-- name: FetchbuttonPermissionForSubSectionsForUser :many
SELECT DISTINCT ON (ss.sub_section_name) ss.id, ss.sub_section_name, ss.sub_section_name_constant, ss.permissions_id, ss.indicator, ss.sub_section_button_id, ss.sub_section_button_action, ss.created_at, ss.updated_at
FROM sub_section ss
JOIN (
    SELECT UNNEST(sub_sections_id) as sub_section_id
    FROM user_company_permissions
    WHERE user_company_permissions.user_id = $1
) u ON ss.id = u.sub_section_id
JOIN permissions p ON ss.permissions_id = p.id
WHERE
  ( p.title % $2 AND ss.sub_section_button_id = p.id )
   OR
   ss.sub_section_button_id = (
      SELECT id
      FROM sub_section  
      WHERE sub_section.sub_section_name ILIKE $2 AND ss.sub_section_button_id = sub_section.id
)
`

type FetchbuttonPermissionForSubSectionsForUserParams struct {
	UserID            int64  `json:"user_id"`
	SectionButtonName string `json:"section_button_name"`
}

func (q *Queries) FetchbuttonPermissionForSubSectionsForUser(ctx context.Context, arg FetchbuttonPermissionForSubSectionsForUserParams) ([]SubSection, error) {
	rows, err := q.db.Query(ctx, fetchbuttonPermissionForSubSectionsForUser, arg.UserID, arg.SectionButtonName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSection
	for rows.Next() {
		var i SubSection
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllIDANDPermissionsFromSubSectionPermission = `-- name: GetAllIDANDPermissionsFromSubSectionPermission :many


SELECT id, permissions_id FROM sub_section
ORDER BY permissions_id LIMIT $1 OFFSET $2
`

type GetAllIDANDPermissionsFromSubSectionPermissionParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllIDANDPermissionsFromSubSectionPermissionRow struct {
	ID            int64 `json:"id"`
	PermissionsID int64 `json:"permissions_id"`
}

// SELECT * FROM sub_section_mv
// WHERE sub_section_button_id = $1;
func (q *Queries) GetAllIDANDPermissionsFromSubSectionPermission(ctx context.Context, arg GetAllIDANDPermissionsFromSubSectionPermissionParams) ([]GetAllIDANDPermissionsFromSubSectionPermissionRow, error) {
	rows, err := q.db.Query(ctx, getAllIDANDPermissionsFromSubSectionPermission, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllIDANDPermissionsFromSubSectionPermissionRow
	for rows.Next() {
		var i GetAllIDANDPermissionsFromSubSectionPermissionRow
		if err := rows.Scan(&i.ID, &i.PermissionsID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllIDANDPermissionsFromSubSectionPermissionWithoutPagination = `-- name: GetAllIDANDPermissionsFromSubSectionPermissionWithoutPagination :many
SELECT id, permissions_id FROM sub_section
ORDER BY permissions_id
`

type GetAllIDANDPermissionsFromSubSectionPermissionWithoutPaginationRow struct {
	ID            int64 `json:"id"`
	PermissionsID int64 `json:"permissions_id"`
}

func (q *Queries) GetAllIDANDPermissionsFromSubSectionPermissionWithoutPagination(ctx context.Context) ([]GetAllIDANDPermissionsFromSubSectionPermissionWithoutPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllIDANDPermissionsFromSubSectionPermissionWithoutPagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllIDANDPermissionsFromSubSectionPermissionWithoutPaginationRow
	for rows.Next() {
		var i GetAllIDANDPermissionsFromSubSectionPermissionWithoutPaginationRow
		if err := rows.Scan(&i.ID, &i.PermissionsID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRelatedIDFromSubSection = `-- name: GetAllRelatedIDFromSubSection :many


WITH RECURSIVE related_sub_sections AS (
    SELECT id, sub_section_button_id
    FROM sub_section
    WHERE sub_section.sub_section_button_id = $1
    UNION ALL
    SELECT s.id, s.sub_section_button_id
    FROM sub_section s
    INNER JOIN related_sub_sections r ON s.sub_section_button_id = r.id
)
SELECT id FROM related_sub_sections
`

// SELECT
//
//	ss.id,
//	ss.sub_section_name,
//	ss.sub_section_name_constant,
//	ss.permissions_id,
//	ss.indicator,
//	ss.sub_section_button_id,
//	ss.sub_section_button_action,
//	ss.created_at,
//	ss.updated_at
//
// FROM
//
//	sub_section ss
//
// JOIN (
//
//	SELECT UNNEST(sub_section_permission) as sub_section_permission
//	FROM users
//	WHERE users.id = $1
//
// ) u ON ss.id = u.sub_section_permission
// JOIN permissions p ON ss.permissions_id = p.id
// WHERE
//
//	p.title ILIKE $2
//	AND (
//	    ss.sub_section_button_id IS NOT NULL
//	    AND ss.sub_section_button_id = COALESCE(
//	        (
//	            SELECT id
//	            FROM sub_section
//	            WHERE sub_section.sub_section_name ILIKE $2
//	        ),
//	        ss.sub_section_button_id
//	    )
//	);
func (q *Queries) GetAllRelatedIDFromSubSection(ctx context.Context, subSectionButtonID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllRelatedIDFromSubSection, subSectionButtonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubSection = `-- name: GetAllSubSection :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section
`

func (q *Queries) GetAllSubSection(ctx context.Context) ([]SubSection, error) {
	rows, err := q.db.Query(ctx, getAllSubSection)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSection
	for rows.Next() {
		var i SubSection
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubSectionByPermissionID = `-- name: GetAllSubSectionByPermissionID :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section 
Where permissions_id = $1 AND sub_section_button_id = $1
`

func (q *Queries) GetAllSubSectionByPermissionID(ctx context.Context, permissionsID int64) ([]SubSection, error) {
	rows, err := q.db.Query(ctx, getAllSubSectionByPermissionID, permissionsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSection
	for rows.Next() {
		var i SubSection
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubSectionByPermissionIDMV = `-- name: GetAllSubSectionByPermissionIDMV :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section_mv 
Where permissions_id = $1 AND sub_section_button_id = $1
`

func (q *Queries) GetAllSubSectionByPermissionIDMV(ctx context.Context, permissionsID int64) ([]SubSectionMv, error) {
	rows, err := q.db.Query(ctx, getAllSubSectionByPermissionIDMV, permissionsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSectionMv
	for rows.Next() {
		var i SubSectionMv
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubSectionByPermissionIDMVWithRelation = `-- name: GetAllSubSectionByPermissionIDMVWithRelation :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section_mv 
Where
  CASE WHEN $1::bigint=0 THEN true ELSE id = ANY($2::bigint[]) END -- it will filtered on the basis of the other then super user
 AND permissions_id = $3::bigint AND sub_section_button_id = $3::bigint
`

type GetAllSubSectionByPermissionIDMVWithRelationParams struct {
	IsSuperUser   int64   `json:"is_super_user"`
	SubSectionsID []int64 `json:"sub_sections_id"`
	PermissionsID int64   `json:"permissions_id"`
}

func (q *Queries) GetAllSubSectionByPermissionIDMVWithRelation(ctx context.Context, arg GetAllSubSectionByPermissionIDMVWithRelationParams) ([]SubSectionMv, error) {
	rows, err := q.db.Query(ctx, getAllSubSectionByPermissionIDMVWithRelation, arg.IsSuperUser, arg.SubSectionsID, arg.PermissionsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSectionMv
	for rows.Next() {
		var i SubSectionMv
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubSectionPermissionBySubSectionButtonID = `-- name: GetAllSubSectionPermissionBySubSectionButtonID :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section
WHERE sub_section_button_id = $1
`

func (q *Queries) GetAllSubSectionPermissionBySubSectionButtonID(ctx context.Context, subSectionButtonID int64) ([]SubSection, error) {
	rows, err := q.db.Query(ctx, getAllSubSectionPermissionBySubSectionButtonID, subSectionButtonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSection
	for rows.Next() {
		var i SubSection
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubSectionPermissionBySubSectionButtonIDMV = `-- name: GetAllSubSectionPermissionBySubSectionButtonIDMV :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section_mv
WHERE
 CASE WHEN $1::bigint=0 THEN true ELSE id = ANY($2::bigint[]) END
AND sub_section_button_id = $3::bigint
`

type GetAllSubSectionPermissionBySubSectionButtonIDMVParams struct {
	IsSuperUser        int64   `json:"is_super_user"`
	SubSectionID       []int64 `json:"sub_section_id"`
	SubSectionButtonID int64   `json:"sub_section_button_id"`
}

func (q *Queries) GetAllSubSectionPermissionBySubSectionButtonIDMV(ctx context.Context, arg GetAllSubSectionPermissionBySubSectionButtonIDMVParams) ([]SubSectionMv, error) {
	rows, err := q.db.Query(ctx, getAllSubSectionPermissionBySubSectionButtonIDMV, arg.IsSuperUser, arg.SubSectionID, arg.SubSectionButtonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSectionMv
	for rows.Next() {
		var i SubSectionMv
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListSubSection = `-- name: GetListSubSection :many
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetListSubSectionParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetListSubSection(ctx context.Context, arg GetListSubSectionParams) ([]SubSection, error) {
	rows, err := q.db.Query(ctx, getListSubSection, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubSection
	for rows.Next() {
		var i SubSection
		if err := rows.Scan(
			&i.ID,
			&i.SubSectionName,
			&i.SubSectionNameConstant,
			&i.PermissionsID,
			&i.Indicator,
			&i.SubSectionButtonID,
			&i.SubSectionButtonAction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubSection = `-- name: GetSubSection :one
SELECT id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at FROM sub_section 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSubSection(ctx context.Context, id int64) (SubSection, error) {
	row := q.db.QueryRow(ctx, getSubSection, id)
	var i SubSection
	err := row.Scan(
		&i.ID,
		&i.SubSectionName,
		&i.SubSectionNameConstant,
		&i.PermissionsID,
		&i.Indicator,
		&i.SubSectionButtonID,
		&i.SubSectionButtonAction,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubSection = `-- name: UpdateSubSection :one
UPDATE sub_section
SET sub_section_name = $2,
  sub_section_name_constant = $3,   
  permissions_id = $4,  
  indicator = $5, 
  sub_section_button_id = $6,  
  sub_section_button_action = $7,  
  updated_at = $8
Where id = $1
RETURNING id, sub_section_name, sub_section_name_constant, permissions_id, indicator, sub_section_button_id, sub_section_button_action, created_at, updated_at
`

type UpdateSubSectionParams struct {
	ID                     int64     `json:"id"`
	SubSectionName         string    `json:"sub_section_name"`
	SubSectionNameConstant string    `json:"sub_section_name_constant"`
	PermissionsID          int64     `json:"permissions_id"`
	Indicator              int64     `json:"indicator"`
	SubSectionButtonID     int64     `json:"sub_section_button_id"`
	SubSectionButtonAction string    `json:"sub_section_button_action"`
	UpdatedAt              time.Time `json:"updated_at"`
}

func (q *Queries) UpdateSubSection(ctx context.Context, arg UpdateSubSectionParams) (SubSection, error) {
	row := q.db.QueryRow(ctx, updateSubSection,
		arg.ID,
		arg.SubSectionName,
		arg.SubSectionNameConstant,
		arg.PermissionsID,
		arg.Indicator,
		arg.SubSectionButtonID,
		arg.SubSectionButtonAction,
		arg.UpdatedAt,
	)
	var i SubSection
	err := row.Scan(
		&i.ID,
		&i.SubSectionName,
		&i.SubSectionNameConstant,
		&i.PermissionsID,
		&i.Indicator,
		&i.SubSectionButtonID,
		&i.SubSectionButtonAction,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
