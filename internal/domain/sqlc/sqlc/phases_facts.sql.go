// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: phases_facts.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPhasesFacts = `-- name: CreatePhasesFacts :one
INSERT INTO phases_facts (
    plot_area, 
    phases_id, 
    completion_status, 
    built_up_area, 
    furnished, 
    no_of_properties, 
    lifestyle, 
    ownership,
    start_date, 
    completion_date, 
    handover_date, 
    service_charge, 
    no_of_parkings, 
    no_of_retails, 
    no_of_pools,
    no_of_elevators,
    created_at,
    update_at,
    completion_percentage,
    completion_percentage_date,
    sc_currency_id,
    unit_of_measure,
    starting_price
    )
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
) RETURNING id, phases_id, completion_status, plot_area, built_up_area, furnished, no_of_properties, lifestyle, ownership, start_date, completion_date, handover_date, service_charge, no_of_parkings, no_of_retails, no_of_pools, no_of_elevators, created_at, update_at, completion_percentage, completion_percentage_date, sc_currency_id, unit_of_measure, starting_price
`

type CreatePhasesFactsParams struct {
	PlotArea                 pgtype.Float8      `json:"plot_area"`
	PhasesID                 int64              `json:"phases_id"`
	CompletionStatus         pgtype.Int8        `json:"completion_status"`
	BuiltUpArea              pgtype.Float8      `json:"built_up_area"`
	Furnished                pgtype.Int8        `json:"furnished"`
	NoOfProperties           pgtype.Int8        `json:"no_of_properties"`
	Lifestyle                pgtype.Int8        `json:"lifestyle"`
	Ownership                pgtype.Int8        `json:"ownership"`
	StartDate                pgtype.Timestamptz `json:"start_date"`
	CompletionDate           pgtype.Timestamptz `json:"completion_date"`
	HandoverDate             pgtype.Timestamptz `json:"handover_date"`
	ServiceCharge            pgtype.Float8      `json:"service_charge"`
	NoOfParkings             pgtype.Int8        `json:"no_of_parkings"`
	NoOfRetails              pgtype.Int8        `json:"no_of_retails"`
	NoOfPools                pgtype.Int8        `json:"no_of_pools"`
	NoOfElevators            pgtype.Int8        `json:"no_of_elevators"`
	CreatedAt                time.Time          `json:"created_at"`
	UpdateAt                 time.Time          `json:"update_at"`
	CompletionPercentage     pgtype.Float8      `json:"completion_percentage"`
	CompletionPercentageDate pgtype.Timestamptz `json:"completion_percentage_date"`
	ScCurrencyID             pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure            pgtype.Text        `json:"unit_of_measure"`
	StartingPrice            pgtype.Int8        `json:"starting_price"`
}

func (q *Queries) CreatePhasesFacts(ctx context.Context, arg CreatePhasesFactsParams) (PhasesFact, error) {
	row := q.db.QueryRow(ctx, createPhasesFacts,
		arg.PlotArea,
		arg.PhasesID,
		arg.CompletionStatus,
		arg.BuiltUpArea,
		arg.Furnished,
		arg.NoOfProperties,
		arg.Lifestyle,
		arg.Ownership,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.ServiceCharge,
		arg.NoOfParkings,
		arg.NoOfRetails,
		arg.NoOfPools,
		arg.NoOfElevators,
		arg.CreatedAt,
		arg.UpdateAt,
		arg.CompletionPercentage,
		arg.CompletionPercentageDate,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
		arg.StartingPrice,
	)
	var i PhasesFact
	err := row.Scan(
		&i.ID,
		&i.PhasesID,
		&i.CompletionStatus,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.Furnished,
		&i.NoOfProperties,
		&i.Lifestyle,
		&i.Ownership,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.ServiceCharge,
		&i.NoOfParkings,
		&i.NoOfRetails,
		&i.NoOfPools,
		&i.NoOfElevators,
		&i.CreatedAt,
		&i.UpdateAt,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.StartingPrice,
	)
	return i, err
}

const deletePhaseFactById = `-- name: DeletePhaseFactById :exec
DELETE from phases_facts where id = $1
`

func (q *Queries) DeletePhaseFactById(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePhaseFactById, id)
	return err
}

const getAllConsumeFactsCountByPhaseId = `-- name: GetAllConsumeFactsCountByPhaseId :one
SELECT COALESCE(SUM(plot_area),0)::bigint AS plot_area_consume,COALESCE(SUM(built_up_area),0)::bigint AS built_up_area_consume,COUNT(project_properties.id) AS properties_consume
FROM properties_facts
LEFT JOIN project_properties ON project_properties.id = properties_facts.properties_id AND properties_facts.property = 1
WHERE project_properties.projects_id = $1 AND project_properties.phases_id = $2 AND (project_properties.status != 5 AND project_properties.status != 6)
`

type GetAllConsumeFactsCountByPhaseIdParams struct {
	ProjectsID int64       `json:"projects_id"`
	PhasesID   pgtype.Int8 `json:"phases_id"`
}

type GetAllConsumeFactsCountByPhaseIdRow struct {
	PlotAreaConsume    int64 `json:"plot_area_consume"`
	BuiltUpAreaConsume int64 `json:"built_up_area_consume"`
	PropertiesConsume  int64 `json:"properties_consume"`
}

func (q *Queries) GetAllConsumeFactsCountByPhaseId(ctx context.Context, arg GetAllConsumeFactsCountByPhaseIdParams) (GetAllConsumeFactsCountByPhaseIdRow, error) {
	row := q.db.QueryRow(ctx, getAllConsumeFactsCountByPhaseId, arg.ProjectsID, arg.PhasesID)
	var i GetAllConsumeFactsCountByPhaseIdRow
	err := row.Scan(&i.PlotAreaConsume, &i.BuiltUpAreaConsume, &i.PropertiesConsume)
	return i, err
}

const getPhasesFactsByPhaseId = `-- name: GetPhasesFactsByPhaseId :one
SELECT id, phases_id, completion_status, plot_area, built_up_area, furnished, no_of_properties, lifestyle, ownership, start_date, completion_date, handover_date, service_charge, no_of_parkings, no_of_retails, no_of_pools, no_of_elevators, created_at, update_at, completion_percentage, completion_percentage_date, sc_currency_id, unit_of_measure, starting_price FROM phases_facts WHERE phases_id = $1
`

func (q *Queries) GetPhasesFactsByPhaseId(ctx context.Context, phasesID int64) (PhasesFact, error) {
	row := q.db.QueryRow(ctx, getPhasesFactsByPhaseId, phasesID)
	var i PhasesFact
	err := row.Scan(
		&i.ID,
		&i.PhasesID,
		&i.CompletionStatus,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.Furnished,
		&i.NoOfProperties,
		&i.Lifestyle,
		&i.Ownership,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.ServiceCharge,
		&i.NoOfParkings,
		&i.NoOfRetails,
		&i.NoOfPools,
		&i.NoOfElevators,
		&i.CreatedAt,
		&i.UpdateAt,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.StartingPrice,
	)
	return i, err
}

const updatePhasesFacts = `-- name: UpdatePhasesFacts :one
UPDATE phases_facts SET 
    plot_area = $2, 
    phases_id = $3, 
    completion_status = $4, 
    built_up_area = $5, 
    furnished = $6, 
    no_of_properties = $7, 
    lifestyle = $8, 
    ownership = $9,
    start_date = $10, 
    completion_date = $11, 
    handover_date = $12, 
    service_charge = $13, 
    no_of_parkings = $14, 
    no_of_retails = $15, 
    no_of_pools = $16,
    no_of_elevators = $17,
    created_at = $18,
    update_at = $19,
    completion_percentage = $20,
    completion_percentage_date = $21,
    sc_currency_id = $22,
    unit_of_measure = $23,
    starting_price = $24
WHERE id = $1 RETURNING id, phases_id, completion_status, plot_area, built_up_area, furnished, no_of_properties, lifestyle, ownership, start_date, completion_date, handover_date, service_charge, no_of_parkings, no_of_retails, no_of_pools, no_of_elevators, created_at, update_at, completion_percentage, completion_percentage_date, sc_currency_id, unit_of_measure, starting_price
`

type UpdatePhasesFactsParams struct {
	ID                       int64              `json:"id"`
	PlotArea                 pgtype.Float8      `json:"plot_area"`
	PhasesID                 int64              `json:"phases_id"`
	CompletionStatus         pgtype.Int8        `json:"completion_status"`
	BuiltUpArea              pgtype.Float8      `json:"built_up_area"`
	Furnished                pgtype.Int8        `json:"furnished"`
	NoOfProperties           pgtype.Int8        `json:"no_of_properties"`
	Lifestyle                pgtype.Int8        `json:"lifestyle"`
	Ownership                pgtype.Int8        `json:"ownership"`
	StartDate                pgtype.Timestamptz `json:"start_date"`
	CompletionDate           pgtype.Timestamptz `json:"completion_date"`
	HandoverDate             pgtype.Timestamptz `json:"handover_date"`
	ServiceCharge            pgtype.Float8      `json:"service_charge"`
	NoOfParkings             pgtype.Int8        `json:"no_of_parkings"`
	NoOfRetails              pgtype.Int8        `json:"no_of_retails"`
	NoOfPools                pgtype.Int8        `json:"no_of_pools"`
	NoOfElevators            pgtype.Int8        `json:"no_of_elevators"`
	CreatedAt                time.Time          `json:"created_at"`
	UpdateAt                 time.Time          `json:"update_at"`
	CompletionPercentage     pgtype.Float8      `json:"completion_percentage"`
	CompletionPercentageDate pgtype.Timestamptz `json:"completion_percentage_date"`
	ScCurrencyID             pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure            pgtype.Text        `json:"unit_of_measure"`
	StartingPrice            pgtype.Int8        `json:"starting_price"`
}

func (q *Queries) UpdatePhasesFacts(ctx context.Context, arg UpdatePhasesFactsParams) (PhasesFact, error) {
	row := q.db.QueryRow(ctx, updatePhasesFacts,
		arg.ID,
		arg.PlotArea,
		arg.PhasesID,
		arg.CompletionStatus,
		arg.BuiltUpArea,
		arg.Furnished,
		arg.NoOfProperties,
		arg.Lifestyle,
		arg.Ownership,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.ServiceCharge,
		arg.NoOfParkings,
		arg.NoOfRetails,
		arg.NoOfPools,
		arg.NoOfElevators,
		arg.CreatedAt,
		arg.UpdateAt,
		arg.CompletionPercentage,
		arg.CompletionPercentageDate,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
		arg.StartingPrice,
	)
	var i PhasesFact
	err := row.Scan(
		&i.ID,
		&i.PhasesID,
		&i.CompletionStatus,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.Furnished,
		&i.NoOfProperties,
		&i.Lifestyle,
		&i.Ownership,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.ServiceCharge,
		&i.NoOfParkings,
		&i.NoOfRetails,
		&i.NoOfPools,
		&i.NoOfElevators,
		&i.CreatedAt,
		&i.UpdateAt,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
		&i.StartingPrice,
	)
	return i, err
}
