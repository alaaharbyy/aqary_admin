// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: communities.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCommunity = `-- name: CreateCommunity :one
INSERT INTO communities (
    community,
    cities_id
)VALUES (
    $1, $2
) RETURNING id, community, cities_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, community_ar
`

type CreateCommunityParams struct {
	Community string      `json:"community"`
	CitiesID  pgtype.Int8 `json:"cities_id"`
}

func (q *Queries) CreateCommunity(ctx context.Context, arg CreateCommunityParams) (Community, error) {
	row := q.db.QueryRow(ctx, createCommunity, arg.Community, arg.CitiesID)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.Community,
		&i.CitiesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CommunityAr,
	)
	return i, err
}

const deleteCommunity = `-- name: DeleteCommunity :exec
DELETE FROM communities
Where id = $1
`

func (q *Queries) DeleteCommunity(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCommunity, id)
	return err
}

const getAllCommunitiesByCountry = `-- name: GetAllCommunitiesByCountry :many
select com.id, com.community, com.cities_id, com.created_at, com.updated_at, com.lat, com.lng, com.status, com.deleted_at, com.updated_by, com.community_ar
from communities com
join cities c on c.id=com.cities_id
join states s on s.id=c.states_id
join countries co on co.id=s.countries_id
where co.id=$1
`

func (q *Queries) GetAllCommunitiesByCountry(ctx context.Context, id int64) ([]Community, error) {
	rows, err := q.db.Query(ctx, getAllCommunitiesByCountry, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Community
	for rows.Next() {
		var i Community
		if err := rows.Scan(
			&i.ID,
			&i.Community,
			&i.CitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCommunityByCitiesId = `-- name: GetAllCommunityByCitiesId :many
SELECT id FROM communities
WHERE cities_id = $1
`

func (q *Queries) GetAllCommunityByCitiesId(ctx context.Context, citiesID pgtype.Int8) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllCommunityByCitiesId, citiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunities = `-- name: GetCommunities :many
SELECT id, community, cities_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, community_ar FROM communities
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetCommunitiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetCommunities(ctx context.Context, arg GetCommunitiesParams) ([]Community, error) {
	rows, err := q.db.Query(ctx, getCommunities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Community
	for rows.Next() {
		var i Community
		if err := rows.Scan(
			&i.ID,
			&i.Community,
			&i.CitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunity = `-- name: GetCommunity :one
SELECT id, community, cities_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, community_ar FROM communities 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetCommunity(ctx context.Context, limit int32) (Community, error) {
	row := q.db.QueryRow(ctx, getCommunity, limit)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.Community,
		&i.CitiesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CommunityAr,
	)
	return i, err
}

const getCommunityByCitiesId = `-- name: GetCommunityByCitiesId :many
SELECT   id, community, cities_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, community_ar FROM communities
WHERE cities_id = $1 AND status= $2::BIGINT ORDER BY id
`

type GetCommunityByCitiesIdParams struct {
	CitiesID     pgtype.Int8 `json:"cities_id"`
	ActiveStatus int64       `json:"active_status"`
}

func (q *Queries) GetCommunityByCitiesId(ctx context.Context, arg GetCommunityByCitiesIdParams) ([]Community, error) {
	rows, err := q.db.Query(ctx, getCommunityByCitiesId, arg.CitiesID, arg.ActiveStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Community
	for rows.Next() {
		var i Community
		if err := rows.Scan(
			&i.ID,
			&i.Community,
			&i.CitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityByCityId = `-- name: GetCommunityByCityId :many
SELECT  DISTINCT ON (communities.community) id, community, cities_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, community_ar FROM communities
WHERE communities.cities_id = $1
`

func (q *Queries) GetCommunityByCityId(ctx context.Context, citiesID pgtype.Int8) ([]Community, error) {
	rows, err := q.db.Query(ctx, getCommunityByCityId, citiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Community
	for rows.Next() {
		var i Community
		if err := rows.Scan(
			&i.ID,
			&i.Community,
			&i.CitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityByName = `-- name: GetCommunityByName :one
SELECT id, community, cities_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, community_ar FROM communities 
WHERE community = $2 LIMIT $1
`

type GetCommunityByNameParams struct {
	Limit     int32  `json:"limit"`
	Community string `json:"community"`
}

func (q *Queries) GetCommunityByName(ctx context.Context, arg GetCommunityByNameParams) (Community, error) {
	row := q.db.QueryRow(ctx, getCommunityByName, arg.Limit, arg.Community)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.Community,
		&i.CitiesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CommunityAr,
	)
	return i, err
}

const getCommunityByStateId = `-- name: GetCommunityByStateId :many
SELECT communities.id, community, cities_id, communities.created_at, communities.updated_at, communities.lat, communities.lng, communities.status, communities.deleted_at, communities.updated_by, community_ar, cities.id, city, states_id, cities.created_at, cities.updated_at, cities.lat, cities.lng, cities.status, cities.deleted_at, cities.updated_by, city_ar, cover_image, description, states.id, state, countries_id, is_capital, states.created_at, states.updated_at, states.lat, states.lng, states.status, states.deleted_at, states.updated_by, state_ar FROM communities
LEFT JOIN cities ON communities.cities_id = cities.id
LEFT JOIN states ON cities.states_id = states.id
WHERE states_id = $1
`

type GetCommunityByStateIdRow struct {
	ID          int64              `json:"id"`
	Community   string             `json:"community"`
	CitiesID    pgtype.Int8        `json:"cities_id"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Lat         pgtype.Float8      `json:"lat"`
	Lng         pgtype.Float8      `json:"lng"`
	Status      int64              `json:"status"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy   int64              `json:"updated_by"`
	CommunityAr pgtype.Text        `json:"community_ar"`
	ID_2        pgtype.Int8        `json:"id_2"`
	City        pgtype.Text        `json:"city"`
	StatesID    pgtype.Int8        `json:"states_id"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2 pgtype.Timestamptz `json:"updated_at_2"`
	Lat_2       pgtype.Float8      `json:"lat_2"`
	Lng_2       pgtype.Float8      `json:"lng_2"`
	Status_2    pgtype.Int8        `json:"status_2"`
	DeletedAt_2 pgtype.Timestamptz `json:"deleted_at_2"`
	UpdatedBy_2 pgtype.Int8        `json:"updated_by_2"`
	CityAr      pgtype.Text        `json:"city_ar"`
	CoverImage  pgtype.Text        `json:"cover_image"`
	Description pgtype.Text        `json:"description"`
	ID_3        pgtype.Int8        `json:"id_3"`
	State       pgtype.Text        `json:"state"`
	CountriesID pgtype.Int8        `json:"countries_id"`
	IsCapital   pgtype.Bool        `json:"is_capital"`
	CreatedAt_3 pgtype.Timestamptz `json:"created_at_3"`
	UpdatedAt_3 pgtype.Timestamptz `json:"updated_at_3"`
	Lat_3       pgtype.Float8      `json:"lat_3"`
	Lng_3       pgtype.Float8      `json:"lng_3"`
	Status_3    pgtype.Int8        `json:"status_3"`
	DeletedAt_3 pgtype.Timestamptz `json:"deleted_at_3"`
	UpdatedBy_3 pgtype.Int8        `json:"updated_by_3"`
	StateAr     pgtype.Text        `json:"state_ar"`
}

func (q *Queries) GetCommunityByStateId(ctx context.Context, statesID pgtype.Int8) ([]GetCommunityByStateIdRow, error) {
	rows, err := q.db.Query(ctx, getCommunityByStateId, statesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommunityByStateIdRow
	for rows.Next() {
		var i GetCommunityByStateIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Community,
			&i.CitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CommunityAr,
			&i.ID_2,
			&i.City,
			&i.StatesID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.Lat_2,
			&i.Lng_2,
			&i.Status_2,
			&i.DeletedAt_2,
			&i.UpdatedBy_2,
			&i.CityAr,
			&i.CoverImage,
			&i.Description,
			&i.ID_3,
			&i.State,
			&i.CountriesID,
			&i.IsCapital,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
			&i.Lat_3,
			&i.Lng_3,
			&i.Status_3,
			&i.DeletedAt_3,
			&i.UpdatedBy_3,
			&i.StateAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListOfCommunity = `-- name: GetListOfCommunity :many
SELECT id, community, cities_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, community_ar FROM communities 
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetListOfCommunity(ctx context.Context, dollar_1 []int64) ([]Community, error) {
	rows, err := q.db.Query(ctx, getListOfCommunity, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Community
	for rows.Next() {
		var i Community
		if err := rows.Scan(
			&i.ID,
			&i.Community,
			&i.CitiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Lat,
			&i.Lng,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommunity = `-- name: UpdateCommunity :one
UPDATE communities
SET community = $2
Where id = $1
RETURNING id, community, cities_id, created_at, updated_at, lat, lng, status, deleted_at, updated_by, community_ar
`

type UpdateCommunityParams struct {
	ID        int64  `json:"id"`
	Community string `json:"community"`
}

func (q *Queries) UpdateCommunity(ctx context.Context, arg UpdateCommunityParams) (Community, error) {
	row := q.db.QueryRow(ctx, updateCommunity, arg.ID, arg.Community)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.Community,
		&i.CitiesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Lat,
		&i.Lng,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CommunityAr,
	)
	return i, err
}
