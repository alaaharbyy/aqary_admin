// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: expertise.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkDeleteCompanyUserExpertise = `-- name: BulkDeleteCompanyUserExpertise :exec
DELETE FROM company_user_expertise
where expertise_id= any($2::bigint[]) AND company_user_id=$1
`

type BulkDeleteCompanyUserExpertiseParams struct {
	CompanyUserID int64   `json:"company_user_id"`
	ExpertiseIds  []int64 `json:"expertise_ids"`
}

func (q *Queries) BulkDeleteCompanyUserExpertise(ctx context.Context, arg BulkDeleteCompanyUserExpertiseParams) error {
	_, err := q.db.Exec(ctx, bulkDeleteCompanyUserExpertise, arg.CompanyUserID, arg.ExpertiseIds)
	return err
}

const checkExitingompanyUserExpertise = `-- name: CheckExitingompanyUserExpertise :one
SELECT id FROM company_user_expertise 
where expertise_id=$1 AND company_user_id=$2
`

type CheckExitingompanyUserExpertiseParams struct {
	ExpertiseID   int64 `json:"expertise_id"`
	CompanyUserID int64 `json:"company_user_id"`
}

func (q *Queries) CheckExitingompanyUserExpertise(ctx context.Context, arg CheckExitingompanyUserExpertiseParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkExitingompanyUserExpertise, arg.ExpertiseID, arg.CompanyUserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCompanyUserExpertise = `-- name: CreateCompanyUserExpertise :one

INSERT INTO company_user_expertise (expertise_id, company_user_id)
VALUES ($1, $2)
RETURNING id
`

type CreateCompanyUserExpertiseParams struct {
	ExpertiseID   int64 `json:"expertise_id"`
	CompanyUserID int64 `json:"company_user_id"`
}

// --------------- company_user_expertise
func (q *Queries) CreateCompanyUserExpertise(ctx context.Context, arg CreateCompanyUserExpertiseParams) (int64, error) {
	row := q.db.QueryRow(ctx, createCompanyUserExpertise, arg.ExpertiseID, arg.CompanyUserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createExpertise = `-- name: CreateExpertise :one
INSERT INTO expertise (title, title_ar, description, status)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateExpertiseParams struct {
	Title       string      `json:"title"`
	TitleAr     pgtype.Text `json:"title_ar"`
	Description pgtype.Text `json:"description"`
	Status      int64       `json:"status"`
}

func (q *Queries) CreateExpertise(ctx context.Context, arg CreateExpertiseParams) (int64, error) {
	row := q.db.QueryRow(ctx, createExpertise,
		arg.Title,
		arg.TitleAr,
		arg.Description,
		arg.Status,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteCompanyUserExpertise = `-- name: DeleteCompanyUserExpertise :exec
DELETE FROM company_user_expertise
WHERE company_user_expertise.id = $1
`

func (q *Queries) DeleteCompanyUserExpertise(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCompanyUserExpertise, id)
	return err
}

const exitingExpertise = `-- name: ExitingExpertise :one
SELECT EXISTS (
    SELECT 1
    FROM expertise
    WHERE title = $1 and status!= $2::bigint
) AS exists
`

type ExitingExpertiseParams struct {
	Title         string `json:"title"`
	DeletedStatus int64  `json:"deleted_status"`
}

func (q *Queries) ExitingExpertise(ctx context.Context, arg ExitingExpertiseParams) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, exitingExpertise, arg.Title, arg.DeletedStatus)
	var exists pgtype.Bool
	err := row.Scan(&exists)
	return exists, err
}

const exitingExpertiseByStatus = `-- name: ExitingExpertiseByStatus :one
SELECT EXISTS (
    SELECT 1
    FROM expertise
    WHERE title = $1 and status= $2::bigint
) AS exists
`

type ExitingExpertiseByStatusParams struct {
	Title  string `json:"title"`
	Status int64  `json:"status"`
}

func (q *Queries) ExitingExpertiseByStatus(ctx context.Context, arg ExitingExpertiseByStatusParams) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, exitingExpertiseByStatus, arg.Title, arg.Status)
	var exists pgtype.Bool
	err := row.Scan(&exists)
	return exists, err
}

const getAllExpertise = `-- name: GetAllExpertise :many
SELECT
    expertise.id, expertise.title, expertise.title_ar, expertise.description, expertise.status, expertise.created_at, expertise.updated_at, expertise.deleted_at
FROM expertise
WHERE status = $1::bigint
AND(
    CASE WHEN $2::varchar IS NULL OR $2::varchar = '' THEN
        TRUE
    ELSE
        expertise.title ILIKE '%' || $2::varchar || '%'
        OR expertise.title_ar ILIKE '%' || $2::varchar || '%'
        OR expertise.description ILIKE '%' || $2::varchar || '%'
    END)
ORDER BY
    CASE
        WHEN $1::bigint = $3::bigint THEN deleted_at
        ELSE updated_at
    END DESC
LIMIT $5 OFFSET $4
`

type GetAllExpertiseParams struct {
	Status        int64       `json:"status"`
	Search        string      `json:"search"`
	DeletedStatus int64       `json:"deleted_status"`
	Offset        pgtype.Int4 `json:"offset"`
	Limit         pgtype.Int4 `json:"limit"`
}

type GetAllExpertiseRow struct {
	Expertise Expertise `json:"expertise"`
}

func (q *Queries) GetAllExpertise(ctx context.Context, arg GetAllExpertiseParams) ([]GetAllExpertiseRow, error) {
	rows, err := q.db.Query(ctx, getAllExpertise,
		arg.Status,
		arg.Search,
		arg.DeletedStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllExpertiseRow
	for rows.Next() {
		var i GetAllExpertiseRow
		if err := rows.Scan(
			&i.Expertise.ID,
			&i.Expertise.Title,
			&i.Expertise.TitleAr,
			&i.Expertise.Description,
			&i.Expertise.Status,
			&i.Expertise.CreatedAt,
			&i.Expertise.UpdatedAt,
			&i.Expertise.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyUserExpertise = `-- name: GetCompanyUserExpertise :many
SELECT 
    company_user_expertise.id,
    expertise.id as expertise_id,
    expertise.title,
    expertise.title_ar
FROM company_user_expertise
JOIN expertise ON company_user_expertise.expertise_id = expertise.id  
WHERE company_user_expertise.company_user_id = $1 AND expertise.status!=6
LIMIT $3
OFFSET $2
`

type GetCompanyUserExpertiseParams struct {
	CompanyUserID int64       `json:"company_user_id"`
	Offset        pgtype.Int4 `json:"offset"`
	Limit         pgtype.Int4 `json:"limit"`
}

type GetCompanyUserExpertiseRow struct {
	ID          int64       `json:"id"`
	ExpertiseID int64       `json:"expertise_id"`
	Title       string      `json:"title"`
	TitleAr     pgtype.Text `json:"title_ar"`
}

func (q *Queries) GetCompanyUserExpertise(ctx context.Context, arg GetCompanyUserExpertiseParams) ([]GetCompanyUserExpertiseRow, error) {
	rows, err := q.db.Query(ctx, getCompanyUserExpertise, arg.CompanyUserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyUserExpertiseRow
	for rows.Next() {
		var i GetCompanyUserExpertiseRow
		if err := rows.Scan(
			&i.ID,
			&i.ExpertiseID,
			&i.Title,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyUserExpertiseCount = `-- name: GetCompanyUserExpertiseCount :one
SELECT COUNT(expertise.id) 
FROM company_user_expertise
JOIN expertise ON company_user_expertise.expertise_id = expertise.id
WHERE company_user_expertise.company_user_id = $1  AND expertise.status!=6
`

func (q *Queries) GetCompanyUserExpertiseCount(ctx context.Context, companyUserID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCompanyUserExpertiseCount, companyUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getExpertise = `-- name: GetExpertise :one
SELECT expertise.id, expertise.title, expertise.title_ar, expertise.description, expertise.status, expertise.created_at, expertise.updated_at, expertise.deleted_at FROM expertise
WHERE id = $1
`

type GetExpertiseRow struct {
	Expertise Expertise `json:"expertise"`
}

func (q *Queries) GetExpertise(ctx context.Context, id int64) (GetExpertiseRow, error) {
	row := q.db.QueryRow(ctx, getExpertise, id)
	var i GetExpertiseRow
	err := row.Scan(
		&i.Expertise.ID,
		&i.Expertise.Title,
		&i.Expertise.TitleAr,
		&i.Expertise.Description,
		&i.Expertise.Status,
		&i.Expertise.CreatedAt,
		&i.Expertise.UpdatedAt,
		&i.Expertise.DeletedAt,
	)
	return i, err
}

const getExpertiseCount = `-- name: GetExpertiseCount :one
SELECT COUNT(*)
FROM expertise
WHERE status = $1::bigint
AND(
    CASE WHEN $2::varchar IS NULL OR $2::varchar = '' THEN
        TRUE
    ELSE
        expertise.title ILIKE '%' || $2::varchar || '%'
        OR expertise.title_ar ILIKE '%' || $2::varchar || '%'
        OR expertise.description ILIKE '%' || $2::varchar || '%'
    END)
`

type GetExpertiseCountParams struct {
	Status int64  `json:"status"`
	Search string `json:"search"`
}

func (q *Queries) GetExpertiseCount(ctx context.Context, arg GetExpertiseCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getExpertiseCount, arg.Status, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSingleCompanyUserExpertise = `-- name: GetSingleCompanyUserExpertise :one
SELECT 
    company_user_expertise.id,
    expertise.id as expertise_id,
    expertise.title,
    expertise.title_ar
FROM company_user_expertise
JOIN expertise ON company_user_expertise.expertise_id = expertise.id
WHERE company_user_expertise.id = $1
`

type GetSingleCompanyUserExpertiseRow struct {
	ID          int64       `json:"id"`
	ExpertiseID int64       `json:"expertise_id"`
	Title       string      `json:"title"`
	TitleAr     pgtype.Text `json:"title_ar"`
}

func (q *Queries) GetSingleCompanyUserExpertise(ctx context.Context, id int64) (GetSingleCompanyUserExpertiseRow, error) {
	row := q.db.QueryRow(ctx, getSingleCompanyUserExpertise, id)
	var i GetSingleCompanyUserExpertiseRow
	err := row.Scan(
		&i.ID,
		&i.ExpertiseID,
		&i.Title,
		&i.TitleAr,
	)
	return i, err
}

const updateExpertise = `-- name: UpdateExpertise :one
UPDATE expertise
SET
    title_ar = COALESCE($2, title_ar),
    description = COALESCE($3, description),
    updated_at = COALESCE($4, updated_at)
WHERE id = $1
RETURNING id
`

type UpdateExpertiseParams struct {
	ID          int64              `json:"id"`
	TitleAr     pgtype.Text        `json:"title_ar"`
	Description pgtype.Text        `json:"description"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateExpertise(ctx context.Context, arg UpdateExpertiseParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateExpertise,
		arg.ID,
		arg.TitleAr,
		arg.Description,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateExpertiseStatus = `-- name: UpdateExpertiseStatus :one
UPDATE expertise
SET
    status = COALESCE($2, status),
    deleted_at = COALESCE($3, deleted_at),
    updated_at = COALESCE($4, updated_at)
WHERE id = $1
RETURNING id
`

type UpdateExpertiseStatusParams struct {
	ID        int64              `json:"id"`
	Status    int64              `json:"status"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateExpertiseStatus(ctx context.Context, arg UpdateExpertiseStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateExpertiseStatus,
		arg.ID,
		arg.Status,
		arg.DeletedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
