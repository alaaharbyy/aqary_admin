// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscriptions_package.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscriptionPackage = `-- name: CreateSubscriptionPackage :one
INSERT INTO "subscription_package" (
    "subscription_order_id",
    "product",
    "no_of_products",
    "original_price_per_unit",
    "product_discount",
    "start_date",
    "end_date",
    "created_by"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, subscription_order_id, product, no_of_products, original_price_per_unit, product_discount, start_date, end_date, created_by, created_at, updated_at
`

type CreateSubscriptionPackageParams struct {
	SubscriptionOrderID  int64              `json:"subscription_order_id"`
	Product              int64              `json:"product"`
	NoOfProducts         int64              `json:"no_of_products"`
	OriginalPricePerUnit float64            `json:"original_price_per_unit"`
	ProductDiscount      float64            `json:"product_discount"`
	StartDate            pgtype.Timestamptz `json:"start_date"`
	EndDate              pgtype.Timestamptz `json:"end_date"`
	CreatedBy            int64              `json:"created_by"`
}

// Create a new subscription package
func (q *Queries) CreateSubscriptionPackage(ctx context.Context, arg CreateSubscriptionPackageParams) (SubscriptionPackage, error) {
	row := q.db.QueryRow(ctx, createSubscriptionPackage,
		arg.SubscriptionOrderID,
		arg.Product,
		arg.NoOfProducts,
		arg.OriginalPricePerUnit,
		arg.ProductDiscount,
		arg.StartDate,
		arg.EndDate,
		arg.CreatedBy,
	)
	var i SubscriptionPackage
	err := row.Scan(
		&i.ID,
		&i.SubscriptionOrderID,
		&i.Product,
		&i.NoOfProducts,
		&i.OriginalPricePerUnit,
		&i.ProductDiscount,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSubscriptionPackage = `-- name: DeleteSubscriptionPackage :exec
DELETE FROM "subscription_package"
WHERE "id" = $1
`

// Delete a subscription package by ID
func (q *Queries) DeleteSubscriptionPackage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionPackage, id)
	return err
}

const getSubscriptionPackage = `-- name: GetSubscriptionPackage :one
SELECT id, subscription_order_id, product, no_of_products, original_price_per_unit, product_discount, start_date, end_date, created_by, created_at, updated_at FROM "subscription_package"
WHERE "id" = $1
`

// Get a subscription package by ID
func (q *Queries) GetSubscriptionPackage(ctx context.Context, id int64) (SubscriptionPackage, error) {
	row := q.db.QueryRow(ctx, getSubscriptionPackage, id)
	var i SubscriptionPackage
	err := row.Scan(
		&i.ID,
		&i.SubscriptionOrderID,
		&i.Product,
		&i.NoOfProducts,
		&i.OriginalPricePerUnit,
		&i.ProductDiscount,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSubscriptionPackages = `-- name: ListSubscriptionPackages :many
SELECT id, subscription_order_id, product, no_of_products, original_price_per_unit, product_discount, start_date, end_date, created_by, created_at, updated_at FROM "subscription_package"
ORDER BY "created_at" DESC
`

// List all subscription packages
func (q *Queries) ListSubscriptionPackages(ctx context.Context) ([]SubscriptionPackage, error) {
	rows, err := q.db.Query(ctx, listSubscriptionPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionPackage
	for rows.Next() {
		var i SubscriptionPackage
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionOrderID,
			&i.Product,
			&i.NoOfProducts,
			&i.OriginalPricePerUnit,
			&i.ProductDiscount,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionPackage = `-- name: UpdateSubscriptionPackage :one
UPDATE "subscription_package"
SET
    "no_of_products" = $2,
    "product_discount" = $3, 
    "start_date" = $4,
    "end_date" = $5, 
    "updated_at" = $6
WHERE "id" = $1
RETURNING id, subscription_order_id, product, no_of_products, original_price_per_unit, product_discount, start_date, end_date, created_by, created_at, updated_at
`

type UpdateSubscriptionPackageParams struct {
	ID              int64              `json:"id"`
	NoOfProducts    int64              `json:"no_of_products"`
	ProductDiscount float64            `json:"product_discount"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

// Update a subscription package and return the updated row
func (q *Queries) UpdateSubscriptionPackage(ctx context.Context, arg UpdateSubscriptionPackageParams) (SubscriptionPackage, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionPackage,
		arg.ID,
		arg.NoOfProducts,
		arg.ProductDiscount,
		arg.StartDate,
		arg.EndDate,
		arg.UpdatedAt,
	)
	var i SubscriptionPackage
	err := row.Scan(
		&i.ID,
		&i.SubscriptionOrderID,
		&i.Product,
		&i.NoOfProducts,
		&i.OriginalPricePerUnit,
		&i.ProductDiscount,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
