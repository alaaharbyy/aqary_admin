// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: review_term.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createReviewTerm = `-- name: CreateReviewTerm :one
INSERT INTO review_terms (
    entity_type_id, 
    review_term,
    review_term_ar, 
    status, 
    created_at, 
    updated_at 
)
SELECT 
    $1, 
    $2, 
    $3, 
    $4, 
    $5, 
    $6
FROM 
    entity_type WHERE id=$1 RETURNING id
`

type CreateReviewTermParams struct {
	EntityTypeID int64       `json:"entity_type_id"`
	ReviewTerm   string      `json:"review_term"`
	ReviewTermAr pgtype.Text `json:"review_term_ar"`
	Status       int64       `json:"status"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

func (q *Queries) CreateReviewTerm(ctx context.Context, arg CreateReviewTermParams) (int64, error) {
	row := q.db.QueryRow(ctx, createReviewTerm,
		arg.EntityTypeID,
		arg.ReviewTerm,
		arg.ReviewTermAr,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteRestoreReviewTerm = `-- name: DeleteRestoreReviewTerm :one
UPDATE review_terms
SET 
    status= $3::BIGINT, 
    updated_at= $2
WHERE 
    id= $1 RETURNING id
`

type DeleteRestoreReviewTermParams struct {
	ID        int64     `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
	Status    int64     `json:"status"`
}

func (q *Queries) DeleteRestoreReviewTerm(ctx context.Context, arg DeleteRestoreReviewTermParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteRestoreReviewTerm, arg.ID, arg.UpdatedAt, arg.Status)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAllReviewTerms = `-- name: GetAllReviewTerms :many
SELECT review_terms.id, review_terms.entity_type_id, review_terms.review_term, review_terms.review_term_ar, review_terms.status, review_terms.created_at, review_terms.updated_at,entity_type.name FROM review_terms 
INNER JOIN entity_type ON entity_type.id=review_terms.entity_type_id
WHERE status= $1::BIGINT 
ORDER BY review_terms.updated_at DESC
LIMIT $3 OFFSET $2
`

type GetAllReviewTermsParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllReviewTermsRow struct {
	ID           int64       `json:"id"`
	EntityTypeID int64       `json:"entity_type_id"`
	ReviewTerm   string      `json:"review_term"`
	ReviewTermAr pgtype.Text `json:"review_term_ar"`
	Status       int64       `json:"status"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Name         string      `json:"name"`
}

func (q *Queries) GetAllReviewTerms(ctx context.Context, arg GetAllReviewTermsParams) ([]GetAllReviewTermsRow, error) {
	rows, err := q.db.Query(ctx, getAllReviewTerms, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllReviewTermsRow
	for rows.Next() {
		var i GetAllReviewTermsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityTypeID,
			&i.ReviewTerm,
			&i.ReviewTermAr,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOfReviewTerms = `-- name: GetNumberOfReviewTerms :one
SELECT COUNT(*) FROM review_terms WHERE status= $1::BIGINT
`

func (q *Queries) GetNumberOfReviewTerms(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOfReviewTerms, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getReviewTermByID = `-- name: GetReviewTermByID :one
SELECT review_terms.id, review_terms.entity_type_id, review_terms.review_term, review_terms.review_term_ar, review_terms.status, review_terms.created_at, review_terms.updated_at,entity_type.name FROM review_terms 
INNER JOIN entity_type ON entity_type.id=review_terms.entity_type_id
WHERE review_terms.id= $1 AND status= $2::BIGINT
`

type GetReviewTermByIDParams struct {
	ID           int64 `json:"id"`
	ActiveStatus int64 `json:"active_status"`
}

type GetReviewTermByIDRow struct {
	ID           int64       `json:"id"`
	EntityTypeID int64       `json:"entity_type_id"`
	ReviewTerm   string      `json:"review_term"`
	ReviewTermAr pgtype.Text `json:"review_term_ar"`
	Status       int64       `json:"status"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Name         string      `json:"name"`
}

func (q *Queries) GetReviewTermByID(ctx context.Context, arg GetReviewTermByIDParams) (GetReviewTermByIDRow, error) {
	row := q.db.QueryRow(ctx, getReviewTermByID, arg.ID, arg.ActiveStatus)
	var i GetReviewTermByIDRow
	err := row.Scan(
		&i.ID,
		&i.EntityTypeID,
		&i.ReviewTerm,
		&i.ReviewTermAr,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
	)
	return i, err
}

const updateReviewTerm = `-- name: UpdateReviewTerm :one
UPDATE 
    review_terms
SET 
    entity_type_id= COALESCE($3,entity_type_id), 
    review_term= COALESCE($4,review_term), 
    review_term_ar=COALESCE($5,review_term_ar), 
    updated_at= $2
WHERE review_terms.id=$1 AND status= $6::BIGINT
AND (
    $3 = entity_type_id 
    OR $3 IS NULL 
    OR EXISTS (SELECT 1 FROM entity_type WHERE id= $3)
) RETURNING id
`

type UpdateReviewTermParams struct {
	ID           int64       `json:"id"`
	UpdatedAt    time.Time   `json:"updated_at"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	ReviewTerm   pgtype.Text `json:"review_term"`
	ReviewTermAr pgtype.Text `json:"review_term_ar"`
	ActiveStatus int64       `json:"active_status"`
}

func (q *Queries) UpdateReviewTerm(ctx context.Context, arg UpdateReviewTermParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateReviewTerm,
		arg.ID,
		arg.UpdatedAt,
		arg.EntityTypeID,
		arg.ReviewTerm,
		arg.ReviewTermAr,
		arg.ActiveStatus,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
