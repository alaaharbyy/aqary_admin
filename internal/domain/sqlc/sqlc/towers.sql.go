// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: towers.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeStatusOfTower = `-- name: ChangeStatusOfTower :one
UPDATE towers
SET
    is_publish=$2
WHERE id=$1
RETURNING id, countries_id, states_id, cities_id, community_id, subcommunity_id, title, title_ar, description, description_ar, image_url, created_at, updated_at, is_publish, created_by
`

type ChangeStatusOfTowerParams struct {
	ID        int64       `json:"id"`
	IsPublish pgtype.Bool `json:"is_publish"`
}

func (q *Queries) ChangeStatusOfTower(ctx context.Context, arg ChangeStatusOfTowerParams) (Tower, error) {
	row := q.db.QueryRow(ctx, changeStatusOfTower, arg.ID, arg.IsPublish)
	var i Tower
	err := row.Scan(
		&i.ID,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Title,
		&i.TitleAr,
		&i.Description,
		&i.DescriptionAr,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsPublish,
		&i.CreatedBy,
	)
	return i, err
}

const createTower = `-- name: CreateTower :one
INSERT INTO towers (
    countries_id,
    states_id,
    cities_id,
    community_id,
    subcommunity_id,
    title,
    title_ar,
    description,
    description_ar,
    image_url,
    created_at,
    updated_at, 
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12,$13
) RETURNING id, countries_id, states_id, cities_id, community_id, subcommunity_id, title, title_ar, description, description_ar, image_url, created_at, updated_at, is_publish, created_by
`

type CreateTowerParams struct {
	CountriesID    int64              `json:"countries_id"`
	StatesID       int64              `json:"states_id"`
	CitiesID       int64              `json:"cities_id"`
	CommunityID    int32              `json:"community_id"`
	SubcommunityID int32              `json:"subcommunity_id"`
	Title          string             `json:"title"`
	TitleAr        pgtype.Text        `json:"title_ar"`
	Description    string             `json:"description"`
	DescriptionAr  pgtype.Text        `json:"description_ar"`
	ImageUrl       string             `json:"image_url"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	CreatedBy      int64              `json:"created_by"`
}

func (q *Queries) CreateTower(ctx context.Context, arg CreateTowerParams) (Tower, error) {
	row := q.db.QueryRow(ctx, createTower,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.CommunityID,
		arg.SubcommunityID,
		arg.Title,
		arg.TitleAr,
		arg.Description,
		arg.DescriptionAr,
		arg.ImageUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
	)
	var i Tower
	err := row.Scan(
		&i.ID,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Title,
		&i.TitleAr,
		&i.Description,
		&i.DescriptionAr,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsPublish,
		&i.CreatedBy,
	)
	return i, err
}

const getAllTowers = `-- name: GetAllTowers :many
SELECT 
	t.id,
	t.title,
	t.description,
	communities.id AS community_id,
	communities.community,
	tm.id AS tower_media_id,
	array_append(tm.image_url,t.image_url)
FROM towers t
INNER JOIN communities ON communities.id=t.community_id 
LEFT JOIN tower_media tm ON tm.towers_id=t.id
ORDER BY t.id DESC 
LIMIT $1 
OFFSET $2
`

type GetAllTowersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllTowersRow struct {
	ID           int64       `json:"id"`
	Title        string      `json:"title"`
	Description  string      `json:"description"`
	CommunityID  int64       `json:"community_id"`
	Community    string      `json:"community"`
	TowerMediaID pgtype.Int8 `json:"tower_media_id"`
	ArrayAppend  interface{} `json:"array_append"`
}

func (q *Queries) GetAllTowers(ctx context.Context, arg GetAllTowersParams) ([]GetAllTowersRow, error) {
	rows, err := q.db.Query(ctx, getAllTowers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTowersRow
	for rows.Next() {
		var i GetAllTowersRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CommunityID,
			&i.Community,
			&i.TowerMediaID,
			&i.ArrayAppend,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOfTowers = `-- name: GetNumberOfTowers :one
SELECT COUNT(id) from towers
`

func (q *Queries) GetNumberOfTowers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOfTowers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTowerByID = `-- name: GetTowerByID :one
SELECT id, countries_id, states_id, cities_id, community_id, subcommunity_id, title, title_ar, description, description_ar, image_url, created_at, updated_at, is_publish, created_by FROM towers WHERE id = $1
`

func (q *Queries) GetTowerByID(ctx context.Context, id int64) (Tower, error) {
	row := q.db.QueryRow(ctx, getTowerByID, id)
	var i Tower
	err := row.Scan(
		&i.ID,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Title,
		&i.TitleAr,
		&i.Description,
		&i.DescriptionAr,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsPublish,
		&i.CreatedBy,
	)
	return i, err
}

const listAllTowers = `-- name: ListAllTowers :many
SELECT id, countries_id, states_id, cities_id, community_id, subcommunity_id, title, title_ar, description, description_ar, image_url, created_at, updated_at, is_publish, created_by FROM towers
`

func (q *Queries) ListAllTowers(ctx context.Context) ([]Tower, error) {
	rows, err := q.db.Query(ctx, listAllTowers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tower
	for rows.Next() {
		var i Tower
		if err := rows.Scan(
			&i.ID,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunityID,
			&i.SubcommunityID,
			&i.Title,
			&i.TitleAr,
			&i.Description,
			&i.DescriptionAr,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublish,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTower = `-- name: UpdateTower :one
UPDATE towers 
SET countries_id = $2,
    states_id = $3,
    cities_id = $4,
    community_id = $5,
    subcommunity_id = $6,
    title = $7,
    title_ar = $8,
    description = $9,
    description_ar = $10,
    image_url = $11, 
    updated_at=$12
WHERE id = $1
RETURNING id, countries_id, states_id, cities_id, community_id, subcommunity_id, title, title_ar, description, description_ar, image_url, created_at, updated_at, is_publish, created_by
`

type UpdateTowerParams struct {
	ID             int64              `json:"id"`
	CountriesID    int64              `json:"countries_id"`
	StatesID       int64              `json:"states_id"`
	CitiesID       int64              `json:"cities_id"`
	CommunityID    int32              `json:"community_id"`
	SubcommunityID int32              `json:"subcommunity_id"`
	Title          string             `json:"title"`
	TitleAr        pgtype.Text        `json:"title_ar"`
	Description    string             `json:"description"`
	DescriptionAr  pgtype.Text        `json:"description_ar"`
	ImageUrl       string             `json:"image_url"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateTower(ctx context.Context, arg UpdateTowerParams) (Tower, error) {
	row := q.db.QueryRow(ctx, updateTower,
		arg.ID,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.CommunityID,
		arg.SubcommunityID,
		arg.Title,
		arg.TitleAr,
		arg.Description,
		arg.DescriptionAr,
		arg.ImageUrl,
		arg.UpdatedAt,
	)
	var i Tower
	err := row.Scan(
		&i.ID,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Title,
		&i.TitleAr,
		&i.Description,
		&i.DescriptionAr,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsPublish,
		&i.CreatedBy,
	)
	return i, err
}
