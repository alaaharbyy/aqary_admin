// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: agent_routes.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAgentRoute = `-- name: CreateAgentRoute :one
INSERT INTO agent_routes (
    leads_id,
    assigned_to,
    routed_to,
    reason,
    routed_date
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5  
) RETURNING id, leads_id, assigned_to, routed_to, reason, routed_date
`

type CreateAgentRouteParams struct {
	LeadsID    int64     `json:"leads_id"`
	AssignedTo int64     `json:"assigned_to"`
	RoutedTo   int64     `json:"routed_to"`
	Reason     string    `json:"reason"`
	RoutedDate time.Time `json:"routed_date"`
}

func (q *Queries) CreateAgentRoute(ctx context.Context, arg CreateAgentRouteParams) (AgentRoute, error) {
	row := q.db.QueryRow(ctx, createAgentRoute,
		arg.LeadsID,
		arg.AssignedTo,
		arg.RoutedTo,
		arg.Reason,
		arg.RoutedDate,
	)
	var i AgentRoute
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.AssignedTo,
		&i.RoutedTo,
		&i.Reason,
		&i.RoutedDate,
	)
	return i, err
}

const getAllAgentRoutes = `-- name: GetAllAgentRoutes :many
SELECT
    ar.id,
    ar.leads_id,
    l.ref_no,
    ar.assigned_to,
    au.username as "assigned_to_username",
    1 as "activity",
    ar.routed_to,
    ru.username as "routed_to_username",
    ar.reason,
    ar.routed_date
FROM
    agent_routes ar join leads l on ar.leads_id = l.id join users au on ar.assigned_to = au.id join users ru on ar.routed_to = ru.id
ORDER BY
    ar.id LIMIT $1 OFFSET $2
`

type GetAllAgentRoutesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllAgentRoutesRow struct {
	ID                 int64       `json:"id"`
	LeadsID            int64       `json:"leads_id"`
	RefNo              string      `json:"ref_no"`
	AssignedTo         int64       `json:"assigned_to"`
	AssignedToUsername string      `json:"assigned_to_username"`
	Activity           pgtype.Int8 `json:"activity"`
	RoutedTo           int64       `json:"routed_to"`
	RoutedToUsername   string      `json:"routed_to_username"`
	Reason             string      `json:"reason"`
	RoutedDate         time.Time   `json:"routed_date"`
}

func (q *Queries) GetAllAgentRoutes(ctx context.Context, arg GetAllAgentRoutesParams) ([]GetAllAgentRoutesRow, error) {
	rows, err := q.db.Query(ctx, getAllAgentRoutes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAgentRoutesRow
	for rows.Next() {
		var i GetAllAgentRoutesRow
		if err := rows.Scan(
			&i.ID,
			&i.LeadsID,
			&i.RefNo,
			&i.AssignedTo,
			&i.AssignedToUsername,
			&i.Activity,
			&i.RoutedTo,
			&i.RoutedToUsername,
			&i.Reason,
			&i.RoutedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAssignedAgents = `-- name: GetAllAssignedAgents :one
select COUNT(DISTINCT(assigned_to)) from agent_routes
`

func (q *Queries) GetAllAssignedAgents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAllAssignedAgents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllAgentRoutes = `-- name: GetCountAllAgentRoutes :one
SELECT
count(ar.*)
FROM
    agent_routes ar join leads l on ar.leads_id = l.id join users au on ar.assigned_to = au.id join users ru on ar.routed_to = ru.id
`

func (q *Queries) GetCountAllAgentRoutes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllAgentRoutes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFilterAgentPerformance = `-- name: GetFilterAgentPerformance :many
    SELECT 
        ar.assigned_to, 
        ar.reason, 
        COUNT(*) AS reason_count,
        ROW_NUMBER() OVER (PARTITION BY ar.assigned_to ORDER BY COUNT(*) DESC) AS reason_rank
    FROM 
        public.agent_routes ar
        WHERE ar.assigned_to in (select assigned_to from agent_routes order by routed_date desc limit $1 offset $2) or $3::BOOLEAN
    GROUP BY 
        ar.assigned_to, 
        ar.reason
    ORDER BY 
    assigned_to
`

type GetFilterAgentPerformanceParams struct {
	Limit             int32 `json:"limit"`
	Offset            int32 `json:"offset"`
	DisablePagination bool  `json:"disable_pagination"`
}

type GetFilterAgentPerformanceRow struct {
	AssignedTo  int64  `json:"assigned_to"`
	Reason      string `json:"reason"`
	ReasonCount int64  `json:"reason_count"`
	ReasonRank  int64  `json:"reason_rank"`
}

func (q *Queries) GetFilterAgentPerformance(ctx context.Context, arg GetFilterAgentPerformanceParams) ([]GetFilterAgentPerformanceRow, error) {
	rows, err := q.db.Query(ctx, getFilterAgentPerformance, arg.Limit, arg.Offset, arg.DisablePagination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilterAgentPerformanceRow
	for rows.Next() {
		var i GetFilterAgentPerformanceRow
		if err := rows.Scan(
			&i.AssignedTo,
			&i.Reason,
			&i.ReasonCount,
			&i.ReasonRank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleAgentRoute = `-- name: GetSingleAgentRoute :one
select id, leads_id, assigned_to, routed_to, reason, routed_date from agent_routes where leads_id = $1 and assigned_to = $2 and reason Ilike $3 LIMIT 1
`

type GetSingleAgentRouteParams struct {
	LeadsID    int64  `json:"leads_id"`
	AssignedTo int64  `json:"assigned_to"`
	Reason     string `json:"reason"`
}

func (q *Queries) GetSingleAgentRoute(ctx context.Context, arg GetSingleAgentRouteParams) (AgentRoute, error) {
	row := q.db.QueryRow(ctx, getSingleAgentRoute, arg.LeadsID, arg.AssignedTo, arg.Reason)
	var i AgentRoute
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.AssignedTo,
		&i.RoutedTo,
		&i.Reason,
		&i.RoutedDate,
	)
	return i, err
}

const getSingleAgentRouteCheck = `-- name: GetSingleAgentRouteCheck :one
select id, leads_id, assigned_to, routed_to, reason, routed_date from agent_routes where leads_id = $1 ORDER BY routed_date desc LIMIT 1
`

func (q *Queries) GetSingleAgentRouteCheck(ctx context.Context, leadsID int64) (AgentRoute, error) {
	row := q.db.QueryRow(ctx, getSingleAgentRouteCheck, leadsID)
	var i AgentRoute
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.AssignedTo,
		&i.RoutedTo,
		&i.Reason,
		&i.RoutedDate,
	)
	return i, err
}

const updateAgentRoute = `-- name: UpdateAgentRoute :one
UPDATE agent_routes
SET
    reason = $2
WHERE
    id = $1
    RETURNING id, leads_id, assigned_to, routed_to, reason, routed_date
`

type UpdateAgentRouteParams struct {
	ID     int64  `json:"id"`
	Reason string `json:"reason"`
}

func (q *Queries) UpdateAgentRoute(ctx context.Context, arg UpdateAgentRouteParams) (AgentRoute, error) {
	row := q.db.QueryRow(ctx, updateAgentRoute, arg.ID, arg.Reason)
	var i AgentRoute
	err := row.Scan(
		&i.ID,
		&i.LeadsID,
		&i.AssignedTo,
		&i.RoutedTo,
		&i.Reason,
		&i.RoutedDate,
	)
	return i, err
}
