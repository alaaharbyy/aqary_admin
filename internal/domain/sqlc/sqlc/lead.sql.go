// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: lead.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLead = `-- name: CreateLead :one
INSERT INTO leads (ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property,
 unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area,
  bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to,
   is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes,
    created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, 
$21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, 
$41, $42, $43, $44, $45, $46, $47) RETURNING id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type
`

type CreateLeadParams struct {
	RefNo                 string             `json:"ref_no"`
	ContactsID            int64              `json:"contacts_id"`
	LeadSource            pgtype.Int8        `json:"lead_source"`
	MediaName             pgtype.Int8        `json:"media_name"`
	LeadType              int64              `json:"lead_type"`
	ContactType           int64              `json:"contact_type"`
	Languages             []int64            `json:"languages"`
	PropertyCategory      int64              `json:"property_category"`
	IsProperty            pgtype.Bool        `json:"is_property"`
	UnitCategory          pgtype.Text        `json:"unit_category"`
	PropertyTypeID        pgtype.Int8        `json:"property_type_id"`
	IsLuxury              pgtype.Bool        `json:"is_luxury"`
	PropertyUnitID        pgtype.Int8        `json:"property_unit_id"`
	PropertyStatusesID    pgtype.Int8        `json:"property_statuses_id"`
	PurposeID             pgtype.Int8        `json:"purpose_id"`
	MinBudget             pgtype.Float8      `json:"min_budget"`
	MaxBudget             pgtype.Float8      `json:"max_budget"`
	MinArea               pgtype.Float8      `json:"min_area"`
	MaxArea               pgtype.Float8      `json:"max_area"`
	Bedroom               pgtype.Int8        `json:"bedroom"`
	Bathroom              pgtype.Int8        `json:"bathroom"`
	CountriesID           int64              `json:"countries_id"`
	StatesID              int64              `json:"states_id"`
	CitiesID              int64              `json:"cities_id"`
	CommunityID           []int64            `json:"community_id"`
	SubcommunityID        []int64            `json:"subcommunity_id"`
	Lat                   pgtype.Text        `json:"lat"`
	Lng                   pgtype.Text        `json:"lng"`
	AssignedTo            pgtype.Int8        `json:"assigned_to"`
	ResidentialStatus     pgtype.Int8        `json:"residential_status"`
	ReferredTo            pgtype.Int8        `json:"referred_to"`
	IsExclusive           pgtype.Bool        `json:"is_exclusive"`
	PriorityLevel         pgtype.Int8        `json:"priority_level"`
	IsFinance             pgtype.Bool        `json:"is_finance"`
	MortgageBankID        pgtype.Int8        `json:"mortgage_bank_id"`
	MortgageStatus        pgtype.Int8        `json:"mortgage_status"`
	RequiredStart         pgtype.Timestamptz `json:"required_start"`
	RequiredEnd           pgtype.Timestamptz `json:"required_end"`
	ClosingRemarks        pgtype.Text        `json:"closing_remarks"`
	InternalNotes         pgtype.Text        `json:"internal_notes"`
	CreatedAt             time.Time          `json:"created_at"`
	LeadsWon              pgtype.Bool        `json:"leads_won"`
	WithReference         pgtype.Bool        `json:"with_reference"`
	IsPropertyBranch      pgtype.Bool        `json:"is_property_branch"`
	PropertyReferenceName pgtype.Text        `json:"property_reference_name"`
	SocialMediaName       pgtype.Text        `json:"social_media_name"`
	SectionType           []int64            `json:"section_type"`
}

func (q *Queries) CreateLead(ctx context.Context, arg CreateLeadParams) (Lead, error) {
	row := q.db.QueryRow(ctx, createLead,
		arg.RefNo,
		arg.ContactsID,
		arg.LeadSource,
		arg.MediaName,
		arg.LeadType,
		arg.ContactType,
		arg.Languages,
		arg.PropertyCategory,
		arg.IsProperty,
		arg.UnitCategory,
		arg.PropertyTypeID,
		arg.IsLuxury,
		arg.PropertyUnitID,
		arg.PropertyStatusesID,
		arg.PurposeID,
		arg.MinBudget,
		arg.MaxBudget,
		arg.MinArea,
		arg.MaxArea,
		arg.Bedroom,
		arg.Bathroom,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.CommunityID,
		arg.SubcommunityID,
		arg.Lat,
		arg.Lng,
		arg.AssignedTo,
		arg.ResidentialStatus,
		arg.ReferredTo,
		arg.IsExclusive,
		arg.PriorityLevel,
		arg.IsFinance,
		arg.MortgageBankID,
		arg.MortgageStatus,
		arg.RequiredStart,
		arg.RequiredEnd,
		arg.ClosingRemarks,
		arg.InternalNotes,
		arg.CreatedAt,
		arg.LeadsWon,
		arg.WithReference,
		arg.IsPropertyBranch,
		arg.PropertyReferenceName,
		arg.SocialMediaName,
		arg.SectionType,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
	)
	return i, err
}

const createLeadDetails = `-- name: CreateLeadDetails :one
INSERT INTO leads (
    ref_no,
    contacts_id,
    lead_type,
    contact_type,
    languages,
    property_category,
    is_property,
    property_unit_id,
    unit_category,
    property_type_id,
    property_statuses_id,
    purpose_id,
    min_budget,
    max_budget,
    min_area,
    max_area,
    bedroom,
    bathroom,
    countries_id,
    states_id,
    cities_id,
    community_id,
    subcommunity_id,
    lat,
    lng,
    is_luxury,
    mortgage_status,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28
)
RETURNING id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type
`

type CreateLeadDetailsParams struct {
	RefNo              string        `json:"ref_no"`
	ContactsID         int64         `json:"contacts_id"`
	LeadType           int64         `json:"lead_type"`
	ContactType        int64         `json:"contact_type"`
	Languages          []int64       `json:"languages"`
	PropertyCategory   int64         `json:"property_category"`
	IsProperty         pgtype.Bool   `json:"is_property"`
	PropertyUnitID     pgtype.Int8   `json:"property_unit_id"`
	UnitCategory       pgtype.Text   `json:"unit_category"`
	PropertyTypeID     pgtype.Int8   `json:"property_type_id"`
	PropertyStatusesID pgtype.Int8   `json:"property_statuses_id"`
	PurposeID          pgtype.Int8   `json:"purpose_id"`
	MinBudget          pgtype.Float8 `json:"min_budget"`
	MaxBudget          pgtype.Float8 `json:"max_budget"`
	MinArea            pgtype.Float8 `json:"min_area"`
	MaxArea            pgtype.Float8 `json:"max_area"`
	Bedroom            pgtype.Int8   `json:"bedroom"`
	Bathroom           pgtype.Int8   `json:"bathroom"`
	CountriesID        int64         `json:"countries_id"`
	StatesID           int64         `json:"states_id"`
	CitiesID           int64         `json:"cities_id"`
	CommunityID        []int64       `json:"community_id"`
	SubcommunityID     []int64       `json:"subcommunity_id"`
	Lat                pgtype.Text   `json:"lat"`
	Lng                pgtype.Text   `json:"lng"`
	IsLuxury           pgtype.Bool   `json:"is_luxury"`
	MortgageStatus     pgtype.Int8   `json:"mortgage_status"`
	CreatedAt          time.Time     `json:"created_at"`
}

func (q *Queries) CreateLeadDetails(ctx context.Context, arg CreateLeadDetailsParams) (Lead, error) {
	row := q.db.QueryRow(ctx, createLeadDetails,
		arg.RefNo,
		arg.ContactsID,
		arg.LeadType,
		arg.ContactType,
		arg.Languages,
		arg.PropertyCategory,
		arg.IsProperty,
		arg.PropertyUnitID,
		arg.UnitCategory,
		arg.PropertyTypeID,
		arg.PropertyStatusesID,
		arg.PurposeID,
		arg.MinBudget,
		arg.MaxBudget,
		arg.MinArea,
		arg.MaxArea,
		arg.Bedroom,
		arg.Bathroom,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.CommunityID,
		arg.SubcommunityID,
		arg.Lat,
		arg.Lng,
		arg.IsLuxury,
		arg.MortgageStatus,
		arg.CreatedAt,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
	)
	return i, err
}

const getAllLeadDetailsByContactId = `-- name: GetAllLeadDetailsByContactId :many
SELECT 
    l.id, l.ref_no, l.contacts_id, l.lead_source, l.media_name, l.lead_type, l.contact_type, l.languages, l.property_category, l.is_property, l.unit_category, l.property_type_id, l.is_luxury, l.property_unit_id, l.property_statuses_id, l.purpose_id, l.min_budget, l.max_budget, l.min_area, l.max_area, l.bedroom, l.bathroom, l.countries_id, l.states_id, l.cities_id, l.community_id, l.subcommunity_id, l.lat, l.lng, l.assigned_to, l.residential_status, l.referred_to, l.is_exclusive, l.priority_level, l.is_finance, l.mortgage_bank_id, l.mortgage_status, l.required_start, l.required_end, l.closing_remarks, l.internal_notes, l.created_at, l.leads_won, l.with_reference, l.is_property_branch, l.property_reference_name, l.social_media_name, l.section_type,
    lp.progress_date,
    lp.progress_status,
    lp.lead_status,
    ln.agent_sms,
    ln.agent_mail,
    ln.agent_whatsapp,
    ln.agent_system_notofication,
    ln.lead_sms,
    ln.lead_mail,
    ln.lead_whatsapp,
    ln.lead_system_notification,
    ln.follow_up_email,
    ln.closed_lost_email,
    ln.closed_lost_sms,
    ln.closed_lost_whatsapp,
    ln.closed_won_email,
    ln.closed_won_sms,
    ln.closed_won_whatsapp
FROM 
    leads l
LEFT JOIN 
    leads_progress lp ON l.id = lp.leads_id
LEFT JOIN 
    leads_notification ln ON l.id = ln.leads_id
WHERE l.contacts_id = $1 LIMIT $2 OFFSET $3
`

type GetAllLeadDetailsByContactIdParams struct {
	ContactsID int64 `json:"contacts_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetAllLeadDetailsByContactIdRow struct {
	ID                      int64              `json:"id"`
	RefNo                   string             `json:"ref_no"`
	ContactsID              int64              `json:"contacts_id"`
	LeadSource              pgtype.Int8        `json:"lead_source"`
	MediaName               pgtype.Int8        `json:"media_name"`
	LeadType                int64              `json:"lead_type"`
	ContactType             int64              `json:"contact_type"`
	Languages               []int64            `json:"languages"`
	PropertyCategory        int64              `json:"property_category"`
	IsProperty              pgtype.Bool        `json:"is_property"`
	UnitCategory            pgtype.Text        `json:"unit_category"`
	PropertyTypeID          pgtype.Int8        `json:"property_type_id"`
	IsLuxury                pgtype.Bool        `json:"is_luxury"`
	PropertyUnitID          pgtype.Int8        `json:"property_unit_id"`
	PropertyStatusesID      pgtype.Int8        `json:"property_statuses_id"`
	PurposeID               pgtype.Int8        `json:"purpose_id"`
	MinBudget               pgtype.Float8      `json:"min_budget"`
	MaxBudget               pgtype.Float8      `json:"max_budget"`
	MinArea                 pgtype.Float8      `json:"min_area"`
	MaxArea                 pgtype.Float8      `json:"max_area"`
	Bedroom                 pgtype.Int8        `json:"bedroom"`
	Bathroom                pgtype.Int8        `json:"bathroom"`
	CountriesID             int64              `json:"countries_id"`
	StatesID                int64              `json:"states_id"`
	CitiesID                int64              `json:"cities_id"`
	CommunityID             []int64            `json:"community_id"`
	SubcommunityID          []int64            `json:"subcommunity_id"`
	Lat                     pgtype.Text        `json:"lat"`
	Lng                     pgtype.Text        `json:"lng"`
	AssignedTo              pgtype.Int8        `json:"assigned_to"`
	ResidentialStatus       pgtype.Int8        `json:"residential_status"`
	ReferredTo              pgtype.Int8        `json:"referred_to"`
	IsExclusive             pgtype.Bool        `json:"is_exclusive"`
	PriorityLevel           pgtype.Int8        `json:"priority_level"`
	IsFinance               pgtype.Bool        `json:"is_finance"`
	MortgageBankID          pgtype.Int8        `json:"mortgage_bank_id"`
	MortgageStatus          pgtype.Int8        `json:"mortgage_status"`
	RequiredStart           pgtype.Timestamptz `json:"required_start"`
	RequiredEnd             pgtype.Timestamptz `json:"required_end"`
	ClosingRemarks          pgtype.Text        `json:"closing_remarks"`
	InternalNotes           pgtype.Text        `json:"internal_notes"`
	CreatedAt               time.Time          `json:"created_at"`
	LeadsWon                pgtype.Bool        `json:"leads_won"`
	WithReference           pgtype.Bool        `json:"with_reference"`
	IsPropertyBranch        pgtype.Bool        `json:"is_property_branch"`
	PropertyReferenceName   pgtype.Text        `json:"property_reference_name"`
	SocialMediaName         pgtype.Text        `json:"social_media_name"`
	SectionType             []int64            `json:"section_type"`
	ProgressDate            pgtype.Timestamptz `json:"progress_date"`
	ProgressStatus          pgtype.Int8        `json:"progress_status"`
	LeadStatus              pgtype.Int8        `json:"lead_status"`
	AgentSms                pgtype.Bool        `json:"agent_sms"`
	AgentMail               pgtype.Bool        `json:"agent_mail"`
	AgentWhatsapp           pgtype.Bool        `json:"agent_whatsapp"`
	AgentSystemNotofication pgtype.Bool        `json:"agent_system_notofication"`
	LeadSms                 pgtype.Bool        `json:"lead_sms"`
	LeadMail                pgtype.Bool        `json:"lead_mail"`
	LeadWhatsapp            pgtype.Bool        `json:"lead_whatsapp"`
	LeadSystemNotification  pgtype.Bool        `json:"lead_system_notification"`
	FollowUpEmail           pgtype.Bool        `json:"follow_up_email"`
	ClosedLostEmail         pgtype.Bool        `json:"closed_lost_email"`
	ClosedLostSms           pgtype.Bool        `json:"closed_lost_sms"`
	ClosedLostWhatsapp      pgtype.Bool        `json:"closed_lost_whatsapp"`
	ClosedWonEmail          pgtype.Bool        `json:"closed_won_email"`
	ClosedWonSms            pgtype.Bool        `json:"closed_won_sms"`
	ClosedWonWhatsapp       pgtype.Bool        `json:"closed_won_whatsapp"`
}

func (q *Queries) GetAllLeadDetailsByContactId(ctx context.Context, arg GetAllLeadDetailsByContactIdParams) ([]GetAllLeadDetailsByContactIdRow, error) {
	rows, err := q.db.Query(ctx, getAllLeadDetailsByContactId, arg.ContactsID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllLeadDetailsByContactIdRow
	for rows.Next() {
		var i GetAllLeadDetailsByContactIdRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.ContactsID,
			&i.LeadSource,
			&i.MediaName,
			&i.LeadType,
			&i.ContactType,
			&i.Languages,
			&i.PropertyCategory,
			&i.IsProperty,
			&i.UnitCategory,
			&i.PropertyTypeID,
			&i.IsLuxury,
			&i.PropertyUnitID,
			&i.PropertyStatusesID,
			&i.PurposeID,
			&i.MinBudget,
			&i.MaxBudget,
			&i.MinArea,
			&i.MaxArea,
			&i.Bedroom,
			&i.Bathroom,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunityID,
			&i.SubcommunityID,
			&i.Lat,
			&i.Lng,
			&i.AssignedTo,
			&i.ResidentialStatus,
			&i.ReferredTo,
			&i.IsExclusive,
			&i.PriorityLevel,
			&i.IsFinance,
			&i.MortgageBankID,
			&i.MortgageStatus,
			&i.RequiredStart,
			&i.RequiredEnd,
			&i.ClosingRemarks,
			&i.InternalNotes,
			&i.CreatedAt,
			&i.LeadsWon,
			&i.WithReference,
			&i.IsPropertyBranch,
			&i.PropertyReferenceName,
			&i.SocialMediaName,
			&i.SectionType,
			&i.ProgressDate,
			&i.ProgressStatus,
			&i.LeadStatus,
			&i.AgentSms,
			&i.AgentMail,
			&i.AgentWhatsapp,
			&i.AgentSystemNotofication,
			&i.LeadSms,
			&i.LeadMail,
			&i.LeadWhatsapp,
			&i.LeadSystemNotification,
			&i.FollowUpEmail,
			&i.ClosedLostEmail,
			&i.ClosedLostSms,
			&i.ClosedLostWhatsapp,
			&i.ClosedWonEmail,
			&i.ClosedWonSms,
			&i.ClosedWonWhatsapp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLeads = `-- name: GetAllLeads :many
SELECT 
    l.id, l.ref_no, l.contacts_id, l.lead_source, l.media_name, l.lead_type, l.contact_type, l.languages, l.property_category, l.is_property, l.unit_category, l.property_type_id, l.is_luxury, l.property_unit_id, l.property_statuses_id, l.purpose_id, l.min_budget, l.max_budget, l.min_area, l.max_area, l.bedroom, l.bathroom, l.countries_id, l.states_id, l.cities_id, l.community_id, l.subcommunity_id, l.lat, l.lng, l.assigned_to, l.residential_status, l.referred_to, l.is_exclusive, l.priority_level, l.is_finance, l.mortgage_bank_id, l.mortgage_status, l.required_start, l.required_end, l.closing_remarks, l.internal_notes, l.created_at, l.leads_won, l.with_reference, l.is_property_branch, l.property_reference_name, l.social_media_name, l.section_type,
    lp.progress_date,
    lp.progress_status,
    lp.lead_status,
    ln.agent_sms,
    ln.agent_mail,
    ln.agent_whatsapp,
    ln.agent_system_notofication,
    ln.lead_sms,
    ln.lead_mail,
    ln.lead_whatsapp,
    ln.lead_system_notification,
    ln.follow_up_email,
    ln.closed_lost_email,
    ln.closed_lost_sms,
    ln.closed_lost_whatsapp,
    ln.closed_won_email,
    ln.closed_won_sms,
    ln.closed_won_whatsapp
FROM 
    leads l
LEFT JOIN 
    leads_progress lp ON l.id = lp.leads_id
LEFT JOIN 
    leads_notification ln ON l.id = ln.leads_id
LIMIT $1 OFFSET $2
`

type GetAllLeadsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllLeadsRow struct {
	ID                      int64              `json:"id"`
	RefNo                   string             `json:"ref_no"`
	ContactsID              int64              `json:"contacts_id"`
	LeadSource              pgtype.Int8        `json:"lead_source"`
	MediaName               pgtype.Int8        `json:"media_name"`
	LeadType                int64              `json:"lead_type"`
	ContactType             int64              `json:"contact_type"`
	Languages               []int64            `json:"languages"`
	PropertyCategory        int64              `json:"property_category"`
	IsProperty              pgtype.Bool        `json:"is_property"`
	UnitCategory            pgtype.Text        `json:"unit_category"`
	PropertyTypeID          pgtype.Int8        `json:"property_type_id"`
	IsLuxury                pgtype.Bool        `json:"is_luxury"`
	PropertyUnitID          pgtype.Int8        `json:"property_unit_id"`
	PropertyStatusesID      pgtype.Int8        `json:"property_statuses_id"`
	PurposeID               pgtype.Int8        `json:"purpose_id"`
	MinBudget               pgtype.Float8      `json:"min_budget"`
	MaxBudget               pgtype.Float8      `json:"max_budget"`
	MinArea                 pgtype.Float8      `json:"min_area"`
	MaxArea                 pgtype.Float8      `json:"max_area"`
	Bedroom                 pgtype.Int8        `json:"bedroom"`
	Bathroom                pgtype.Int8        `json:"bathroom"`
	CountriesID             int64              `json:"countries_id"`
	StatesID                int64              `json:"states_id"`
	CitiesID                int64              `json:"cities_id"`
	CommunityID             []int64            `json:"community_id"`
	SubcommunityID          []int64            `json:"subcommunity_id"`
	Lat                     pgtype.Text        `json:"lat"`
	Lng                     pgtype.Text        `json:"lng"`
	AssignedTo              pgtype.Int8        `json:"assigned_to"`
	ResidentialStatus       pgtype.Int8        `json:"residential_status"`
	ReferredTo              pgtype.Int8        `json:"referred_to"`
	IsExclusive             pgtype.Bool        `json:"is_exclusive"`
	PriorityLevel           pgtype.Int8        `json:"priority_level"`
	IsFinance               pgtype.Bool        `json:"is_finance"`
	MortgageBankID          pgtype.Int8        `json:"mortgage_bank_id"`
	MortgageStatus          pgtype.Int8        `json:"mortgage_status"`
	RequiredStart           pgtype.Timestamptz `json:"required_start"`
	RequiredEnd             pgtype.Timestamptz `json:"required_end"`
	ClosingRemarks          pgtype.Text        `json:"closing_remarks"`
	InternalNotes           pgtype.Text        `json:"internal_notes"`
	CreatedAt               time.Time          `json:"created_at"`
	LeadsWon                pgtype.Bool        `json:"leads_won"`
	WithReference           pgtype.Bool        `json:"with_reference"`
	IsPropertyBranch        pgtype.Bool        `json:"is_property_branch"`
	PropertyReferenceName   pgtype.Text        `json:"property_reference_name"`
	SocialMediaName         pgtype.Text        `json:"social_media_name"`
	SectionType             []int64            `json:"section_type"`
	ProgressDate            pgtype.Timestamptz `json:"progress_date"`
	ProgressStatus          pgtype.Int8        `json:"progress_status"`
	LeadStatus              pgtype.Int8        `json:"lead_status"`
	AgentSms                pgtype.Bool        `json:"agent_sms"`
	AgentMail               pgtype.Bool        `json:"agent_mail"`
	AgentWhatsapp           pgtype.Bool        `json:"agent_whatsapp"`
	AgentSystemNotofication pgtype.Bool        `json:"agent_system_notofication"`
	LeadSms                 pgtype.Bool        `json:"lead_sms"`
	LeadMail                pgtype.Bool        `json:"lead_mail"`
	LeadWhatsapp            pgtype.Bool        `json:"lead_whatsapp"`
	LeadSystemNotification  pgtype.Bool        `json:"lead_system_notification"`
	FollowUpEmail           pgtype.Bool        `json:"follow_up_email"`
	ClosedLostEmail         pgtype.Bool        `json:"closed_lost_email"`
	ClosedLostSms           pgtype.Bool        `json:"closed_lost_sms"`
	ClosedLostWhatsapp      pgtype.Bool        `json:"closed_lost_whatsapp"`
	ClosedWonEmail          pgtype.Bool        `json:"closed_won_email"`
	ClosedWonSms            pgtype.Bool        `json:"closed_won_sms"`
	ClosedWonWhatsapp       pgtype.Bool        `json:"closed_won_whatsapp"`
}

func (q *Queries) GetAllLeads(ctx context.Context, arg GetAllLeadsParams) ([]GetAllLeadsRow, error) {
	rows, err := q.db.Query(ctx, getAllLeads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllLeadsRow
	for rows.Next() {
		var i GetAllLeadsRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.ContactsID,
			&i.LeadSource,
			&i.MediaName,
			&i.LeadType,
			&i.ContactType,
			&i.Languages,
			&i.PropertyCategory,
			&i.IsProperty,
			&i.UnitCategory,
			&i.PropertyTypeID,
			&i.IsLuxury,
			&i.PropertyUnitID,
			&i.PropertyStatusesID,
			&i.PurposeID,
			&i.MinBudget,
			&i.MaxBudget,
			&i.MinArea,
			&i.MaxArea,
			&i.Bedroom,
			&i.Bathroom,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunityID,
			&i.SubcommunityID,
			&i.Lat,
			&i.Lng,
			&i.AssignedTo,
			&i.ResidentialStatus,
			&i.ReferredTo,
			&i.IsExclusive,
			&i.PriorityLevel,
			&i.IsFinance,
			&i.MortgageBankID,
			&i.MortgageStatus,
			&i.RequiredStart,
			&i.RequiredEnd,
			&i.ClosingRemarks,
			&i.InternalNotes,
			&i.CreatedAt,
			&i.LeadsWon,
			&i.WithReference,
			&i.IsPropertyBranch,
			&i.PropertyReferenceName,
			&i.SocialMediaName,
			&i.SectionType,
			&i.ProgressDate,
			&i.ProgressStatus,
			&i.LeadStatus,
			&i.AgentSms,
			&i.AgentMail,
			&i.AgentWhatsapp,
			&i.AgentSystemNotofication,
			&i.LeadSms,
			&i.LeadMail,
			&i.LeadWhatsapp,
			&i.LeadSystemNotification,
			&i.FollowUpEmail,
			&i.ClosedLostEmail,
			&i.ClosedLostSms,
			&i.ClosedLostWhatsapp,
			&i.ClosedWonEmail,
			&i.ClosedWonSms,
			&i.ClosedWonWhatsapp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllLeads = `-- name: GetCountAllLeads :many
SELECT COUNT(*) FROM leads
`

func (q *Queries) GetCountAllLeads(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getCountAllLeads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var count int64
		if err := rows.Scan(&count); err != nil {
			return nil, err
		}
		items = append(items, count)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllLeadsByContactId = `-- name: GetCountAllLeadsByContactId :one
SELECT COUNT(*) FROM leads WHERE contacts_id = $1
`

func (q *Queries) GetCountAllLeadsByContactId(ctx context.Context, contactsID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllLeadsByContactId, contactsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountLeadsByContactId = `-- name: GetCountLeadsByContactId :one
SELECT count(*)
FROM leads
WHERE contacts_id = $1
`

func (q *Queries) GetCountLeadsByContactId(ctx context.Context, contactsID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountLeadsByContactId, contactsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountLeadsBySources = `-- name: GetCountLeadsBySources :one
SELECT count(*)
FROM leads
WHERE lead_source = $1
`

func (q *Queries) GetCountLeadsBySources(ctx context.Context, leadSource pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, getCountLeadsBySources, leadSource)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountLeadsForContacts = `-- name: GetCountLeadsForContacts :one

SELECT
COUNT(*)
FROM
    leads AS lead
INNER JOIN
    contacts AS contact ON lead.contacts_id = contact.id
INNER JOIN
    shareable_contact_details AS scd ON contact.id = scd.contacts_id
LEFT JOIN
    leads_progress AS lp ON lead.id = lp.leads_id Where lead.contacts_id = $1
`

// -- name: GetLeadsForContact :many
// SELECT
//
//		lead.id,
//	    lead.ref_no AS ref_no,
//	    lead.lead_type AS lead_type,
//	    lead.is_property,
//	    lead.property_type_id,
//	    lead.unit_category,
//	    contact.name AS contact_name,
//	    scd.mobile AS contact_mobile,
//	    scd.email AS contact_email,
//	    lp.lead_status AS lead_status,
//	    lp.progress_status AS progress_status
//
// FROM
//
//	leads AS lead
//
// INNER JOIN
//
//	contacts AS contact ON lead.contacts_id = contact.id
//
// INNER JOIN
//
//	shareable_contact_details AS scd ON contact.id = scd.contacts_id
//
// LEFT JOIN
//
//	leads_progress AS lp ON lead.id = lp.leads_id WHERE lead.contacts_id = $1 ORDER BY lp.id desc LIMIT $2 OFFSET $3;
func (q *Queries) GetCountLeadsForContacts(ctx context.Context, contactsID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountLeadsForContacts, contactsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountLeadsForManage = `-- name: GetCountLeadsForManage :one

SELECT
COUNT(*)
FROM
    leads AS lead
INNER JOIN
    contacts AS contact ON lead.contacts_id = contact.id
INNER JOIN
    shareable_contact_details AS scd ON contact.id = scd.contacts_id
LEFT JOIN
    leads_progress AS lp ON lead.id = lp.leads_id
`

// -- name: GetLeadsForManage :many
// SELECT
//
//		lead.id,
//	    lead.ref_no AS ref_no,
//	    lead.lead_type AS lead_type,
//	    lead.is_property,
//	    lead.property_type_id,
//	    lead.unit_category,
//	    lead.section_type,
//	    contact.name AS contact_name,
//	    scd.mobile AS contact_mobile,
//	    scd.email AS contact_email,
//	    lp.lead_status AS lead_status,
//	    lp.progress_status AS progress_status
//
// FROM
//
//	leads AS lead
//
// INNER JOIN
//
//	contacts AS contact ON lead.contacts_id = contact.id
//
// INNER JOIN
//
//	shareable_contact_details AS scd ON contact.id = scd.contacts_id
//
// LEFT JOIN
//
//	leads_progress AS lp ON lead.id = lp.leads_id ORDER BY lp.id desc LIMIT $1 OFFSET $2;
func (q *Queries) GetCountLeadsForManage(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountLeadsForManage)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLeadById = `-- name: GetLeadById :one
SELECT l.id, l.ref_no, l.contacts_id, l.lead_source, l.media_name, l.lead_type, l.contact_type, l.languages, l.property_category, l.is_property, l.unit_category, l.property_type_id, l.is_luxury, l.property_unit_id, l.property_statuses_id, l.purpose_id, l.min_budget, l.max_budget, l.min_area, l.max_area, l.bedroom, l.bathroom, l.countries_id, l.states_id, l.cities_id, l.community_id, l.subcommunity_id, l.lat, l.lng, l.assigned_to, l.residential_status, l.referred_to, l.is_exclusive, l.priority_level, l.is_finance, l.mortgage_bank_id, l.mortgage_status, l.required_start, l.required_end, l.closing_remarks, l.internal_notes, l.created_at, l.leads_won, l.with_reference, l.is_property_branch, l.property_reference_name, l.social_media_name, l.section_type, c.country, ci.city, s."state",  COALESCE(communities_names, '{}') AS communities_names, 
COALESCE(sub_communities_names, '{}') AS sub_communities_names
FROM leads l
left join countries c on l.countries_id = c.id
left join cities ci on l.cities_id = ci.id
left join states s on l.states_id = s.id
    LEFT JOIN LATERAL (
        SELECT array_agg(com.community)::varchar[] AS communities_names
        FROM unnest(l.community_id) AS community_id
        JOIN communities com ON community_id = com.id
    ) AS communities_names ON TRUE
    LEFT JOIN LATERAL (
        SELECT array_agg(scom.sub_community)::varchar[] AS sub_communities_names
        FROM unnest(l.subcommunity_id) AS sub_community_id
        JOIN sub_communities scom ON sub_community_id = scom.id
    ) AS sub_communities_names ON TRUE
WHERE l.id = $1
`

type GetLeadByIdRow struct {
	ID                    int64              `json:"id"`
	RefNo                 string             `json:"ref_no"`
	ContactsID            int64              `json:"contacts_id"`
	LeadSource            pgtype.Int8        `json:"lead_source"`
	MediaName             pgtype.Int8        `json:"media_name"`
	LeadType              int64              `json:"lead_type"`
	ContactType           int64              `json:"contact_type"`
	Languages             []int64            `json:"languages"`
	PropertyCategory      int64              `json:"property_category"`
	IsProperty            pgtype.Bool        `json:"is_property"`
	UnitCategory          pgtype.Text        `json:"unit_category"`
	PropertyTypeID        pgtype.Int8        `json:"property_type_id"`
	IsLuxury              pgtype.Bool        `json:"is_luxury"`
	PropertyUnitID        pgtype.Int8        `json:"property_unit_id"`
	PropertyStatusesID    pgtype.Int8        `json:"property_statuses_id"`
	PurposeID             pgtype.Int8        `json:"purpose_id"`
	MinBudget             pgtype.Float8      `json:"min_budget"`
	MaxBudget             pgtype.Float8      `json:"max_budget"`
	MinArea               pgtype.Float8      `json:"min_area"`
	MaxArea               pgtype.Float8      `json:"max_area"`
	Bedroom               pgtype.Int8        `json:"bedroom"`
	Bathroom              pgtype.Int8        `json:"bathroom"`
	CountriesID           int64              `json:"countries_id"`
	StatesID              int64              `json:"states_id"`
	CitiesID              int64              `json:"cities_id"`
	CommunityID           []int64            `json:"community_id"`
	SubcommunityID        []int64            `json:"subcommunity_id"`
	Lat                   pgtype.Text        `json:"lat"`
	Lng                   pgtype.Text        `json:"lng"`
	AssignedTo            pgtype.Int8        `json:"assigned_to"`
	ResidentialStatus     pgtype.Int8        `json:"residential_status"`
	ReferredTo            pgtype.Int8        `json:"referred_to"`
	IsExclusive           pgtype.Bool        `json:"is_exclusive"`
	PriorityLevel         pgtype.Int8        `json:"priority_level"`
	IsFinance             pgtype.Bool        `json:"is_finance"`
	MortgageBankID        pgtype.Int8        `json:"mortgage_bank_id"`
	MortgageStatus        pgtype.Int8        `json:"mortgage_status"`
	RequiredStart         pgtype.Timestamptz `json:"required_start"`
	RequiredEnd           pgtype.Timestamptz `json:"required_end"`
	ClosingRemarks        pgtype.Text        `json:"closing_remarks"`
	InternalNotes         pgtype.Text        `json:"internal_notes"`
	CreatedAt             time.Time          `json:"created_at"`
	LeadsWon              pgtype.Bool        `json:"leads_won"`
	WithReference         pgtype.Bool        `json:"with_reference"`
	IsPropertyBranch      pgtype.Bool        `json:"is_property_branch"`
	PropertyReferenceName pgtype.Text        `json:"property_reference_name"`
	SocialMediaName       pgtype.Text        `json:"social_media_name"`
	SectionType           []int64            `json:"section_type"`
	Country               pgtype.Text        `json:"country"`
	City                  pgtype.Text        `json:"city"`
	State                 pgtype.Text        `json:"state"`
	CommunitiesNames      []string           `json:"communities_names"`
	SubCommunitiesNames   []string           `json:"sub_communities_names"`
}

func (q *Queries) GetLeadById(ctx context.Context, id int64) (GetLeadByIdRow, error) {
	row := q.db.QueryRow(ctx, getLeadById, id)
	var i GetLeadByIdRow
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
		&i.Country,
		&i.City,
		&i.State,
		&i.CommunitiesNames,
		&i.SubCommunitiesNames,
	)
	return i, err
}

const getLeadByRefNo = `-- name: GetLeadByRefNo :one
SELECT id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type FROM leads WHERE ref_no = $1 and contacts_id = $2 LIMIT 1
`

type GetLeadByRefNoParams struct {
	RefNo      string `json:"ref_no"`
	ContactsID int64  `json:"contacts_id"`
}

func (q *Queries) GetLeadByRefNo(ctx context.Context, arg GetLeadByRefNoParams) (Lead, error) {
	row := q.db.QueryRow(ctx, getLeadByRefNo, arg.RefNo, arg.ContactsID)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
	)
	return i, err
}

const getLeadDetailsById = `-- name: GetLeadDetailsById :one
SELECT 
    l.id, l.ref_no, l.contacts_id, l.lead_source, l.media_name, l.lead_type, l.contact_type, l.languages, l.property_category, l.is_property, l.unit_category, l.property_type_id, l.is_luxury, l.property_unit_id, l.property_statuses_id, l.purpose_id, l.min_budget, l.max_budget, l.min_area, l.max_area, l.bedroom, l.bathroom, l.countries_id, l.states_id, l.cities_id, l.community_id, l.subcommunity_id, l.lat, l.lng, l.assigned_to, l.residential_status, l.referred_to, l.is_exclusive, l.priority_level, l.is_finance, l.mortgage_bank_id, l.mortgage_status, l.required_start, l.required_end, l.closing_remarks, l.internal_notes, l.created_at, l.leads_won, l.with_reference, l.is_property_branch, l.property_reference_name, l.social_media_name, l.section_type,
    lp.progress_date,
    lp.progress_status,
    lp.lead_status,
    ln.agent_sms,
    ln.agent_mail,
    ln.agent_whatsapp,
    ln.agent_system_notofication,
    ln.lead_sms,
    ln.lead_mail,
    ln.lead_whatsapp,
    ln.lead_system_notification,
    ln.follow_up_email,
    ln.closed_lost_email,
    ln.closed_lost_sms,
    ln.closed_lost_whatsapp,
    ln.closed_won_email,
    ln.closed_won_sms,
    ln.closed_won_whatsapp
FROM 
    leads l
LEFT JOIN 
    leads_progress lp ON l.id = lp.leads_id
LEFT JOIN 
    leads_notification ln ON l.id = ln.leads_id
WHERE 
    l.id = $1 LIMIT 1
`

type GetLeadDetailsByIdRow struct {
	ID                      int64              `json:"id"`
	RefNo                   string             `json:"ref_no"`
	ContactsID              int64              `json:"contacts_id"`
	LeadSource              pgtype.Int8        `json:"lead_source"`
	MediaName               pgtype.Int8        `json:"media_name"`
	LeadType                int64              `json:"lead_type"`
	ContactType             int64              `json:"contact_type"`
	Languages               []int64            `json:"languages"`
	PropertyCategory        int64              `json:"property_category"`
	IsProperty              pgtype.Bool        `json:"is_property"`
	UnitCategory            pgtype.Text        `json:"unit_category"`
	PropertyTypeID          pgtype.Int8        `json:"property_type_id"`
	IsLuxury                pgtype.Bool        `json:"is_luxury"`
	PropertyUnitID          pgtype.Int8        `json:"property_unit_id"`
	PropertyStatusesID      pgtype.Int8        `json:"property_statuses_id"`
	PurposeID               pgtype.Int8        `json:"purpose_id"`
	MinBudget               pgtype.Float8      `json:"min_budget"`
	MaxBudget               pgtype.Float8      `json:"max_budget"`
	MinArea                 pgtype.Float8      `json:"min_area"`
	MaxArea                 pgtype.Float8      `json:"max_area"`
	Bedroom                 pgtype.Int8        `json:"bedroom"`
	Bathroom                pgtype.Int8        `json:"bathroom"`
	CountriesID             int64              `json:"countries_id"`
	StatesID                int64              `json:"states_id"`
	CitiesID                int64              `json:"cities_id"`
	CommunityID             []int64            `json:"community_id"`
	SubcommunityID          []int64            `json:"subcommunity_id"`
	Lat                     pgtype.Text        `json:"lat"`
	Lng                     pgtype.Text        `json:"lng"`
	AssignedTo              pgtype.Int8        `json:"assigned_to"`
	ResidentialStatus       pgtype.Int8        `json:"residential_status"`
	ReferredTo              pgtype.Int8        `json:"referred_to"`
	IsExclusive             pgtype.Bool        `json:"is_exclusive"`
	PriorityLevel           pgtype.Int8        `json:"priority_level"`
	IsFinance               pgtype.Bool        `json:"is_finance"`
	MortgageBankID          pgtype.Int8        `json:"mortgage_bank_id"`
	MortgageStatus          pgtype.Int8        `json:"mortgage_status"`
	RequiredStart           pgtype.Timestamptz `json:"required_start"`
	RequiredEnd             pgtype.Timestamptz `json:"required_end"`
	ClosingRemarks          pgtype.Text        `json:"closing_remarks"`
	InternalNotes           pgtype.Text        `json:"internal_notes"`
	CreatedAt               time.Time          `json:"created_at"`
	LeadsWon                pgtype.Bool        `json:"leads_won"`
	WithReference           pgtype.Bool        `json:"with_reference"`
	IsPropertyBranch        pgtype.Bool        `json:"is_property_branch"`
	PropertyReferenceName   pgtype.Text        `json:"property_reference_name"`
	SocialMediaName         pgtype.Text        `json:"social_media_name"`
	SectionType             []int64            `json:"section_type"`
	ProgressDate            pgtype.Timestamptz `json:"progress_date"`
	ProgressStatus          pgtype.Int8        `json:"progress_status"`
	LeadStatus              pgtype.Int8        `json:"lead_status"`
	AgentSms                pgtype.Bool        `json:"agent_sms"`
	AgentMail               pgtype.Bool        `json:"agent_mail"`
	AgentWhatsapp           pgtype.Bool        `json:"agent_whatsapp"`
	AgentSystemNotofication pgtype.Bool        `json:"agent_system_notofication"`
	LeadSms                 pgtype.Bool        `json:"lead_sms"`
	LeadMail                pgtype.Bool        `json:"lead_mail"`
	LeadWhatsapp            pgtype.Bool        `json:"lead_whatsapp"`
	LeadSystemNotification  pgtype.Bool        `json:"lead_system_notification"`
	FollowUpEmail           pgtype.Bool        `json:"follow_up_email"`
	ClosedLostEmail         pgtype.Bool        `json:"closed_lost_email"`
	ClosedLostSms           pgtype.Bool        `json:"closed_lost_sms"`
	ClosedLostWhatsapp      pgtype.Bool        `json:"closed_lost_whatsapp"`
	ClosedWonEmail          pgtype.Bool        `json:"closed_won_email"`
	ClosedWonSms            pgtype.Bool        `json:"closed_won_sms"`
	ClosedWonWhatsapp       pgtype.Bool        `json:"closed_won_whatsapp"`
}

func (q *Queries) GetLeadDetailsById(ctx context.Context, id int64) (GetLeadDetailsByIdRow, error) {
	row := q.db.QueryRow(ctx, getLeadDetailsById, id)
	var i GetLeadDetailsByIdRow
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
		&i.ProgressDate,
		&i.ProgressStatus,
		&i.LeadStatus,
		&i.AgentSms,
		&i.AgentMail,
		&i.AgentWhatsapp,
		&i.AgentSystemNotofication,
		&i.LeadSms,
		&i.LeadMail,
		&i.LeadWhatsapp,
		&i.LeadSystemNotification,
		&i.FollowUpEmail,
		&i.ClosedLostEmail,
		&i.ClosedLostSms,
		&i.ClosedLostWhatsapp,
		&i.ClosedWonEmail,
		&i.ClosedWonSms,
		&i.ClosedWonWhatsapp,
	)
	return i, err
}

const getLeadStatisticsByLeadType = `-- name: GetLeadStatisticsByLeadType :many
SELECT lead_type, COUNT(*) FROM leads GROUP BY lead_type ORDER BY lead_type
`

type GetLeadStatisticsByLeadTypeRow struct {
	LeadType int64 `json:"lead_type"`
	Count    int64 `json:"count"`
}

func (q *Queries) GetLeadStatisticsByLeadType(ctx context.Context) ([]GetLeadStatisticsByLeadTypeRow, error) {
	rows, err := q.db.Query(ctx, getLeadStatisticsByLeadType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeadStatisticsByLeadTypeRow
	for rows.Next() {
		var i GetLeadStatisticsByLeadTypeRow
		if err := rows.Scan(&i.LeadType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeadsByCityAndLeadTypeFilter = `-- name: GetLeadsByCityAndLeadTypeFilter :many
SELECT city,
  SUM(CASE WHEN lead_type = 1 THEN cnt ELSE 0 END) AS sale,
  SUM(CASE WHEN lead_type = 2 THEN cnt ELSE 0 END) AS rent,
  SUM(CASE WHEN lead_type = 3 THEN cnt ELSE 0 END) AS exchange
FROM (
  SELECT c.city, l.lead_type, COUNT(*) AS cnt
  FROM leads l JOIN cities c on l.cities_id = c.id
  WHERE required_start >= $1 AND required_end <= $2 AND l.assigned_to = $3 AND contacts_id IN (SELECT cu.users_id FROM company_users cu JOIN contacts c ON cu.users_id = c.users_id WHERE cu.company_id = $4 
    ) GROUP BY c.city, l.lead_type
) AS grouped_data
GROUP BY city
`

type GetLeadsByCityAndLeadTypeFilterParams struct {
	RequiredStart pgtype.Timestamptz `json:"required_start"`
	RequiredEnd   pgtype.Timestamptz `json:"required_end"`
	AssignedTo    pgtype.Int8        `json:"assigned_to"`
	CompanyID     int64              `json:"company_id"`
}

type GetLeadsByCityAndLeadTypeFilterRow struct {
	City     string `json:"city"`
	Sale     int64  `json:"sale"`
	Rent     int64  `json:"rent"`
	Exchange int64  `json:"exchange"`
}

// AND
//
//	cu.company_type = $5
//	 AND cu.is_branch = $6
func (q *Queries) GetLeadsByCityAndLeadTypeFilter(ctx context.Context, arg GetLeadsByCityAndLeadTypeFilterParams) ([]GetLeadsByCityAndLeadTypeFilterRow, error) {
	rows, err := q.db.Query(ctx, getLeadsByCityAndLeadTypeFilter,
		arg.RequiredStart,
		arg.RequiredEnd,
		arg.AssignedTo,
		arg.CompanyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeadsByCityAndLeadTypeFilterRow
	for rows.Next() {
		var i GetLeadsByCityAndLeadTypeFilterRow
		if err := rows.Scan(
			&i.City,
			&i.Sale,
			&i.Rent,
			&i.Exchange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeadsByContactIdWithPagination = `-- name: GetLeadsByContactIdWithPagination :many
SELECT id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type
FROM leads
WHERE contacts_id = $1
ORDER BY id
OFFSET $2
LIMIT $3
`

type GetLeadsByContactIdWithPaginationParams struct {
	ContactsID int64 `json:"contacts_id"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) GetLeadsByContactIdWithPagination(ctx context.Context, arg GetLeadsByContactIdWithPaginationParams) ([]Lead, error) {
	rows, err := q.db.Query(ctx, getLeadsByContactIdWithPagination, arg.ContactsID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lead
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.ContactsID,
			&i.LeadSource,
			&i.MediaName,
			&i.LeadType,
			&i.ContactType,
			&i.Languages,
			&i.PropertyCategory,
			&i.IsProperty,
			&i.UnitCategory,
			&i.PropertyTypeID,
			&i.IsLuxury,
			&i.PropertyUnitID,
			&i.PropertyStatusesID,
			&i.PurposeID,
			&i.MinBudget,
			&i.MaxBudget,
			&i.MinArea,
			&i.MaxArea,
			&i.Bedroom,
			&i.Bathroom,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunityID,
			&i.SubcommunityID,
			&i.Lat,
			&i.Lng,
			&i.AssignedTo,
			&i.ResidentialStatus,
			&i.ReferredTo,
			&i.IsExclusive,
			&i.PriorityLevel,
			&i.IsFinance,
			&i.MortgageBankID,
			&i.MortgageStatus,
			&i.RequiredStart,
			&i.RequiredEnd,
			&i.ClosingRemarks,
			&i.InternalNotes,
			&i.CreatedAt,
			&i.LeadsWon,
			&i.WithReference,
			&i.IsPropertyBranch,
			&i.PropertyReferenceName,
			&i.SocialMediaName,
			&i.SectionType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeadsBySources = `-- name: GetLeadsBySources :many
SELECT l.id, l.ref_no, l.created_at, l.internal_notes,
CASE WHEN lp.lead_status = 1 THEN 'Open' WHEN lp.lead_status = 2 THEN 'Close' ELSE null END AS "status",
CASE WHEN lp.progress_status = 1 THEN 'In Progress' WHEN lp.lead_status = 2 THEN 'Not yet connected'
WHEN lp.lead_status = 3 THEN 'Called but no reply' WHEN lp.lead_status = 4 THEN 'Follow-up'
WHEN lp.lead_status = 2 THEN 'Awaiting Finance Approval' WHEN lp.lead_status = 2 THEN 'Change Travel Plans'
ELSE null END AS "progress status",
  CASE WHEN l.lead_source = 1 THEN (SELECT COUNT(*) FROM leads_properties WHERE leads_properties.leads_id = l.id) ELSE NULL END AS "count",
  CASE WHEN l.lead_source != 1 THEN ' - ' ELSE NULL END AS "message",
  CASE WHEN l.lead_source = 3 THEN ' - ' ELSE NULL END AS "inquiry"
FROM leads l
LEFT JOIN leads_progress lp ON l.id = lp.leads_id WHERE l.lead_source = $1 LIMIT $2 OFFSET $3
`

type GetLeadsBySourcesParams struct {
	LeadSource pgtype.Int8 `json:"lead_source"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetLeadsBySourcesRow struct {
	ID             int64       `json:"id"`
	RefNo          string      `json:"ref_no"`
	CreatedAt      time.Time   `json:"created_at"`
	InternalNotes  pgtype.Text `json:"internal_notes"`
	Status         interface{} `json:"status"`
	ProgressStatus interface{} `json:"progress status"`
	Count          interface{} `json:"count"`
	Message        interface{} `json:"message"`
	Inquiry        interface{} `json:"inquiry"`
}

func (q *Queries) GetLeadsBySources(ctx context.Context, arg GetLeadsBySourcesParams) ([]GetLeadsBySourcesRow, error) {
	rows, err := q.db.Query(ctx, getLeadsBySources, arg.LeadSource, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeadsBySourcesRow
	for rows.Next() {
		var i GetLeadsBySourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CreatedAt,
			&i.InternalNotes,
			&i.Status,
			&i.ProgressStatus,
			&i.Count,
			&i.Message,
			&i.Inquiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeadsBySourcesFilter = `-- name: GetLeadsBySourcesFilter :many


SELECT city,
  SUM(CASE WHEN lead_type = 1 THEN cnt ELSE 0 END) AS sale,
  SUM(CASE WHEN lead_type = 2 THEN cnt ELSE 0 END) AS rent,
  SUM(CASE WHEN lead_type = 3 THEN cnt ELSE 0 END) AS exchange
FROM (
  SELECT c.city, l.lead_type, COUNT(*) AS cnt
  FROM leads l JOIN cities c on l.cities_id = c.id
  GROUP BY c.city, l.lead_type
) AS grouped_data
GROUP BY city
`

type GetLeadsBySourcesFilterRow struct {
	City     string `json:"city"`
	Sale     int64  `json:"sale"`
	Rent     int64  `json:"rent"`
	Exchange int64  `json:"exchange"`
}

// SELECT l.id, l.ref_no, l.created_at, l.internal_notes,
// CASE WHEN lp.lead_status = 1 THEN 'Open' WHEN lp.lead_status = 2 THEN 'Close' ELSE null END AS "status",
// CASE WHEN lp.progress_status = 1 THEN 'In Progress' WHEN lp.lead_status = 2 THEN 'Not yet connected'
// WHEN lp.lead_status = 3 THEN 'Called but no reply' WHEN lp.lead_status = 4 THEN 'Follow-up'
// WHEN lp.lead_status = 2 THEN 'Awaiting Finance Approval' WHEN lp.lead_status = 2 THEN 'Change Travel Plans'
// ELSE null END AS "progress status",
//
//	CASE WHEN l.lead_source = 1 THEN (SELECT COUNT(*) FROM leads_properties WHERE leads_properties.leads_id = l.id) ELSE NULL END AS "count",
//	CASE WHEN l.lead_source != 1 THEN ' - ' ELSE NULL END AS "message",
//	CASE WHEN l.lead_source = 3 THEN ' - ' ELSE NULL END AS "inquiry"
//
// FROM leads l
// LEFT JOIN leads_progress lp ON l.id = lp.leads_id WHERE l.lead_source = $1 AND l.required_start >= $2 AND l.required_end <= $3 AND l.assigned_to = $4 AND l.contacts_id IN (SELECT cu.users_id FROM company_users cu JOIN contacts c ON cu.users_id = c.users_id WHERE cu.company_id = $5 AND cu.company_type = $6 AND cu.is_branch = $7) AND l.lead_type = $8 LIMIT $9 OFFSET $10
// ;
// SELECT count(*)
// FROM leads
// WHERE lead_source = $1 AND required_start >= $2 AND required_end <= $3 AND leads.assigned_to = $4 AND contacts_id IN (SELECT cu.users_id FROM company_users cu JOIN contacts c ON cu.users_id = c.users_id WHERE cu.company_id = $5
// --  AND cu.company_type = $6 AND cu.is_branch = $7
//
//	) AND lead_type = $8 ;
func (q *Queries) GetLeadsBySourcesFilter(ctx context.Context) ([]GetLeadsBySourcesFilterRow, error) {
	rows, err := q.db.Query(ctx, getLeadsBySourcesFilter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeadsBySourcesFilterRow
	for rows.Next() {
		var i GetLeadsBySourcesFilterRow
		if err := rows.Scan(
			&i.City,
			&i.Sale,
			&i.Rent,
			&i.Exchange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeadsIdAndRefNo = `-- name: GetLeadsIdAndRefNo :many
SELECT id, ref_no FROM leads WHERE contacts_id = $1
`

type GetLeadsIdAndRefNoRow struct {
	ID    int64  `json:"id"`
	RefNo string `json:"ref_no"`
}

func (q *Queries) GetLeadsIdAndRefNo(ctx context.Context, contactsID int64) ([]GetLeadsIdAndRefNoRow, error) {
	rows, err := q.db.Query(ctx, getLeadsIdAndRefNo, contactsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeadsIdAndRefNoRow
	for rows.Next() {
		var i GetLeadsIdAndRefNoRow
		if err := rows.Scan(&i.ID, &i.RefNo); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionTypes = `-- name: GetSectionTypes :many
SELECT id, type FROM property_types WHERE id = ANY($1::bigint[])
`

type GetSectionTypesRow struct {
	ID   int64  `json:"id"`
	Type string `json:"type"`
}

func (q *Queries) GetSectionTypes(ctx context.Context, dollar_1 []int64) ([]GetSectionTypesRow, error) {
	rows, err := q.db.Query(ctx, getSectionTypes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSectionTypesRow
	for rows.Next() {
		var i GetSectionTypesRow
		if err := rows.Scan(&i.ID, &i.Type); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleLead = `-- name: GetSingleLead :one
SELECT id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type FROM leads WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSingleLead(ctx context.Context, id int64) (Lead, error) {
	row := q.db.QueryRow(ctx, getSingleLead, id)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
	)
	return i, err
}

const updateLead = `-- name: UpdateLead :one

UPDATE leads
SET lead_source = $2,
    media_name = $3,
    lead_type = $4,
    contact_type = $5,
    property_category = $6,
    is_property = $7,
    unit_category = $8,
    property_type_id = $9,
    is_luxury = $10,
    property_unit_id = $11,
    property_statuses_id = $12,
    purpose_id = $13,
    min_budget = $14,
    max_budget = $15,
    min_area = $16,
    max_area = $17,
    bedroom = $18,
    bathroom = $19,
    countries_id = $20,
    states_id = $21,
    cities_id = $22,
    community_id = $23,
    subcommunity_id = $24,
    lat = $25,
    lng = $26,
    assigned_to = $27,
    residential_status = $28,
    referred_to = $29,
    is_exclusive = $30,
    priority_level = $31,
    is_finance = $32,
    mortgage_bank_id = $33,
    mortgage_status = $34,
    required_start = $35,
    required_end = $36,
    closing_remarks = $37,
    internal_notes = $38,
    with_reference = $39,
    is_property_branch = $40,
    property_reference_name = $41,
    social_media_name = $42,
    section_type = $43
WHERE id = $1
RETURNING id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type
`

type UpdateLeadParams struct {
	ID                    int64              `json:"id"`
	LeadSource            pgtype.Int8        `json:"lead_source"`
	MediaName             pgtype.Int8        `json:"media_name"`
	LeadType              int64              `json:"lead_type"`
	ContactType           int64              `json:"contact_type"`
	PropertyCategory      int64              `json:"property_category"`
	IsProperty            pgtype.Bool        `json:"is_property"`
	UnitCategory          pgtype.Text        `json:"unit_category"`
	PropertyTypeID        pgtype.Int8        `json:"property_type_id"`
	IsLuxury              pgtype.Bool        `json:"is_luxury"`
	PropertyUnitID        pgtype.Int8        `json:"property_unit_id"`
	PropertyStatusesID    pgtype.Int8        `json:"property_statuses_id"`
	PurposeID             pgtype.Int8        `json:"purpose_id"`
	MinBudget             pgtype.Float8      `json:"min_budget"`
	MaxBudget             pgtype.Float8      `json:"max_budget"`
	MinArea               pgtype.Float8      `json:"min_area"`
	MaxArea               pgtype.Float8      `json:"max_area"`
	Bedroom               pgtype.Int8        `json:"bedroom"`
	Bathroom              pgtype.Int8        `json:"bathroom"`
	CountriesID           int64              `json:"countries_id"`
	StatesID              int64              `json:"states_id"`
	CitiesID              int64              `json:"cities_id"`
	CommunityID           []int64            `json:"community_id"`
	SubcommunityID        []int64            `json:"subcommunity_id"`
	Lat                   pgtype.Text        `json:"lat"`
	Lng                   pgtype.Text        `json:"lng"`
	AssignedTo            pgtype.Int8        `json:"assigned_to"`
	ResidentialStatus     pgtype.Int8        `json:"residential_status"`
	ReferredTo            pgtype.Int8        `json:"referred_to"`
	IsExclusive           pgtype.Bool        `json:"is_exclusive"`
	PriorityLevel         pgtype.Int8        `json:"priority_level"`
	IsFinance             pgtype.Bool        `json:"is_finance"`
	MortgageBankID        pgtype.Int8        `json:"mortgage_bank_id"`
	MortgageStatus        pgtype.Int8        `json:"mortgage_status"`
	RequiredStart         pgtype.Timestamptz `json:"required_start"`
	RequiredEnd           pgtype.Timestamptz `json:"required_end"`
	ClosingRemarks        pgtype.Text        `json:"closing_remarks"`
	InternalNotes         pgtype.Text        `json:"internal_notes"`
	WithReference         pgtype.Bool        `json:"with_reference"`
	IsPropertyBranch      pgtype.Bool        `json:"is_property_branch"`
	PropertyReferenceName pgtype.Text        `json:"property_reference_name"`
	SocialMediaName       pgtype.Text        `json:"social_media_name"`
	SectionType           []int64            `json:"section_type"`
}

// -- name: GetLeadsByContactIdWithoutPagination :many
// SELECT
//
//		lead.id,
//	    lead.ref_no AS ref_no,
//	    lead.lead_type AS lead_type,
//	    lead.is_property,
//	    lead.property_type_id,
//	    lead.unit_category,
//	    contact.name AS contact_name,
//	    scd.mobile AS contact_mobile,
//	    scd.email AS contact_email,
//	    lp.lead_status AS lead_status,
//	    lp.progress_status AS progress_status
//
// FROM
//
//	leads AS lead
//
// INNER JOIN
//
//	contacts AS contact ON lead.contacts_id = contact.id
//
// INNER JOIN
//
//	shareable_contact_details AS scd ON contact.id = scd.contacts_id
//
// LEFT JOIN
//
//	leads_progress AS lp ON lead.id = lp.leads_id WHERE lead.contacts_id = $1 ORDER BY lp.id desc;
func (q *Queries) UpdateLead(ctx context.Context, arg UpdateLeadParams) (Lead, error) {
	row := q.db.QueryRow(ctx, updateLead,
		arg.ID,
		arg.LeadSource,
		arg.MediaName,
		arg.LeadType,
		arg.ContactType,
		arg.PropertyCategory,
		arg.IsProperty,
		arg.UnitCategory,
		arg.PropertyTypeID,
		arg.IsLuxury,
		arg.PropertyUnitID,
		arg.PropertyStatusesID,
		arg.PurposeID,
		arg.MinBudget,
		arg.MaxBudget,
		arg.MinArea,
		arg.MaxArea,
		arg.Bedroom,
		arg.Bathroom,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.CommunityID,
		arg.SubcommunityID,
		arg.Lat,
		arg.Lng,
		arg.AssignedTo,
		arg.ResidentialStatus,
		arg.ReferredTo,
		arg.IsExclusive,
		arg.PriorityLevel,
		arg.IsFinance,
		arg.MortgageBankID,
		arg.MortgageStatus,
		arg.RequiredStart,
		arg.RequiredEnd,
		arg.ClosingRemarks,
		arg.InternalNotes,
		arg.WithReference,
		arg.IsPropertyBranch,
		arg.PropertyReferenceName,
		arg.SocialMediaName,
		arg.SectionType,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
	)
	return i, err
}

const updateLeadDetails = `-- name: UpdateLeadDetails :one
UPDATE leads
SET
    lead_type = $2,
    contact_type = $3,
    languages = $4,
    property_category = $5,
    is_property = $6,
    property_unit_id = $7,
    unit_category = $8,
    property_type_id = $9,
    property_statuses_id = $10,
    purpose_id = $11,
    min_budget = $12,
    max_budget = $13,
    min_area = $14,
    max_area = $15,
    bedroom = $16,
    bathroom = $17,
    countries_id = $18,
    states_id = $19,
    cities_id = $20,
    community_id = $21,
    subcommunity_id = $22,
    lat = $23,
    lng = $24,
    is_luxury = $25,
    mortgage_status = $26
WHERE
    id = $1
RETURNING id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type
`

type UpdateLeadDetailsParams struct {
	ID                 int64         `json:"id"`
	LeadType           int64         `json:"lead_type"`
	ContactType        int64         `json:"contact_type"`
	Languages          []int64       `json:"languages"`
	PropertyCategory   int64         `json:"property_category"`
	IsProperty         pgtype.Bool   `json:"is_property"`
	PropertyUnitID     pgtype.Int8   `json:"property_unit_id"`
	UnitCategory       pgtype.Text   `json:"unit_category"`
	PropertyTypeID     pgtype.Int8   `json:"property_type_id"`
	PropertyStatusesID pgtype.Int8   `json:"property_statuses_id"`
	PurposeID          pgtype.Int8   `json:"purpose_id"`
	MinBudget          pgtype.Float8 `json:"min_budget"`
	MaxBudget          pgtype.Float8 `json:"max_budget"`
	MinArea            pgtype.Float8 `json:"min_area"`
	MaxArea            pgtype.Float8 `json:"max_area"`
	Bedroom            pgtype.Int8   `json:"bedroom"`
	Bathroom           pgtype.Int8   `json:"bathroom"`
	CountriesID        int64         `json:"countries_id"`
	StatesID           int64         `json:"states_id"`
	CitiesID           int64         `json:"cities_id"`
	CommunityID        []int64       `json:"community_id"`
	SubcommunityID     []int64       `json:"subcommunity_id"`
	Lat                pgtype.Text   `json:"lat"`
	Lng                pgtype.Text   `json:"lng"`
	IsLuxury           pgtype.Bool   `json:"is_luxury"`
	MortgageStatus     pgtype.Int8   `json:"mortgage_status"`
}

func (q *Queries) UpdateLeadDetails(ctx context.Context, arg UpdateLeadDetailsParams) (Lead, error) {
	row := q.db.QueryRow(ctx, updateLeadDetails,
		arg.ID,
		arg.LeadType,
		arg.ContactType,
		arg.Languages,
		arg.PropertyCategory,
		arg.IsProperty,
		arg.PropertyUnitID,
		arg.UnitCategory,
		arg.PropertyTypeID,
		arg.PropertyStatusesID,
		arg.PurposeID,
		arg.MinBudget,
		arg.MaxBudget,
		arg.MinArea,
		arg.MaxArea,
		arg.Bedroom,
		arg.Bathroom,
		arg.CountriesID,
		arg.StatesID,
		arg.CitiesID,
		arg.CommunityID,
		arg.SubcommunityID,
		arg.Lat,
		arg.Lng,
		arg.IsLuxury,
		arg.MortgageStatus,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
	)
	return i, err
}

const updateLeadInternalNotes = `-- name: UpdateLeadInternalNotes :one
UPDATE leads
SET internal_notes = $2
WHERE id = $1
RETURNING id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type
`

type UpdateLeadInternalNotesParams struct {
	ID            int64       `json:"id"`
	InternalNotes pgtype.Text `json:"internal_notes"`
}

func (q *Queries) UpdateLeadInternalNotes(ctx context.Context, arg UpdateLeadInternalNotesParams) (Lead, error) {
	row := q.db.QueryRow(ctx, updateLeadInternalNotes, arg.ID, arg.InternalNotes)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
	)
	return i, err
}

const updateLeadReferenceDetails = `-- name: UpdateLeadReferenceDetails :one
UPDATE leads
SET
    lead_source = $2,
    media_name = $3,
    is_exclusive = $4,
    assigned_to = $5,
    residential_status = $6,
    referred_to = $7,
    priority_level = $8,
    is_finance = $9,
    mortgage_status = $10,
    required_start = $11,
    required_end = $12,
    closing_remarks = $13,
    mortgage_bank_id = $14
WHERE
    id = $1
RETURNING id, ref_no, contacts_id, lead_source, media_name, lead_type, contact_type, languages, property_category, is_property, unit_category, property_type_id, is_luxury, property_unit_id, property_statuses_id, purpose_id, min_budget, max_budget, min_area, max_area, bedroom, bathroom, countries_id, states_id, cities_id, community_id, subcommunity_id, lat, lng, assigned_to, residential_status, referred_to, is_exclusive, priority_level, is_finance, mortgage_bank_id, mortgage_status, required_start, required_end, closing_remarks, internal_notes, created_at, leads_won, with_reference, is_property_branch, property_reference_name, social_media_name, section_type
`

type UpdateLeadReferenceDetailsParams struct {
	ID                int64              `json:"id"`
	LeadSource        pgtype.Int8        `json:"lead_source"`
	MediaName         pgtype.Int8        `json:"media_name"`
	IsExclusive       pgtype.Bool        `json:"is_exclusive"`
	AssignedTo        pgtype.Int8        `json:"assigned_to"`
	ResidentialStatus pgtype.Int8        `json:"residential_status"`
	ReferredTo        pgtype.Int8        `json:"referred_to"`
	PriorityLevel     pgtype.Int8        `json:"priority_level"`
	IsFinance         pgtype.Bool        `json:"is_finance"`
	MortgageStatus    pgtype.Int8        `json:"mortgage_status"`
	RequiredStart     pgtype.Timestamptz `json:"required_start"`
	RequiredEnd       pgtype.Timestamptz `json:"required_end"`
	ClosingRemarks    pgtype.Text        `json:"closing_remarks"`
	MortgageBankID    pgtype.Int8        `json:"mortgage_bank_id"`
}

func (q *Queries) UpdateLeadReferenceDetails(ctx context.Context, arg UpdateLeadReferenceDetailsParams) (Lead, error) {
	row := q.db.QueryRow(ctx, updateLeadReferenceDetails,
		arg.ID,
		arg.LeadSource,
		arg.MediaName,
		arg.IsExclusive,
		arg.AssignedTo,
		arg.ResidentialStatus,
		arg.ReferredTo,
		arg.PriorityLevel,
		arg.IsFinance,
		arg.MortgageStatus,
		arg.RequiredStart,
		arg.RequiredEnd,
		arg.ClosingRemarks,
		arg.MortgageBankID,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.ContactsID,
		&i.LeadSource,
		&i.MediaName,
		&i.LeadType,
		&i.ContactType,
		&i.Languages,
		&i.PropertyCategory,
		&i.IsProperty,
		&i.UnitCategory,
		&i.PropertyTypeID,
		&i.IsLuxury,
		&i.PropertyUnitID,
		&i.PropertyStatusesID,
		&i.PurposeID,
		&i.MinBudget,
		&i.MaxBudget,
		&i.MinArea,
		&i.MaxArea,
		&i.Bedroom,
		&i.Bathroom,
		&i.CountriesID,
		&i.StatesID,
		&i.CitiesID,
		&i.CommunityID,
		&i.SubcommunityID,
		&i.Lat,
		&i.Lng,
		&i.AssignedTo,
		&i.ResidentialStatus,
		&i.ReferredTo,
		&i.IsExclusive,
		&i.PriorityLevel,
		&i.IsFinance,
		&i.MortgageBankID,
		&i.MortgageStatus,
		&i.RequiredStart,
		&i.RequiredEnd,
		&i.ClosingRemarks,
		&i.InternalNotes,
		&i.CreatedAt,
		&i.LeadsWon,
		&i.WithReference,
		&i.IsPropertyBranch,
		&i.PropertyReferenceName,
		&i.SocialMediaName,
		&i.SectionType,
	)
	return i, err
}
