// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: schedule_view.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointment (
	created_by,
	status,
    timeslots_id,
    client_id,
    remarks,
    background_color,
    appoinment_type,
    appoinment_app,
    valid_id
) VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9
)RETURNING id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id
`

type CreateAppointmentParams struct {
	CreatedBy       int64       `json:"created_by"`
	Status          int64       `json:"status"`
	TimeslotsID     int64       `json:"timeslots_id"`
	ClientID        pgtype.Int8 `json:"client_id"`
	Remarks         pgtype.Text `json:"remarks"`
	BackgroundColor string      `json:"background_color"`
	AppoinmentType  int64       `json:"appoinment_type"`
	AppoinmentApp   pgtype.Int8 `json:"appoinment_app"`
	ValidID         int64       `json:"valid_id"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.CreatedBy,
		arg.Status,
		arg.TimeslotsID,
		arg.ClientID,
		arg.Remarks,
		arg.BackgroundColor,
		arg.AppoinmentType,
		arg.AppoinmentApp,
		arg.ValidID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const createScheduleView = `-- name: CreateScheduleView :one
INSERT INTO schedule_view (
    ref_no,
    created_by,
    owner_id, 
    entity_type_id, 
    entity_id, 
    start_date, 
    end_date,
    interval_time, 
    sessions,
    lat,
    lng
) VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11
)RETURNING id, ref_no, created_by, owner_id, entity_type_id, entity_id, start_date, end_date, created_at, updated_at, interval_time, sessions, lat, lng
`

type CreateScheduleViewParams struct {
	RefNo        string      `json:"ref_no"`
	CreatedBy    int64       `json:"created_by"`
	OwnerID      pgtype.Int8 `json:"owner_id"`
	EntityTypeID int64       `json:"entity_type_id"`
	EntityID     int64       `json:"entity_id"`
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	IntervalTime int64       `json:"interval_time"`
	Sessions     []byte      `json:"sessions"`
	Lat          string      `json:"lat"`
	Lng          string      `json:"lng"`
}

func (q *Queries) CreateScheduleView(ctx context.Context, arg CreateScheduleViewParams) (ScheduleView, error) {
	row := q.db.QueryRow(ctx, createScheduleView,
		arg.RefNo,
		arg.CreatedBy,
		arg.OwnerID,
		arg.EntityTypeID,
		arg.EntityID,
		arg.StartDate,
		arg.EndDate,
		arg.IntervalTime,
		arg.Sessions,
		arg.Lat,
		arg.Lng,
	)
	var i ScheduleView
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CreatedBy,
		&i.OwnerID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IntervalTime,
		&i.Sessions,
		&i.Lat,
		&i.Lng,
	)
	return i, err
}

const createTimeSlotsForSV = `-- name: CreateTimeSlotsForSV :one
INSERT INTO timeslots(
    date,
    start_time,
    end_time,
    status,
    entity_type_id,
    entity_id
)VALUES(
    $1, $2, $3, $4, $5, $6
) RETURNING id, date, start_time, end_time, status, entity_type_id, entity_id
`

type CreateTimeSlotsForSVParams struct {
	Date         time.Time `json:"date"`
	StartTime    time.Time `json:"start_time"`
	EndTime      time.Time `json:"end_time"`
	Status       int64     `json:"status"`
	EntityTypeID int64     `json:"entity_type_id"`
	EntityID     int64     `json:"entity_id"`
}

func (q *Queries) CreateTimeSlotsForSV(ctx context.Context, arg CreateTimeSlotsForSVParams) (Timeslot, error) {
	row := q.db.QueryRow(ctx, createTimeSlotsForSV,
		arg.Date,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.EntityTypeID,
		arg.EntityID,
	)
	var i Timeslot
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}

const getAllAppoinment = `-- name: GetAllAppoinment :many
select id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id from appointment
`

func (q *Queries) GetAllAppoinment(ctx context.Context) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, getAllAppoinment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.TimeslotsID,
			&i.CreatedBy,
			&i.Status,
			&i.ClientID,
			&i.Remarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BackgroundColor,
			&i.AppoinmentType,
			&i.AppoinmentApp,
			&i.ValidID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllScheduleSessionByMonth = `-- name: GetAllScheduleSessionByMonth :many
WITH unnested_sessions AS (
  SELECT
    t.id,
	t.ref_no,
	t.owner_id,
	t.interval_time,
    jsonb_array_elements(t.sessions::jsonb) AS session
  FROM schedule_view t
  WHERE
 (   (DATE_TRUNC('month', $1::timestamp) BETWEEN t.start_date AND t.end_date)
    OR (DATE_TRUNC('month', $1::timestamp) + INTERVAL '1 month' - INTERVAL '1 day' BETWEEN t.start_date AND t.end_date)
    OR (t.start_date BETWEEN DATE_TRUNC('month', $1::timestamp) AND DATE_TRUNC('month', $1::timestamp) + INTERVAL '1 month' - INTERVAL '1 day')
)
    AND t.entity_type_id = $2::BIGINT AND t.entity_id = $3::BIGINT
),
parsed_sessions AS (
  SELECT
    id,
	ref_no,
	owner_id,
	interval_time,
    (session->>'Name')::text AS session_name,
    (session->>'StartTime')::timestamp AS start_time,
    (session->>'EndTime')::timestamp AS end_time,
    (session->>'Date')::date AS session_date
  FROM unnested_sessions
)
SELECT
  session_date,
  jsonb_agg(
    jsonb_build_object(
		'schedule_id', id::bigint,
		'owner_id', owner_id::bigint,
		'ref_no', ref_no::text,
		'interval_time', interval_time::bigint,
    'name', session_name,
    'start_time', start_time,
    'end_time', end_time
    )
    ORDER BY start_time
  ) AS sessions
FROM parsed_sessions
GROUP BY session_date
ORDER BY session_date
`

type GetAllScheduleSessionByMonthParams struct {
	Currentdate  pgtype.Timestamp `json:"currentdate"`
	EntityTypeID int64            `json:"entity_type_id"`
	EntityID     int64            `json:"entity_id"`
}

type GetAllScheduleSessionByMonthRow struct {
	SessionDate time.Time `json:"session_date"`
	Sessions    []byte    `json:"sessions"`
}

func (q *Queries) GetAllScheduleSessionByMonth(ctx context.Context, arg GetAllScheduleSessionByMonthParams) ([]GetAllScheduleSessionByMonthRow, error) {
	rows, err := q.db.Query(ctx, getAllScheduleSessionByMonth, arg.Currentdate, arg.EntityTypeID, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllScheduleSessionByMonthRow
	for rows.Next() {
		var i GetAllScheduleSessionByMonthRow
		if err := rows.Scan(&i.SessionDate, &i.Sessions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllScheduleSlotsByWeek = `-- name: GetAllScheduleSlotsByWeek :many
SELECT 
timeslots.date::date,
jsonb_agg(
        jsonb_build_object(
            'schedule_id', timeslots.entity_id::bigint,
            'start_time', timeslots.start_time,
            'end_time', timeslots.end_time,
            'status', timeslots.status::bigint
        )
        ORDER BY timeslots.start_time
    ) AS slots
FROM timeslots
INNER JOIN schedule_view ON timeslots.entity_id = schedule_view.id
WHERE
timeslots.entity_type_id = 13
AND timeslots.status != 6
AND schedule_view.entity_type_id = $1::BIGINT
AND schedule_view.entity_id = $2::BIGINT 
AND DATE_TRUNC('week', timeslots.date) = DATE_TRUNC('week', $3::timestamp)
GROUP BY timeslots.date
ORDER BY timeslots.date
`

type GetAllScheduleSlotsByWeekParams struct {
	EntityTypeID int64            `json:"entity_type_id"`
	EntityID     int64            `json:"entity_id"`
	Currentdate  pgtype.Timestamp `json:"currentdate"`
}

type GetAllScheduleSlotsByWeekRow struct {
	TimeslotsDate time.Time `json:"timeslots_date"`
	Slots         []byte    `json:"slots"`
}

func (q *Queries) GetAllScheduleSlotsByWeek(ctx context.Context, arg GetAllScheduleSlotsByWeekParams) ([]GetAllScheduleSlotsByWeekRow, error) {
	rows, err := q.db.Query(ctx, getAllScheduleSlotsByWeek, arg.EntityTypeID, arg.EntityID, arg.Currentdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllScheduleSlotsByWeekRow
	for rows.Next() {
		var i GetAllScheduleSlotsByWeekRow
		if err := rows.Scan(&i.TimeslotsDate, &i.Slots); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllScheduleSlotsByWeekly = `-- name: GetAllScheduleSlotsByWeekly :many
  --   DATE_TRUNC('month', $3::timestamp) BETWEEN t.start_time AND t.end_time
  --   OR (DATE_TRUNC('month', $3::timestamp) + INTERVAL '1 month' - INTERVAL '1 day') BETWEEN t.start_time AND t.end_time
  --   OR t.start_time BETWEEN DATE_TRUNC('month', $3::timestamp) AND DATE_TRUNC('month', $3::timestamp) + INTERVAL '1 month' - INTERVAL '1 day'
  -- );


SELECT 
    appointment.id AS appointment_id,
appointment.status AS appointment_status,
appointment.background_color,
users.email,
profiles.first_name,
profiles.last_name,
users.phone_number,
profiles.profile_image_url,
timeslots.date::date,
schedule_view.id,
timeslots.id AS time_slot_id,
timeslots."date",
timeslots.start_time,
timeslots.end_time,
timeslots.status AS time_slot_status,
timeslots.entity_id AS schedule_id
FROM timeslots
INNER JOIN schedule_view ON timeslots.entity_id = schedule_view.id
LEFT JOIN appointment ON appointment.timeslots_id = timeslots.id AND appointment.status != 5
LEFT JOIN users ON users.id = appointment.client_id
LEFT JOIN profiles ON profiles.users_id = users.id
WHERE
timeslots.entity_type_id = 13
AND timeslots.status != 6
AND schedule_view.entity_type_id = $1::BIGINT
AND schedule_view.entity_id = $2::BIGINT 
AND DATE_TRUNC('week', timeslots.date) = DATE_TRUNC('week', $3::timestamp)
ORDER BY timeslots.date
`

type GetAllScheduleSlotsByWeeklyParams struct {
	EntityTypeID int64            `json:"entity_type_id"`
	EntityID     int64            `json:"entity_id"`
	Currentdate  pgtype.Timestamp `json:"currentdate"`
}

type GetAllScheduleSlotsByWeeklyRow struct {
	AppointmentID     pgtype.Int8 `json:"appointment_id"`
	AppointmentStatus pgtype.Int8 `json:"appointment_status"`
	BackgroundColor   pgtype.Text `json:"background_color"`
	Email             pgtype.Text `json:"email"`
	FirstName         pgtype.Text `json:"first_name"`
	LastName          pgtype.Text `json:"last_name"`
	PhoneNumber       pgtype.Text `json:"phone_number"`
	ProfileImageUrl   pgtype.Text `json:"profile_image_url"`
	TimeslotsDate     time.Time   `json:"timeslots_date"`
	ID                int64       `json:"id"`
	TimeSlotID        int64       `json:"time_slot_id"`
	Date              time.Time   `json:"date"`
	StartTime         time.Time   `json:"start_time"`
	EndTime           time.Time   `json:"end_time"`
	TimeSlotStatus    int64       `json:"time_slot_status"`
	ScheduleID        int64       `json:"schedule_id"`
}

// AND (
func (q *Queries) GetAllScheduleSlotsByWeekly(ctx context.Context, arg GetAllScheduleSlotsByWeeklyParams) ([]GetAllScheduleSlotsByWeeklyRow, error) {
	rows, err := q.db.Query(ctx, getAllScheduleSlotsByWeekly, arg.EntityTypeID, arg.EntityID, arg.Currentdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllScheduleSlotsByWeeklyRow
	for rows.Next() {
		var i GetAllScheduleSlotsByWeeklyRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.AppointmentStatus,
			&i.BackgroundColor,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.ProfileImageUrl,
			&i.TimeslotsDate,
			&i.ID,
			&i.TimeSlotID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.TimeSlotStatus,
			&i.ScheduleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllScheduleView = `-- name: GetAllScheduleView :many
select id, ref_no, created_by, owner_id, entity_type_id, entity_id, start_date, end_date, created_at, updated_at, interval_time, sessions, lat, lng from schedule_view
`

func (q *Queries) GetAllScheduleView(ctx context.Context) ([]ScheduleView, error) {
	rows, err := q.db.Query(ctx, getAllScheduleView)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduleView
	for rows.Next() {
		var i ScheduleView
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CreatedBy,
			&i.OwnerID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IntervalTime,
			&i.Sessions,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllScheduleViewSessionsByProperty = `-- name: GetAllScheduleViewSessionsByProperty :many
SELECT 
  schedule_view.id, 
  schedule_view.sessions 
FROM schedule_view
INNER JOIN timeslots t ON t.entity_id = schedule_view.id
WHERE 
  schedule_view.entity_type_id = $2 
  AND schedule_view.entity_id = $1
`

type GetAllScheduleViewSessionsByPropertyParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
}

type GetAllScheduleViewSessionsByPropertyRow struct {
	ID       int64  `json:"id"`
	Sessions []byte `json:"sessions"`
}

func (q *Queries) GetAllScheduleViewSessionsByProperty(ctx context.Context, arg GetAllScheduleViewSessionsByPropertyParams) ([]GetAllScheduleViewSessionsByPropertyRow, error) {
	rows, err := q.db.Query(ctx, getAllScheduleViewSessionsByProperty, arg.EntityID, arg.EntityTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllScheduleViewSessionsByPropertyRow
	for rows.Next() {
		var i GetAllScheduleViewSessionsByPropertyRow
		if err := rows.Scan(&i.ID, &i.Sessions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppoinmentbyId = `-- name: GetAppoinmentbyId :one
select id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id from appointment where id =$1
`

func (q *Queries) GetAppoinmentbyId(ctx context.Context, id int64) (Appointment, error) {
	row := q.db.QueryRow(ctx, getAppoinmentbyId, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const getPropertyLocationByPropertyID = `-- name: GetPropertyLocationByPropertyID :one
SELECT l.lat, l.lng FROM property p
INNER JOIN addresses a on p.addresses_id = a.id
LEFT JOIN locations l ON l.id = a.locations_id
where p.id = $1
`

type GetPropertyLocationByPropertyIDRow struct {
	Lat pgtype.Text `json:"lat"`
	Lng pgtype.Text `json:"lng"`
}

func (q *Queries) GetPropertyLocationByPropertyID(ctx context.Context, id int64) (GetPropertyLocationByPropertyIDRow, error) {
	row := q.db.QueryRow(ctx, getPropertyLocationByPropertyID, id)
	var i GetPropertyLocationByPropertyIDRow
	err := row.Scan(&i.Lat, &i.Lng)
	return i, err
}

const getScheduleViewbyId = `-- name: GetScheduleViewbyId :one
select id, ref_no, created_by, owner_id, entity_type_id, entity_id, start_date, end_date, created_at, updated_at, interval_time, sessions, lat, lng from schedule_view where id =$1
`

func (q *Queries) GetScheduleViewbyId(ctx context.Context, id int64) (ScheduleView, error) {
	row := q.db.QueryRow(ctx, getScheduleViewbyId, id)
	var i ScheduleView
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CreatedBy,
		&i.OwnerID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IntervalTime,
		&i.Sessions,
		&i.Lat,
		&i.Lng,
	)
	return i, err
}

const getTimeSlotsForEntity = `-- name: GetTimeSlotsForEntity :many
SELECT 
ts.id, ts.date, ts.start_time, ts.end_time, ts.status, ts.entity_type_id, ts.entity_id
FROM 
	timeslots ts
WHERE 
	ts.end_time>now()
AND
	ts.entity_id= $1::BIGINT AND ts.entity_type_id= $2::BIGINT AND
	COALESCE((SELECT CASE  $2::BIGINT
               WHEN 11 THEN (SELECT 1 FROM services WHERE services.id = $1::BIGINT)
               WHEN 14 THEN (SELECT unit_versions.status::BIGINT FROM unit_versions WHERE unit_versions.id = $1::BIGINT)
               WHEN 15 THEN (SELECT property_versions.status::BIGINT FROM property_versions WHERE property_versions.id = $1::BIGINT)
               ELSE 0::BIGINT
           END),6::BIGINT) NOT IN(0,6)
ORDER BY 
	ts.id DESC
`

type GetTimeSlotsForEntityParams struct {
	Column1 int64 `json:"column_1"`
	Column2 int64 `json:"column_2"`
}

type GetTimeSlotsForEntityRow struct {
	Timeslot Timeslot `json:"timeslot"`
}

func (q *Queries) GetTimeSlotsForEntity(ctx context.Context, arg GetTimeSlotsForEntityParams) ([]GetTimeSlotsForEntityRow, error) {
	rows, err := q.db.Query(ctx, getTimeSlotsForEntity, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeSlotsForEntityRow
	for rows.Next() {
		var i GetTimeSlotsForEntityRow
		if err := rows.Scan(
			&i.Timeslot.ID,
			&i.Timeslot.Date,
			&i.Timeslot.StartTime,
			&i.Timeslot.EndTime,
			&i.Timeslot.Status,
			&i.Timeslot.EntityTypeID,
			&i.Timeslot.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitLocationByUnitID = `-- name: GetUnitLocationByUnitID :one
SELECT l.lat, l.lng FROM units u
INNER JOIN addresses a on u.addresses_id = a.id
LEFT JOIN locations l ON a.locations_id = l.id
where u.id = $1
`

type GetUnitLocationByUnitIDRow struct {
	Lat pgtype.Text `json:"lat"`
	Lng pgtype.Text `json:"lng"`
}

func (q *Queries) GetUnitLocationByUnitID(ctx context.Context, id int64) (GetUnitLocationByUnitIDRow, error) {
	row := q.db.QueryRow(ctx, getUnitLocationByUnitID, id)
	var i GetUnitLocationByUnitIDRow
	err := row.Scan(&i.Lat, &i.Lng)
	return i, err
}

const updateAppointment = `-- name: UpdateAppointment :one
UPDATE appointment
SET status = $1,
    timeslots_id= $2,
    background_color = $3,
    remarks = $4,
    updated_at = $5,
    appoinment_type = $6,
    appoinment_app = $7,
    valid_id = $8
WHERE id = $9
RETURNING id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id
`

type UpdateAppointmentParams struct {
	Status          int64       `json:"status"`
	TimeslotsID     int64       `json:"timeslots_id"`
	BackgroundColor string      `json:"background_color"`
	Remarks         pgtype.Text `json:"remarks"`
	UpdatedAt       time.Time   `json:"updated_at"`
	AppoinmentType  int64       `json:"appoinment_type"`
	AppoinmentApp   pgtype.Int8 `json:"appoinment_app"`
	ValidID         int64       `json:"valid_id"`
	ID              int64       `json:"id"`
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointment,
		arg.Status,
		arg.TimeslotsID,
		arg.BackgroundColor,
		arg.Remarks,
		arg.UpdatedAt,
		arg.AppoinmentType,
		arg.AppoinmentApp,
		arg.ValidID,
		arg.ID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const updateAppointmentStatus = `-- name: UpdateAppointmentStatus :one
UPDATE appointment
SET status = $1,
    remarks = $2,
    updated_at = $3
WHERE id = $4
RETURNING id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id
`

type UpdateAppointmentStatusParams struct {
	Status    int64       `json:"status"`
	Remarks   pgtype.Text `json:"remarks"`
	UpdatedAt time.Time   `json:"updated_at"`
	ID        int64       `json:"id"`
}

func (q *Queries) UpdateAppointmentStatus(ctx context.Context, arg UpdateAppointmentStatusParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointmentStatus,
		arg.Status,
		arg.Remarks,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const updateScheduleView = `-- name: UpdateScheduleView :one
UPDATE schedule_view
SET owner_id = $1,
    entity_type_id= $2,
    entity_id = $3,
    start_date = $4,
    end_date = $5,
    interval_time = $6,
    sessions = $7,
    updated_at = $8,
    lat = $9,
    lng = $10
WHERE id = $11
RETURNING id, ref_no, created_by, owner_id, entity_type_id, entity_id, start_date, end_date, created_at, updated_at, interval_time, sessions, lat, lng
`

type UpdateScheduleViewParams struct {
	OwnerID      pgtype.Int8 `json:"owner_id"`
	EntityTypeID int64       `json:"entity_type_id"`
	EntityID     int64       `json:"entity_id"`
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	IntervalTime int64       `json:"interval_time"`
	Sessions     []byte      `json:"sessions"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Lat          string      `json:"lat"`
	Lng          string      `json:"lng"`
	ID           int64       `json:"id"`
}

func (q *Queries) UpdateScheduleView(ctx context.Context, arg UpdateScheduleViewParams) (ScheduleView, error) {
	row := q.db.QueryRow(ctx, updateScheduleView,
		arg.OwnerID,
		arg.EntityTypeID,
		arg.EntityID,
		arg.StartDate,
		arg.EndDate,
		arg.IntervalTime,
		arg.Sessions,
		arg.UpdatedAt,
		arg.Lat,
		arg.Lng,
		arg.ID,
	)
	var i ScheduleView
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CreatedBy,
		&i.OwnerID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IntervalTime,
		&i.Sessions,
		&i.Lat,
		&i.Lng,
	)
	return i, err
}
