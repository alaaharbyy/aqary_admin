// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: services.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createService = `-- name: CreateService :one
INSERT INTO services (
    ref_no,
    company_id,
    company_activities_id,
    service_name,
    service_name_ar,
    description,
    description_ar,
    price,
    tag_id,
    service_rank,
    created_by,
    created_at,
    updated_at,
    status
)VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12,$13,$14
) RETURNING id, ref_no, company_id, company_activities_id, service_name, description, description_ar, price, tag_id, service_rank, created_by, created_at, updated_at, status, slug, service_name_ar
`

type CreateServiceParams struct {
	RefNo               string      `json:"ref_no"`
	CompanyID           int64       `json:"company_id"`
	CompanyActivitiesID int64       `json:"company_activities_id"`
	ServiceName         string      `json:"service_name"`
	ServiceNameAr       pgtype.Text `json:"service_name_ar"`
	Description         string      `json:"description"`
	DescriptionAr       string      `json:"description_ar"`
	Price               float64     `json:"price"`
	TagID               []int64     `json:"tag_id"`
	ServiceRank         int32       `json:"service_rank"`
	CreatedBy           int64       `json:"created_by"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	Status              int64       `json:"status"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.RefNo,
		arg.CompanyID,
		arg.CompanyActivitiesID,
		arg.ServiceName,
		arg.ServiceNameAr,
		arg.Description,
		arg.DescriptionAr,
		arg.Price,
		arg.TagID,
		arg.ServiceRank,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyID,
		&i.CompanyActivitiesID,
		&i.ServiceName,
		&i.Description,
		&i.DescriptionAr,
		&i.Price,
		&i.TagID,
		&i.ServiceRank,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Slug,
		&i.ServiceNameAr,
	)
	return i, err
}

const getService = `-- name: GetService :one
with service_tags AS (
    SELECT 
        services.id AS service_id,
        ARRAY_AGG(global_tagging.tag_name::varchar)::varchar[] AS tag_names
    FROM services
    JOIN LATERAL UNNEST(services.tag_id) AS tags_id ON true
    JOIN global_tagging ON global_tagging.id = tags_id
    GROUP BY services.id
)
SELECT
    services.id, services.ref_no, services.company_id, services.company_activities_id, services.service_name, services.description, services.description_ar, services.price, services.tag_id, services.service_rank, services.created_by, services.created_at, services.updated_at, services.status, services.slug, services.service_name_ar,companies.company_name, company_activities.activity_name,company_activities.activity_name_ar,service_tags.tag_names::varchar[]
FROM services
JOIN companies ON companies.id=services.company_id
JOIN company_activities ON company_activities.id=services.company_activities_id
LEFT JOIN service_tags ON service_tags.service_id = services.id
WHERE services.id=$1
`

type GetServiceRow struct {
	Service             Service     `json:"service"`
	CompanyName         string      `json:"company_name"`
	ActivityName        string      `json:"activity_name"`
	ActivityNameAr      pgtype.Text `json:"activity_name_ar"`
	ServiceTagsTagNames []string    `json:"service_tags_tag_names"`
}

func (q *Queries) GetService(ctx context.Context, id int64) (GetServiceRow, error) {
	row := q.db.QueryRow(ctx, getService, id)
	var i GetServiceRow
	err := row.Scan(
		&i.Service.ID,
		&i.Service.RefNo,
		&i.Service.CompanyID,
		&i.Service.CompanyActivitiesID,
		&i.Service.ServiceName,
		&i.Service.Description,
		&i.Service.DescriptionAr,
		&i.Service.Price,
		&i.Service.TagID,
		&i.Service.ServiceRank,
		&i.Service.CreatedBy,
		&i.Service.CreatedAt,
		&i.Service.UpdatedAt,
		&i.Service.Status,
		&i.Service.Slug,
		&i.Service.ServiceNameAr,
		&i.CompanyName,
		&i.ActivityName,
		&i.ActivityNameAr,
		&i.ServiceTagsTagNames,
	)
	return i, err
}

const getServiceReviews = `-- name: GetServiceReviews :many
with score as (
  select reviews_table.entity_review_id as id,  json_agg( json_build_object( 'term', review_terms.review_term, 'term_ar', review_terms.review_term_ar, 'value',reviews_table.review_value ) ) as scores from reviews_table
	join review_terms on review_terms.id=reviews_table.review_term_id 
	group by reviews_table.entity_review_id
)
SELECT 
	services.service_name,
	services.service_name_ar,
	companies.company_name,
	company_activities.activity_name,
	company_activities.activity_name_ar,
	score.scores,
	entity_review.id, entity_review.entity_type_id, entity_review.entity_id, entity_review.description, entity_review.title, entity_review.reviewer, entity_review.review_date, entity_review.image_url, entity_review.overall_avg, 
	profiles.first_name,
	profiles.last_name,
	profiles.profile_image_url
FROM entity_review 
JOIN score ON score.id=entity_review.id
JOIN services ON services.id=entity_review.entity_id 
JOIN companies ON companies.id=services.company_id
JOIN company_activities ON company_activities.id=services.company_activities_id
JOIN profiles on profiles.users_id=entity_review.reviewer
WHERE entity_review.entity_type_id= $2 AND services.id= $1 AND services.status!=6 AND companies.status!=6 AND company_activities.status!=6
`

type GetServiceReviewsParams struct {
	ID                 int64 `json:"id"`
	ServicesEntityType int64 `json:"services_entity_type"`
}

type GetServiceReviewsRow struct {
	ServiceName     string       `json:"service_name"`
	ServiceNameAr   pgtype.Text  `json:"service_name_ar"`
	CompanyName     string       `json:"company_name"`
	ActivityName    string       `json:"activity_name"`
	ActivityNameAr  pgtype.Text  `json:"activity_name_ar"`
	Scores          []byte       `json:"scores"`
	EntityReview    EntityReview `json:"entity_review"`
	FirstName       string       `json:"first_name"`
	LastName        string       `json:"last_name"`
	ProfileImageUrl pgtype.Text  `json:"profile_image_url"`
}

func (q *Queries) GetServiceReviews(ctx context.Context, arg GetServiceReviewsParams) ([]GetServiceReviewsRow, error) {
	rows, err := q.db.Query(ctx, getServiceReviews, arg.ID, arg.ServicesEntityType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServiceReviewsRow
	for rows.Next() {
		var i GetServiceReviewsRow
		if err := rows.Scan(
			&i.ServiceName,
			&i.ServiceNameAr,
			&i.CompanyName,
			&i.ActivityName,
			&i.ActivityNameAr,
			&i.Scores,
			&i.EntityReview.ID,
			&i.EntityReview.EntityTypeID,
			&i.EntityReview.EntityID,
			&i.EntityReview.Description,
			&i.EntityReview.Title,
			&i.EntityReview.Reviewer,
			&i.EntityReview.ReviewDate,
			&i.EntityReview.ImageUrl,
			&i.EntityReview.OverallAvg,
			&i.FirstName,
			&i.LastName,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServices = `-- name: GetServices :many
WITH rating AS(
	SELECT  entity_review.entity_id AS id, avg(reviews_table.review_value) AS rating_value FROM entity_review 
	JOIN reviews_table ON reviews_table.entity_review_id=entity_review.id
	WHERE entity_review.entity_type_id= $5
	GROUP BY entity_review.entity_id
),
service_tags AS (
    SELECT 
        services.id AS service_id,
        ARRAY_AGG(global_tagging.tag_name::varchar)::varchar[] AS tag_names
    FROM services
    JOIN LATERAL UNNEST(services.tag_id) AS tags_id ON true
    JOIN global_tagging ON global_tagging.id = tags_id
    GROUP BY services.id
)
SELECT 
    services.id, services.ref_no, services.company_id, services.company_activities_id, services.service_name, services.description, services.description_ar, services.price, services.tag_id, services.service_rank, services.created_by, services.created_at, services.updated_at, services.status, services.slug, services.service_name_ar,
    companies.company_name, 
    CASE WHEN $4::varchar = 'ar' THEN COALESCE(company_activities.activity_name_ar,company_activities.activity_name)
    ELSE COALESCE(company_activities.activity_name, '') END::varchar as company_activity,
    COALESCE(rating.rating_value, 0.0),
    service_tags.tag_names::varchar[]
FROM services
JOIN companies ON companies.id = services.company_id
JOIN company_activities ON company_activities.id = services.company_activities_id
LEFT JOIN rating ON rating.id = services.id
LEFT JOIN service_tags ON service_tags.service_id = services.id
WHERE services.status = $3
LIMIT $1 OFFSET $2
`

type GetServicesParams struct {
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
	Status             int64  `json:"status"`
	Lang               string `json:"lang"`
	ServicesEntityType int64  `json:"services_entity_type"`
}

type GetServicesRow struct {
	Service             Service  `json:"service"`
	CompanyName         string   `json:"company_name"`
	CompanyActivity     string   `json:"company_activity"`
	RatingValue         float64  `json:"rating_value"`
	ServiceTagsTagNames []string `json:"service_tags_tag_names"`
}

func (q *Queries) GetServices(ctx context.Context, arg GetServicesParams) ([]GetServicesRow, error) {
	rows, err := q.db.Query(ctx, getServices,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.Lang,
		arg.ServicesEntityType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServicesRow
	for rows.Next() {
		var i GetServicesRow
		if err := rows.Scan(
			&i.Service.ID,
			&i.Service.RefNo,
			&i.Service.CompanyID,
			&i.Service.CompanyActivitiesID,
			&i.Service.ServiceName,
			&i.Service.Description,
			&i.Service.DescriptionAr,
			&i.Service.Price,
			&i.Service.TagID,
			&i.Service.ServiceRank,
			&i.Service.CreatedBy,
			&i.Service.CreatedAt,
			&i.Service.UpdatedAt,
			&i.Service.Status,
			&i.Service.Slug,
			&i.Service.ServiceNameAr,
			&i.CompanyName,
			&i.CompanyActivity,
			&i.RatingValue,
			&i.ServiceTagsTagNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesCount = `-- name: GetServicesCount :one
SELECT 
    count(services.id)
FROM services
JOIN companies ON companies.id = services.company_id
JOIN company_activities ON company_activities.id = services.company_activities_id
WHERE services.status = $1
`

func (q *Queries) GetServicesCount(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getServicesCount, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateService = `-- name: UpdateService :one
UPDATE services SET 
    service_name=$1,
    service_name_ar=$2,
    description=$3,
    description_ar=$4,
    price=$5,
    tag_id=$6,
    service_rank=$7,
    updated_at=$8
WHERE id=$9
RETURNING id, ref_no, company_id, company_activities_id, service_name, description, description_ar, price, tag_id, service_rank, created_by, created_at, updated_at, status, slug, service_name_ar
`

type UpdateServiceParams struct {
	ServiceName   string      `json:"service_name"`
	ServiceNameAr pgtype.Text `json:"service_name_ar"`
	Description   string      `json:"description"`
	DescriptionAr string      `json:"description_ar"`
	Price         float64     `json:"price"`
	TagID         []int64     `json:"tag_id"`
	ServiceRank   int32       `json:"service_rank"`
	UpdatedAt     time.Time   `json:"updated_at"`
	ID            int64       `json:"id"`
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateService,
		arg.ServiceName,
		arg.ServiceNameAr,
		arg.Description,
		arg.DescriptionAr,
		arg.Price,
		arg.TagID,
		arg.ServiceRank,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyID,
		&i.CompanyActivitiesID,
		&i.ServiceName,
		&i.Description,
		&i.DescriptionAr,
		&i.Price,
		&i.TagID,
		&i.ServiceRank,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Slug,
		&i.ServiceNameAr,
	)
	return i, err
}

const updateServiceRank = `-- name: UpdateServiceRank :one
UPDATE services SET 
    service_rank=$3,
    updated_at=$2
WHERE id=$1
RETURNING id, ref_no, company_id, company_activities_id, service_name, description, description_ar, price, tag_id, service_rank, created_by, created_at, updated_at, status, slug, service_name_ar
`

type UpdateServiceRankParams struct {
	ID          int64     `json:"id"`
	UpdatedAt   time.Time `json:"updated_at"`
	ServiceRank int32     `json:"service_rank"`
}

func (q *Queries) UpdateServiceRank(ctx context.Context, arg UpdateServiceRankParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateServiceRank, arg.ID, arg.UpdatedAt, arg.ServiceRank)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyID,
		&i.CompanyActivitiesID,
		&i.ServiceName,
		&i.Description,
		&i.DescriptionAr,
		&i.Price,
		&i.TagID,
		&i.ServiceRank,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Slug,
		&i.ServiceNameAr,
	)
	return i, err
}

const updateServiceStatus = `-- name: UpdateServiceStatus :one
UPDATE services SET 
    status=$1,
    updated_at=$2
WHERE id=$3
RETURNING id, ref_no, company_id, company_activities_id, service_name, description, description_ar, price, tag_id, service_rank, created_by, created_at, updated_at, status, slug, service_name_ar
`

type UpdateServiceStatusParams struct {
	Status    int64     `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) UpdateServiceStatus(ctx context.Context, arg UpdateServiceStatusParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateServiceStatus, arg.Status, arg.UpdatedAt, arg.ID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CompanyID,
		&i.CompanyActivitiesID,
		&i.ServiceName,
		&i.Description,
		&i.DescriptionAr,
		&i.Price,
		&i.TagID,
		&i.ServiceRank,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Slug,
		&i.ServiceNameAr,
	)
	return i, err
}
