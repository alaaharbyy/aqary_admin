// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: social_connections.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteSocialConnectionByID = `-- name: DeleteSocialConnectionByID :exec
DELETE FROM social_connections WHERE id = $1
`

func (q *Queries) DeleteSocialConnectionByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSocialConnectionByID, id)
	return err
}

const deleteSocialConnectionByUserIdAndRequesteBy = `-- name: DeleteSocialConnectionByUserIdAndRequesteBy :exec

DELETE FROM social_connections WHERE connection_status_id = $1 
AND requested_by = $2
`

type DeleteSocialConnectionByUserIdAndRequesteByParams struct {
	ConnectionStatusID int64 `json:"connection_status_id"`
	RequestedBy        int64 `json:"requested_by"`
}

// -- name: GetSingleOneWaySocialConnection :one
// SELECT *
// FROM social_connections
// WHERE
//
//	("user_id" = $1 AND "requested_by" = $2) LIMIT 1;
//
// AND user_id = $2
func (q *Queries) DeleteSocialConnectionByUserIdAndRequesteBy(ctx context.Context, arg DeleteSocialConnectionByUserIdAndRequesteByParams) error {
	_, err := q.db.Exec(ctx, deleteSocialConnectionByUserIdAndRequesteBy, arg.ConnectionStatusID, arg.RequestedBy)
	return err
}

const getConnectionWithNotStatus = `-- name: GetConnectionWithNotStatus :many
WITH x AS (
SELECT 
	sc.requested_by as "id",
    p.first_name,
    cu.company_id,
    --    cu.company_type,
    --    cu.is_branch,
    ct.title AS company_type_title,
    ct.title_ar AS company_type_title_ar,
    sc.request_date,
    (
        SELECT COUNT(*)
        FROM social_connections sc
        WHERE 
        -- (sc.requested_by = u.id OR sc.user_id = u.id) AND 
        sc.connection_status_id = 2
    ) AS total_social_connections
FROM social_connections sc
JOIN users u ON sc.requested_by = u.id
JOIN profiles p ON u.profiles_id = p.id
LEFT JOIN company_users cu ON u.id = cu.users_id
LEFT JOIN company_types ct ON cu.company_type = ct.id
WHERE 
 sc.connection_status_id != $1
UNION 
SELECT 
	-- sc.user_id as "id",
    p.first_name,
    cu.company_id,
       cu.company_type,
       cu.is_branch,
    ct.title AS company_type_title,
    ct.title_ar AS company_type_title_ar,
    sc.request_date,
    (
        SELECT COUNT(*)
        FROM social_connections sc
        WHERE 
        -- (sc.requested_by = u.id OR sc.user_id = u.id) AND
         sc.connection_status_id = 2
    ) AS total_social_connections
FROM social_connections sc
JOIN profiles p ON u.profiles_id = p.id
LEFT JOIN company_users cu ON u.id = cu.users_id
LEFT JOIN company_types ct ON cu.company_type = ct.id
WHERE sc.requested_by = $1
AND sc.connection_status_id != $2) SELECT id, first_name, company_id, company_type_title, company_type_title_ar, request_date, total_social_connections FROM x LIMIT $3 OFFSET $4
`

type GetConnectionWithNotStatusParams struct {
	ConnectionStatusID   int64 `json:"connection_status_id"`
	ConnectionStatusID_2 int64 `json:"connection_status_id_2"`
	Limit                int32 `json:"limit"`
	Offset               int32 `json:"offset"`
}

type GetConnectionWithNotStatusRow struct {
	ID                     int64       `json:"id"`
	FirstName              string      `json:"first_name"`
	CompanyID              pgtype.Int8 `json:"company_id"`
	CompanyTypeTitle       pgtype.Text `json:"company_type_title"`
	CompanyTypeTitleAr     pgtype.Text `json:"company_type_title_ar"`
	RequestDate            time.Time   `json:"request_date"`
	TotalSocialConnections int64       `json:"total_social_connections"`
}

// sc.user_id = $1 AND
// JOIN users u ON sc.user_id = u.id
func (q *Queries) GetConnectionWithNotStatus(ctx context.Context, arg GetConnectionWithNotStatusParams) ([]GetConnectionWithNotStatusRow, error) {
	rows, err := q.db.Query(ctx, getConnectionWithNotStatus,
		arg.ConnectionStatusID,
		arg.ConnectionStatusID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConnectionWithNotStatusRow
	for rows.Next() {
		var i GetConnectionWithNotStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.CompanyID,
			&i.CompanyTypeTitle,
			&i.CompanyTypeTitleAr,
			&i.RequestDate,
			&i.TotalSocialConnections,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConnectionWithStatus = `-- name: GetConnectionWithStatus :many
WITH x AS (
SELECT 
sc.id,
	sc.requested_by as "user_id",
	'from' as "direction",
    p.first_name,
    cu.company_id,
    --    cu.company_type,
    --    cu.is_branch,
    ct.title AS company_type_title,
    ct.title_ar AS company_type_title_ar,
    sc.request_date,
    (
        SELECT COUNT(*)
        FROM social_connections sc
        WHERE (sc.requested_by = u.id OR sc.user_id = u.id)
        AND sc.connection_status_id = 2
    ) AS total_social_connections
FROM social_connections sc
JOIN users u ON sc.requested_by = u.id
JOIN profiles p ON u.profiles_id = p.id
LEFT JOIN company_users cu ON u.id = cu.users_id
LEFT JOIN company_types ct ON cu.company_type = ct.id
WHERE 
 sc.connection_status_id = $1
UNION 
SELECT 
sc.id,
	-- sc.user_id as "user_id",
	'to' as "direction",
    p.first_name,
    cu.company_id,
       cu.company_type,
       cu.is_branch,
    ct.title AS company_type_title,
    ct.title_ar AS company_type_title_ar,
    sc.request_date,
    (
        SELECT COUNT(*)
        FROM social_connections sc
        WHERE 
        -- (sc.requested_by = u.id OR sc.user_id = u.id) AND
         sc.connection_status_id = 2
    ) AS total_social_connections
FROM social_connections sc
JOIN profiles p ON u.profiles_id = p.id
LEFT JOIN company_users cu ON u.id = cu.users_id
LEFT JOIN company_types ct ON cu.company_type = ct.id
WHERE sc.requested_by = $1
AND sc.connection_status_id = $2) SELECT id, user_id, direction, first_name, company_id, company_type_title, company_type_title_ar, request_date, total_social_connections FROM x LIMIT $3 OFFSET $4
`

type GetConnectionWithStatusParams struct {
	ConnectionStatusID   int64 `json:"connection_status_id"`
	ConnectionStatusID_2 int64 `json:"connection_status_id_2"`
	Limit                int32 `json:"limit"`
	Offset               int32 `json:"offset"`
}

type GetConnectionWithStatusRow struct {
	ID                     int64       `json:"id"`
	UserID                 int64       `json:"user_id"`
	Direction              string      `json:"direction"`
	FirstName              string      `json:"first_name"`
	CompanyID              pgtype.Int8 `json:"company_id"`
	CompanyTypeTitle       pgtype.Text `json:"company_type_title"`
	CompanyTypeTitleAr     pgtype.Text `json:"company_type_title_ar"`
	RequestDate            time.Time   `json:"request_date"`
	TotalSocialConnections int64       `json:"total_social_connections"`
}

// sc.user_id = $1
// AND
// JOIN users u ON sc.user_id = u.id
func (q *Queries) GetConnectionWithStatus(ctx context.Context, arg GetConnectionWithStatusParams) ([]GetConnectionWithStatusRow, error) {
	rows, err := q.db.Query(ctx, getConnectionWithStatus,
		arg.ConnectionStatusID,
		arg.ConnectionStatusID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConnectionWithStatusRow
	for rows.Next() {
		var i GetConnectionWithStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Direction,
			&i.FirstName,
			&i.CompanyID,
			&i.CompanyTypeTitle,
			&i.CompanyTypeTitleAr,
			&i.RequestDate,
			&i.TotalSocialConnections,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConnectionWithStatusRequesteBy = `-- name: GetConnectionWithStatusRequesteBy :many
SELECT 
	-- sc.user_id as "id",
    p.first_name,
    cu.company_id,
    --    cu.company_type,
    --    cu.is_branch,
    ct.title AS company_type_title,
    ct.title_ar AS company_type_title_ar,
    sc.request_date,
    (
        SELECT COUNT(*)
        FROM social_connections sc
        WHERE 
        -- (sc.requested_by = u.id OR sc.user_id = u.id) AND
         sc.connection_status_id = 2
    ) AS total_social_connections
FROM social_connections sc
JOIN profiles p ON u.profiles_id = p.id
LEFT JOIN company_users cu ON u.id = cu.users_id
LEFT JOIN company_types ct ON cu.company_type = ct.id
WHERE sc.requested_by = $1
AND sc.connection_status_id = $2 LIMIT $3 OFFSET $4
`

type GetConnectionWithStatusRequesteByParams struct {
	RequestedBy        int64 `json:"requested_by"`
	ConnectionStatusID int64 `json:"connection_status_id"`
	Limit              int32 `json:"limit"`
	Offset             int32 `json:"offset"`
}

type GetConnectionWithStatusRequesteByRow struct {
	FirstName              string      `json:"first_name"`
	CompanyID              pgtype.Int8 `json:"company_id"`
	CompanyTypeTitle       pgtype.Text `json:"company_type_title"`
	CompanyTypeTitleAr     pgtype.Text `json:"company_type_title_ar"`
	RequestDate            time.Time   `json:"request_date"`
	TotalSocialConnections int64       `json:"total_social_connections"`
}

// JOIN users u ON sc.user_id = u.id
func (q *Queries) GetConnectionWithStatusRequesteBy(ctx context.Context, arg GetConnectionWithStatusRequesteByParams) ([]GetConnectionWithStatusRequesteByRow, error) {
	rows, err := q.db.Query(ctx, getConnectionWithStatusRequesteBy,
		arg.RequestedBy,
		arg.ConnectionStatusID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConnectionWithStatusRequesteByRow
	for rows.Next() {
		var i GetConnectionWithStatusRequesteByRow
		if err := rows.Scan(
			&i.FirstName,
			&i.CompanyID,
			&i.CompanyTypeTitle,
			&i.CompanyTypeTitleAr,
			&i.RequestDate,
			&i.TotalSocialConnections,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConnectionWithStatusUser = `-- name: GetConnectionWithStatusUser :many
SELECT 
	sc.requested_by as "id",
    p.first_name,
    cu.company_id,
    --    cu.company_type,
    --    cu.is_branch,
    ct.title AS company_type_title,
    ct.title_ar AS company_type_title_ar,
    sc.request_date,
    (
        SELECT COUNT(*)
        FROM social_connections sc
        WHERE 
        -- (sc.requested_by = u.id OR sc.user_id = u.id) AND 
        sc.connection_status_id = 2
    ) AS total_social_connections
FROM social_connections sc
JOIN users u ON sc.requested_by = u.id
JOIN profiles p ON u.profiles_id = p.id
LEFT JOIN company_users cu ON u.id = cu.users_id
LEFT JOIN company_types ct ON cu.company_type = ct.id
WHERE 
 sc.connection_status_id = $1 LIMIT $2 OFFSET $3
`

type GetConnectionWithStatusUserParams struct {
	ConnectionStatusID int64 `json:"connection_status_id"`
	Limit              int32 `json:"limit"`
	Offset             int32 `json:"offset"`
}

type GetConnectionWithStatusUserRow struct {
	ID                     int64       `json:"id"`
	FirstName              string      `json:"first_name"`
	CompanyID              pgtype.Int8 `json:"company_id"`
	CompanyTypeTitle       pgtype.Text `json:"company_type_title"`
	CompanyTypeTitleAr     pgtype.Text `json:"company_type_title_ar"`
	RequestDate            time.Time   `json:"request_date"`
	TotalSocialConnections int64       `json:"total_social_connections"`
}

// sc.user_id = $1 AND
func (q *Queries) GetConnectionWithStatusUser(ctx context.Context, arg GetConnectionWithStatusUserParams) ([]GetConnectionWithStatusUserRow, error) {
	rows, err := q.db.Query(ctx, getConnectionWithStatusUser, arg.ConnectionStatusID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConnectionWithStatusUserRow
	for rows.Next() {
		var i GetConnectionWithStatusUserRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.CompanyID,
			&i.CompanyTypeTitle,
			&i.CompanyTypeTitleAr,
			&i.RequestDate,
			&i.TotalSocialConnections,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountConnectionWithNotStatus = `-- name: GetCountConnectionWithNotStatus :one
SELECT 
COUNT (*)
FROM social_connections sc
WHERE 
 sc.connection_status_id != $1
`

// (sc.user_id = $1 OR sc.requested_by = $1) AND
func (q *Queries) GetCountConnectionWithNotStatus(ctx context.Context, connectionStatusID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountConnectionWithNotStatus, connectionStatusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountConnectionWithNotStatusRequestedBy = `-- name: GetCountConnectionWithNotStatusRequestedBy :one
SELECT 
COUNT (*)
FROM social_connections sc
WHERE sc.requested_by = $1
AND sc.connection_status_id != $2
`

type GetCountConnectionWithNotStatusRequestedByParams struct {
	RequestedBy        int64 `json:"requested_by"`
	ConnectionStatusID int64 `json:"connection_status_id"`
}

func (q *Queries) GetCountConnectionWithNotStatusRequestedBy(ctx context.Context, arg GetCountConnectionWithNotStatusRequestedByParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountConnectionWithNotStatusRequestedBy, arg.RequestedBy, arg.ConnectionStatusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountConnectionWithNotStatusUser = `-- name: GetCountConnectionWithNotStatusUser :one
SELECT 
COUNT (*)
FROM social_connections sc
WHERE 
 sc.connection_status_id != $1
`

// sc.user_id = $1 AND
func (q *Queries) GetCountConnectionWithNotStatusUser(ctx context.Context, connectionStatusID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountConnectionWithNotStatusUser, connectionStatusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountConnectionWithStatus = `-- name: GetCountConnectionWithStatus :one
SELECT 
COUNT (*)
FROM social_connections sc
WHERE
  sc.connection_status_id = $1
`

// (sc.user_id = $1 OR sc.requested_by = $1) AND
func (q *Queries) GetCountConnectionWithStatus(ctx context.Context, connectionStatusID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountConnectionWithStatus, connectionStatusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountConnectionWithStatusRequestedBy = `-- name: GetCountConnectionWithStatusRequestedBy :one
SELECT 
COUNT (*)
FROM social_connections sc
WHERE sc.requested_by = $1
AND sc.connection_status_id = $2
`

type GetCountConnectionWithStatusRequestedByParams struct {
	RequestedBy        int64 `json:"requested_by"`
	ConnectionStatusID int64 `json:"connection_status_id"`
}

func (q *Queries) GetCountConnectionWithStatusRequestedBy(ctx context.Context, arg GetCountConnectionWithStatusRequestedByParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountConnectionWithStatusRequestedBy, arg.RequestedBy, arg.ConnectionStatusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountConnectionWithStatusUser = `-- name: GetCountConnectionWithStatusUser :one
SELECT 
COUNT (*)
FROM social_connections sc
WHERE 
 sc.connection_status_id = $1
`

// sc.user_id = $1 AND
func (q *Queries) GetCountConnectionWithStatusUser(ctx context.Context, connectionStatusID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountConnectionWithStatusUser, connectionStatusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSingleSocialConnection = `-- name: GetSingleSocialConnection :one


INSERT INTO social_connections (
    -- user_id,
    requested_by,
    request_date,
    connection_status_id,
    remarks
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, companies_id, requested_by, request_date, updated_at, remarks, connection_status_id
`

type GetSingleSocialConnectionParams struct {
	RequestedBy        int64     `json:"requested_by"`
	RequestDate        time.Time `json:"request_date"`
	ConnectionStatusID int64     `json:"connection_status_id"`
	Remarks            string    `json:"remarks"`
}

// SELECT *
// FROM social_connections
// WHERE
//
//	("user_id" = $1 AND "requested_by" = $2)
//	OR
//	("user_id" = $2 AND "requested_by" = $1) LIMIT 1;
//
// SELECT *
// FROM social_connections AS sc1
// INNER JOIN social_connections AS sc2 ON sc1.requested_by = sc2.user_id
// WHERE
//
//	(sc1.user_id = $1 AND sc2.requested_by = $2)
//	OR
//	(sc1.user_id = $2 AND sc2.requested_by = $1) LIMIT 1;
func (q *Queries) GetSingleSocialConnection(ctx context.Context, arg GetSingleSocialConnectionParams) (SocialConnection, error) {
	row := q.db.QueryRow(ctx, getSingleSocialConnection,
		arg.RequestedBy,
		arg.RequestDate,
		arg.ConnectionStatusID,
		arg.Remarks,
	)
	var i SocialConnection
	err := row.Scan(
		&i.ID,
		&i.CompaniesID,
		&i.RequestedBy,
		&i.RequestDate,
		&i.UpdatedAt,
		&i.Remarks,
		&i.ConnectionStatusID,
	)
	return i, err
}

const updateSocialConnection = `-- name: UpdateSocialConnection :one
UPDATE social_connections
SET
    connection_status_id = $2,
    updated_at = $3
WHERE
    id = $1
RETURNING id, companies_id, requested_by, request_date, updated_at, remarks, connection_status_id
`

type UpdateSocialConnectionParams struct {
	ID                 int64              `json:"id"`
	ConnectionStatusID int64              `json:"connection_status_id"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateSocialConnection(ctx context.Context, arg UpdateSocialConnectionParams) (SocialConnection, error) {
	row := q.db.QueryRow(ctx, updateSocialConnection, arg.ID, arg.ConnectionStatusID, arg.UpdatedAt)
	var i SocialConnection
	err := row.Scan(
		&i.ID,
		&i.CompaniesID,
		&i.RequestedBy,
		&i.RequestDate,
		&i.UpdatedAt,
		&i.Remarks,
		&i.ConnectionStatusID,
	)
	return i, err
}

const updateSocialConnectionByUserIdAndRequestedBy = `-- name: UpdateSocialConnectionByUserIdAndRequestedBy :one
UPDATE social_connections
SET
    connection_status_id = $3,
    updated_at = $2
WHERE
    -- user_id = $1 AND 
    requested_by = $1
RETURNING id, companies_id, requested_by, request_date, updated_at, remarks, connection_status_id
`

type UpdateSocialConnectionByUserIdAndRequestedByParams struct {
	RequestedBy        int64              `json:"requested_by"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ConnectionStatusID int64              `json:"connection_status_id"`
}

func (q *Queries) UpdateSocialConnectionByUserIdAndRequestedBy(ctx context.Context, arg UpdateSocialConnectionByUserIdAndRequestedByParams) (SocialConnection, error) {
	row := q.db.QueryRow(ctx, updateSocialConnectionByUserIdAndRequestedBy, arg.RequestedBy, arg.UpdatedAt, arg.ConnectionStatusID)
	var i SocialConnection
	err := row.Scan(
		&i.ID,
		&i.CompaniesID,
		&i.RequestedBy,
		&i.RequestDate,
		&i.UpdatedAt,
		&i.Remarks,
		&i.ConnectionStatusID,
	)
	return i, err
}

const updateSocialConnectionStatus = `-- name: UpdateSocialConnectionStatus :one
UPDATE social_connections SET connection_status_id = $1, updated_at = $2, remarks = $3 WHERE 
 requested_by = $4
 RETURNING id, companies_id, requested_by, request_date, updated_at, remarks, connection_status_id
`

type UpdateSocialConnectionStatusParams struct {
	ConnectionStatusID int64              `json:"connection_status_id"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Remarks            string             `json:"remarks"`
	RequestedBy        int64              `json:"requested_by"`
}

// user_id = $4 AND
func (q *Queries) UpdateSocialConnectionStatus(ctx context.Context, arg UpdateSocialConnectionStatusParams) (SocialConnection, error) {
	row := q.db.QueryRow(ctx, updateSocialConnectionStatus,
		arg.ConnectionStatusID,
		arg.UpdatedAt,
		arg.Remarks,
		arg.RequestedBy,
	)
	var i SocialConnection
	err := row.Scan(
		&i.ID,
		&i.CompaniesID,
		&i.RequestedBy,
		&i.RequestDate,
		&i.UpdatedAt,
		&i.Remarks,
		&i.ConnectionStatusID,
	)
	return i, err
}
