// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: banks.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBank = `-- name: CreateBank :one
INSERT INTO bank_listing(
    name,
    bank_logo_url,
    bank_url,
    fixed_interest_rate,
    bank_process_fee,
    mail,
    created_by,
    created_at,
    updated_at,
    status,
    country_id
)VALUES (
    $1,  
    $2,  
    $3, 
    $4, 
    $5,  
    $6,  
    $7, 
    $8, 
    $9, 
    $10,
    $11
)
RETURNING id, name, bank_logo_url, bank_url, fixed_interest_rate, bank_process_fee, mail, created_by, created_at, updated_at, status, country_id
`

type CreateBankParams struct {
	Name              string    `json:"name"`
	BankLogoUrl       string    `json:"bank_logo_url"`
	BankUrl           string    `json:"bank_url"`
	FixedInterestRate float64   `json:"fixed_interest_rate"`
	BankProcessFee    float64   `json:"bank_process_fee"`
	Mail              string    `json:"mail"`
	CreatedBy         int64     `json:"created_by"`
	CreatedAt         time.Time `json:"created_at"`
	UpdatedAt         time.Time `json:"updated_at"`
	Status            int64     `json:"status"`
	CountryID         int64     `json:"country_id"`
}

func (q *Queries) CreateBank(ctx context.Context, arg CreateBankParams) (BankListing, error) {
	row := q.db.QueryRow(ctx, createBank,
		arg.Name,
		arg.BankLogoUrl,
		arg.BankUrl,
		arg.FixedInterestRate,
		arg.BankProcessFee,
		arg.Mail,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.CountryID,
	)
	var i BankListing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BankLogoUrl,
		&i.BankUrl,
		&i.FixedInterestRate,
		&i.BankProcessFee,
		&i.Mail,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CountryID,
	)
	return i, err
}

const createBankBranch = `-- name: CreateBankBranch :one
INSERT INTO bank_branches(
    bank_id,
    branch_name,
    phone,
    is_main_branch,
    address_id,
    status
)VALUES (
    $1,  
    $2,  
    $3, 
    $4, 
    $5,  
    $6
)
RETURNING id, bank_id, branch_name, phone, is_main_branch, address_id, status
`

type CreateBankBranchParams struct {
	BankID       int64       `json:"bank_id"`
	BranchName   string      `json:"branch_name"`
	Phone        string      `json:"phone"`
	IsMainBranch pgtype.Bool `json:"is_main_branch"`
	AddressID    int64       `json:"address_id"`
	Status       int64       `json:"status"`
}

func (q *Queries) CreateBankBranch(ctx context.Context, arg CreateBankBranchParams) (BankBranch, error) {
	row := q.db.QueryRow(ctx, createBankBranch,
		arg.BankID,
		arg.BranchName,
		arg.Phone,
		arg.IsMainBranch,
		arg.AddressID,
		arg.Status,
	)
	var i BankBranch
	err := row.Scan(
		&i.ID,
		&i.BankID,
		&i.BranchName,
		&i.Phone,
		&i.IsMainBranch,
		&i.AddressID,
		&i.Status,
	)
	return i, err
}

const getAllBanks = `-- name: GetAllBanks :many
SELECT id, bank_name, bank_logo_url, created_at FROM banks
`

func (q *Queries) GetAllBanks(ctx context.Context) ([]Bank, error) {
	rows, err := q.db.Query(ctx, getAllBanks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bank
	for rows.Next() {
		var i Bank
		if err := rows.Scan(
			&i.ID,
			&i.BankName,
			&i.BankLogoUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBank = `-- name: GetBank :one
SELECT 
    bank_listing.id, bank_listing.name, bank_listing.bank_logo_url, bank_listing.bank_url, bank_listing.fixed_interest_rate, bank_listing.bank_process_fee, bank_listing.mail, bank_listing.created_by, bank_listing.created_at, bank_listing.updated_at, bank_listing.status, bank_listing.country_id,countries.country
FROM bank_listing
JOIN countries ON countries.id=bank_listing.country_id
WHERE bank_listing.id= $1
`

type GetBankRow struct {
	BankListing BankListing `json:"bank_listing"`
	Country     string      `json:"country"`
}

func (q *Queries) GetBank(ctx context.Context, id int64) (GetBankRow, error) {
	row := q.db.QueryRow(ctx, getBank, id)
	var i GetBankRow
	err := row.Scan(
		&i.BankListing.ID,
		&i.BankListing.Name,
		&i.BankListing.BankLogoUrl,
		&i.BankListing.BankUrl,
		&i.BankListing.FixedInterestRate,
		&i.BankListing.BankProcessFee,
		&i.BankListing.Mail,
		&i.BankListing.CreatedBy,
		&i.BankListing.CreatedAt,
		&i.BankListing.UpdatedAt,
		&i.BankListing.Status,
		&i.BankListing.CountryID,
		&i.Country,
	)
	return i, err
}

const getBankBranch = `-- name: GetBankBranch :one
SELECT 
    bank_branches.id, bank_branches.bank_id, bank_branches.branch_name, bank_branches.phone, bank_branches.is_main_branch, bank_branches.address_id, bank_branches.status, addresses.id, addresses.countries_id, addresses.states_id, addresses.cities_id, addresses.communities_id, addresses.sub_communities_id, addresses.locations_id, addresses.created_at, addresses.updated_at, addresses.property_map_location_id, addresses.full_address, addresses.full_address_ar,
    coalesce(locations.lat,''::varchar)::varchar as "lat",
    coalesce(locations.lng,''::varchar)::varchar as "lng",
    coalesce(states.state,''::varchar)::varchar as "state",
    coalesce(cities.city,''::varchar)::varchar as "city",
    coalesce(communities.community,''::varchar)::varchar as "community",
    coalesce(sub_communities.sub_community,''::varchar)::varchar as "sub_community"

FROM bank_branches
JOIN addresses ON addresses.id=bank_branches.address_id 
LEFT JOIN locations ON locations.id=addresses.locations_id
LEFT JOIN states ON addresses.states_id = states.id
LEFT JOIN cities ON addresses.cities_id = cities.id
LEFT JOIN communities ON addresses.communities_id = communities.id
LEFT JOIN sub_communities ON addresses.sub_communities_id = sub_communities.id
WHERE bank_branches.id= $1
`

type GetBankBranchRow struct {
	BankBranch   BankBranch `json:"bank_branch"`
	Address      Address    `json:"address"`
	Lat          string     `json:"lat"`
	Lng          string     `json:"lng"`
	State        string     `json:"state"`
	City         string     `json:"city"`
	Community    string     `json:"community"`
	SubCommunity string     `json:"sub_community"`
}

func (q *Queries) GetBankBranch(ctx context.Context, id int64) (GetBankBranchRow, error) {
	row := q.db.QueryRow(ctx, getBankBranch, id)
	var i GetBankBranchRow
	err := row.Scan(
		&i.BankBranch.ID,
		&i.BankBranch.BankID,
		&i.BankBranch.BranchName,
		&i.BankBranch.Phone,
		&i.BankBranch.IsMainBranch,
		&i.BankBranch.AddressID,
		&i.BankBranch.Status,
		&i.Address.ID,
		&i.Address.CountriesID,
		&i.Address.StatesID,
		&i.Address.CitiesID,
		&i.Address.CommunitiesID,
		&i.Address.SubCommunitiesID,
		&i.Address.LocationsID,
		&i.Address.CreatedAt,
		&i.Address.UpdatedAt,
		&i.Address.PropertyMapLocationID,
		&i.Address.FullAddress,
		&i.Address.FullAddressAr,
		&i.Lat,
		&i.Lng,
		&i.State,
		&i.City,
		&i.Community,
		&i.SubCommunity,
	)
	return i, err
}

const getBankBranchesByStatus = `-- name: GetBankBranchesByStatus :many
SELECT
	bank_branches.id, bank_branches.bank_id, bank_branches.branch_name, bank_branches.phone, bank_branches.is_main_branch, bank_branches.address_id, bank_branches.status,
	addresses.full_address,
	bank_listing."name"
FROM bank_branches
JOIN addresses ON addresses.id=bank_branches.address_id 
JOIN bank_listing ON bank_listing.id=bank_branches.bank_id AND bank_listing.status=1
WHERE bank_branches.status=$1 AND bank_listing.id=$2
ORDER BY bank_branches.id DESC
LIMIT $4
OFFSET $3
`

type GetBankBranchesByStatusParams struct {
	Status int64       `json:"status"`
	ID     int64       `json:"id"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetBankBranchesByStatusRow struct {
	BankBranch  BankBranch  `json:"bank_branch"`
	FullAddress pgtype.Text `json:"full_address"`
	Name        string      `json:"name"`
}

func (q *Queries) GetBankBranchesByStatus(ctx context.Context, arg GetBankBranchesByStatusParams) ([]GetBankBranchesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getBankBranchesByStatus,
		arg.Status,
		arg.ID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBankBranchesByStatusRow
	for rows.Next() {
		var i GetBankBranchesByStatusRow
		if err := rows.Scan(
			&i.BankBranch.ID,
			&i.BankBranch.BankID,
			&i.BankBranch.BranchName,
			&i.BankBranch.Phone,
			&i.BankBranch.IsMainBranch,
			&i.BankBranch.AddressID,
			&i.BankBranch.Status,
			&i.FullAddress,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBankBranchesCountByStatus = `-- name: GetBankBranchesCountByStatus :one
SELECT
	count(bank_branches.id)
FROM bank_branches
JOIN addresses ON addresses.id=bank_branches.address_id 
JOIN bank_listing ON bank_listing.id=bank_branches.bank_id AND bank_listing.status=1
WHERE bank_branches.status=$1 AND bank_listing.id=$2
`

type GetBankBranchesCountByStatusParams struct {
	Status int64 `json:"status"`
	ID     int64 `json:"id"`
}

func (q *Queries) GetBankBranchesCountByStatus(ctx context.Context, arg GetBankBranchesCountByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, getBankBranchesCountByStatus, arg.Status, arg.ID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBankById = `-- name: GetBankById :one
SELECT id, bank_name, bank_logo_url, created_at FROM banks WHERE id = $1
`

func (q *Queries) GetBankById(ctx context.Context, id int64) (Bank, error) {
	row := q.db.QueryRow(ctx, getBankById, id)
	var i Bank
	err := row.Scan(
		&i.ID,
		&i.BankName,
		&i.BankLogoUrl,
		&i.CreatedAt,
	)
	return i, err
}

const getBanksByStatus = `-- name: GetBanksByStatus :many
SELECT 
bank_listing.id, bank_listing.name, bank_listing.bank_logo_url, bank_listing.bank_url, bank_listing.fixed_interest_rate, bank_listing.bank_process_fee, bank_listing.mail, bank_listing.created_by, bank_listing.created_at, bank_listing.updated_at, bank_listing.status, bank_listing.country_id,countries.country
FROM bank_listing
JOIN countries ON countries.id=bank_listing.country_id
WHERE bank_listing.status= $1
ORDER BY updated_at DESC
LIMIT $3
OFFSET $2
`

type GetBanksByStatusParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetBanksByStatusRow struct {
	BankListing BankListing `json:"bank_listing"`
	Country     string      `json:"country"`
}

func (q *Queries) GetBanksByStatus(ctx context.Context, arg GetBanksByStatusParams) ([]GetBanksByStatusRow, error) {
	rows, err := q.db.Query(ctx, getBanksByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBanksByStatusRow
	for rows.Next() {
		var i GetBanksByStatusRow
		if err := rows.Scan(
			&i.BankListing.ID,
			&i.BankListing.Name,
			&i.BankListing.BankLogoUrl,
			&i.BankListing.BankUrl,
			&i.BankListing.FixedInterestRate,
			&i.BankListing.BankProcessFee,
			&i.BankListing.Mail,
			&i.BankListing.CreatedBy,
			&i.BankListing.CreatedAt,
			&i.BankListing.UpdatedAt,
			&i.BankListing.Status,
			&i.BankListing.CountryID,
			&i.Country,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBanksCountByStatus = `-- name: GetBanksCountByStatus :one
SELECT 
    count(bank_listing.id)
FROM bank_listing
WHERE bank_listing.status= $1
`

func (q *Queries) GetBanksCountByStatus(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getBanksCountByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateBank = `-- name: UpdateBank :one
UPDATE bank_listing
SET
    name=$1,
    bank_logo_url=$2,
    bank_url=$3,
    fixed_interest_rate=$4,
    bank_process_fee=$5,
    mail=$6,
    updated_at=$7,
    country_id=$8
WHERE 
    id=$9
RETURNING id, name, bank_logo_url, bank_url, fixed_interest_rate, bank_process_fee, mail, created_by, created_at, updated_at, status, country_id
`

type UpdateBankParams struct {
	Name              string    `json:"name"`
	BankLogoUrl       string    `json:"bank_logo_url"`
	BankUrl           string    `json:"bank_url"`
	FixedInterestRate float64   `json:"fixed_interest_rate"`
	BankProcessFee    float64   `json:"bank_process_fee"`
	Mail              string    `json:"mail"`
	UpdatedAt         time.Time `json:"updated_at"`
	CountryID         int64     `json:"country_id"`
	ID                int64     `json:"id"`
}

func (q *Queries) UpdateBank(ctx context.Context, arg UpdateBankParams) (BankListing, error) {
	row := q.db.QueryRow(ctx, updateBank,
		arg.Name,
		arg.BankLogoUrl,
		arg.BankUrl,
		arg.FixedInterestRate,
		arg.BankProcessFee,
		arg.Mail,
		arg.UpdatedAt,
		arg.CountryID,
		arg.ID,
	)
	var i BankListing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BankLogoUrl,
		&i.BankUrl,
		&i.FixedInterestRate,
		&i.BankProcessFee,
		&i.Mail,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CountryID,
	)
	return i, err
}

const updateBankBranch = `-- name: UpdateBankBranch :one
UPDATE bank_branches
SET
    phone=$2,
    is_main_branch=$3,
    address_id=$4,
    branch_name=$5,
    bank_id=$6
WHERE id=$1
RETURNING id, bank_id, branch_name, phone, is_main_branch, address_id, status
`

type UpdateBankBranchParams struct {
	ID           int64       `json:"id"`
	Phone        string      `json:"phone"`
	IsMainBranch pgtype.Bool `json:"is_main_branch"`
	AddressID    int64       `json:"address_id"`
	BranchName   string      `json:"branch_name"`
	BankID       int64       `json:"bank_id"`
}

func (q *Queries) UpdateBankBranch(ctx context.Context, arg UpdateBankBranchParams) (BankBranch, error) {
	row := q.db.QueryRow(ctx, updateBankBranch,
		arg.ID,
		arg.Phone,
		arg.IsMainBranch,
		arg.AddressID,
		arg.BranchName,
		arg.BankID,
	)
	var i BankBranch
	err := row.Scan(
		&i.ID,
		&i.BankID,
		&i.BranchName,
		&i.Phone,
		&i.IsMainBranch,
		&i.AddressID,
		&i.Status,
	)
	return i, err
}

const updateBankBranchStatus = `-- name: UpdateBankBranchStatus :one
UPDATE bank_branches
SET
    status=$1
WHERE 
    id=$2
RETURNING id, bank_id, branch_name, phone, is_main_branch, address_id, status
`

type UpdateBankBranchStatusParams struct {
	Status int64 `json:"status"`
	ID     int64 `json:"id"`
}

func (q *Queries) UpdateBankBranchStatus(ctx context.Context, arg UpdateBankBranchStatusParams) (BankBranch, error) {
	row := q.db.QueryRow(ctx, updateBankBranchStatus, arg.Status, arg.ID)
	var i BankBranch
	err := row.Scan(
		&i.ID,
		&i.BankID,
		&i.BranchName,
		&i.Phone,
		&i.IsMainBranch,
		&i.AddressID,
		&i.Status,
	)
	return i, err
}

const updateBankMainBranch = `-- name: UpdateBankMainBranch :one
UPDATE bank_branches
SET
    is_main_branch=$1
WHERE 
    id=$2
RETURNING id, bank_id, branch_name, phone, is_main_branch, address_id, status
`

type UpdateBankMainBranchParams struct {
	IsMainBranch pgtype.Bool `json:"is_main_branch"`
	ID           int64       `json:"id"`
}

func (q *Queries) UpdateBankMainBranch(ctx context.Context, arg UpdateBankMainBranchParams) (BankBranch, error) {
	row := q.db.QueryRow(ctx, updateBankMainBranch, arg.IsMainBranch, arg.ID)
	var i BankBranch
	err := row.Scan(
		&i.ID,
		&i.BankID,
		&i.BranchName,
		&i.Phone,
		&i.IsMainBranch,
		&i.AddressID,
		&i.Status,
	)
	return i, err
}

const updateBankStatus = `-- name: UpdateBankStatus :one
UPDATE bank_listing
SET
    status=$1
WHERE 
    id=$2
RETURNING id, name, bank_logo_url, bank_url, fixed_interest_rate, bank_process_fee, mail, created_by, created_at, updated_at, status, country_id
`

type UpdateBankStatusParams struct {
	Status int64 `json:"status"`
	ID     int64 `json:"id"`
}

func (q *Queries) UpdateBankStatus(ctx context.Context, arg UpdateBankStatusParams) (BankListing, error) {
	row := q.db.QueryRow(ctx, updateBankStatus, arg.Status, arg.ID)
	var i BankListing
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BankLogoUrl,
		&i.BankUrl,
		&i.FixedInterestRate,
		&i.BankProcessFee,
		&i.Mail,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CountryID,
	)
	return i, err
}
