// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: properties_facts.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPropertyFact = `-- name: CreatePropertyFact :one
INSERT INTO properties_facts (
 bedroom,   
 bathroom, 
 plot_area,  
 built_up_area, 
 view, 
 furnished, 
 ownership,  
 completion_status, 
 start_date, 
 completion_date,  
 handover_date,  
 no_of_floor,  
 no_of_units, 
 min_area,  
 max_area,  
 service_charge,  
 parking,  
 ask_price,  
 price , 
 rent_type,  
 no_of_payment,  
 no_of_retail, 
 no_of_pool, 
 elevator, 
 starting_price ,
 life_style,  
 properties_id,  
 property,  
 is_branch ,
 created_at,  
 updated_at,
 available_units,
 is_project_fact,
 project_id,
 completion_percentage,
 completion_percentage_date,
 type_name_id,
 sc_currency_id,
 unit_of_measure
)VALUES (
     $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,$21,$22,$23,$24,$25,$26,$27,$28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39
) RETURNING id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, created_at, updated_at, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure
`

type CreatePropertyFactParams struct {
	Bedroom                  pgtype.Text        `json:"bedroom"`
	Bathroom                 pgtype.Int8        `json:"bathroom"`
	PlotArea                 pgtype.Float8      `json:"plot_area"`
	BuiltUpArea              pgtype.Float8      `json:"built_up_area"`
	View                     []int64            `json:"view"`
	Furnished                pgtype.Int8        `json:"furnished"`
	Ownership                pgtype.Int8        `json:"ownership"`
	CompletionStatus         pgtype.Int8        `json:"completion_status"`
	StartDate                pgtype.Timestamptz `json:"start_date"`
	CompletionDate           pgtype.Timestamptz `json:"completion_date"`
	HandoverDate             pgtype.Timestamptz `json:"handover_date"`
	NoOfFloor                pgtype.Int8        `json:"no_of_floor"`
	NoOfUnits                pgtype.Int8        `json:"no_of_units"`
	MinArea                  pgtype.Float8      `json:"min_area"`
	MaxArea                  pgtype.Float8      `json:"max_area"`
	ServiceCharge            pgtype.Int8        `json:"service_charge"`
	Parking                  pgtype.Int8        `json:"parking"`
	AskPrice                 pgtype.Bool        `json:"ask_price"`
	Price                    pgtype.Float8      `json:"price"`
	RentType                 pgtype.Int8        `json:"rent_type"`
	NoOfPayment              pgtype.Int8        `json:"no_of_payment"`
	NoOfRetail               pgtype.Int8        `json:"no_of_retail"`
	NoOfPool                 pgtype.Int8        `json:"no_of_pool"`
	Elevator                 pgtype.Int8        `json:"elevator"`
	StartingPrice            pgtype.Int8        `json:"starting_price"`
	LifeStyle                pgtype.Int8        `json:"life_style"`
	PropertiesID             pgtype.Int8        `json:"properties_id"`
	Property                 int64              `json:"property"`
	IsBranch                 pgtype.Bool        `json:"is_branch"`
	CreatedAt                time.Time          `json:"created_at"`
	UpdatedAt                time.Time          `json:"updated_at"`
	AvailableUnits           pgtype.Int8        `json:"available_units"`
	IsProjectFact            pgtype.Bool        `json:"is_project_fact"`
	ProjectID                pgtype.Int8        `json:"project_id"`
	CompletionPercentage     pgtype.Int8        `json:"completion_percentage"`
	CompletionPercentageDate pgtype.Timestamptz `json:"completion_percentage_date"`
	TypeNameID               pgtype.Int8        `json:"type_name_id"`
	ScCurrencyID             pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure            pgtype.Text        `json:"unit_of_measure"`
}

func (q *Queries) CreatePropertyFact(ctx context.Context, arg CreatePropertyFactParams) (PropertiesFact, error) {
	row := q.db.QueryRow(ctx, createPropertyFact,
		arg.Bedroom,
		arg.Bathroom,
		arg.PlotArea,
		arg.BuiltUpArea,
		arg.View,
		arg.Furnished,
		arg.Ownership,
		arg.CompletionStatus,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.NoOfFloor,
		arg.NoOfUnits,
		arg.MinArea,
		arg.MaxArea,
		arg.ServiceCharge,
		arg.Parking,
		arg.AskPrice,
		arg.Price,
		arg.RentType,
		arg.NoOfPayment,
		arg.NoOfRetail,
		arg.NoOfPool,
		arg.Elevator,
		arg.StartingPrice,
		arg.LifeStyle,
		arg.PropertiesID,
		arg.Property,
		arg.IsBranch,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AvailableUnits,
		arg.IsProjectFact,
		arg.ProjectID,
		arg.CompletionPercentage,
		arg.CompletionPercentageDate,
		arg.TypeNameID,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
	)
	var i PropertiesFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.PropertiesID,
		&i.Property,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableUnits,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.IsProjectFact,
		&i.ProjectID,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.TypeNameID,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}

const deletePropertyFact = `-- name: DeletePropertyFact :exec
DELETE FROM properties_facts
Where id = $1
`

func (q *Queries) DeletePropertyFact(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePropertyFact, id)
	return err
}

const getAllConsumeFactsCountByProjectId = `-- name: GetAllConsumeFactsCountByProjectId :one
SELECT COALESCE(SUM(plot_area),0)::bigint AS plot_area_consume,COALESCE(SUM(built_up_area),0)::bigint AS built_up_area_consume,COUNT(project_properties.id) AS properties_consume
FROM properties_facts
LEFT JOIN project_properties ON project_properties.id = properties_facts.properties_id AND properties_facts.property = 1
WHERE project_properties.projects_id = $1 AND project_properties.phases_id IS NULL AND (project_properties.status != 5 AND project_properties.status != 6)
`

type GetAllConsumeFactsCountByProjectIdRow struct {
	PlotAreaConsume    int64 `json:"plot_area_consume"`
	BuiltUpAreaConsume int64 `json:"built_up_area_consume"`
	PropertiesConsume  int64 `json:"properties_consume"`
}

func (q *Queries) GetAllConsumeFactsCountByProjectId(ctx context.Context, projectsID int64) (GetAllConsumeFactsCountByProjectIdRow, error) {
	row := q.db.QueryRow(ctx, getAllConsumeFactsCountByProjectId, projectsID)
	var i GetAllConsumeFactsCountByProjectIdRow
	err := row.Scan(&i.PlotAreaConsume, &i.BuiltUpAreaConsume, &i.PropertiesConsume)
	return i, err
}

const getAllPropertyFact = `-- name: GetAllPropertyFact :many
SELECT id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, created_at, updated_at, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure FROM properties_facts
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllPropertyFactParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPropertyFact(ctx context.Context, arg GetAllPropertyFactParams) ([]PropertiesFact, error) {
	rows, err := q.db.Query(ctx, getAllPropertyFact, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertiesFact
	for rows.Next() {
		var i PropertiesFact
		if err := rows.Scan(
			&i.ID,
			&i.Bedroom,
			&i.Bathroom,
			&i.PlotArea,
			&i.BuiltUpArea,
			&i.View,
			&i.Furnished,
			&i.Ownership,
			&i.CompletionStatus,
			&i.StartDate,
			&i.CompletionDate,
			&i.HandoverDate,
			&i.NoOfFloor,
			&i.NoOfUnits,
			&i.MinArea,
			&i.MaxArea,
			&i.ServiceCharge,
			&i.Parking,
			&i.AskPrice,
			&i.Price,
			&i.RentType,
			&i.NoOfPayment,
			&i.NoOfRetail,
			&i.NoOfPool,
			&i.Elevator,
			&i.StartingPrice,
			&i.LifeStyle,
			&i.PropertiesID,
			&i.Property,
			&i.IsBranch,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AvailableUnits,
			&i.CommercialTax,
			&i.MunicipalityTax,
			&i.IsProjectFact,
			&i.ProjectID,
			&i.CompletionPercentage,
			&i.CompletionPercentageDate,
			&i.TypeNameID,
			&i.ScCurrencyID,
			&i.UnitOfMeasure,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectFacts = `-- name: GetProjectFacts :one
SELECT id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, created_at, updated_at, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure FROM properties_facts WHERE  is_project_fact = TRUE AND project_id = $1
`

func (q *Queries) GetProjectFacts(ctx context.Context, projectID pgtype.Int8) (PropertiesFact, error) {
	row := q.db.QueryRow(ctx, getProjectFacts, projectID)
	var i PropertiesFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.PropertiesID,
		&i.Property,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableUnits,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.IsProjectFact,
		&i.ProjectID,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.TypeNameID,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}

const getPropertyFact = `-- name: GetPropertyFact :one
SELECT id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, created_at, updated_at, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure FROM properties_facts 
WHERE id = $1
`

func (q *Queries) GetPropertyFact(ctx context.Context, id int64) (PropertiesFact, error) {
	row := q.db.QueryRow(ctx, getPropertyFact, id)
	var i PropertiesFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.PropertiesID,
		&i.Property,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableUnits,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.IsProjectFact,
		&i.ProjectID,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.TypeNameID,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}

const getPropertyFactsByProperties = `-- name: GetPropertyFactsByProperties :one
SELECT id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, created_at, updated_at, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure FROM properties_facts 
WHERE properties_facts.properties_id = $1 AND properties_facts.property = $2 AND properties_facts.is_branch = $3
`

type GetPropertyFactsByPropertiesParams struct {
	PropertiesID pgtype.Int8 `json:"properties_id"`
	Property     int64       `json:"property"`
	IsBranch     pgtype.Bool `json:"is_branch"`
}

func (q *Queries) GetPropertyFactsByProperties(ctx context.Context, arg GetPropertyFactsByPropertiesParams) (PropertiesFact, error) {
	row := q.db.QueryRow(ctx, getPropertyFactsByProperties, arg.PropertiesID, arg.Property, arg.IsBranch)
	var i PropertiesFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.PropertiesID,
		&i.Property,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableUnits,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.IsProjectFact,
		&i.ProjectID,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.TypeNameID,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}

const updateCompletionPercentageAndDateForProperties = `-- name: UpdateCompletionPercentageAndDateForProperties :exec
UPDATE properties_facts
SET updated_at = $2,
completion_percentage = $3,
completion_percentage_date = $4
Where project_id = $1 AND property = 1 AND is_project_fact = FALSE
`

type UpdateCompletionPercentageAndDateForPropertiesParams struct {
	ProjectID                pgtype.Int8        `json:"project_id"`
	UpdatedAt                time.Time          `json:"updated_at"`
	CompletionPercentage     pgtype.Int8        `json:"completion_percentage"`
	CompletionPercentageDate pgtype.Timestamptz `json:"completion_percentage_date"`
}

func (q *Queries) UpdateCompletionPercentageAndDateForProperties(ctx context.Context, arg UpdateCompletionPercentageAndDateForPropertiesParams) error {
	_, err := q.db.Exec(ctx, updateCompletionPercentageAndDateForProperties,
		arg.ProjectID,
		arg.UpdatedAt,
		arg.CompletionPercentage,
		arg.CompletionPercentageDate,
	)
	return err
}

const updatePropertyFact = `-- name: UpdatePropertyFact :one
UPDATE properties_facts
SET  bedroom = $2,  
bathroom = $3, 
plot_area = $4,  
built_up_area = $5, 
view = $6, 
furnished = $7, 
ownership = $8,  
completion_status = $9, 
start_date = $10, 
completion_date = $11,  
handover_date = $12,  
no_of_floor = $13,  
no_of_units = $14, 
min_area = $15,  
max_area = $16,  
service_charge = $17,  
parking = $18,  
ask_price = $19,  
price = $20, 
rent_type = $21,  
no_of_payment = $22,  
no_of_retail = $23, 
no_of_pool = $24, 
elevator = $25, 
starting_price = $26,
life_style = $27,  
properties_id = $28,  
property = $29,  
is_branch = $30,
created_at = $31,  
updated_at = $32,
available_units = $33,
is_project_fact = $34,
project_id = $35,
completion_percentage = $36,
completion_percentage_date = $37,
type_name_id = $38,
sc_currency_id = $39,
unit_of_measure = $40
Where id = $1
RETURNING id, bedroom, bathroom, plot_area, built_up_area, view, furnished, ownership, completion_status, start_date, completion_date, handover_date, no_of_floor, no_of_units, min_area, max_area, service_charge, parking, ask_price, price, rent_type, no_of_payment, no_of_retail, no_of_pool, elevator, starting_price, life_style, properties_id, property, is_branch, created_at, updated_at, available_units, commercial_tax, municipality_tax, is_project_fact, project_id, completion_percentage, completion_percentage_date, type_name_id, sc_currency_id, unit_of_measure
`

type UpdatePropertyFactParams struct {
	ID                       int64              `json:"id"`
	Bedroom                  pgtype.Text        `json:"bedroom"`
	Bathroom                 pgtype.Int8        `json:"bathroom"`
	PlotArea                 pgtype.Float8      `json:"plot_area"`
	BuiltUpArea              pgtype.Float8      `json:"built_up_area"`
	View                     []int64            `json:"view"`
	Furnished                pgtype.Int8        `json:"furnished"`
	Ownership                pgtype.Int8        `json:"ownership"`
	CompletionStatus         pgtype.Int8        `json:"completion_status"`
	StartDate                pgtype.Timestamptz `json:"start_date"`
	CompletionDate           pgtype.Timestamptz `json:"completion_date"`
	HandoverDate             pgtype.Timestamptz `json:"handover_date"`
	NoOfFloor                pgtype.Int8        `json:"no_of_floor"`
	NoOfUnits                pgtype.Int8        `json:"no_of_units"`
	MinArea                  pgtype.Float8      `json:"min_area"`
	MaxArea                  pgtype.Float8      `json:"max_area"`
	ServiceCharge            pgtype.Int8        `json:"service_charge"`
	Parking                  pgtype.Int8        `json:"parking"`
	AskPrice                 pgtype.Bool        `json:"ask_price"`
	Price                    pgtype.Float8      `json:"price"`
	RentType                 pgtype.Int8        `json:"rent_type"`
	NoOfPayment              pgtype.Int8        `json:"no_of_payment"`
	NoOfRetail               pgtype.Int8        `json:"no_of_retail"`
	NoOfPool                 pgtype.Int8        `json:"no_of_pool"`
	Elevator                 pgtype.Int8        `json:"elevator"`
	StartingPrice            pgtype.Int8        `json:"starting_price"`
	LifeStyle                pgtype.Int8        `json:"life_style"`
	PropertiesID             pgtype.Int8        `json:"properties_id"`
	Property                 int64              `json:"property"`
	IsBranch                 pgtype.Bool        `json:"is_branch"`
	CreatedAt                time.Time          `json:"created_at"`
	UpdatedAt                time.Time          `json:"updated_at"`
	AvailableUnits           pgtype.Int8        `json:"available_units"`
	IsProjectFact            pgtype.Bool        `json:"is_project_fact"`
	ProjectID                pgtype.Int8        `json:"project_id"`
	CompletionPercentage     pgtype.Int8        `json:"completion_percentage"`
	CompletionPercentageDate pgtype.Timestamptz `json:"completion_percentage_date"`
	TypeNameID               pgtype.Int8        `json:"type_name_id"`
	ScCurrencyID             pgtype.Int8        `json:"sc_currency_id"`
	UnitOfMeasure            pgtype.Text        `json:"unit_of_measure"`
}

func (q *Queries) UpdatePropertyFact(ctx context.Context, arg UpdatePropertyFactParams) (PropertiesFact, error) {
	row := q.db.QueryRow(ctx, updatePropertyFact,
		arg.ID,
		arg.Bedroom,
		arg.Bathroom,
		arg.PlotArea,
		arg.BuiltUpArea,
		arg.View,
		arg.Furnished,
		arg.Ownership,
		arg.CompletionStatus,
		arg.StartDate,
		arg.CompletionDate,
		arg.HandoverDate,
		arg.NoOfFloor,
		arg.NoOfUnits,
		arg.MinArea,
		arg.MaxArea,
		arg.ServiceCharge,
		arg.Parking,
		arg.AskPrice,
		arg.Price,
		arg.RentType,
		arg.NoOfPayment,
		arg.NoOfRetail,
		arg.NoOfPool,
		arg.Elevator,
		arg.StartingPrice,
		arg.LifeStyle,
		arg.PropertiesID,
		arg.Property,
		arg.IsBranch,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AvailableUnits,
		arg.IsProjectFact,
		arg.ProjectID,
		arg.CompletionPercentage,
		arg.CompletionPercentageDate,
		arg.TypeNameID,
		arg.ScCurrencyID,
		arg.UnitOfMeasure,
	)
	var i PropertiesFact
	err := row.Scan(
		&i.ID,
		&i.Bedroom,
		&i.Bathroom,
		&i.PlotArea,
		&i.BuiltUpArea,
		&i.View,
		&i.Furnished,
		&i.Ownership,
		&i.CompletionStatus,
		&i.StartDate,
		&i.CompletionDate,
		&i.HandoverDate,
		&i.NoOfFloor,
		&i.NoOfUnits,
		&i.MinArea,
		&i.MaxArea,
		&i.ServiceCharge,
		&i.Parking,
		&i.AskPrice,
		&i.Price,
		&i.RentType,
		&i.NoOfPayment,
		&i.NoOfRetail,
		&i.NoOfPool,
		&i.Elevator,
		&i.StartingPrice,
		&i.LifeStyle,
		&i.PropertiesID,
		&i.Property,
		&i.IsBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AvailableUnits,
		&i.CommercialTax,
		&i.MunicipalityTax,
		&i.IsProjectFact,
		&i.ProjectID,
		&i.CompletionPercentage,
		&i.CompletionPercentageDate,
		&i.TypeNameID,
		&i.ScCurrencyID,
		&i.UnitOfMeasure,
	)
	return i, err
}
