// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_properties_documents.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProjectPropertyDocument = `-- name: CreateProjectPropertyDocument :one
INSERT INTO project_properties_documents (
    documents_category_id,
    documents_subcategory_id,
    file_url,
    created_at,
    updated_at,
    project_properties_id,
    status
)VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, documents_category_id, documents_subcategory_id, file_url, created_at, updated_at, project_properties_id, status
`

type CreateProjectPropertyDocumentParams struct {
	DocumentsCategoryID    int64     `json:"documents_category_id"`
	DocumentsSubcategoryID int64     `json:"documents_subcategory_id"`
	FileUrl                []string  `json:"file_url"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
	ProjectPropertiesID    int64     `json:"project_properties_id"`
	Status                 int64     `json:"status"`
}

func (q *Queries) CreateProjectPropertyDocument(ctx context.Context, arg CreateProjectPropertyDocumentParams) (ProjectPropertiesDocument, error) {
	row := q.db.QueryRow(ctx, createProjectPropertyDocument,
		arg.DocumentsCategoryID,
		arg.DocumentsSubcategoryID,
		arg.FileUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProjectPropertiesID,
		arg.Status,
	)
	var i ProjectPropertiesDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectPropertiesID,
		&i.Status,
	)
	return i, err
}

const deleteProjectPropertyDocument = `-- name: DeleteProjectPropertyDocument :exec
DELETE FROM project_properties_documents
Where id = $1
`

func (q *Queries) DeleteProjectPropertyDocument(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectPropertyDocument, id)
	return err
}

const getAllDocsByProjectPropertyIDWithOutPagination = `-- name: GetAllDocsByProjectPropertyIDWithOutPagination :many
SELECT project_properties_documents.id, project_properties_documents.documents_category_id, project_properties_documents.documents_subcategory_id, project_properties_documents.file_url, project_properties_documents.created_at, project_properties_documents.updated_at, project_properties_documents.project_properties_id, project_properties_documents.status, documents_category.category,documents_category.category_ar,documents_subcategory.sub_category FROM project_properties_documents 
LEFT JOIN documents_category ON documents_category.id = project_properties_documents.documents_category_id 
LEFT JOIN documents_subcategory ON documents_subcategory.id = project_properties_documents.documents_subcategory_id 
WHERE project_properties_documents.project_properties_id = $1
`

type GetAllDocsByProjectPropertyIDWithOutPaginationRow struct {
	ID                     int64       `json:"id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                []string    `json:"file_url"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	ProjectPropertiesID    int64       `json:"project_properties_id"`
	Status                 int64       `json:"status"`
	Category               pgtype.Text `json:"category"`
	CategoryAr             pgtype.Text `json:"category_ar"`
	SubCategory            pgtype.Text `json:"sub_category"`
}

func (q *Queries) GetAllDocsByProjectPropertyIDWithOutPagination(ctx context.Context, projectPropertiesID int64) ([]GetAllDocsByProjectPropertyIDWithOutPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllDocsByProjectPropertyIDWithOutPagination, projectPropertiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDocsByProjectPropertyIDWithOutPaginationRow
	for rows.Next() {
		var i GetAllDocsByProjectPropertyIDWithOutPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentsCategoryID,
			&i.DocumentsSubcategoryID,
			&i.FileUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectPropertiesID,
			&i.Status,
			&i.Category,
			&i.CategoryAr,
			&i.SubCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDocsByProjectPropertyUnitByIDWithOutPagination = `-- name: GetAllDocsByProjectPropertyUnitByIDWithOutPagination :many
SELECT units_documents.id, units_documents.documents_category_id, units_documents.documents_subcategory_id, units_documents.file_url, units_documents.units_id, units_documents.status, units_documents.created_at, units_documents.updated_at, documents_category.category,documents_category.category_ar,documents_subcategory.sub_category FROM units_documents 
LEFT JOIN documents_category ON documents_category.id = units_documents.documents_category_id 
LEFT JOIN documents_subcategory ON documents_subcategory.id = units_documents.documents_subcategory_id 
WHERE units_documents.units_id = $1
`

type GetAllDocsByProjectPropertyUnitByIDWithOutPaginationRow struct {
	ID                     int64       `json:"id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                []string    `json:"file_url"`
	UnitsID                int64       `json:"units_id"`
	Status                 int64       `json:"status"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	Category               pgtype.Text `json:"category"`
	CategoryAr             pgtype.Text `json:"category_ar"`
	SubCategory            pgtype.Text `json:"sub_category"`
}

func (q *Queries) GetAllDocsByProjectPropertyUnitByIDWithOutPagination(ctx context.Context, unitsID int64) ([]GetAllDocsByProjectPropertyUnitByIDWithOutPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllDocsByProjectPropertyUnitByIDWithOutPagination, unitsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDocsByProjectPropertyUnitByIDWithOutPaginationRow
	for rows.Next() {
		var i GetAllDocsByProjectPropertyUnitByIDWithOutPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentsCategoryID,
			&i.DocumentsSubcategoryID,
			&i.FileUrl,
			&i.UnitsID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Category,
			&i.CategoryAr,
			&i.SubCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertyDocByProjectPropertyId = `-- name: GetAllProjectPropertyDocByProjectPropertyId :many
SELECT project_properties_documents.id, 
project_properties_documents.documents_category_id,
 project_properties_documents.documents_subcategory_id,
  project_properties_documents.file_url,
   project_properties_documents.created_at,
    project_properties_documents.updated_at, project_properties_documents.project_properties_id,
     project_properties_documents.status, documents_category.category,documents_category.category_ar,
     documents_subcategory.sub_category 
FROM project_properties_documents 
LEFT JOIN documents_category ON documents_category.id = project_properties_documents.documents_category_id 
LEFT JOIN documents_subcategory ON documents_subcategory.id = project_properties_documents.documents_subcategory_id 
WHERE project_properties_documents.project_properties_id = $3 LIMIT $1 OFFSET $2
`

type GetAllProjectPropertyDocByProjectPropertyIdParams struct {
	Limit               int32 `json:"limit"`
	Offset              int32 `json:"offset"`
	ProjectPropertiesID int64 `json:"project_properties_id"`
}

type GetAllProjectPropertyDocByProjectPropertyIdRow struct {
	ID                     int64       `json:"id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                []string    `json:"file_url"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	ProjectPropertiesID    int64       `json:"project_properties_id"`
	Status                 int64       `json:"status"`
	Category               pgtype.Text `json:"category"`
	CategoryAr             pgtype.Text `json:"category_ar"`
	SubCategory            pgtype.Text `json:"sub_category"`
}

func (q *Queries) GetAllProjectPropertyDocByProjectPropertyId(ctx context.Context, arg GetAllProjectPropertyDocByProjectPropertyIdParams) ([]GetAllProjectPropertyDocByProjectPropertyIdRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertyDocByProjectPropertyId, arg.Limit, arg.Offset, arg.ProjectPropertiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPropertyDocByProjectPropertyIdRow
	for rows.Next() {
		var i GetAllProjectPropertyDocByProjectPropertyIdRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentsCategoryID,
			&i.DocumentsSubcategoryID,
			&i.FileUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectPropertiesID,
			&i.Status,
			&i.Category,
			&i.CategoryAr,
			&i.SubCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertyDocument = `-- name: GetAllProjectPropertyDocument :many
SELECT id, documents_category_id, documents_subcategory_id, file_url, created_at, updated_at, project_properties_id, status FROM project_properties_documents
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllProjectPropertyDocumentParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProjectPropertyDocument(ctx context.Context, arg GetAllProjectPropertyDocumentParams) ([]ProjectPropertiesDocument, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertyDocument, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectPropertiesDocument
	for rows.Next() {
		var i ProjectPropertiesDocument
		if err := rows.Scan(
			&i.ID,
			&i.DocumentsCategoryID,
			&i.DocumentsSubcategoryID,
			&i.FileUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectPropertiesID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountProjectPropertyDocByProjectPropertyId = `-- name: GetCountProjectPropertyDocByProjectPropertyId :one
SELECT count(*) FROM project_properties_documents 
WHERE project_properties_documents.project_properties_id = $1
`

func (q *Queries) GetCountProjectPropertyDocByProjectPropertyId(ctx context.Context, projectPropertiesID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProjectPropertyDocByProjectPropertyId, projectPropertiesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjPhaseDocCatAndSubCatByProjProp = `-- name: GetProjPhaseDocCatAndSubCatByProjProp :many
WITH x AS(
SELECT projects_id AS id,documents_category_id,documents_subcategory_id
FROM project_documents
UNION ALL
SELECT phases_id AS id,documents_category_id,documents_subcategory_id
FROM phases_documents
)SELECT x.id, x.documents_category_id, x.documents_subcategory_id,documents_category.category AS documents_category, documents_category.category_ar as documents_category_ar, documents_subcategory.sub_category AS documents_subcategory FROM x
INNER JOIN project_properties ON project_properties.id = $1
AND 
CASE 
WHEN project_properties.is_multiphase IS TRUE THEN project_properties.phases_id = x.id 
ELSE project_properties.projects_id = x.id 
END
INNER JOIN documents_category ON documents_category.id = x.documents_category_id
INNER JOIN documents_subcategory ON documents_subcategory.id = x.documents_subcategory_id
ORDER BY documents_category.id
`

type GetProjPhaseDocCatAndSubCatByProjPropRow struct {
	ID                     int64       `json:"id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	DocumentsCategory      string      `json:"documents_category"`
	DocumentsCategoryAr    pgtype.Text `json:"documents_category_ar"`
	DocumentsSubcategory   string      `json:"documents_subcategory"`
}

func (q *Queries) GetProjPhaseDocCatAndSubCatByProjProp(ctx context.Context, projectPropertiesID int64) ([]GetProjPhaseDocCatAndSubCatByProjPropRow, error) {
	rows, err := q.db.Query(ctx, getProjPhaseDocCatAndSubCatByProjProp, projectPropertiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjPhaseDocCatAndSubCatByProjPropRow
	for rows.Next() {
		var i GetProjPhaseDocCatAndSubCatByProjPropRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentsCategoryID,
			&i.DocumentsSubcategoryID,
			&i.DocumentsCategory,
			&i.DocumentsCategoryAr,
			&i.DocumentsSubcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectPropertyDocByProjectPropertyDocId = `-- name: GetProjectPropertyDocByProjectPropertyDocId :one
SELECT project_properties_documents.id, project_properties_documents.documents_category_id, 
project_properties_documents.documents_subcategory_id, project_properties_documents.file_url,
 project_properties_documents.created_at, project_properties_documents.updated_at,
 project_properties_documents.project_properties_id, project_properties_documents.status, 
 documents_category.category,documents_category.category_ar,documents_subcategory.sub_category,project_properties.property_name 
FROM project_properties_documents
LEFT JOIN documents_category ON documents_category.id = project_properties_documents.documents_category_id 
LEFT JOIN documents_subcategory ON documents_subcategory.id = project_properties_documents.documents_subcategory_id 
INNER JOIN project_properties ON project_properties.id = project_properties_documents.project_properties_id 
WHERE project_properties_documents.id = $1 LIMIT 1
`

type GetProjectPropertyDocByProjectPropertyDocIdRow struct {
	ID                     int64       `json:"id"`
	DocumentsCategoryID    int64       `json:"documents_category_id"`
	DocumentsSubcategoryID int64       `json:"documents_subcategory_id"`
	FileUrl                []string    `json:"file_url"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	ProjectPropertiesID    int64       `json:"project_properties_id"`
	Status                 int64       `json:"status"`
	Category               pgtype.Text `json:"category"`
	CategoryAr             pgtype.Text `json:"category_ar"`
	SubCategory            pgtype.Text `json:"sub_category"`
	PropertyName           string      `json:"property_name"`
}

func (q *Queries) GetProjectPropertyDocByProjectPropertyDocId(ctx context.Context, id int64) (GetProjectPropertyDocByProjectPropertyDocIdRow, error) {
	row := q.db.QueryRow(ctx, getProjectPropertyDocByProjectPropertyDocId, id)
	var i GetProjectPropertyDocByProjectPropertyDocIdRow
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectPropertiesID,
		&i.Status,
		&i.Category,
		&i.CategoryAr,
		&i.SubCategory,
		&i.PropertyName,
	)
	return i, err
}

const getProjectPropertyDocument = `-- name: GetProjectPropertyDocument :one
SELECT project_properties_documents.id, project_properties_documents.documents_category_id, project_properties_documents.documents_subcategory_id, project_properties_documents.file_url, project_properties_documents.created_at, project_properties_documents.updated_at, project_properties_documents.project_properties_id, project_properties_documents.status,project_properties.property_name 
FROM project_properties_documents 
INNER JOIN project_properties ON project_properties.id = project_properties_documents.project_properties_id
WHERE project_properties_documents.id = $1 LIMIT 1
`

type GetProjectPropertyDocumentRow struct {
	ID                     int64     `json:"id"`
	DocumentsCategoryID    int64     `json:"documents_category_id"`
	DocumentsSubcategoryID int64     `json:"documents_subcategory_id"`
	FileUrl                []string  `json:"file_url"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
	ProjectPropertiesID    int64     `json:"project_properties_id"`
	Status                 int64     `json:"status"`
	PropertyName           string    `json:"property_name"`
}

func (q *Queries) GetProjectPropertyDocument(ctx context.Context, id int64) (GetProjectPropertyDocumentRow, error) {
	row := q.db.QueryRow(ctx, getProjectPropertyDocument, id)
	var i GetProjectPropertyDocumentRow
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectPropertiesID,
		&i.Status,
		&i.PropertyName,
	)
	return i, err
}

const getProjectPropertyDocumentByProjPropertyId = `-- name: GetProjectPropertyDocumentByProjPropertyId :one
SELECT id, documents_category_id, documents_subcategory_id, file_url, created_at, updated_at, project_properties_id, status FROM project_properties_documents 
WHERE project_properties_id = $1 and documents_category_id=$2 and documents_subcategory_id=$3 LIMIT 1
`

type GetProjectPropertyDocumentByProjPropertyIdParams struct {
	ProjectPropertiesID    int64 `json:"project_properties_id"`
	DocumentsCategoryID    int64 `json:"documents_category_id"`
	DocumentsSubcategoryID int64 `json:"documents_subcategory_id"`
}

func (q *Queries) GetProjectPropertyDocumentByProjPropertyId(ctx context.Context, arg GetProjectPropertyDocumentByProjPropertyIdParams) (ProjectPropertiesDocument, error) {
	row := q.db.QueryRow(ctx, getProjectPropertyDocumentByProjPropertyId, arg.ProjectPropertiesID, arg.DocumentsCategoryID, arg.DocumentsSubcategoryID)
	var i ProjectPropertiesDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectPropertiesID,
		&i.Status,
	)
	return i, err
}

const getProjetPropertyDocumentsByProjectIdAndDocCatIdAndSubDocCatId = `-- name: GetProjetPropertyDocumentsByProjectIdAndDocCatIdAndSubDocCatId :one
SELECT  id, documents_category_id, documents_subcategory_id, file_url, created_at, updated_at, projects_id, status FROM project_documents
WHERE  projects_id = $1 AND  documents_category_id = $2 AND documents_subcategory_id = $3
`

type GetProjetPropertyDocumentsByProjectIdAndDocCatIdAndSubDocCatIdParams struct {
	ProjectsID             int64 `json:"projects_id"`
	DocumentsCategoryID    int64 `json:"documents_category_id"`
	DocumentsSubcategoryID int64 `json:"documents_subcategory_id"`
}

func (q *Queries) GetProjetPropertyDocumentsByProjectIdAndDocCatIdAndSubDocCatId(ctx context.Context, arg GetProjetPropertyDocumentsByProjectIdAndDocCatIdAndSubDocCatIdParams) (ProjectDocument, error) {
	row := q.db.QueryRow(ctx, getProjetPropertyDocumentsByProjectIdAndDocCatIdAndSubDocCatId, arg.ProjectsID, arg.DocumentsCategoryID, arg.DocumentsSubcategoryID)
	var i ProjectDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectsID,
		&i.Status,
	)
	return i, err
}

const getProjetPropertyDocumentsByProjectPropertyIdAndDocCatIdAndSubDocCatId = `-- name: GetProjetPropertyDocumentsByProjectPropertyIdAndDocCatIdAndSubDocCatId :one
SELECT id, documents_category_id, documents_subcategory_id, file_url, created_at, updated_at, project_properties_id, status FROM project_properties_documents 
WHERE project_properties_id= $1
AND
  documents_category_id = $2
AND
documents_subcategory_id = $3
`

type GetProjetPropertyDocumentsByProjectPropertyIdAndDocCatIdAndSubDocCatIdParams struct {
	ProjectPropertiesID    int64 `json:"project_properties_id"`
	DocumentsCategoryID    int64 `json:"documents_category_id"`
	DocumentsSubcategoryID int64 `json:"documents_subcategory_id"`
}

func (q *Queries) GetProjetPropertyDocumentsByProjectPropertyIdAndDocCatIdAndSubDocCatId(ctx context.Context, arg GetProjetPropertyDocumentsByProjectPropertyIdAndDocCatIdAndSubDocCatIdParams) (ProjectPropertiesDocument, error) {
	row := q.db.QueryRow(ctx, getProjetPropertyDocumentsByProjectPropertyIdAndDocCatIdAndSubDocCatId, arg.ProjectPropertiesID, arg.DocumentsCategoryID, arg.DocumentsSubcategoryID)
	var i ProjectPropertiesDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectPropertiesID,
		&i.Status,
	)
	return i, err
}

const updateProjectPropertyDocument = `-- name: UpdateProjectPropertyDocument :one
UPDATE project_properties_documents
SET    documents_category_id = $2,
    documents_subcategory_id = $3,
    file_url = $4,
    created_at = $5,
    updated_at = $6,
    project_properties_id = $7,
    status = $8
Where id = $1
RETURNING id, documents_category_id, documents_subcategory_id, file_url, created_at, updated_at, project_properties_id, status
`

type UpdateProjectPropertyDocumentParams struct {
	ID                     int64     `json:"id"`
	DocumentsCategoryID    int64     `json:"documents_category_id"`
	DocumentsSubcategoryID int64     `json:"documents_subcategory_id"`
	FileUrl                []string  `json:"file_url"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
	ProjectPropertiesID    int64     `json:"project_properties_id"`
	Status                 int64     `json:"status"`
}

func (q *Queries) UpdateProjectPropertyDocument(ctx context.Context, arg UpdateProjectPropertyDocumentParams) (ProjectPropertiesDocument, error) {
	row := q.db.QueryRow(ctx, updateProjectPropertyDocument,
		arg.ID,
		arg.DocumentsCategoryID,
		arg.DocumentsSubcategoryID,
		arg.FileUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProjectPropertiesID,
		arg.Status,
	)
	var i ProjectPropertiesDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectPropertiesID,
		&i.Status,
	)
	return i, err
}

const updateProjectPropertyDocumentFiles = `-- name: UpdateProjectPropertyDocumentFiles :one
UPDATE project_properties_documents 
SET file_url = $2,
    updated_at = $3
WHERE id = $1
RETURNING id, documents_category_id, documents_subcategory_id, file_url, created_at, updated_at, project_properties_id, status
`

type UpdateProjectPropertyDocumentFilesParams struct {
	ID        int64     `json:"id"`
	FileUrl   []string  `json:"file_url"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateProjectPropertyDocumentFiles(ctx context.Context, arg UpdateProjectPropertyDocumentFilesParams) (ProjectPropertiesDocument, error) {
	row := q.db.QueryRow(ctx, updateProjectPropertyDocumentFiles, arg.ID, arg.FileUrl, arg.UpdatedAt)
	var i ProjectPropertiesDocument
	err := row.Scan(
		&i.ID,
		&i.DocumentsCategoryID,
		&i.DocumentsSubcategoryID,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectPropertiesID,
		&i.Status,
	)
	return i, err
}
