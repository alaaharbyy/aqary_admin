// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: views.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createViews = `-- name: CreateViews :one
INSERT INTO views (
    title,
    icon,
    created_at,
    updated_at, 
    status,
    title_ar
) VALUES (
    $1, $2, $3, $4,$5,$6
) RETURNING id, title, status, icon, created_at, updated_at, title_ar
`

type CreateViewsParams struct {
	Title     string      `json:"title"`
	Icon      pgtype.Text `json:"icon"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
	Status    int64       `json:"status"`
	TitleAr   pgtype.Text `json:"title_ar"`
}

func (q *Queries) CreateViews(ctx context.Context, arg CreateViewsParams) (View, error) {
	row := q.db.QueryRow(ctx, createViews,
		arg.Title,
		arg.Icon,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.TitleAr,
	)
	var i View
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const deleteViews = `-- name: DeleteViews :exec
UPDATE views
SET status = $2, 
    updated_at=$3
WHERE id = $1
`

type DeleteViewsParams struct {
	ID        int64     `json:"id"`
	Status    int64     `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) DeleteViews(ctx context.Context, arg DeleteViewsParams) error {
	_, err := q.db.Exec(ctx, deleteViews, arg.ID, arg.Status, arg.UpdatedAt)
	return err
}

const getAllViews = `-- name: GetAllViews :many
SELECT id, title, status, icon, created_at, updated_at, title_ar FROM views
ORDER BY id DESC
LIMIT $1
OFFSET $2
`

type GetAllViewsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllViews(ctx context.Context, arg GetAllViewsParams) ([]View, error) {
	rows, err := q.db.Query(ctx, getAllViews, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []View
	for rows.Next() {
		var i View
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllViewsById = `-- name: GetAllViewsById :many
SELECT id, title, status, icon, created_at, updated_at, title_ar FROM views WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetAllViewsById(ctx context.Context, dollar_1 []int64) ([]View, error) {
	rows, err := q.db.Query(ctx, getAllViewsById, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []View
	for rows.Next() {
		var i View
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllViewsByStatus = `-- name: GetAllViewsByStatus :many
SELECT id, title, status, icon, created_at, updated_at, title_ar FROM views
where status = $1
ORDER BY updated_at DESC
LIMIT $3
OFFSET $2
`

type GetAllViewsByStatusParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

func (q *Queries) GetAllViewsByStatus(ctx context.Context, arg GetAllViewsByStatusParams) ([]View, error) {
	rows, err := q.db.Query(ctx, getAllViewsByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []View
	for rows.Next() {
		var i View
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllViewsByStatusCount = `-- name: GetAllViewsByStatusCount :one
SELECT COUNT(id) AS total FROM views
where status = $1
`

func (q *Queries) GetAllViewsByStatusCount(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAllViewsByStatusCount, status)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getAllViewsCount = `-- name: GetAllViewsCount :one
SELECT COUNT(id) AS total FROM views
`

func (q *Queries) GetAllViewsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAllViewsCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getAllViewsForProperty = `-- name: GetAllViewsForProperty :many
    SELECT views.id, views.title, views.status, views.icon, views.created_at, views.updated_at, views.title_ar
    FROM property
    JOIN views ON views.id = ANY(ARRAY(SELECT jsonb_array_elements_text(facts->'views')::BIGINT)) WHERE property.id= $1
`

type GetAllViewsForPropertyRow struct {
	View View `json:"view"`
}

func (q *Queries) GetAllViewsForProperty(ctx context.Context, id int64) ([]GetAllViewsForPropertyRow, error) {
	rows, err := q.db.Query(ctx, getAllViewsForProperty, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllViewsForPropertyRow
	for rows.Next() {
		var i GetAllViewsForPropertyRow
		if err := rows.Scan(
			&i.View.ID,
			&i.View.Title,
			&i.View.Status,
			&i.View.Icon,
			&i.View.CreatedAt,
			&i.View.UpdatedAt,
			&i.View.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllViewsWithoutPagenation = `-- name: GetAllViewsWithoutPagenation :many
SELECT id, title, status, icon, created_at, updated_at, title_ar FROM views
WHERE status = $1::BIGINT
ORDER BY id
`

func (q *Queries) GetAllViewsWithoutPagenation(ctx context.Context, activeStatus int64) ([]View, error) {
	rows, err := q.db.Query(ctx, getAllViewsWithoutPagenation, activeStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []View
	for rows.Next() {
		var i View
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllViews = `-- name: GetCountAllViews :one
select count(*) FROM views
`

func (q *Queries) GetCountAllViews(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllViews)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getViews = `-- name: GetViews :one
SELECT id, title, status, icon, created_at, updated_at, title_ar FROM views 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetViews(ctx context.Context, limit int32) (View, error) {
	row := q.db.QueryRow(ctx, getViews, limit)
	var i View
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const getViewsWithStatus = `-- name: GetViewsWithStatus :one
SELECT id, title, status, icon, created_at, updated_at, title_ar FROM views 
WHERE id = $1 AND status!= $2::BIGINT
`

type GetViewsWithStatusParams struct {
	ID            int64 `json:"id"`
	DeletedStatus int64 `json:"deleted_status"`
}

func (q *Queries) GetViewsWithStatus(ctx context.Context, arg GetViewsWithStatusParams) (View, error) {
	row := q.db.QueryRow(ctx, getViewsWithStatus, arg.ID, arg.DeletedStatus)
	var i View
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const updateViews = `-- name: UpdateViews :one
UPDATE views
SET  
    title = $2,
    icon = $3,
    created_at = $4,
    updated_at = $5,
    title_ar=$6
Where id = $1
RETURNING id, title, status, icon, created_at, updated_at, title_ar
`

type UpdateViewsParams struct {
	ID        int64       `json:"id"`
	Title     string      `json:"title"`
	Icon      pgtype.Text `json:"icon"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
	TitleAr   pgtype.Text `json:"title_ar"`
}

func (q *Queries) UpdateViews(ctx context.Context, arg UpdateViewsParams) (View, error) {
	row := q.db.QueryRow(ctx, updateViews,
		arg.ID,
		arg.Title,
		arg.Icon,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.TitleAr,
	)
	var i View
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Status,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}
