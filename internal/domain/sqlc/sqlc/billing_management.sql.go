// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: billing_management.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllSubscriberDocuments = `-- name: GetAllSubscriberDocuments :many
WITH x AS (
    -- Company License Documents
    SELECT 
        license.id,
        license.license_type_id,
        license.license_no,
        license.license_issue_date,
        license.license_expiry_date,
        license.license_registration_date,
        license.license_file_url,
        CONCAT(
            license.metadata ->> 'original_file_name',
            license.metadata ->> 'original_file_extension'
        )::text AS original_file_name,
        1::bigint AS subscriber_type
    FROM license
    WHERE license.entity_id = $3::bigint 
      AND license.entity_type_id = 6 -- Company
      AND 1 = $4::bigint

    UNION ALL

    -- User License Document (if exists)
    SELECT 
        license.id,
        license.license_type_id,
        license.license_no,
        license.license_issue_date,
        license.license_expiry_date,
        license.license_registration_date,
        license.license_file_url,
        CONCAT(
            license.metadata ->> 'original_file_name',
            license.metadata ->> 'original_file_extension'
        )::text AS original_file_name,
        CASE 
            WHEN users.user_types_id = 3 THEN 3 
            ELSE 2 
        END::bigint AS subscriber_type
    FROM users
    INNER JOIN profiles ON profiles.users_id = users.id
    INNER JOIN license 
        ON license.entity_id = users.id 
        AND license.entity_type_id = 9 -- User License
    WHERE users.user_types_id IN (3, 4)
      AND users.id = $3::bigint
      AND $4::bigint IN (2, 3)

    UNION ALL

    -- User Passport Document (if exists)
    SELECT 
        users.id,
        0 AS license_type_id,
        profiles.passport_no,
        NULL AS license_issue_date,
        profiles.passport_expiry_date,
        NULL AS license_registration_date,
        profiles.passport_image_url,
        ''::text AS original_file_name,
        CASE 
            WHEN users.user_types_id = 3 THEN 3 
            ELSE 2 
        END::bigint AS subscriber_type
    FROM users
    INNER JOIN profiles ON profiles.users_id = users.id
    WHERE users.user_types_id IN (3, 4)
      AND users.id = $3::bigint
      AND $4::bigint IN (2, 3) 
)
SELECT id, license_type_id, license_no, license_issue_date, license_expiry_date, license_registration_date, license_file_url, original_file_name, subscriber_type FROM x
LIMIT $2
OFFSET $1
`

type GetAllSubscriberDocumentsParams struct {
	Offset         pgtype.Int4 `json:"offset"`
	Limit          pgtype.Int4 `json:"limit"`
	SubscriberID   int64       `json:"subscriber_id"`
	SubscriberType int64       `json:"subscriber_type"`
}

type GetAllSubscriberDocumentsRow struct {
	ID                      int64              `json:"id"`
	LicenseTypeID           int64              `json:"license_type_id"`
	LicenseNo               string             `json:"license_no"`
	LicenseIssueDate        pgtype.Timestamptz `json:"license_issue_date"`
	LicenseExpiryDate       pgtype.Timestamptz `json:"license_expiry_date"`
	LicenseRegistrationDate pgtype.Timestamptz `json:"license_registration_date"`
	LicenseFileUrl          pgtype.Text        `json:"license_file_url"`
	OriginalFileName        string             `json:"original_file_name"`
	SubscriberType          int64              `json:"subscriber_type"`
}

func (q *Queries) GetAllSubscriberDocuments(ctx context.Context, arg GetAllSubscriberDocumentsParams) ([]GetAllSubscriberDocumentsRow, error) {
	rows, err := q.db.Query(ctx, getAllSubscriberDocuments,
		arg.Offset,
		arg.Limit,
		arg.SubscriberID,
		arg.SubscriberType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriberDocumentsRow
	for rows.Next() {
		var i GetAllSubscriberDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.LicenseTypeID,
			&i.LicenseNo,
			&i.LicenseIssueDate,
			&i.LicenseExpiryDate,
			&i.LicenseRegistrationDate,
			&i.LicenseFileUrl,
			&i.OriginalFileName,
			&i.SubscriberType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubsribersByStatus = `-- name: GetAllSubsribersByStatus :many
WITH x AS (
    SELECT 
        DISTINCT companies.id,
        companies.logo_url,
        companies.company_name AS subscriber_name,
        companies.status,
        1::bigint AS subscriber_type,
        subscription_order.order_no,
        subscription_order.contract_file,
        subscription_order.draft_contract
    FROM companies
    LEFT JOIN subscription_order 
        ON subscription_order.subscriber_id = companies.id 
        AND subscription_order.subscriber_type = 1
        AND subscription_order.status = 1 -- only draft subscription_order
    WHERE companies.status = $3::bigint
      AND (1 = $3::bigint OR subscription_order.id IS NOT NULL) -- handle pending legally or pending financially logic

    UNION ALL

    SELECT 
        DISTINCT users.id,
        '' AS logo_url,
        CONCAT(profiles.first_name, ' ', profiles.last_name) AS subscriber_name,
        users.status,
      CASE WHEN users.user_types_id = 3 THEN 3 ELSE 2 END::bigint AS subscriber_type,
        subscription_order.order_no,
        subscription_order.contract_file,
        subscription_order.draft_contract
    FROM users
    INNER JOIN profiles 
        ON profiles.users_id = users.id
    LEFT JOIN subscription_order 
        ON subscription_order.subscriber_id = users.id 
        AND subscription_order.subscriber_type IN (2,3)
        AND subscription_order.status = 1  -- only draft subscription_order
    WHERE users.status = $3::bigint
      AND (1 = $3::bigint OR subscription_order.id IS NOT NULL) -- handle pending legally or pending financially logic
      AND users.user_types_id IN (3,4) -- only freelancer & owner user type
)SELECT id, logo_url, subscriber_name, status, subscriber_type, order_no, contract_file, draft_contract FROM x
LIMIT $2
OFFSET $1
`

type GetAllSubsribersByStatusParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
	Status int64       `json:"status"`
}

type GetAllSubsribersByStatusRow struct {
	ID             int64       `json:"id"`
	LogoUrl        string      `json:"logo_url"`
	SubscriberName string      `json:"subscriber_name"`
	Status         int64       `json:"status"`
	SubscriberType int64       `json:"subscriber_type"`
	OrderNo        pgtype.Text `json:"order_no"`
	ContractFile   pgtype.Text `json:"contract_file"`
	DraftContract  pgtype.Text `json:"draft_contract"`
}

func (q *Queries) GetAllSubsribersByStatus(ctx context.Context, arg GetAllSubsribersByStatusParams) ([]GetAllSubsribersByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAllSubsribersByStatus, arg.Offset, arg.Limit, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubsribersByStatusRow
	for rows.Next() {
		var i GetAllSubsribersByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.LogoUrl,
			&i.SubscriberName,
			&i.Status,
			&i.SubscriberType,
			&i.OrderNo,
			&i.ContractFile,
			&i.DraftContract,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllSubscriberDocuments = `-- name: GetCountAllSubscriberDocuments :one
WITH x AS (
    -- Company License Documents
    SELECT 
        license.id,
        license.license_type_id,
        license.license_no,
        license.license_issue_date,
        license.license_expiry_date,
        license.license_registration_date,
        license.license_file_url,
        CONCAT(
            license.metadata ->> 'original_file_name',
            license.metadata ->> 'original_file_extension'
        )::text AS original_file_name,
        1::bigint AS subscriber_type
    FROM license
    WHERE license.entity_id = $1::bigint 
      AND license.entity_type_id = 6 -- Company
      AND 1 = $2::bigint

    UNION ALL

    -- User License Document (if exists)
    SELECT 
        license.id,
        license.license_type_id,
        license.license_no,
        license.license_issue_date,
        license.license_expiry_date,
        license.license_registration_date,
        license.license_file_url,
        CONCAT(
            license.metadata ->> 'original_file_name',
            license.metadata ->> 'original_file_extension'
        )::text AS original_file_name,
        CASE 
            WHEN users.user_types_id = 3 THEN 3 
            ELSE 2 
        END::bigint AS subscriber_type
    FROM users
    INNER JOIN profiles ON profiles.users_id = users.id
    INNER JOIN license 
        ON license.entity_id = users.id 
        AND license.entity_type_id = 9 -- User License
    WHERE users.user_types_id IN (3, 4)
      AND users.id = $1::bigint
      AND $2::bigint IN (2, 3)

    UNION ALL

    -- User Passport Document (if exists)
    SELECT 
        users.id,
        0 AS license_type_id,
        profiles.passport_no,
        NULL AS license_issue_date,
        profiles.passport_expiry_date,
        NULL AS license_registration_date,
        profiles.passport_image_url,
        ''::text AS original_file_name,
        CASE 
            WHEN users.user_types_id = 3 THEN 3 
            ELSE 2 
        END::bigint AS subscriber_type
    FROM users
    INNER JOIN profiles ON profiles.users_id = users.id
    WHERE users.user_types_id IN (3, 4)
      AND users.id = $1::bigint
      AND $2::bigint IN (2, 3) 
)
SELECT COUNT(*) FROM x
`

type GetCountAllSubscriberDocumentsParams struct {
	SubscriberID   int64 `json:"subscriber_id"`
	SubscriberType int64 `json:"subscriber_type"`
}

func (q *Queries) GetCountAllSubscriberDocuments(ctx context.Context, arg GetCountAllSubscriberDocumentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllSubscriberDocuments, arg.SubscriberID, arg.SubscriberType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllSubsribersByStatus = `-- name: GetCountAllSubsribersByStatus :one
WITH x AS (
    SELECT 
        DISTINCT companies.id,
        companies.logo_url,
        companies.company_name AS subscriber_name,
        companies.status,
        1::bigint AS subscriber_type,
        subscription_order.order_no,
        subscription_order.contract_file,
        subscription_order.draft_contract
    FROM companies
    LEFT JOIN subscription_order 
        ON subscription_order.subscriber_id = companies.id 
        AND subscription_order.subscriber_type = 1  -- only company subscriber type
        AND subscription_order.status = 1 -- only draft subscription_order
    WHERE companies.status = $1::bigint
      AND (1 = $1::bigint OR subscription_order.id IS NOT NULL) -- handle pending legally or pending financially logic

    UNION ALL

    SELECT 
        DISTINCT users.id,
        '' AS logo_url,
        CONCAT(profiles.first_name, ' ', profiles.last_name) AS subscriber_name,
        users.status,
      CASE WHEN users.user_types_id = 3 THEN 3 ELSE 2 END::bigint AS subscriber_type,
        subscription_order.order_no,
        subscription_order.contract_file,
        subscription_order.draft_contract
    FROM users
    INNER JOIN profiles 
        ON profiles.users_id = users.id
    LEFT JOIN subscription_order 
        ON subscription_order.subscriber_id = users.id 
        AND subscription_order.subscriber_type IN (2,3) -- only freelancer & owner subscriber type
        AND subscription_order.status = 1  -- only draft subscription_order
    WHERE users.status = $1::bigint
      AND (1 = $1::bigint OR subscription_order.id IS NOT NULL) -- handle pending legally or pending financially logic
      AND users.user_types_id IN (3,4) -- only freelancer & owner user type
)SELECT COUNT(*) FROM x
`

func (q *Queries) GetCountAllSubsribersByStatus(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllSubsribersByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRejectedSubscribers = `-- name: GetRejectedSubscribers :many
WITH latestverification
     AS (SELECT DISTINCT ON (entity_id) so.entity_type_id,
                                        so.entity_id,
                                        so.verification,
                                        so.notes,
                                        so.created_at
         FROM   company_verification so
         ORDER  BY so.entity_id,
                   so.created_at DESC)
SELECT lv.entity_type_id,
       lv.entity_id,
       lv.verification,
       lv.notes,
       lv.created_at,
       CASE
         WHEN lv.entity_type_id = 6 THEN 1
         WHEN users.user_types_id  = 3 THEN 3
         WHEN users.user_types_id = 4 THEN 2
       END::bigint AS "subscriber_type",
       CASE
         WHEN lv.entity_type_id = 6 THEN companies.company_name
         ELSE Trim(Concat(pr.first_name, ' ', pr.last_name))
       END::varchar AS "subscriber_name"
FROM   latestverification lv
       LEFT JOIN companies
              ON lv.entity_type_id = 6
                 AND companies.id = lv.entity_id
       LEFT JOIN users
              ON lv.entity_type_id = 9
                 AND users.id = lv.entity_id
       LEFT JOIN profiles pr
              ON lv.entity_type_id = 9
                 AND users.id = pr.users_id
       LEFT JOIN user_types ut
              ON lv.entity_type_id = 9
                 AND users.user_types_id = ut.id
WHERE  lv.verification IN ( 3, 4)
LIMIT $2
OFFSET $1
`

type GetRejectedSubscribersParams struct {
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetRejectedSubscribersRow struct {
	EntityTypeID   int64     `json:"entity_type_id"`
	EntityID       int64     `json:"entity_id"`
	Verification   int32     `json:"verification"`
	Notes          string    `json:"notes"`
	CreatedAt      time.Time `json:"created_at"`
	SubscriberType int64     `json:"subscriber_type"`
	SubscriberName string    `json:"subscriber_name"`
}

func (q *Queries) GetRejectedSubscribers(ctx context.Context, arg GetRejectedSubscribersParams) ([]GetRejectedSubscribersRow, error) {
	rows, err := q.db.Query(ctx, getRejectedSubscribers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRejectedSubscribersRow
	for rows.Next() {
		var i GetRejectedSubscribersRow
		if err := rows.Scan(
			&i.EntityTypeID,
			&i.EntityID,
			&i.Verification,
			&i.Notes,
			&i.CreatedAt,
			&i.SubscriberType,
			&i.SubscriberName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRejectedSubscribersCount = `-- name: GetRejectedSubscribersCount :one
WITH latestverification
     AS (SELECT DISTINCT ON (entity_id) so.entity_type_id,
                                        so.entity_id,
                                        so.verification,
                                        so.notes,
                                        so.created_at
         FROM   company_verification so
         ORDER  BY so.entity_id,
                   so.created_at DESC)
SELECT COUNT(lv.entity_id)
FROM   latestverification lv
WHERE  lv.verification IN ( 3, 4 )
`

func (q *Queries) GetRejectedSubscribersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getRejectedSubscribersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSubscribersByType = `-- name: GetSubscribersByType :many
SELECT so.subscriber_id,
       so.subscriber_type,
       so.order_no,
       CASE
         WHEN so.subscriber_type = 1 THEN companies.company_name
         ELSE Trim(Concat(pr.first_name, ' ', pr.last_name))
       END AS "subscriber_name"
FROM   subscription_order so
       LEFT JOIN companies
              ON so.subscriber_type = 1
                 AND companies.id = so.subscriber_id
       LEFT JOIN users
              ON so.subscriber_type IN ( 2, 3 )
                 AND users.id = so.subscriber_id
                 AND users.user_types_id IN ( 3, 4 )
       LEFT JOIN profiles pr
              ON so.subscriber_type IN ( 2, 3 )
                 AND users.id = pr.users_id
WHERE  so.subscriber_type = $1::bigint
       AND so.status NOT IN ( 5, 6 )
GROUP  BY so.subscriber_id,
          so.subscriber_type,
          so.order_no,
          companies.company_name,
          pr.first_name,
          pr.last_name
`

type GetSubscribersByTypeRow struct {
	SubscriberID   int64       `json:"subscriber_id"`
	SubscriberType int64       `json:"subscriber_type"`
	OrderNo        string      `json:"order_no"`
	SubscriberName interface{} `json:"subscriber_name"`
}

func (q *Queries) GetSubscribersByType(ctx context.Context, typeID int64) ([]GetSubscribersByTypeRow, error) {
	rows, err := q.db.Query(ctx, getSubscribersByType, typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscribersByTypeRow
	for rows.Next() {
		var i GetSubscribersByTypeRow
		if err := rows.Scan(
			&i.SubscriberID,
			&i.SubscriberType,
			&i.OrderNo,
			&i.SubscriberName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
