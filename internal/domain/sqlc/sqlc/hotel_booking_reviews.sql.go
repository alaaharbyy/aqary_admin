// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: hotel_booking_reviews.sql

package sqlc

import (
	"context"
	"time"
)

const createHotelBookingReview = `-- name: CreateHotelBookingReview :one
INSERT INTO hotel_booking_reviews(posted_hotel_booking, review_date, user_id, comfort, rooms, cleanliness, building, title, review)
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, posted_hotel_booking, review_date, user_id, comfort, rooms, cleanliness, building, title, review, status
`

type CreateHotelBookingReviewParams struct {
	PostedHotelBooking int64     `json:"posted_hotel_booking"`
	ReviewDate         time.Time `json:"review_date"`
	UserID             int64     `json:"user_id"`
	Comfort            float64   `json:"comfort"`
	Rooms              float64   `json:"rooms"`
	Cleanliness        float64   `json:"cleanliness"`
	Building           float64   `json:"building"`
	Title              string    `json:"title"`
	Review             string    `json:"review"`
}

func (q *Queries) CreateHotelBookingReview(ctx context.Context, arg CreateHotelBookingReviewParams) (HotelBookingReview, error) {
	row := q.db.QueryRow(ctx, createHotelBookingReview,
		arg.PostedHotelBooking,
		arg.ReviewDate,
		arg.UserID,
		arg.Comfort,
		arg.Rooms,
		arg.Cleanliness,
		arg.Building,
		arg.Title,
		arg.Review,
	)
	var i HotelBookingReview
	err := row.Scan(
		&i.ID,
		&i.PostedHotelBooking,
		&i.ReviewDate,
		&i.UserID,
		&i.Comfort,
		&i.Rooms,
		&i.Cleanliness,
		&i.Building,
		&i.Title,
		&i.Review,
		&i.Status,
	)
	return i, err
}

const getAllHotelBookingReviews = `-- name: GetAllHotelBookingReviews :many
SELECT id, posted_hotel_booking, review_date, user_id, comfort, rooms, cleanliness, building, title, review, status FROM hotel_booking_reviews
`

func (q *Queries) GetAllHotelBookingReviews(ctx context.Context) ([]HotelBookingReview, error) {
	rows, err := q.db.Query(ctx, getAllHotelBookingReviews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HotelBookingReview
	for rows.Next() {
		var i HotelBookingReview
		if err := rows.Scan(
			&i.ID,
			&i.PostedHotelBooking,
			&i.ReviewDate,
			&i.UserID,
			&i.Comfort,
			&i.Rooms,
			&i.Cleanliness,
			&i.Building,
			&i.Title,
			&i.Review,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHotelBookingReviews = `-- name: GetHotelBookingReviews :one
SELECT id, posted_hotel_booking, review_date, user_id, comfort, rooms, cleanliness, building, title, review, status FROM hotel_booking_reviews WHERE id=$1
`

func (q *Queries) GetHotelBookingReviews(ctx context.Context, id int64) (HotelBookingReview, error) {
	row := q.db.QueryRow(ctx, getHotelBookingReviews, id)
	var i HotelBookingReview
	err := row.Scan(
		&i.ID,
		&i.PostedHotelBooking,
		&i.ReviewDate,
		&i.UserID,
		&i.Comfort,
		&i.Rooms,
		&i.Cleanliness,
		&i.Building,
		&i.Title,
		&i.Review,
		&i.Status,
	)
	return i, err
}

const updateHotelBookingReview = `-- name: UpdateHotelBookingReview :one
UPDATE hotel_booking_reviews
SET posted_hotel_booking = $2,
    review_date = $3,
    user_id = $4,
    comfort = $5,
    rooms = $6,
    cleanliness = $7,
    building = $8,
    title = $9,
    review = $10
WHERE id = $1 RETURNING id, posted_hotel_booking, review_date, user_id, comfort, rooms, cleanliness, building, title, review, status
`

type UpdateHotelBookingReviewParams struct {
	ID                 int64     `json:"id"`
	PostedHotelBooking int64     `json:"posted_hotel_booking"`
	ReviewDate         time.Time `json:"review_date"`
	UserID             int64     `json:"user_id"`
	Comfort            float64   `json:"comfort"`
	Rooms              float64   `json:"rooms"`
	Cleanliness        float64   `json:"cleanliness"`
	Building           float64   `json:"building"`
	Title              string    `json:"title"`
	Review             string    `json:"review"`
}

func (q *Queries) UpdateHotelBookingReview(ctx context.Context, arg UpdateHotelBookingReviewParams) (HotelBookingReview, error) {
	row := q.db.QueryRow(ctx, updateHotelBookingReview,
		arg.ID,
		arg.PostedHotelBooking,
		arg.ReviewDate,
		arg.UserID,
		arg.Comfort,
		arg.Rooms,
		arg.Cleanliness,
		arg.Building,
		arg.Title,
		arg.Review,
	)
	var i HotelBookingReview
	err := row.Scan(
		&i.ID,
		&i.PostedHotelBooking,
		&i.ReviewDate,
		&i.UserID,
		&i.Comfort,
		&i.Rooms,
		&i.Cleanliness,
		&i.Building,
		&i.Title,
		&i.Review,
		&i.Status,
	)
	return i, err
}
