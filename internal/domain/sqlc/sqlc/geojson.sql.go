// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: geojson.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPropertiesForGeoJson = `-- name: GetPropertiesForGeoJson :many
WITH facilities_and_amenities AS(
    SELECT p.id,fa."type",
    array_agg(DISTINCT coalesce(fae.facility_amenity_id,0))::bigint[] AS facilities_amenities
    FROM property p
    LEFT JOIN facilities_amenities_entity fae ON fae.entity_id=p.id AND fae.entity_type_id= $6::bigint
    LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id
    group by p.id,fa."type" 
),
property_media_agg AS (
    SELECT
        entity_id,
        entity_type_id,
        array_agg(DISTINCT media_type ORDER BY media_type) AS media
    FROM 
        global_media
    where global_media.entity_type_id = $6::bigint
    or  global_media.entity_type_id = $2::bigint
    GROUP BY 
        entity_id,entity_type_id
),
MinDates AS (
    SELECT 
    	property_versions.id as property_id,
        plan_installments.payment_plans,
        MIN(plan_installments."date") AS earliest_date
    FROM 
        property_versions
    JOIN 
        payment_plans_packages 
        ON payment_plans_packages.entity_id = property_versions.id 
        AND payment_plans_packages.entity_type_id = $6::bigint
    JOIN 
        plan_installments 
        ON plan_installments.payment_plans = ANY(payment_plans_packages.payment_plans_id)
    GROUP BY 
        plan_installments.payment_plans,property_versions.id
),
downpayment as(
    SELECT 
        property_versions.id as property_id, 
        ARRAY_AGG(plan_installments.percentage) as percentages
    FROM property_versions
    LEFT JOIN MinDates ON  MinDates.property_id=property_versions.id
    left JOIN 
        plan_installments 
        ON plan_installments.payment_plans = MinDates.payment_plans 
        AND plan_installments."date" = MinDates.earliest_date
    group by property_versions.id
),
DesiredCountries as (
    SELECT property_versions.id AS property_id,ARRAY_AGG(addresses.countries_id) AS "countries" FROM property_versions 
    JOIN swap_requirement ON swap_requirement.entity_id=property_versions.id AND swap_requirement.entity_type= $2::bigint
    JOIN swap_requirment_address ON swap_requirment_address.swap_requirment_id=swap_requirement.id
    JOIN addresses ON addresses.id=swap_requirment_address.addresses_id
    WHERE property_versions.category= 3
    GROUP BY property_versions.id
),
media as(
	SELECT DISTINCT on (property_versions.id)
    property_versions.id AS property_versions_id, 
    global_media.file_urls[1]::varchar AS image_url
	FROM property_versions
	join property on property.id=property_versions.property_id
	JOIN global_media 
	  ON   ( case when property_versions.has_gallery is null OR property_versions.has_gallery=FALSE then property.id = global_media.entity_id and global_media.entity_type_id= $6::bigint
    else global_media.entity_id=property_versions.id and global_media.entity_type_id= $2::BIGINT END) 
    where 
	    global_media.media_type = 1 
	    AND global_media.gallery_type = 'Main'
)
SELECT 
	-- property version filters, 
     pv.id,
	 pv.agent_id, 
	 pv.category,
	--  pv.title, 
	--  pv.title_arabic, 
	--  pv.description, 
	--  pv.description_arabic, 
	 pv.ref_no, 
	 pv.is_main, 
	 pv.is_verified, 
	 pv."exclusive",
	 pv.is_hotdeal,
	
	-- property filters,
	--  p.property_title, 
	--  p.property_title_arabic, 
	 p.property_name, 
	--  p.description as property_description,
	--  p.description_arabic as property_description_arabic,
	 pv.property_rank,
     p.is_project_property, 
     p.unit_type_id, 
    coalesce((p.facts->>'life_style')::BIGINT, 0)::bigint as life_style,
    coalesce((pv.facts->>'price')::float, 0)::float as price,
    coalesce((pv.facts->>'starting_price')::FLOAT, 0)::FLOAT as starting_price,
    coalesce((p.facts->>'bedroom')::VARCHAR, '')::VARCHAR as bedroom,
    coalesce((p.facts->>'completion_status')::BIGINT, 0)::BIGINT as completion_status, 
    coalesce((p.facts->>'completion_percentage')::bigint, 0)::bigint as completion_percentage,
    coalesce((p.facts->>'ownership')::bigint, 0)::bigint as ownership,
    coalesce((p.facts->>'furnished')::bigint, 0)::bigint as furnished,
    coalesce((p.facts->>'max_area')::FLOAT, 0)::FLOAT as max_area,   
    coalesce((p.facts->>'min_area')::FLOAT, 0)::FLOAT as min_area,
    coalesce((p.facts->>'built_up_area')::FLOAT, 0)::FLOAT as built_up_area,
    coalesce((p.facts->>'plot_area')::FLOAT, 0)::FLOAT as plot_area,
    coalesce((p.facts->>'parking')::BIGINT, 0)::BIGINT as parking,
    coalesce((p.facts->>'no_of_floor')::BIGINT, 0)::BIGINT as no_of_floor,
    coalesce((p.facts->>'handover_date')::timestamp, CURRENT_TIMESTAMP)::timestamp as handover_date,
    coalesce((p.facts->>'service_charge')::FLOAT, 0.0)::FLOAT as service_charge, 
    coalesce((string_to_array(trim(both '[]' from p.facts->>'views'), ',')::BIGINT[]), array[]::bigint[])::bigint[]  as views,
    coalesce((pv.facts->>'investment')::bool,false)::bool as investment,    
    coalesce((pv.facts->>'roi')::bool,false)::bool as roi,

    coalesce(f.facilities_amenities::bigint[], array[]::bigint[])::bigint[] as facilities,
    coalesce(am.facilities_amenities::bigint[], array[]::bigint[])::bigint[] as amenities,
    p.company_id as developer_company_id,
    cu.company_id as broker_company_id,
    p.property_type_id as property_type_id,
    gpt.type as property_type,

    gpt."usage",
	-- -- filters
    coalesce(DesiredCountries.countries::bigint[], '{}'::bigint[])::bigint[] as swap_desired_countries,
    -- coalesce(downpayment.percentages::varchar[], '{}'::varchar[])::varchar[] as downpayment_percentages,
    coalesce(array_remove(downpayment.percentages, NULL), '{}'::varchar[])::varchar[] as downpayment_percentages,
    coalesce(property_media_agg.media::bigint[], '{}'::bigint[])::bigint[] as property_media_types,
    media.image_url,


	-- location filters
    a.id, a.countries_id, a.states_id, a.cities_id, a.communities_id, a.sub_communities_id, a.locations_id, a.created_at, a.updated_at, a.property_map_location_id, a.full_address, a.full_address_ar,  
    locations.lat, 
    locations.lng

    
FROM property_versions pv 
JOIN property p ON pv.property_id = p.id
LEFT JOIN phases ON phases.id= p.entity_id AND p.entity_type_id= $1::bigint 
JOIN property_media_agg ON ( case when pv.has_gallery is null OR pv.has_gallery=FALSE then p.id = property_media_agg.entity_id 
    else property_media_agg.entity_id=pv.id and property_media_agg.entity_type_id= $2::BIGINT END)
JOIN global_property_type gpt ON gpt.id=p.property_type_id
JOIN media on media.property_versions_id=pv.id
JOIN addresses a on p.addresses_id=a.id
LEFT JOIN locations ON locations.id=a.locations_id
LEFT JOIN properties_map_location  ON properties_map_location.id=a.property_map_location_id
LEFT JOIN downpayment ON downpayment.property_id = pv.id
LEFT JOIN facilities_and_amenities f ON f.id=p.id AND f."type"=1
LEFT JOIN facilities_and_amenities am ON am.id=p.id AND am."type"=2
JOIN company_users cu ON cu.users_id=pv.agent_id
JOIN users ON users.id=cu.users_id
LEFT JOIN DesiredCountries 
    ON DesiredCountries.property_id = pv.id 
    AND pv.category= $3::BIGINT
WHERE cu.company_id= $4::BIGINT and pv.status not in (1,5,6) and users.status=2 AND gpt."usage"= any($5::BIGINT[])
`

type GetPropertiesForGeoJsonParams struct {
	PhaseType           int64   `json:"phase_type"`
	PropertyVersionType int64   `json:"property_version_type"`
	SwapCategory        int64   `json:"swap_category"`
	CompanyID           int64   `json:"company_id"`
	Usage               []int64 `json:"usage"`
	PropertyType        int64   `json:"property_type"`
}

type GetPropertiesForGeoJsonRow struct {
	ID                     int64            `json:"id"`
	AgentID                int64            `json:"agent_id"`
	Category               int64            `json:"category"`
	RefNo                  string           `json:"ref_no"`
	IsMain                 bool             `json:"is_main"`
	IsVerified             bool             `json:"is_verified"`
	Exclusive              bool             `json:"exclusive"`
	IsHotdeal              bool             `json:"is_hotdeal"`
	PropertyName           string           `json:"property_name"`
	PropertyRank           int64            `json:"property_rank"`
	IsProjectProperty      bool             `json:"is_project_property"`
	UnitTypeID             []int64          `json:"unit_type_id"`
	LifeStyle              int64            `json:"life_style"`
	Price                  float64          `json:"price"`
	StartingPrice          float64          `json:"starting_price"`
	Bedroom                string           `json:"bedroom"`
	CompletionStatus       int64            `json:"completion_status"`
	CompletionPercentage   int64            `json:"completion_percentage"`
	Ownership              int64            `json:"ownership"`
	Furnished              int64            `json:"furnished"`
	MaxArea                float64          `json:"max_area"`
	MinArea                float64          `json:"min_area"`
	BuiltUpArea            float64          `json:"built_up_area"`
	PlotArea               float64          `json:"plot_area"`
	Parking                int64            `json:"parking"`
	NoOfFloor              int64            `json:"no_of_floor"`
	HandoverDate           pgtype.Timestamp `json:"handover_date"`
	ServiceCharge          float64          `json:"service_charge"`
	Views                  []int64          `json:"views"`
	Investment             pgtype.Bool      `json:"investment"`
	Roi                    pgtype.Bool      `json:"roi"`
	Facilities             []int64          `json:"facilities"`
	Amenities              []int64          `json:"amenities"`
	DeveloperCompanyID     pgtype.Int8      `json:"developer_company_id"`
	BrokerCompanyID        int64            `json:"broker_company_id"`
	PropertyTypeID         int64            `json:"property_type_id"`
	PropertyType           string           `json:"property_type"`
	Usage                  int64            `json:"usage"`
	SwapDesiredCountries   []int64          `json:"swap_desired_countries"`
	DownpaymentPercentages []string         `json:"downpayment_percentages"`
	PropertyMediaTypes     []int64          `json:"property_media_types"`
	ImageUrl               string           `json:"image_url"`
	Address                Address          `json:"address"`
	Lat                    pgtype.Text      `json:"lat"`
	Lng                    pgtype.Text      `json:"lng"`
}

func (q *Queries) GetPropertiesForGeoJson(ctx context.Context, arg GetPropertiesForGeoJsonParams) ([]GetPropertiesForGeoJsonRow, error) {
	rows, err := q.db.Query(ctx, getPropertiesForGeoJson,
		arg.PhaseType,
		arg.PropertyVersionType,
		arg.SwapCategory,
		arg.CompanyID,
		arg.Usage,
		arg.PropertyType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertiesForGeoJsonRow
	for rows.Next() {
		var i GetPropertiesForGeoJsonRow
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.Category,
			&i.RefNo,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.IsHotdeal,
			&i.PropertyName,
			&i.PropertyRank,
			&i.IsProjectProperty,
			&i.UnitTypeID,
			&i.LifeStyle,
			&i.Price,
			&i.StartingPrice,
			&i.Bedroom,
			&i.CompletionStatus,
			&i.CompletionPercentage,
			&i.Ownership,
			&i.Furnished,
			&i.MaxArea,
			&i.MinArea,
			&i.BuiltUpArea,
			&i.PlotArea,
			&i.Parking,
			&i.NoOfFloor,
			&i.HandoverDate,
			&i.ServiceCharge,
			&i.Views,
			&i.Investment,
			&i.Roi,
			&i.Facilities,
			&i.Amenities,
			&i.DeveloperCompanyID,
			&i.BrokerCompanyID,
			&i.PropertyTypeID,
			&i.PropertyType,
			&i.Usage,
			&i.SwapDesiredCountries,
			&i.DownpaymentPercentages,
			&i.PropertyMediaTypes,
			&i.ImageUrl,
			&i.Address.ID,
			&i.Address.CountriesID,
			&i.Address.StatesID,
			&i.Address.CitiesID,
			&i.Address.CommunitiesID,
			&i.Address.SubCommunitiesID,
			&i.Address.LocationsID,
			&i.Address.CreatedAt,
			&i.Address.UpdatedAt,
			&i.Address.PropertyMapLocationID,
			&i.Address.FullAddress,
			&i.Address.FullAddressAr,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitsForGeoJson = `-- name: GetUnitsForGeoJson :many
WITH facilities_and_amenities AS(
    SELECT uv.id,
    fa."type",
    array_agg(DISTINCT coalesce(fae.facility_amenity_id,0))::bigint[] AS facilities_amenities
    FROM unit_versions uv
    JOIN units u on u.id=uv.unit_id
    LEFT JOIN facilities_amenities_entity fae ON fae.entity_id=u.id AND fae.entity_type_id= $1::bigint 
    LEFT JOIN facilities_amenities fa ON fae.facility_amenity_id=fa.id 
    group by uv.id, fa."type" 
),
unit_media_agg AS (
    SELECT
        entity_id,entity_type_id,
        array_agg(DISTINCT media_type ORDER BY media_type) AS media
    FROM 
        global_media
    WHERE global_media.entity_type_id = $1::bigint
    OR global_media.entity_type_id = $2::bigint
    GROUP BY 
        entity_id,entity_type_id
),
MinDates AS (
    SELECT  
        	unit_versions.id as unit_id,
        plan_installments.payment_plans,
        MIN(plan_installments."date") AS earliest_date
    FROM 
        unit_versions
    JOIN 
        payment_plans_packages 
        ON payment_plans_packages.entity_id = unit_versions.id 
        AND payment_plans_packages.entity_type_id = $2::bigint
    JOIN 
        plan_installments 
        ON plan_installments.payment_plans = ANY(payment_plans_packages.payment_plans_id)
    GROUP BY 
        plan_installments.payment_plans,unit_versions.id
),
downpayment as(
    SELECT 
        unit_versions.id as "unit_id", 
        ARRAY_AGG(plan_installments.percentage) as percentages
    FROM unit_versions
    LEFT JOIN MinDates ON  MinDates.unit_id=unit_versions.id
    left JOIN 
        plan_installments 
        ON plan_installments.payment_plans = MinDates.payment_plans 
        AND plan_installments."date" = MinDates.earliest_date
    group by unit_versions.id
),
DesiredCountries as (
    SELECT DISTINCT unit_versions.id AS unit_id,ARRAY_AGG(addresses.countries_id) AS "countries" FROM unit_versions 
    JOIN swap_requirement ON swap_requirement.entity_id=unit_versions.id AND swap_requirement.entity_type= $2::BIGINT
    JOIN swap_requirment_address ON swap_requirment_address.swap_requirment_id=swap_requirement.id
    JOIN addresses ON addresses.id=swap_requirment_address.addresses_id
    WHERE unit_versions."type"= 3
    GROUP BY unit_versions.id
),
media as(
	SELECT DISTINCT on (unit_versions.id)
    unit_versions.id AS unit_version_id, 
    global_media.file_urls[1]::varchar AS image_url
	FROM unit_versions
	join units on units.id=unit_versions.unit_id
	JOIN global_media 
	  ON   ( case when unit_versions.has_gallery is null OR unit_versions.has_gallery=FALSE then units.id = global_media.entity_id  and global_media.entity_type_id= $1::bigint 
    else global_media.entity_id=unit_versions.id and global_media.entity_type_id= $2::BIGINT END)
    where 
	     global_media.media_type = 1 
	    AND global_media.gallery_type = 'Main'
)
SELECT
    uv.id,
    uv.listed_by,
    uv."type" as category,
    uv.ref_no, 
	uv.is_main, 
	uv.is_verified, 
	uv."exclusive",
	uv.is_hotdeal,
    uv.unit_rank,
    
    ut."usage",
    ut.id as unit_type_id,
    ut.type as unit_type,
    u.is_project_unit,    
    coalesce((u.facts->>'life_style')::BIGINT, 0)::bigint as life_style,
    coalesce((uv.facts->>'price')::float, 0)::float as price,
    coalesce((uv.facts->>'starting_price')::FLOAT, 0)::FLOAT as starting_price,
    coalesce((u.facts->>'bedroom')::VARCHAR, '')::VARCHAR as bedroom,
    coalesce((u.facts->>'bathroom')::bigint, 0)::bigint as bathroom,
    coalesce((u.facts->>'completion_status')::BIGINT, 0)::BIGINT as completion_status, 
    coalesce((u.facts->>'completion_percentage')::bigint, 0)::bigint as completion_percentage,
    coalesce((u.facts->>'ownership')::bigint, 0)::bigint as ownership,
    coalesce((u.facts->>'furnished')::bigint, 0)::bigint as furnished,
    coalesce((u.facts->>'max_area')::FLOAT, 0)::FLOAT as max_area,   
    coalesce((u.facts->>'min_area')::FLOAT, 0)::FLOAT as min_area,
    coalesce((u.facts->>'built_up_area')::FLOAT, 0)::FLOAT as built_up_area,
    coalesce((u.facts->>'plot_area')::FLOAT, 0)::FLOAT as plot_area,
    coalesce((u.facts->>'parking')::BIGINT, 0)::BIGINT as parking,
    coalesce((u.facts->>'no_of_floor')::BIGINT, 0)::BIGINT as no_of_floor,
    coalesce((u.facts->>'handover_date')::timestamp, CURRENT_TIMESTAMP)::timestamp as handover_date,
    coalesce((u.facts->>'service_charge')::FLOAT, 0.0)::FLOAT as service_charge, 
    coalesce((string_to_array(trim(both '[]' from u.facts->>'views'), ',')::BIGINT[]), array[]::bigint[])::bigint[]  as views,
    coalesce((uv.facts->>'investment')::bool,false)::bool as investment,    
    coalesce((uv.facts->>'roi')::bool,false)::bool as roi,
    coalesce(f.facilities_amenities::bigint[], array[]::bigint[])::bigint[] as facilities,
    coalesce(am.facilities_amenities::bigint[], array[]::bigint[])::bigint[] as amenities,
    
    coalesce(DesiredCountries.countries::bigint[], '{}'::bigint[])::bigint[] as swap_desired_countries,
    -- coalesce(downpayment.percentages::varchar[], '{}'::varchar[])::varchar[] as downpayment_percentages,
    coalesce(array_remove(downpayment.percentages, NULL), '{}'::varchar[])::varchar[] as downpayment_percentages,
    coalesce(unit_media_agg.media::bigint[], '{}'::bigint[])::bigint[] as property_media_types,
    media.image_url,
	

    u.company_id as developer_company_id,
    cu.company_id as broker_company_id,
    -- location filters
    a.id, a.countries_id, a.states_id, a.cities_id, a.communities_id, a.sub_communities_id, a.locations_id, a.created_at, a.updated_at, a.property_map_location_id, a.full_address, a.full_address_ar,  
    locations.lat, 
    locations.lng

FROM unit_versions uv
JOIN units u on u.id=uv.unit_id -- changed
JOIN unit_type ut on ut.id=u.unit_type_id -- changed
JOIN addresses a on u.addresses_id=a.id -- changed
JOIN media on media.unit_version_id=uv.id
LEFT JOIN locations ON locations.id=a.locations_id
join unit_media_agg on (
	case when uv.has_gallery is null OR uv.has_gallery=FALSE then unit_media_agg.entity_id=u.id and unit_media_agg.entity_type_id= $1::bigint 
	ELSE  unit_media_agg.entity_id=uv.id and unit_media_agg.entity_type_id= $2::BIGINT END)
LEFT JOIN downpayment ON downpayment.unit_id = uv.id
LEFT JOIN facilities_and_amenities f ON f.id=uv.id AND f."type"=1
LEFT JOIN facilities_and_amenities am ON am.id=uv.id AND am."type"=2
LEFT JOIN property p ON p.id=u.entity_id AND u.entity_type_id= $3::bigint
JOIN company_users cu ON cu.users_id=uv.listed_by
JOIN users ON users.id=cu.users_id
LEFT JOIN DesiredCountries ON DesiredCountries.unit_id=uv.id AND uv.type=3
WHERE 
    cu.company_id= $4::BIGINT 
    AND users.status=2
    AND uv.status not in (1,5,6)
`

type GetUnitsForGeoJsonParams struct {
	UnitEntityType         int64 `json:"unit_entity_type"`
	UnitversionsEntityType int64 `json:"unitversions_entity_type"`
	PropertyEntityType     int64 `json:"property_entity_type"`
	CompanyID              int64 `json:"company_id"`
}

type GetUnitsForGeoJsonRow struct {
	ID                     int64            `json:"id"`
	ListedBy               int64            `json:"listed_by"`
	Category               int64            `json:"category"`
	RefNo                  string           `json:"ref_no"`
	IsMain                 bool             `json:"is_main"`
	IsVerified             bool             `json:"is_verified"`
	Exclusive              bool             `json:"exclusive"`
	IsHotdeal              bool             `json:"is_hotdeal"`
	UnitRank               int64            `json:"unit_rank"`
	Usage                  int64            `json:"usage"`
	UnitTypeID             int64            `json:"unit_type_id"`
	UnitType               string           `json:"unit_type"`
	IsProjectUnit          pgtype.Bool      `json:"is_project_unit"`
	LifeStyle              int64            `json:"life_style"`
	Price                  float64          `json:"price"`
	StartingPrice          float64          `json:"starting_price"`
	Bedroom                string           `json:"bedroom"`
	Bathroom               int64            `json:"bathroom"`
	CompletionStatus       int64            `json:"completion_status"`
	CompletionPercentage   int64            `json:"completion_percentage"`
	Ownership              int64            `json:"ownership"`
	Furnished              int64            `json:"furnished"`
	MaxArea                float64          `json:"max_area"`
	MinArea                float64          `json:"min_area"`
	BuiltUpArea            float64          `json:"built_up_area"`
	PlotArea               float64          `json:"plot_area"`
	Parking                int64            `json:"parking"`
	NoOfFloor              int64            `json:"no_of_floor"`
	HandoverDate           pgtype.Timestamp `json:"handover_date"`
	ServiceCharge          float64          `json:"service_charge"`
	Views                  []int64          `json:"views"`
	Investment             pgtype.Bool      `json:"investment"`
	Roi                    pgtype.Bool      `json:"roi"`
	Facilities             []int64          `json:"facilities"`
	Amenities              []int64          `json:"amenities"`
	SwapDesiredCountries   []int64          `json:"swap_desired_countries"`
	DownpaymentPercentages []string         `json:"downpayment_percentages"`
	PropertyMediaTypes     []int64          `json:"property_media_types"`
	ImageUrl               string           `json:"image_url"`
	DeveloperCompanyID     pgtype.Int8      `json:"developer_company_id"`
	BrokerCompanyID        int64            `json:"broker_company_id"`
	Address                Address          `json:"address"`
	Lat                    pgtype.Text      `json:"lat"`
	Lng                    pgtype.Text      `json:"lng"`
}

func (q *Queries) GetUnitsForGeoJson(ctx context.Context, arg GetUnitsForGeoJsonParams) ([]GetUnitsForGeoJsonRow, error) {
	rows, err := q.db.Query(ctx, getUnitsForGeoJson,
		arg.UnitEntityType,
		arg.UnitversionsEntityType,
		arg.PropertyEntityType,
		arg.CompanyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitsForGeoJsonRow
	for rows.Next() {
		var i GetUnitsForGeoJsonRow
		if err := rows.Scan(
			&i.ID,
			&i.ListedBy,
			&i.Category,
			&i.RefNo,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.IsHotdeal,
			&i.UnitRank,
			&i.Usage,
			&i.UnitTypeID,
			&i.UnitType,
			&i.IsProjectUnit,
			&i.LifeStyle,
			&i.Price,
			&i.StartingPrice,
			&i.Bedroom,
			&i.Bathroom,
			&i.CompletionStatus,
			&i.CompletionPercentage,
			&i.Ownership,
			&i.Furnished,
			&i.MaxArea,
			&i.MinArea,
			&i.BuiltUpArea,
			&i.PlotArea,
			&i.Parking,
			&i.NoOfFloor,
			&i.HandoverDate,
			&i.ServiceCharge,
			&i.Views,
			&i.Investment,
			&i.Roi,
			&i.Facilities,
			&i.Amenities,
			&i.SwapDesiredCountries,
			&i.DownpaymentPercentages,
			&i.PropertyMediaTypes,
			&i.ImageUrl,
			&i.DeveloperCompanyID,
			&i.BrokerCompanyID,
			&i.Address.ID,
			&i.Address.CountriesID,
			&i.Address.StatesID,
			&i.Address.CitiesID,
			&i.Address.CommunitiesID,
			&i.Address.SubCommunitiesID,
			&i.Address.LocationsID,
			&i.Address.CreatedAt,
			&i.Address.UpdatedAt,
			&i.Address.PropertyMapLocationID,
			&i.Address.FullAddress,
			&i.Address.FullAddressAr,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
