// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: global_property.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkIfPropertyExistsByRefNo = `-- name: CheckIfPropertyExistsByRefNo :one
SELECT EXISTS (
    SELECT 1
    FROM property
    INNER JOIN property_versions 
        ON property_versions.property_id = property.id 
        AND property_versions.is_main IS TRUE
    WHERE property_versions.ref_no = $1
)::boolean AS is_property_exist
`

// ---- used for xml
func (q *Queries) CheckIfPropertyExistsByRefNo(ctx context.Context, refNo string) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfPropertyExistsByRefNo, refNo)
	var is_property_exist bool
	err := row.Scan(&is_property_exist)
	return is_property_exist, err
}

const createNewProperty = `-- name: CreateNewProperty :one
INSERT INTO property (
    company_id,
    property_type_id, 
    property_title, 
    property_title_arabic, 
    is_verified, 
    addresses_id, 
    entity_type_id,
    entity_id,
    status,
    is_show_owner_info,
    property_name, 
    description, 
    description_arabic,
    owner_users_id,
    user_id,
    from_xml,
    facts,
    updated_by,
    notes,
    notes_ar,
	is_public_note,
    is_project_property,
    unit_type_id
) VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,
    $14,$15,$16,$17,$18,$19,$20,$21,$22,$23
)RETURNING id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date
`

type CreateNewPropertyParams struct {
	CompanyID           pgtype.Int8 `json:"company_id"`
	PropertyTypeID      int64       `json:"property_type_id"`
	PropertyTitle       string      `json:"property_title"`
	PropertyTitleArabic pgtype.Text `json:"property_title_arabic"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	AddressesID         int64       `json:"addresses_id"`
	EntityTypeID        int64       `json:"entity_type_id"`
	EntityID            int64       `json:"entity_id"`
	Status              int64       `json:"status"`
	IsShowOwnerInfo     pgtype.Bool `json:"is_show_owner_info"`
	PropertyName        string      `json:"property_name"`
	Description         string      `json:"description"`
	DescriptionArabic   pgtype.Text `json:"description_arabic"`
	OwnerUsersID        pgtype.Int8 `json:"owner_users_id"`
	UserID              int64       `json:"user_id"`
	FromXml             pgtype.Bool `json:"from_xml"`
	Facts               []byte      `json:"facts"`
	UpdatedBy           int64       `json:"updated_by"`
	Notes               pgtype.Text `json:"notes"`
	NotesAr             pgtype.Text `json:"notes_ar"`
	IsPublicNote        bool        `json:"is_public_note"`
	IsProjectProperty   bool        `json:"is_project_property"`
	UnitTypeID          []int64     `json:"unit_type_id"`
}

func (q *Queries) CreateNewProperty(ctx context.Context, arg CreateNewPropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, createNewProperty,
		arg.CompanyID,
		arg.PropertyTypeID,
		arg.PropertyTitle,
		arg.PropertyTitleArabic,
		arg.IsVerified,
		arg.AddressesID,
		arg.EntityTypeID,
		arg.EntityID,
		arg.Status,
		arg.IsShowOwnerInfo,
		arg.PropertyName,
		arg.Description,
		arg.DescriptionArabic,
		arg.OwnerUsersID,
		arg.UserID,
		arg.FromXml,
		arg.Facts,
		arg.UpdatedBy,
		arg.Notes,
		arg.NotesAr,
		arg.IsPublicNote,
		arg.IsProjectProperty,
		arg.UnitTypeID,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const createPropertyAgents = `-- name: CreatePropertyAgents :one
INSERT INTO property_agents (
property_id,
agent_id,
note,
assignment_date
) VALUES (
    $1,$2,$3,$4
)RETURNING id, property_id, agent_id, note, assignment_date, created_at, updated_at
`

type CreatePropertyAgentsParams struct {
	PropertyID     int64     `json:"property_id"`
	AgentID        int64     `json:"agent_id"`
	Note           string    `json:"note"`
	AssignmentDate time.Time `json:"assignment_date"`
}

func (q *Queries) CreatePropertyAgents(ctx context.Context, arg CreatePropertyAgentsParams) (PropertyAgent, error) {
	row := q.db.QueryRow(ctx, createPropertyAgents,
		arg.PropertyID,
		arg.AgentID,
		arg.Note,
		arg.AssignmentDate,
	)
	var i PropertyAgent
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.AgentID,
		&i.Note,
		&i.AssignmentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPropertyVersion = `-- name: CreatePropertyVersion :one
INSERT INTO property_versions (
title,
title_arabic,
description,
description_arabic,
property_id,
property_rank,
facts,
updated_by,
agent_id,
ref_no,
is_main,
is_verified,
exclusive,
start_date,
end_date,
category,
refreshed_at
) VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
)RETURNING id, title, views_count, title_arabic, description, description_arabic, property_rank, property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type CreatePropertyVersionParams struct {
	Title             string             `json:"title"`
	TitleArabic       pgtype.Text        `json:"title_arabic"`
	Description       string             `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	PropertyID        int64              `json:"property_id"`
	PropertyRank      int64              `json:"property_rank"`
	Facts             []byte             `json:"facts"`
	UpdatedBy         int64              `json:"updated_by"`
	AgentID           int64              `json:"agent_id"`
	RefNo             string             `json:"ref_no"`
	IsMain            bool               `json:"is_main"`
	IsVerified        bool               `json:"is_verified"`
	Exclusive         bool               `json:"exclusive"`
	StartDate         pgtype.Date        `json:"start_date"`
	EndDate           pgtype.Date        `json:"end_date"`
	Category          int64              `json:"category"`
	RefreshedAt       pgtype.Timestamptz `json:"refreshed_at"`
}

func (q *Queries) CreatePropertyVersion(ctx context.Context, arg CreatePropertyVersionParams) (PropertyVersion, error) {
	row := q.db.QueryRow(ctx, createPropertyVersion,
		arg.Title,
		arg.TitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.PropertyID,
		arg.PropertyRank,
		arg.Facts,
		arg.UpdatedBy,
		arg.AgentID,
		arg.RefNo,
		arg.IsMain,
		arg.IsVerified,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.Category,
		arg.RefreshedAt,
	)
	var i PropertyVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const createUnitTypeVariation = `-- name: CreateUnitTypeVariation :one
INSERT INTO unit_type_variation (
    description,
    description_ar,
    min_area, 
    max_area, 
    min_price, 
    max_price, 
    parking,
    balcony, 
    bedrooms,
    bathroom,
    property_id,
    title,
    title_ar,
    ref_no,
    image_url, 
    status, 
    unit_type_id  
) VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16, $17
)RETURNING id, description, min_area, max_area, min_price, max_price, parking, balcony, bedrooms, bathroom, property_id, unit_type_id, title, image_url, description_ar, status, ref_no, created_at, updated_at, title_ar
`

type CreateUnitTypeVariationParams struct {
	Description   string      `json:"description"`
	DescriptionAr pgtype.Text `json:"description_ar"`
	MinArea       float64     `json:"min_area"`
	MaxArea       float64     `json:"max_area"`
	MinPrice      float64     `json:"min_price"`
	MaxPrice      float64     `json:"max_price"`
	Parking       int64       `json:"parking"`
	Balcony       int64       `json:"balcony"`
	Bedrooms      pgtype.Text `json:"bedrooms"`
	Bathroom      pgtype.Text `json:"bathroom"`
	PropertyID    int64       `json:"property_id"`
	Title         string      `json:"title"`
	TitleAr       pgtype.Text `json:"title_ar"`
	RefNo         string      `json:"ref_no"`
	ImageUrl      []string    `json:"image_url"`
	Status        int64       `json:"status"`
	UnitTypeID    int64       `json:"unit_type_id"`
}

func (q *Queries) CreateUnitTypeVariation(ctx context.Context, arg CreateUnitTypeVariationParams) (UnitTypeVariation, error) {
	row := q.db.QueryRow(ctx, createUnitTypeVariation,
		arg.Description,
		arg.DescriptionAr,
		arg.MinArea,
		arg.MaxArea,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Parking,
		arg.Balcony,
		arg.Bedrooms,
		arg.Bathroom,
		arg.PropertyID,
		arg.Title,
		arg.TitleAr,
		arg.RefNo,
		arg.ImageUrl,
		arg.Status,
		arg.UnitTypeID,
	)
	var i UnitTypeVariation
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.MinArea,
		&i.MaxArea,
		&i.MinPrice,
		&i.MaxPrice,
		&i.Parking,
		&i.Balcony,
		&i.Bedrooms,
		&i.Bathroom,
		&i.PropertyID,
		&i.UnitTypeID,
		&i.Title,
		&i.ImageUrl,
		&i.DescriptionAr,
		&i.Status,
		&i.RefNo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const deleteUnitTypeVariationsById = `-- name: DeleteUnitTypeVariationsById :exec
UPDATE unit_type_variation
SET status = 6,
updated_at=now()
WHERE unit_type_variation.id = $1::bigint
`

func (q *Queries) DeleteUnitTypeVariationsById(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUnitTypeVariationsById, id)
	return err
}

const getAddToForPropertyVersion = `-- name: GetAddToForPropertyVersion :one
WITH category_flags AS (
    SELECT 
        MAX(CASE WHEN pv.category = 1 THEN 1 ELSE 0 END) AS has_sale,
        MAX(CASE WHEN pv.category = 2 THEN 1 ELSE 0 END) AS has_rent
    FROM 
        property p
    INNER JOIN 
        property_versions pv ON pv.property_id = p.id
    WHERE 
        p.id = $1
)
SELECT 
    CASE 
        WHEN has_sale = 1 AND has_rent = 1 THEN NULL -- Both exist, return nothing
        WHEN has_rent = 1 THEN 'sale'              -- Rent exists, return sale
        WHEN has_sale = 1 THEN 'rent'              -- Sale exists, return rent
    END AS result
FROM 
    category_flags
`

func (q *Queries) GetAddToForPropertyVersion(ctx context.Context, id int64) (interface{}, error) {
	row := q.db.QueryRow(ctx, getAddToForPropertyVersion, id)
	var result interface{}
	err := row.Scan(&result)
	return result, err
}

const getAllAgents = `-- name: GetAllAgents :many
SELECT u.id, CONCAT(first_name,' ',last_name)::varchar AS agent_name
FROM users u
INNER JOIN profiles ON profiles.users_id = u.id
LEFT JOIN company_users cu ON $1::boolean = true AND cu.company_id = $2::bigint  -- company id if the visited user is company user or company admin
WHERE u.user_types_id = 2 
AND CASE WHEN $1::boolean = false THEN cu.users_id IS NULL ELSE cu.users_id = u.id END
AND  ($3::varchar = '%%'::varchar OR CONCAT(first_name,' ', last_name)::varchar ILIKE $3::varchar)
AND u.status NOT IN (5,6)
ORDER BY u.id
`

type GetAllAgentsParams struct {
	IsCompanyUser bool   `json:"is_company_user"`
	ActiveCompany int64  `json:"active_company"`
	Search        string `json:"search"`
}

type GetAllAgentsRow struct {
	ID        int64  `json:"id"`
	AgentName string `json:"agent_name"`
}

// SELECT u.id, u.username
// FROM users u
// WHERE
//
//	($1 = 11 AND u.user_types_id = 2 AND u.username like $2)
//
// OR
//
//	($1 != 11 AND u.id IN (
//	    SELECT cu.users_id
//	    FROM company_users cu
//	    WHERE cu.company_id = (
//	        SELECT c.id
//	        FROM users u
//	        INNER JOIN companies c ON c.users_id = u.id
//	        WHERE u.id = $1 AND u.user_types_id = 1 AND u.username like $2
//	    )
//	));
func (q *Queries) GetAllAgents(ctx context.Context, arg GetAllAgentsParams) ([]GetAllAgentsRow, error) {
	rows, err := q.db.Query(ctx, getAllAgents, arg.IsCompanyUser, arg.ActiveCompany, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAgentsRow
	for rows.Next() {
		var i GetAllAgentsRow
		if err := rows.Scan(&i.ID, &i.AgentName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyAgents = `-- name: GetAllCompanyAgents :many
SELECT u.id, CONCAT(first_name,' ',last_name)::varchar AS agent_name
FROM users u
INNER JOIN profiles ON profiles.users_id = u.id
LEFT JOIN company_users cu ON $1::boolean = true AND cu.users_id = u.id::bigint  -- company id if the visited user is company user or company admin
WHERE u.user_types_id = 2 
AND CASE WHEN $1::boolean = false THEN cu.users_id IS NULL ELSE cu.company_id = $2 END
AND u.status NOT IN (5,6)
ORDER BY u.id
`

type GetAllCompanyAgentsParams struct {
	IsCompanyUser bool  `json:"is_company_user"`
	ActiveCompany int64 `json:"active_company"`
}

type GetAllCompanyAgentsRow struct {
	ID        int64  `json:"id"`
	AgentName string `json:"agent_name"`
}

func (q *Queries) GetAllCompanyAgents(ctx context.Context, arg GetAllCompanyAgentsParams) ([]GetAllCompanyAgentsRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyAgents, arg.IsCompanyUser, arg.ActiveCompany)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyAgentsRow
	for rows.Next() {
		var i GetAllCompanyAgentsRow
		if err := rows.Scan(&i.ID, &i.AgentName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFreelanceAgents = `-- name: GetAllFreelanceAgents :many
select u.id, CONCAT(first_name,' ',last_name)::varchar AS agent_name from users u
INNER JOIN profiles ON profiles.users_id = u.id where u.user_types_id= 4
`

type GetAllFreelanceAgentsRow struct {
	ID        int64  `json:"id"`
	AgentName string `json:"agent_name"`
}

func (q *Queries) GetAllFreelanceAgents(ctx context.Context) ([]GetAllFreelanceAgentsRow, error) {
	rows, err := q.db.Query(ctx, getAllFreelanceAgents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFreelanceAgentsRow
	for rows.Next() {
		var i GetAllFreelanceAgentsRow
		if err := rows.Scan(&i.ID, &i.AgentName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllGlobalProperty = `-- name: GetAllGlobalProperty :many
select id, 
CASE 
  WHEN $2::varchar = 'ar' THEN COALESCE(type_ar,"type")
  ELSE COALESCE("type", '') 
END::varchar AS "type",
code, property_type_facts, "usage", created_at, updated_at, status, icon, is_project
from global_property_type where is_project =$1
and status = $3::BIGINT
`

type GetAllGlobalPropertyParams struct {
	IsProject    pgtype.Bool `json:"is_project"`
	Lang         string      `json:"lang"`
	ActiveStatus int64       `json:"active_status"`
}

type GetAllGlobalPropertyRow struct {
	ID                int64       `json:"id"`
	Type              string      `json:"type"`
	Code              string      `json:"code"`
	PropertyTypeFacts []byte      `json:"property_type_facts"`
	Usage             int64       `json:"usage"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	Status            int64       `json:"status"`
	Icon              pgtype.Text `json:"icon"`
	IsProject         pgtype.Bool `json:"is_project"`
}

func (q *Queries) GetAllGlobalProperty(ctx context.Context, arg GetAllGlobalPropertyParams) ([]GetAllGlobalPropertyRow, error) {
	rows, err := q.db.Query(ctx, getAllGlobalProperty, arg.IsProject, arg.Lang, arg.ActiveStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGlobalPropertyRow
	for rows.Next() {
		var i GetAllGlobalPropertyRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.PropertyTypeFacts,
			&i.Usage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Icon,
			&i.IsProject,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertiesByUsageandName = `-- name: GetAllPropertiesByUsageandName :many
SELECT distinct property.id, property.property_name, gp.type,is_project_property
FROM property
INNER JOIN property_versions pv ON pv.property_id = property.id
LEFT JOIN company_users cu ON cu.users_id = pv.agent_id
LEFT JOIN companies c ON property.company_id = c.id
INNER JOIN global_property_type gp ON gp.id = property.property_type_id
WHERE 
     (
       case when $2::BIGINT = 0 then true else
        ( 
        c.id = $2::BIGINT
        -- OR 
        -- cu.company_id =@company_id::BIGINT 
        ) end
    )
    AND 
      (
        $3::BIGINT = 0 
        OR pv.agent_id = $3::BIGINT
      )	 
    AND  property.property_name LIKE '%' || $1 || '%'
`

type GetAllPropertiesByUsageandNameParams struct {
	Column1   pgtype.Text `json:"column_1"`
	CompanyID int64       `json:"company_id"`
	AgentID   int64       `json:"agent_id"`
}

type GetAllPropertiesByUsageandNameRow struct {
	ID                int64  `json:"id"`
	PropertyName      string `json:"property_name"`
	Type              string `json:"type"`
	IsProjectProperty bool   `json:"is_project_property"`
}

func (q *Queries) GetAllPropertiesByUsageandName(ctx context.Context, arg GetAllPropertiesByUsageandNameParams) ([]GetAllPropertiesByUsageandNameRow, error) {
	rows, err := q.db.Query(ctx, getAllPropertiesByUsageandName, arg.Column1, arg.CompanyID, arg.AgentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPropertiesByUsageandNameRow
	for rows.Next() {
		var i GetAllPropertiesByUsageandNameRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyName,
			&i.Type,
			&i.IsProjectProperty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertiesVersionByCountry = `-- name: GetAllPropertiesVersionByCountry :many
Select pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at,p.property_name,p.from_xml,p.is_verified,p.status,p.property_type_id,p.owner_users_id,
p.addresses_id, gp."type",
COALESCE(CAST(pq.quality_score AS FLOAT), 0.0) AS quality_score ,
refresh_schedules.next_run_at AS next_run_at
FROM property p
INNER JOIN property_versions pv ON pv.property_id = p.id
LEFT JOIN global_property_type gp ON gp.id = p.property_type_id
LEFT JOIN addresses a ON p.addresses_id = a.id
LEFT JOIN property_quality_score pq ON pq.property_id = p.id
LEFT JOIN companies c ON p.company_id = c.id
LEFT JOIN company_users cu ON cu.users_id = pv.agent_id
LEFT JOIN countries co ON a.countries_id = co.id
LEFT JOIN states ON a.states_id = states.id   
LEFT JOIN cities ON a.cities_id = cities.id
LEFT JOIN sub_communities ON sub_communities.id = a.sub_communities_id
LEFT JOIN refresh_schedules ON refresh_schedules.entity_type_id= $4::BIGINT AND refresh_schedules.entity_id= pv.id AND refresh_schedules.status not in (5,6)
WHERE 
     (
        $5::BIGINT = 0 
        OR c.id = $5::BIGINT
        AND cu.company_id = $5::BIGINT
    )
    AND 
    (
        $6::BIGINT = 0 
        OR pv.agent_id = $6::BIGINT
    )	 
AND (case when $7::bigint=0 then p.status not in (5,6) and pv.status not in (5,6) else pv.status= $7::bigint end)
AND p.entity_type_id != 1 AND
gp.usage = ANY($8::bigint[])
AND (CASE WHEN $9::bigint= 0 THEN true ELSE (pv.facts->'life_style')::bigint = $9 END)
AND (CASE 
    WHEN $10::bigint = 0 THEN true 
    WHEN $11::bool IS NULL THEN true 
    WHEN $11::bool = true THEN a.countries_id = $10::bigint 
    ELSE a.countries_id != $10::bigint 
    END)
AND (CASE WHEN $3::varchar = '%%' THEN TRUE 
    ELSE 
        p.property_name ILIKE '%'||$3||'%' OR 
        p.property_title ILIKE '%'||$3||'%' OR
        co.country ILIKE '%'||$3||'%' OR 
        gp."type" ILIKE '%'||$3||'%' OR 
        states."state" ILIKE '%'||$3||'%' OR 
        cities.city ILIKE '%'||$3||'%' OR 
        sub_communities.sub_community ILIKE '%'||$3||'%' OR 
        pv.ref_no ILIKE $3 END)
GROUP BY p.id,pv.id,gp.id,pq.quality_score, next_run_at
ORDER BY pv.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllPropertiesVersionByCountryParams struct {
	Limit                     int32       `json:"limit"`
	Offset                    int32       `json:"offset"`
	Column3                   string      `json:"column_3"`
	PropertyVersionEntityType int64       `json:"property_version_entity_type"`
	CompanyID                 int64       `json:"company_id"`
	AgentID                   int64       `json:"agent_id"`
	Status                    int64       `json:"status"`
	Usage                     []int64     `json:"usage"`
	LifeStyle                 int64       `json:"life_style"`
	CountryID                 int64       `json:"country_id"`
	IsLocal                   pgtype.Bool `json:"is_local"`
}

type GetAllPropertiesVersionByCountryRow struct {
	ID                int64              `json:"id"`
	Title             string             `json:"title"`
	ViewsCount        int64              `json:"views_count"`
	TitleArabic       pgtype.Text        `json:"title_arabic"`
	Description       string             `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	PropertyRank      int64              `json:"property_rank"`
	PropertyID        int64              `json:"property_id"`
	Facts             []byte             `json:"facts"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	UpdatedBy         int64              `json:"updated_by"`
	Status            int64              `json:"status"`
	AgentID           int64              `json:"agent_id"`
	RefNo             string             `json:"ref_no"`
	Category          int64              `json:"category"`
	HasGallery        pgtype.Bool        `json:"has_gallery"`
	HasPlans          pgtype.Bool        `json:"has_plans"`
	IsMain            bool               `json:"is_main"`
	IsVerified        bool               `json:"is_verified"`
	Exclusive         bool               `json:"exclusive"`
	StartDate         pgtype.Date        `json:"start_date"`
	EndDate           pgtype.Date        `json:"end_date"`
	Slug              string             `json:"slug"`
	IsHotdeal         bool               `json:"is_hotdeal"`
	RefreshedAt       pgtype.Timestamptz `json:"refreshed_at"`
	PropertyName      string             `json:"property_name"`
	FromXml           pgtype.Bool        `json:"from_xml"`
	IsVerified_2      pgtype.Bool        `json:"is_verified_2"`
	Status_2          int64              `json:"status_2"`
	PropertyTypeID    int64              `json:"property_type_id"`
	OwnerUsersID      pgtype.Int8        `json:"owner_users_id"`
	AddressesID       int64              `json:"addresses_id"`
	Type              pgtype.Text        `json:"type"`
	QualityScore      interface{}        `json:"quality_score"`
	NextRunAt         pgtype.Timestamptz `json:"next_run_at"`
}

func (q *Queries) GetAllPropertiesVersionByCountry(ctx context.Context, arg GetAllPropertiesVersionByCountryParams) ([]GetAllPropertiesVersionByCountryRow, error) {
	rows, err := q.db.Query(ctx, getAllPropertiesVersionByCountry,
		arg.Limit,
		arg.Offset,
		arg.Column3,
		arg.PropertyVersionEntityType,
		arg.CompanyID,
		arg.AgentID,
		arg.Status,
		arg.Usage,
		arg.LifeStyle,
		arg.CountryID,
		arg.IsLocal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPropertiesVersionByCountryRow
	for rows.Next() {
		var i GetAllPropertiesVersionByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.PropertyName,
			&i.FromXml,
			&i.IsVerified_2,
			&i.Status_2,
			&i.PropertyTypeID,
			&i.OwnerUsersID,
			&i.AddressesID,
			&i.Type,
			&i.QualityScore,
			&i.NextRunAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertiesVersionByStatus = `-- name: GetAllPropertiesVersionByStatus :many
Select pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at,p.property_name,p.is_verified,p.status,p.property_type_id,p.user_id,
p.addresses_id, gp."type"from property p 
INNER JOIN property_versions pv ON pv.property_id=p.id 
LEFT JOIN global_property_type gp ON gp.id = p.property_type_id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN companies c ON p.company_id = c.id
LEFT JOIN company_users cu ON cu.users_id = pv.agent_id
AND p.status =$3
WHERE 
     (
        $4::BIGINT = 0 
        OR c.id = $4::BIGINT
        AND cu.company_id = $4::BIGINT
    )
    AND 
    (
        $5::BIGINT = 0 
        OR pv.agent_id = $5::BIGINT
    )	
GROUP BY p.id,pv.id,gp.id
ORDER BY pv.created_at ASC
LIMIT $1 OFFSET $2
`

type GetAllPropertiesVersionByStatusParams struct {
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
	Status    int64 `json:"status"`
	CompanyID int64 `json:"company_id"`
	AgentID   int64 `json:"agent_id"`
}

type GetAllPropertiesVersionByStatusRow struct {
	ID                int64              `json:"id"`
	Title             string             `json:"title"`
	ViewsCount        int64              `json:"views_count"`
	TitleArabic       pgtype.Text        `json:"title_arabic"`
	Description       string             `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	PropertyRank      int64              `json:"property_rank"`
	PropertyID        int64              `json:"property_id"`
	Facts             []byte             `json:"facts"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	UpdatedBy         int64              `json:"updated_by"`
	Status            int64              `json:"status"`
	AgentID           int64              `json:"agent_id"`
	RefNo             string             `json:"ref_no"`
	Category          int64              `json:"category"`
	HasGallery        pgtype.Bool        `json:"has_gallery"`
	HasPlans          pgtype.Bool        `json:"has_plans"`
	IsMain            bool               `json:"is_main"`
	IsVerified        bool               `json:"is_verified"`
	Exclusive         bool               `json:"exclusive"`
	StartDate         pgtype.Date        `json:"start_date"`
	EndDate           pgtype.Date        `json:"end_date"`
	Slug              string             `json:"slug"`
	IsHotdeal         bool               `json:"is_hotdeal"`
	RefreshedAt       pgtype.Timestamptz `json:"refreshed_at"`
	PropertyName      string             `json:"property_name"`
	IsVerified_2      pgtype.Bool        `json:"is_verified_2"`
	Status_2          int64              `json:"status_2"`
	PropertyTypeID    int64              `json:"property_type_id"`
	UserID            int64              `json:"user_id"`
	AddressesID       int64              `json:"addresses_id"`
	Type              pgtype.Text        `json:"type"`
}

func (q *Queries) GetAllPropertiesVersionByStatus(ctx context.Context, arg GetAllPropertiesVersionByStatusParams) ([]GetAllPropertiesVersionByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAllPropertiesVersionByStatus,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.CompanyID,
		arg.AgentID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPropertiesVersionByStatusRow
	for rows.Next() {
		var i GetAllPropertiesVersionByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.PropertyName,
			&i.IsVerified_2,
			&i.Status_2,
			&i.PropertyTypeID,
			&i.UserID,
			&i.AddressesID,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertyVersionsIdS = `-- name: GetAllPropertyVersionsIdS :many
SELECT id from property_versions
`

func (q *Queries) GetAllPropertyVersionsIdS(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllPropertyVersionsIdS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnitTypes = `-- name: GetAllUnitTypes :one
select id, type, code, facts, listing_facts, usage, created_at, updated_at, status, icon, type_ar from unit_type where id = $1
`

func (q *Queries) GetAllUnitTypes(ctx context.Context, id int64) (UnitType, error) {
	row := q.db.QueryRow(ctx, getAllUnitTypes, id)
	var i UnitType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.Facts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.TypeAr,
	)
	return i, err
}

const getCompanyUserCountByUserAndCompany = `-- name: GetCompanyUserCountByUserAndCompany :one
SELECT COUNT(company_users.id)
FROM company_users
WHERE company_users.users_id = $1::bigint
AND company_users.company_id = $2::bigint
GROUP BY company_users.id
ORDER BY company_users.id
`

type GetCompanyUserCountByUserAndCompanyParams struct {
	ID        int64 `json:"id"`
	Companyid int64 `json:"companyid"`
}

func (q *Queries) GetCompanyUserCountByUserAndCompany(ctx context.Context, arg GetCompanyUserCountByUserAndCompanyParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCompanyUserCountByUserAndCompany, arg.ID, arg.Companyid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllPropertiesVersionByCountry = `-- name: GetCountAllPropertiesVersionByCountry :one
Select count(pv.*) from property p 
INNER JOIN property_versions pv ON pv.property_id = p.id
JOIN global_property_type gp ON gp.id = p.property_type_id
LEFT JOIN addresses a ON p.addresses_id = a.id
LEFT JOIN property_quality_score pq ON pq.property_id = p.id
LEFT JOIN companies c ON p.company_id = c.id
LEFT JOIN company_users cu ON cu.users_id = pv.agent_id
LEFT JOIN countries co ON a.countries_id = co.id
LEFT JOIN states ON a.states_id = states.id   
LEFT JOIN cities ON a.cities_id = cities.id
LEFT JOIN sub_communities ON sub_communities.id = a.sub_communities_id
WHERE 
     (
        $2::BIGINT = 0 
        OR c.id = $2::BIGINT
        AND cu.company_id = $2::BIGINT
    )
    AND 
    (
        $3::BIGINT = 0 
        OR pv.agent_id = $3::BIGINT
    )	 
AND (case when $4::bigint=0 then p.status not in (5,6) and pv.status not in (5,6) else pv.status= $4::bigint end)
AND p.entity_type_id != 1 AND
gp.usage = ANY($5::bigint[])
AND CASE WHEN $6::bigint= 0 THEN true ELSE (pv.facts->'life_style')::bigint = $6 END
AND (CASE 
    WHEN $7::bigint = 0 THEN true 
    WHEN $8::bool IS NULL THEN true 
    WHEN $8::bool = true THEN a.countries_id = $7::bigint 
    ELSE a.countries_id != $7::bigint 
    END)
AND (CASE WHEN $1::varchar = '%%' THEN TRUE 
    ELSE 
        p.property_name ILIKE '%'||$1||'%'  OR 
        p.property_title ILIKE '%'||$1||'%' OR
        co.country ILIKE '%'||$1||'%' OR 
        gp."type" ILIKE '%'||$1||'%' OR 
        states."state" ILIKE '%'||$1||'%' OR 
        cities.city ILIKE '%'||$1||'%' OR 
        sub_communities.sub_community ILIKE '%'||$1||'%' OR 
        pv.ref_no ILIKE $1 END)
`

type GetCountAllPropertiesVersionByCountryParams struct {
	Column1   string      `json:"column_1"`
	CompanyID int64       `json:"company_id"`
	AgentID   int64       `json:"agent_id"`
	Status    int64       `json:"status"`
	Usage     []int64     `json:"usage"`
	LifeStyle int64       `json:"life_style"`
	CountryID int64       `json:"country_id"`
	IsLocal   pgtype.Bool `json:"is_local"`
}

func (q *Queries) GetCountAllPropertiesVersionByCountry(ctx context.Context, arg GetCountAllPropertiesVersionByCountryParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllPropertiesVersionByCountry,
		arg.Column1,
		arg.CompanyID,
		arg.AgentID,
		arg.Status,
		arg.Usage,
		arg.LifeStyle,
		arg.CountryID,
		arg.IsLocal,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountProjectPropertiesForList = `-- name: GetCountProjectPropertiesForList :one
Select count(pv.*) from property p 
INNER JOIN property_versions pv ON pv.property_id = p.id 
LEFT JOIN projects pr ON p.entity_id = pr.id
LEFT JOIN global_property_type gpt ON p.property_type_id = gpt.id
WHERE p.status !=6 AND pv.status !=6 AND p.entity_type_id = 1 AND pr.id = $1
`

func (q *Queries) GetCountProjectPropertiesForList(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProjectPropertiesForList, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountProjectPropertiesForListPhase = `-- name: GetCountProjectPropertiesForListPhase :one
Select count(p.*) from property p 
LEFT JOIN phases ph  ON p.entity_id = ph.id
LEFT JOIN projects pr ON ph.projects_id = pr.id
INNER JOIN property_versions pv ON pv.property_id = p.id
LEFT JOIN global_property_type gpt ON p.property_type_id = gpt.id
WHERE p.status !=6 AND p.entity_type_id = 2  AND ph.id = $1
`

func (q *Queries) GetCountProjectPropertiesForListPhase(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProjectPropertiesForListPhase, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountPropertiesVersionByStatus = `-- name: GetCountPropertiesVersionByStatus :one
Select count(pv.*) from property p 
INNER JOIN property_versions pv ON pv.property_id=p.id 
JOIN global_property_type gp ON gp.id = p.property_type_id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN companies c ON p.company_id = c.id
LEFT JOIN company_users cu ON cu.users_id = pv.agent_id
AND p.status =  $1
WHERE 
     (
        $2::BIGINT = 0 
        OR c.id = $2::BIGINT
        AND cu.company_id = $2::BIGINT
    )
    AND 
    (
        $3::BIGINT = 0 
        OR pv.agent_id = $3::BIGINT
    )
`

type GetCountPropertiesVersionByStatusParams struct {
	Status    int64 `json:"status"`
	CompanyID int64 `json:"company_id"`
	AgentID   int64 `json:"agent_id"`
}

func (q *Queries) GetCountPropertiesVersionByStatus(ctx context.Context, arg GetCountPropertiesVersionByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountPropertiesVersionByStatus, arg.Status, arg.CompanyID, arg.AgentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountPropertyVersionsByPropertyId = `-- name: GetCountPropertyVersionsByPropertyId :one
select count(*) from property_versions where property_id=$1
`

func (q *Queries) GetCountPropertyVersionsByPropertyId(ctx context.Context, propertyID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountPropertyVersionsByPropertyId, propertyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDealPropertyVersion = `-- name: GetDealPropertyVersion :one
select is_hotdeal from  property_versions where id = $1
`

func (q *Queries) GetDealPropertyVersion(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, getDealPropertyVersion, id)
	var is_hotdeal bool
	err := row.Scan(&is_hotdeal)
	return is_hotdeal, err
}

const getDealUnitVersion = `-- name: GetDealUnitVersion :one
select is_hotdeal from  unit_versions where id = $1
`

func (q *Queries) GetDealUnitVersion(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, getDealUnitVersion, id)
	var is_hotdeal bool
	err := row.Scan(&is_hotdeal)
	return is_hotdeal, err
}

const getFacilitiesAmenitiesByEntity = `-- name: GetFacilitiesAmenitiesByEntity :many
select 
ca.category,
jsonb_agg(
        jsonb_build_object(
			'id', fa.id,
            'title', 
            CASE WHEN $4::varchar = 'ar' THEN COALESCE(fa.title_ar,fa.title)
            ELSE COALESCE(fa.title, '') END,            
            'icon_url', fa.icon_url,
            'type', fa.type::bigint,
            'created_at', fa.created_at
        )
        ORDER BY fa.created_at
    ) AS fac_ame
from facilities_amenities_entity fae inner join facilities_amenities fa
on fae.facility_amenity_id = fa.id
inner join categories ca on fa.categories = ca.id
where fae.entity_type_id = $1 and fae.entity_id = $2
and fa.type=$3
GROUP BY ca.category
ORDER BY ca.category
`

type GetFacilitiesAmenitiesByEntityParams struct {
	EntityTypeID int64  `json:"entity_type_id"`
	EntityID     int64  `json:"entity_id"`
	Type         int64  `json:"type"`
	Lang         string `json:"lang"`
}

type GetFacilitiesAmenitiesByEntityRow struct {
	Category string `json:"category"`
	FacAme   []byte `json:"fac_ame"`
}

func (q *Queries) GetFacilitiesAmenitiesByEntity(ctx context.Context, arg GetFacilitiesAmenitiesByEntityParams) ([]GetFacilitiesAmenitiesByEntityRow, error) {
	rows, err := q.db.Query(ctx, getFacilitiesAmenitiesByEntity,
		arg.EntityTypeID,
		arg.EntityID,
		arg.Type,
		arg.Lang,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFacilitiesAmenitiesByEntityRow
	for rows.Next() {
		var i GetFacilitiesAmenitiesByEntityRow
		if err := rows.Scan(&i.Category, &i.FacAme); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFacilityAmenityByPropertyID = `-- name: GetFacilityAmenityByPropertyID :many

select ca.category AS category,
    -- Group type 1 (Facility) into a JSON array
    jsonb_agg(
        jsonb_build_object(
            'id', facilities_amenities.id,
            'type', facilities_amenities.type,
            'title', facilities_amenities.title,
            'icon_url', facilities_amenities.icon_url,
            'category', ca.category,
            'created_at', facilities_amenities.created_at
        )
        ORDER BY facilities_amenities.created_at
    ) FILTER (WHERE facilities_amenities.type = $2) AS facilities_amenity
 from property p
LEFT JOIN facilities_amenities_entity AS fe ON fe.entity_type_id = 3 AND fe.entity_id = p.id
LEFT JOIN facilities_amenities ON facilities_amenities.id = fe.facility_amenity_id
LEFT JOIN categories ca ON ca.id = facilities_amenities.categories
where p.id = $1 and facilities_amenities."type"= $2
GROUP BY p.id,ca.id
`

type GetFacilityAmenityByPropertyIDParams struct {
	ID   int64 `json:"id"`
	Type int64 `json:"type"`
}

type GetFacilityAmenityByPropertyIDRow struct {
	Category          pgtype.Text `json:"category"`
	FacilitiesAmenity []byte      `json:"facilities_amenity"`
}

// -- name: GetFacilityAmenityByPropertyID :many
// SELECT
// ca.category AS category,
//
//	-- Group type 1 (Facility) into a JSON array
//	jsonb_agg(
//	    jsonb_build_object(
//	        'id', facilities_amenities.id,
//	        'label', facilities_amenities.title,
//	        'icon', facilities_amenities.icon_url,
//	        'category', ca.category,
//	        'created_at', facilities_amenities.created_at
//	    )
//	    ORDER BY facilities_amenities.created_at
//	) FILTER (WHERE facilities_amenities.type = 1) AS facilities,
//	-- Group type 2 (Amenity) into a JSON array
//	jsonb_agg(
//	    jsonb_build_object(
//	        'id', facilities_amenities.id,
//	        'label', facilities_amenities.title,
//	        'icon', facilities_amenities.icon_url,
//	        'category', ca.category,
//	        'created_at', facilities_amenities.created_at
//	    )
//	    ORDER BY facilities_amenities.created_at
//	) FILTER (WHERE facilities_amenities.type = 2) AS amenities
//
// FROM property p
// LEFT JOIN facilities_amenities_entity fe ON fe.entity_type_id = 3 AND fe.entity_id = p.id
// LEFT JOIN facilities_amenities ON facilities_amenities.id = fe.facility_amenity_id
// LEFT JOIN categories ca ON ca.id = facilities_amenities.categories
// WHERE p.id = $1
// GROUP BY p.id, facilities_amenities.id,ca.category;
func (q *Queries) GetFacilityAmenityByPropertyID(ctx context.Context, arg GetFacilityAmenityByPropertyIDParams) ([]GetFacilityAmenityByPropertyIDRow, error) {
	rows, err := q.db.Query(ctx, getFacilityAmenityByPropertyID, arg.ID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFacilityAmenityByPropertyIDRow
	for rows.Next() {
		var i GetFacilityAmenityByPropertyIDRow
		if err := rows.Scan(&i.Category, &i.FacilitiesAmenity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalPropertiesByStatusID = `-- name: GetGlobalPropertiesByStatusID :many
SELECT property.id, property.company_id, property.property_type_id, property.unit_type_id, property.property_title, property.property_title_arabic, property.is_verified, property.addresses_id, property.entity_type_id, property.entity_id, property.status, property.is_show_owner_info, property.property_name, property.description, property.description_arabic, property.owner_users_id, property.user_id, property.updated_by, property.from_xml, property.facts, property.notes, property.created_at, property.updated_at, property.notes_ar, property.is_public_note, property.is_project_property, property.exclusive, property.start_date, property.end_date,property_versions.ref_no,ph.phase_name, ph1.phase_name, pr.project_name,pr1.project_name, addresses.full_address, global_property_type.type AS property_type
FROM property
LEFT JOIN global_property_type ON property.property_type_id = global_property_type.id
INNER JOIN addresses ON property.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
INNER JOIN companies ON property.company_id = companies.id 
LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
LEFT JOIN property_versions ON property_versions.property_id = property.id
LEFT JOIN phases ph ON ph.id = property.entity_id and property.entity_type_id = 2
LEFT JOIN projects pr ON pr.id=ph.projects_id
LEFT JOIN projects pr1 ON pr1.id= property.entity_id and property.entity_type_id = 1
LEFT JOIN phases ph1 ON ph1.projects_id =pr.id
WHERE
    (CASE WHEN $3 = '%%' THEN TRUE 
    ELSE 
        property.property_name % $3 OR 
        property.property_title % $3 OR
        countries.country % $3 OR 
        global_property_type."type" % $3 OR 
        states."state" % $3 OR 
        cities.city % $3 OR 
        companies.company_name % $3 
        -- sub_communities.sub_community % @search
    END )
    AND property.status = $4::bigint
    AND (CASE WHEN $5::bigint = 0 THEN (property.entity_type_id = ANY($6::bigint[])) ELSE (property.entity_id = $5::bigint AND property.entity_type_id  = ANY($6::bigint[] ))   END)
    AND (CASE WHEN $7::bigint = 0 THEN true ELSE global_property_type.usage = $7::bigint END)
    -- AND (CASE WHEN @company_id::bigint = 0 THEN property.user_id = @user_id::bigint ELSE property.company_id = @company_id::bigint END)
      AND CASE WHEN $8::BOOLEAN = true THEN true ELSE (
        $9 != true
        OR (
            ($10 != false OR property.company_id = $11::bigint)
            AND ($10 != true OR property.company_id = $11::bigint)
        )
    ) END
    -- Location filters
    AND ($12::bigint = 0 OR addresses.countries_id = $12::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    AND ($13::bigint = 0 OR addresses.cities_id = $13::bigint)
    AND ($14::bigint = 0 OR addresses.communities_id = $14::bigint)
    AND ($15::bigint = 0 OR addresses.sub_communities_id = $15::bigint)
GROUP BY property.id, global_property_type.type, addresses.full_address,property_versions.id, pr.id, ph.id, ph1.id, pr1.id
ORDER BY property.updated_at DESC
LIMIT $1 OFFSET $2
`

type GetGlobalPropertiesByStatusIDParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	Search         interface{} `json:"search"`
	Status         int64       `json:"status"`
	EntityID       int64       `json:"entity_id"`
	EntityTypeID   []int64     `json:"entity_type_id"`
	Usage          int64       `json:"usage"`
	IsAdmin        bool        `json:"is_admin"`
	IsCompanyUser  interface{} `json:"is_company_user"`
	CompanyBranch  interface{} `json:"company_branch"`
	CompanyID      int64       `json:"company_id"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
}

type GetGlobalPropertiesByStatusIDRow struct {
	ID                  int64       `json:"id"`
	CompanyID           pgtype.Int8 `json:"company_id"`
	PropertyTypeID      int64       `json:"property_type_id"`
	UnitTypeID          []int64     `json:"unit_type_id"`
	PropertyTitle       string      `json:"property_title"`
	PropertyTitleArabic pgtype.Text `json:"property_title_arabic"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	AddressesID         int64       `json:"addresses_id"`
	EntityTypeID        int64       `json:"entity_type_id"`
	EntityID            int64       `json:"entity_id"`
	Status              int64       `json:"status"`
	IsShowOwnerInfo     pgtype.Bool `json:"is_show_owner_info"`
	PropertyName        string      `json:"property_name"`
	Description         string      `json:"description"`
	DescriptionArabic   pgtype.Text `json:"description_arabic"`
	OwnerUsersID        pgtype.Int8 `json:"owner_users_id"`
	UserID              int64       `json:"user_id"`
	UpdatedBy           int64       `json:"updated_by"`
	FromXml             pgtype.Bool `json:"from_xml"`
	Facts               []byte      `json:"facts"`
	Notes               pgtype.Text `json:"notes"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	NotesAr             pgtype.Text `json:"notes_ar"`
	IsPublicNote        bool        `json:"is_public_note"`
	IsProjectProperty   bool        `json:"is_project_property"`
	Exclusive           bool        `json:"exclusive"`
	StartDate           pgtype.Date `json:"start_date"`
	EndDate             pgtype.Date `json:"end_date"`
	RefNo               pgtype.Text `json:"ref_no"`
	PhaseName           pgtype.Text `json:"phase_name"`
	PhaseName_2         pgtype.Text `json:"phase_name_2"`
	ProjectName         pgtype.Text `json:"project_name"`
	ProjectName_2       pgtype.Text `json:"project_name_2"`
	FullAddress         pgtype.Text `json:"full_address"`
	PropertyType        pgtype.Text `json:"property_type"`
}

// SEARCH CRITERIA
func (q *Queries) GetGlobalPropertiesByStatusID(ctx context.Context, arg GetGlobalPropertiesByStatusIDParams) ([]GetGlobalPropertiesByStatusIDRow, error) {
	rows, err := q.db.Query(ctx, getGlobalPropertiesByStatusID,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.Status,
		arg.EntityID,
		arg.EntityTypeID,
		arg.Usage,
		arg.IsAdmin,
		arg.IsCompanyUser,
		arg.CompanyBranch,
		arg.CompanyID,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalPropertiesByStatusIDRow
	for rows.Next() {
		var i GetGlobalPropertiesByStatusIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description,
			&i.DescriptionArabic,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy,
			&i.FromXml,
			&i.Facts,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.RefNo,
			&i.PhaseName,
			&i.PhaseName_2,
			&i.ProjectName,
			&i.ProjectName_2,
			&i.FullAddress,
			&i.PropertyType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalPropertiesCountByStatusID = `-- name: GetGlobalPropertiesCountByStatusID :one
SELECT COUNT(property.*)
FROM property
LEFT JOIN global_property_type ON property.property_type_id = global_property_type.id
INNER JOIN addresses ON property.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
INNER JOIN companies ON property.company_id = companies.id 
LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
WHERE
    (CASE WHEN $1 = '%%' THEN TRUE 
    ELSE 
        property.property_name % $1 OR 
        property.property_title % $1 OR
        countries.country % $1 OR 
        global_property_type."type" % $1 OR 
        states."state" % $1 OR 
        cities.city % $1 OR 
        companies.company_name % $1 
        -- sub_communities.sub_community % @search
    END )
    AND property.status = $2::bigint
    AND (CASE WHEN $3::bigint = 0 THEN (property.entity_type_id = ANY($4::bigint[])) ELSE (property.entity_id = $3::bigint AND property.entity_type_id  = ANY($4::bigint[] ))   END)
    AND (CASE WHEN $5::bigint = 0 THEN true ELSE global_property_type.usage = $5::bigint END)
    -- AND (CASE WHEN @company_id::bigint = 0 THEN property.user_id = @user_id::bigint ELSE property.company_id = @company_id::bigint END)
      AND CASE WHEN $6::BOOLEAN = true THEN true ELSE (
        $7 != true
        OR (
            ($8 != false OR property.company_id = $9::bigint)
            AND ($8 != true OR property.company_id = $9::bigint)
        )
    ) END
    -- Location filters
    AND ($10::bigint = 0 OR addresses.countries_id = $10::bigint)
    -- AND (@state_id::bigint = 0 OR addresses.states_id = @state_id::bigint)
    AND ($11::bigint = 0 OR addresses.cities_id = $11::bigint)
    AND ($12::bigint = 0 OR addresses.communities_id = $12::bigint)
    AND ($13::bigint = 0 OR addresses.sub_communities_id = $13::bigint)
`

type GetGlobalPropertiesCountByStatusIDParams struct {
	Search         interface{} `json:"search"`
	Status         int64       `json:"status"`
	EntityID       int64       `json:"entity_id"`
	EntityTypeID   []int64     `json:"entity_type_id"`
	Usage          int64       `json:"usage"`
	IsAdmin        bool        `json:"is_admin"`
	IsCompanyUser  interface{} `json:"is_company_user"`
	CompanyBranch  interface{} `json:"company_branch"`
	CompanyID      int64       `json:"company_id"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
}

// SEARCH CRITERIA
func (q *Queries) GetGlobalPropertiesCountByStatusID(ctx context.Context, arg GetGlobalPropertiesCountByStatusIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getGlobalPropertiesCountByStatusID,
		arg.Search,
		arg.Status,
		arg.EntityID,
		arg.EntityTypeID,
		arg.Usage,
		arg.IsAdmin,
		arg.IsCompanyUser,
		arg.CompanyBranch,
		arg.CompanyID,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGlobalPropertyById = `-- name: GetGlobalPropertyById :one
SELECT id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date
FROM property
WHERE property.id = $1::bigint
LIMIT 1
`

func (q *Queries) GetGlobalPropertyById(ctx context.Context, id int64) (Property, error) {
	row := q.db.QueryRow(ctx, getGlobalPropertyById, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getGlobalPropertyByUsage = `-- name: GetGlobalPropertyByUsage :many
select id, type, code, property_type_facts, listing_facts, usage, created_at, updated_at, status, icon, is_project, type_ar from global_property_type where usage = $1
`

func (q *Queries) GetGlobalPropertyByUsage(ctx context.Context, usage int64) ([]GlobalPropertyType, error) {
	rows, err := q.db.Query(ctx, getGlobalPropertyByUsage, usage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GlobalPropertyType
	for rows.Next() {
		var i GlobalPropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.PropertyTypeFacts,
			&i.ListingFacts,
			&i.Usage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Icon,
			&i.IsProject,
			&i.TypeAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalUnitByStatusID = `-- name: GetGlobalUnitByStatusID :many
SELECT units.id, units.unit_no, units.unitno_is_public, units.notes, units.unit_title, units.description, units.description_arabic, units.unit_title_arabic, units.notes_arabic, units.notes_public, units.is_verified, units.entity_type_id, units.entity_id, units.created_at, units.updated_at, units.addresses_id, units.unit_type_id, units.created_by, units.updated_by, units.type_name_id, units.owner_users_id, units.from_xml, units.company_id, units.status, units.facts, units.is_project_unit, units.exclusive, units.start_date, units.end_date, addresses.full_address,
unit_versions.ref_no AS unit_ref_no, 
unit_versions."type" AS unit_category, 
unit_versions.title,
property.property_name AS property_name
FROM  unit_versions
LEFT JOIN units ON unit_versions.unit_id = units.id
INNER JOIN property ON units.entity_Id = property.id
INNER JOIN addresses ON units.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
INNER JOIN companies ON units.company_id = companies.id
WHERE 
    ($3 = '%%' OR 
        unit_versions.title % $3 OR 
        unit_versions.title_arabic % $3 OR 
        countries.country % $3 OR 
        states."state" % $3 OR 
        cities.city % $3 OR 
        companies.company_name % $3 OR
        property.property_name % $3 
    )
AND unit_versions.status = $4::bigint
AND (CASE WHEN $5::bigint = 0 THEN units.entity_Id IS NULL ELSE units.entity_type_id = $5::bigint   END)
AND (CASE WHEN $6::bigint = 0 THEN units.created_by = $7::bigint ELSE units.company_id = $6::bigint END)
GROUP BY units.id, unit_versions.ref_no, unit_versions."type", unit_versions.title, property.property_name
ORDER BY units.id
LIMIT $1 OFFSET $2
`

type GetGlobalUnitByStatusIDParams struct {
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	Search       interface{} `json:"search"`
	Status       int64       `json:"status"`
	EntityTypeID int64       `json:"entity_type_id"`
	CompanyID    int64       `json:"company_id"`
	UserID       int64       `json:"user_id"`
}

type GetGlobalUnitByStatusIDRow struct {
	ID                pgtype.Int8        `json:"id"`
	UnitNo            pgtype.Text        `json:"unit_no"`
	UnitnoIsPublic    pgtype.Bool        `json:"unitno_is_public"`
	Notes             pgtype.Text        `json:"notes"`
	UnitTitle         pgtype.Text        `json:"unit_title"`
	Description       pgtype.Text        `json:"description"`
	DescriptionArabic pgtype.Text        `json:"description_arabic"`
	UnitTitleArabic   pgtype.Text        `json:"unit_title_arabic"`
	NotesArabic       pgtype.Text        `json:"notes_arabic"`
	NotesPublic       pgtype.Bool        `json:"notes_public"`
	IsVerified        pgtype.Bool        `json:"is_verified"`
	EntityTypeID      pgtype.Int8        `json:"entity_type_id"`
	EntityID          pgtype.Int8        `json:"entity_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	AddressesID       pgtype.Int8        `json:"addresses_id"`
	UnitTypeID        pgtype.Int8        `json:"unit_type_id"`
	CreatedBy         pgtype.Int8        `json:"created_by"`
	UpdatedBy         pgtype.Int8        `json:"updated_by"`
	TypeNameID        pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID      pgtype.Int8        `json:"owner_users_id"`
	FromXml           pgtype.Bool        `json:"from_xml"`
	CompanyID         pgtype.Int8        `json:"company_id"`
	Status            pgtype.Int8        `json:"status"`
	Facts             []byte             `json:"facts"`
	IsProjectUnit     pgtype.Bool        `json:"is_project_unit"`
	Exclusive         pgtype.Bool        `json:"exclusive"`
	StartDate         pgtype.Date        `json:"start_date"`
	EndDate           pgtype.Date        `json:"end_date"`
	FullAddress       pgtype.Text        `json:"full_address"`
	UnitRefNo         string             `json:"unit_ref_no"`
	UnitCategory      int64              `json:"unit_category"`
	Title             string             `json:"title"`
	PropertyName      string             `json:"property_name"`
}

// SEARCH CRITERIA
func (q *Queries) GetGlobalUnitByStatusID(ctx context.Context, arg GetGlobalUnitByStatusIDParams) ([]GetGlobalUnitByStatusIDRow, error) {
	rows, err := q.db.Query(ctx, getGlobalUnitByStatusID,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.Status,
		arg.EntityTypeID,
		arg.CompanyID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalUnitByStatusIDRow
	for rows.Next() {
		var i GetGlobalUnitByStatusIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UnitNo,
			&i.UnitnoIsPublic,
			&i.Notes,
			&i.UnitTitle,
			&i.Description,
			&i.DescriptionArabic,
			&i.UnitTitleArabic,
			&i.NotesArabic,
			&i.NotesPublic,
			&i.IsVerified,
			&i.EntityTypeID,
			&i.EntityID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AddressesID,
			&i.UnitTypeID,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.TypeNameID,
			&i.OwnerUsersID,
			&i.FromXml,
			&i.CompanyID,
			&i.Status,
			&i.Facts,
			&i.IsProjectUnit,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.FullAddress,
			&i.UnitRefNo,
			&i.UnitCategory,
			&i.Title,
			&i.PropertyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalUnitCountByStatusID = `-- name: GetGlobalUnitCountByStatusID :one
SELECT COUNT(units.id)
FROM  unit_versions
LEFT JOIN units ON unit_versions.unit_id = units.id
INNER JOIN property ON units.entity_Id = property.id
INNER JOIN addresses ON units.addresses_id = addresses.id 
INNER JOIN countries ON addresses.countries_id = countries.id  
INNER JOIN states ON addresses.states_id = states.id   
INNER JOIN cities ON addresses.cities_id = cities.id
INNER JOIN companies ON units.company_id = companies.id
WHERE 
    ($1 = '%%' OR 
        unit_versions.title % $1 OR 
        unit_versions.title_arabic % $1 OR 
        countries.country % $1 OR 
        states."state" % $1 OR 
        cities.city % $1 OR 
        companies.company_name % $1 OR
        property.property_name % $1 
    )
AND unit_versions.status = $2::bigint
AND (CASE WHEN $3::bigint = 0 THEN units.entity_Id IS NULL ELSE units.entity_type_id = $3::bigint  END)
AND (CASE WHEN $4::bigint = 0 THEN units.created_by = $5::bigint ELSE units.company_id = $4::bigint END)
GROUP BY units.id
ORDER BY units.id
`

type GetGlobalUnitCountByStatusIDParams struct {
	Search       interface{} `json:"search"`
	Status       int64       `json:"status"`
	EntityTypeID int64       `json:"entity_type_id"`
	CompanyID    int64       `json:"company_id"`
	UserID       int64       `json:"user_id"`
}

// SEARCH CRITERIA
func (q *Queries) GetGlobalUnitCountByStatusID(ctx context.Context, arg GetGlobalUnitCountByStatusIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getGlobalUnitCountByStatusID,
		arg.Search,
		arg.Status,
		arg.EntityTypeID,
		arg.CompanyID,
		arg.UserID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOwnerByName = `-- name: GetOwnerByName :many
SELECT 
    CONCAT(profiles.first_name, ' ', profiles.last_name)::varchar AS full_name, 
    users.id
FROM users
INNER JOIN profiles ON profiles.users_id = users.id
WHERE CONCAT(profiles.first_name, ' ', profiles.last_name) ilike  $1 
  AND users.user_types_id = 3 and users.status  != 5 and users.status != 6
`

type GetOwnerByNameRow struct {
	FullName string `json:"full_name"`
	ID       int64  `json:"id"`
}

func (q *Queries) GetOwnerByName(ctx context.Context, firstName string) ([]GetOwnerByNameRow, error) {
	rows, err := q.db.Query(ctx, getOwnerByName, firstName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOwnerByNameRow
	for rows.Next() {
		var i GetOwnerByNameRow
		if err := rows.Scan(&i.FullName, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnerByPhone = `-- name: GetOwnerByPhone :many
SELECT  CONCAT(profiles.first_name, ' ', profiles.last_name)::varchar AS full_name, users.id, users.username
FROM users
INNER JOIN profiles ON profiles.users_id = users.id
WHERE users.phone_number ilike $1 and users.user_types_id = 3 and users.status  != 5 and users.status != 6
`

type GetOwnerByPhoneRow struct {
	FullName string `json:"full_name"`
	ID       int64  `json:"id"`
	Username string `json:"username"`
}

func (q *Queries) GetOwnerByPhone(ctx context.Context, phoneNumber pgtype.Text) ([]GetOwnerByPhoneRow, error) {
	rows, err := q.db.Query(ctx, getOwnerByPhone, phoneNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOwnerByPhoneRow
	for rows.Next() {
		var i GetOwnerByPhoneRow
		if err := rows.Scan(&i.FullName, &i.ID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhaseByProjectId = `-- name: GetPhaseByProjectId :one
select id, phase_name, addresses_id, created_at, updated_at, status, live_status, ref_no, projects_id, rating, description, description_ar, polygon_coords, facts, exclusive, start_date, end_date, bank_name, registration_date, escrow_number from phases where projects_id = $1
`

func (q *Queries) GetPhaseByProjectId(ctx context.Context, projectsID int64) (Phase, error) {
	row := q.db.QueryRow(ctx, getPhaseByProjectId, projectsID)
	var i Phase
	err := row.Scan(
		&i.ID,
		&i.PhaseName,
		&i.AddressesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.LiveStatus,
		&i.RefNo,
		&i.ProjectsID,
		&i.Rating,
		&i.Description,
		&i.DescriptionAr,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
	)
	return i, err
}

const getPhasePropertyCount = `-- name: GetPhasePropertyCount :one
select count(*) from property where entity_id= $1 and entity_type_id =2 and status!=6
`

func (q *Queries) GetPhasePropertyCount(ctx context.Context, entityID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getPhasePropertyCount, entityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectPropertiesForList = `-- name: GetProjectPropertiesForList :many
Select p.id, p.company_id, p.property_type_id, p.unit_type_id, p.property_title, p.property_title_arabic, p.is_verified, p.addresses_id, p.entity_type_id, p.entity_id, p.status, p.is_show_owner_info, p.property_name, p.description, p.description_arabic, p.owner_users_id, p.user_id, p.updated_by, p.from_xml, p.facts, p.notes, p.created_at, p.updated_at, p.notes_ar, p.is_public_note, p.is_project_property, p.exclusive, p.start_date, p.end_date, pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at, pr.project_name,gpt.type AS property_type_name,
   refresh_schedules.next_run_at AS next_run_at
from property p 
INNER JOIN property_versions pv ON pv.property_id = p.id 
LEFT JOIN refresh_schedules ON refresh_schedules.entity_type_id= $5::BIGINT AND refresh_schedules.entity_id= pv.id AND refresh_schedules.status not in (5,6)
LEFT JOIN projects pr ON p.entity_id = pr.id
LEFT JOIN global_property_type gpt ON p.property_type_id = gpt.id
WHERE p.status !=6 AND pv.status !=6 AND p.entity_type_id = $4 AND pr.id = $3
ORDER BY p.id desc
LIMIT $1 OFFSET $2
`

type GetProjectPropertiesForListParams struct {
	Limit                     int32 `json:"limit"`
	Offset                    int32 `json:"offset"`
	ID                        int64 `json:"id"`
	EntityTypeID              int64 `json:"entity_type_id"`
	PropertyVersionEntityType int64 `json:"property_version_entity_type"`
}

type GetProjectPropertiesForListRow struct {
	ID                  int64              `json:"id"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified          pgtype.Bool        `json:"is_verified"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status              int64              `json:"status"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy           int64              `json:"updated_by"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts               []byte             `json:"facts"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	ID_2                int64              `json:"id_2"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts_2             []byte             `json:"facts_2"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	Status_2            int64              `json:"status_2"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified_2        bool               `json:"is_verified_2"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ProjectName         pgtype.Text        `json:"project_name"`
	PropertyTypeName    pgtype.Text        `json:"property_type_name"`
	NextRunAt           pgtype.Timestamptz `json:"next_run_at"`
}

func (q *Queries) GetProjectPropertiesForList(ctx context.Context, arg GetProjectPropertiesForListParams) ([]GetProjectPropertiesForListRow, error) {
	rows, err := q.db.Query(ctx, getProjectPropertiesForList,
		arg.Limit,
		arg.Offset,
		arg.ID,
		arg.EntityTypeID,
		arg.PropertyVersionEntityType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectPropertiesForListRow
	for rows.Next() {
		var i GetProjectPropertiesForListRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description,
			&i.DescriptionArabic,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy,
			&i.FromXml,
			&i.Facts,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.ID_2,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.UpdatedBy_2,
			&i.Status_2,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified_2,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ProjectName,
			&i.PropertyTypeName,
			&i.NextRunAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectPropertiesForListPhase = `-- name: GetProjectPropertiesForListPhase :many
Select p.id, p.company_id, p.property_type_id, p.unit_type_id, p.property_title, p.property_title_arabic, p.is_verified, p.addresses_id, p.entity_type_id, p.entity_id, p.status, p.is_show_owner_info, p.property_name, p.description, p.description_arabic, p.owner_users_id, p.user_id, p.updated_by, p.from_xml, p.facts, p.notes, p.created_at, p.updated_at, p.notes_ar, p.is_public_note, p.is_project_property, p.exclusive, p.start_date, p.end_date,pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at, pr.project_name,ph.phase_name,gpt.type AS property_type_name,
    refresh_schedules.next_run_at AS next_run_at
from property p 
LEFT JOIN phases ph  ON p.entity_id = ph.id
LEFT JOIN projects pr ON ph.projects_id = pr.id
INNER JOIN property_versions pv ON pv.property_id = p.id
LEFT JOIN global_property_type gpt ON p.property_type_id = gpt.id
LEFT JOIN refresh_schedules ON refresh_schedules.entity_type_id= $4::BIGINT AND refresh_schedules.entity_id= pv.id AND refresh_schedules.status not in (5,6)
WHERE p.status !=6 AND p.entity_type_id = 2  AND ph.id = $3
ORDER BY p.id desc
LIMIT $1 OFFSET $2
`

type GetProjectPropertiesForListPhaseParams struct {
	Limit                     int32 `json:"limit"`
	Offset                    int32 `json:"offset"`
	ID                        int64 `json:"id"`
	PropertyVersionEntityType int64 `json:"property_version_entity_type"`
}

type GetProjectPropertiesForListPhaseRow struct {
	ID                  int64              `json:"id"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified          pgtype.Bool        `json:"is_verified"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status              int64              `json:"status"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy           int64              `json:"updated_by"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts               []byte             `json:"facts"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	ID_2                int64              `json:"id_2"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts_2             []byte             `json:"facts_2"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	Status_2            int64              `json:"status_2"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified_2        bool               `json:"is_verified_2"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ProjectName         pgtype.Text        `json:"project_name"`
	PhaseName           pgtype.Text        `json:"phase_name"`
	PropertyTypeName    pgtype.Text        `json:"property_type_name"`
	NextRunAt           pgtype.Timestamptz `json:"next_run_at"`
}

func (q *Queries) GetProjectPropertiesForListPhase(ctx context.Context, arg GetProjectPropertiesForListPhaseParams) ([]GetProjectPropertiesForListPhaseRow, error) {
	rows, err := q.db.Query(ctx, getProjectPropertiesForListPhase,
		arg.Limit,
		arg.Offset,
		arg.ID,
		arg.PropertyVersionEntityType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectPropertiesForListPhaseRow
	for rows.Next() {
		var i GetProjectPropertiesForListPhaseRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description,
			&i.DescriptionArabic,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy,
			&i.FromXml,
			&i.Facts,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.ID_2,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.UpdatedBy_2,
			&i.Status_2,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified_2,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ProjectName,
			&i.PhaseName,
			&i.PropertyTypeName,
			&i.NextRunAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectPropertyCount = `-- name: GetProjectPropertyCount :one
select count(*) from property where entity_id= $1 and entity_type_id =1 and status!=6
`

func (q *Queries) GetProjectPropertyCount(ctx context.Context, entityID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectPropertyCount, entityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProperties = `-- name: GetProperties :many
Select p.id, p.company_id, p.property_type_id, p.unit_type_id, p.property_title, p.property_title_arabic, p.is_verified, p.addresses_id, p.entity_type_id, p.entity_id, p.status, p.is_show_owner_info, p.property_name, p.description, p.description_arabic, p.owner_users_id, p.user_id, p.updated_by, p.from_xml, p.facts, p.notes, p.created_at, p.updated_at, p.notes_ar, p.is_public_note, p.is_project_property, p.exclusive, p.start_date, p.end_date,pv.ref_no, pv.category,pv.facts,
COALESCE(CAST(pq.quality_score AS FLOAT), 0.0) AS quality_score  from property p
LEFT JOIN (SELECT DISTINCT ON (property_id)property_id,ref_no, category, facts
    FROM property_versions
    ORDER BY property_id, created_at DESC  
) pv ON p.id = pv.property_id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN property_quality_score pq on pq.property_id = p.id
WHERE CASE $3::BOOLEAN
   WHEN true THEN (a.countries_id = 1)
   WHEN false THEN (a.countries_id != 1)
END
AND p.status !=6 AND p.entity_type_id!=1 AND p.entity_type_id!=2 AND p.is_project_property IS FALSE
ORDER BY p.id desc
LIMIT $1 OFFSET $2
`

type GetPropertiesParams struct {
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
	IsLocal bool  `json:"is_local"`
}

type GetPropertiesRow struct {
	ID                  int64       `json:"id"`
	CompanyID           pgtype.Int8 `json:"company_id"`
	PropertyTypeID      int64       `json:"property_type_id"`
	UnitTypeID          []int64     `json:"unit_type_id"`
	PropertyTitle       string      `json:"property_title"`
	PropertyTitleArabic pgtype.Text `json:"property_title_arabic"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	AddressesID         int64       `json:"addresses_id"`
	EntityTypeID        int64       `json:"entity_type_id"`
	EntityID            int64       `json:"entity_id"`
	Status              int64       `json:"status"`
	IsShowOwnerInfo     pgtype.Bool `json:"is_show_owner_info"`
	PropertyName        string      `json:"property_name"`
	Description         string      `json:"description"`
	DescriptionArabic   pgtype.Text `json:"description_arabic"`
	OwnerUsersID        pgtype.Int8 `json:"owner_users_id"`
	UserID              int64       `json:"user_id"`
	UpdatedBy           int64       `json:"updated_by"`
	FromXml             pgtype.Bool `json:"from_xml"`
	Facts               []byte      `json:"facts"`
	Notes               pgtype.Text `json:"notes"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	NotesAr             pgtype.Text `json:"notes_ar"`
	IsPublicNote        bool        `json:"is_public_note"`
	IsProjectProperty   bool        `json:"is_project_property"`
	Exclusive           bool        `json:"exclusive"`
	StartDate           pgtype.Date `json:"start_date"`
	EndDate             pgtype.Date `json:"end_date"`
	RefNo               string      `json:"ref_no"`
	Category            int64       `json:"category"`
	Facts_2             []byte      `json:"facts_2"`
	QualityScore        interface{} `json:"quality_score"`
}

func (q *Queries) GetProperties(ctx context.Context, arg GetPropertiesParams) ([]GetPropertiesRow, error) {
	rows, err := q.db.Query(ctx, getProperties, arg.Limit, arg.Offset, arg.IsLocal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertiesRow
	for rows.Next() {
		var i GetPropertiesRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description,
			&i.DescriptionArabic,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy,
			&i.FromXml,
			&i.Facts,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.RefNo,
			&i.Category,
			&i.Facts_2,
			&i.QualityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertiesCount = `-- name: GetPropertiesCount :one
Select count(p.*) from property p 
LEFT JOIN (SELECT DISTINCT ON (property_id)property_id,ref_no, category
    FROM property_versions
    ORDER BY property_id, created_at DESC  
) pv ON p.id = pv.property_id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN property_quality_score pq on pq.property_id = p.id
WHERE CASE $1::BOOLEAN
   WHEN true THEN (a.countries_id = 1)
   WHEN false THEN (a.countries_id != 1)
END
AND p.status !=6 AND p.entity_type_id!=1 AND p.entity_type_id!=2 AND p.is_project_property IS FALSE
`

func (q *Queries) GetPropertiesCount(ctx context.Context, isLocal bool) (int64, error) {
	row := q.db.QueryRow(ctx, getPropertiesCount, isLocal)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPropertiesVersionsCount = `-- name: GetPropertiesVersionsCount :one
select count(pv.*) from property_versions pv 
inner join property p on pv.property_id =p.id
inner join global_property_type gp on p.property_type_id =gp.id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN property_quality_score pq on pq.property_id = p.id
WHERE CASE $1::BOOLEAN
   WHEN true THEN (a.countries_id = 1)
   WHEN false THEN (a.countries_id != 1)
END
AND CASE WHEN $2= 0 THEN true ELSE gp."usage" = $2 END
AND CASE WHEN $3= 0 THEN true ELSE (pv.facts->'life_style')::bigint = $3 END
AND p.status !=6 AND p.entity_type_id!=1 AND p.entity_type_id!=2 AND p.is_project_property IS FALSE AND pv.status!=6
`

type GetPropertiesVersionsCountParams struct {
	IsLocal   bool        `json:"is_local"`
	Usage     interface{} `json:"usage"`
	LifeStyle interface{} `json:"life_style"`
}

func (q *Queries) GetPropertiesVersionsCount(ctx context.Context, arg GetPropertiesVersionsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPropertiesVersionsCount, arg.IsLocal, arg.Usage, arg.LifeStyle)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPropertiesVersionsCountInternational = `-- name: GetPropertiesVersionsCountInternational :one
select count(pv.*) from property_versions pv 
inner join property p on pv.property_id =p.id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN property_quality_score pq on pq.property_id = p.id
WHERE a.countries_id != $1
AND
     (
        $2::BIGINT = 0 
        OR c.id = $2::BIGINT
        AND cu.company_id = $2::BIGINT
    )
    AND 
    (
        $3::BIGINT = 0 
        OR pv.agent_id = $3::BIGINT
    )
AND p.status !=6 AND p.entity_type_id!=1 AND p.entity_type_id!=2 AND p.is_project_property IS FALSE AND pv.status!=6
`

type GetPropertiesVersionsCountInternationalParams struct {
	CountriesID pgtype.Int8 `json:"countries_id"`
	CompanyID   int64       `json:"company_id"`
	AgentID     int64       `json:"agent_id"`
}

func (q *Queries) GetPropertiesVersionsCountInternational(ctx context.Context, arg GetPropertiesVersionsCountInternationalParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPropertiesVersionsCountInternational, arg.CountriesID, arg.CompanyID, arg.AgentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPropertiesVersionsCountLocal = `-- name: GetPropertiesVersionsCountLocal :one
select count(pv.*) from property_versions pv 
inner join property p on pv.property_id =p.id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN property_quality_score pq on pq.property_id = p.id
WHERE a.countries_id = $1
AND
     (
        $2::BIGINT = 0 
        OR c.id = $2::BIGINT
        AND cu.company_id = $2::BIGINT
    )
    AND 
    (
        $3::BIGINT = 0 
        OR pv.agent_id = $3::BIGINT
    )
AND p.status !=6 AND p.entity_type_id!=1 AND p.entity_type_id!=2 AND p.is_project_property IS FALSE AND pv.status!=6
`

type GetPropertiesVersionsCountLocalParams struct {
	CountriesID pgtype.Int8 `json:"countries_id"`
	CompanyID   int64       `json:"company_id"`
	AgentID     int64       `json:"agent_id"`
}

func (q *Queries) GetPropertiesVersionsCountLocal(ctx context.Context, arg GetPropertiesVersionsCountLocalParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPropertiesVersionsCountLocal, arg.CountriesID, arg.CompanyID, arg.AgentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPropertyByPropertyId = `-- name: GetPropertyByPropertyId :one
select id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date from property where id = $1 and status != 6
`

func (q *Queries) GetPropertyByPropertyId(ctx context.Context, id int64) (Property, error) {
	row := q.db.QueryRow(ctx, getPropertyByPropertyId, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getPropertyByRefNo = `-- name: GetPropertyByRefNo :one
SELECT property.id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, property.is_verified, addresses_id, entity_type_id, entity_id, property.status, is_show_owner_info, property_name, property.description, property.description_arabic, owner_users_id, user_id, property.updated_by, from_xml, property.facts, notes, property.created_at, property.updated_at, notes_ar, is_public_note, is_project_property, property.exclusive, property.start_date, property.end_date, property_versions.id, title, views_count, title_arabic, property_versions.description, property_versions.description_arabic, property_versions.property_rank, property_id, property_versions.facts, property_versions.created_at, property_versions.updated_at, property_versions.updated_by, property_versions.status, agent_id, ref_no, category, has_gallery, has_plans, is_main, property_versions.is_verified, property_versions.exclusive, property_versions.start_date, property_versions.end_date, slug, is_hotdeal, refreshed_at
FROM property
INNER JOIN property_versions 
    ON property_versions.property_id = property.id 
    AND property_versions.is_main IS TRUE
WHERE property_versions.ref_no = $1
`

type GetPropertyByRefNoRow struct {
	ID                  int64              `json:"id"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified          pgtype.Bool        `json:"is_verified"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status              int64              `json:"status"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy           int64              `json:"updated_by"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts               []byte             `json:"facts"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	ID_2                int64              `json:"id_2"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts_2             []byte             `json:"facts_2"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	Status_2            int64              `json:"status_2"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified_2        bool               `json:"is_verified_2"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
}

// ---- used for xml
func (q *Queries) GetPropertyByRefNo(ctx context.Context, refNo string) (GetPropertyByRefNoRow, error) {
	row := q.db.QueryRow(ctx, getPropertyByRefNo, refNo)
	var i GetPropertyByRefNoRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.ID_2,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description_2,
		&i.DescriptionArabic_2,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts_2,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.UpdatedBy_2,
		&i.Status_2,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified_2,
		&i.Exclusive_2,
		&i.StartDate_2,
		&i.EndDate_2,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const getPropertyVersionByID = `-- name: GetPropertyVersionByID :one
select property_versions.id, title, views_count, title_arabic, property_versions.description, property_versions.description_arabic, property_rank, property_id, property_versions.facts, property_versions.created_at, property_versions.updated_at, property_versions.updated_by, property_versions.status, agent_id, ref_no, category, has_gallery, has_plans, is_main, property_versions.is_verified, property_versions.exclusive, property_versions.start_date, property_versions.end_date, slug, is_hotdeal, refreshed_at, property.id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, property.is_verified, addresses_id, entity_type_id, entity_id, property.status, is_show_owner_info, property_name, property.description, property.description_arabic, owner_users_id, user_id, property.updated_by, from_xml, property.facts, notes, property.created_at, property.updated_at, notes_ar, is_public_note, is_project_property, property.exclusive, property.start_date, property.end_date from property_versions
INNER JOIN property ON property_versions.property_id = property.id
where property_versions.property_id=$1
`

type GetPropertyVersionByIDRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts               []byte             `json:"facts"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	UpdatedBy           int64              `json:"updated_by"`
	Status              int64              `json:"status"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status_2            int64              `json:"status_2"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts_2             []byte             `json:"facts_2"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

func (q *Queries) GetPropertyVersionByID(ctx context.Context, propertyID int64) (GetPropertyVersionByIDRow, error) {
	row := q.db.QueryRow(ctx, getPropertyVersionByID, propertyID)
	var i GetPropertyVersionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
		&i.ID_2,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified_2,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status_2,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description_2,
		&i.DescriptionArabic_2,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy_2,
		&i.FromXml,
		&i.Facts_2,
		&i.Notes,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive_2,
		&i.StartDate_2,
		&i.EndDate_2,
	)
	return i, err
}

const getPropertyVersions = `-- name: GetPropertyVersions :many
select pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at,p.id, p.company_id, p.property_type_id, p.unit_type_id, p.property_title, p.property_title_arabic, p.is_verified, p.addresses_id, p.entity_type_id, p.entity_id, p.status, p.is_show_owner_info, p.property_name, p.description, p.description_arabic, p.owner_users_id, p.user_id, p.updated_by, p.from_xml, p.facts, p.notes, p.created_at, p.updated_at, p.notes_ar, p.is_public_note, p.is_project_property, p.exclusive, p.start_date, p.end_date,COALESCE(CAST(pq.quality_score AS FLOAT), 0.0) AS quality_score from property_versions pv
inner join property p on pv.property_id =p.id
inner join global_property_type gp on p.property_type_id =gp.id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN property_quality_score pq on pq.property_id = p.id
WHERE CASE $3::BOOLEAN
   WHEN true THEN (a.countries_id = 1)
   WHEN false THEN (a.countries_id != 1)
END
AND CASE WHEN $4= 0 THEN true ELSE gp."usage" = $4 END
AND CASE WHEN $5= 0 THEN true ELSE (pv.facts->'life_style')::bigint = $5 END
AND p.status !=6 AND p.entity_type_id!=1 AND p.entity_type_id!=2 AND p.is_project_property IS FALSE AND pv.status!=6
ORDER BY p.id desc
LIMIT $1 OFFSET $2
`

type GetPropertyVersionsParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	IsLocal   bool        `json:"is_local"`
	Usage     interface{} `json:"usage"`
	LifeStyle interface{} `json:"life_style"`
}

type GetPropertyVersionsRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts               []byte             `json:"facts"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	UpdatedBy           int64              `json:"updated_by"`
	Status              int64              `json:"status"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status_2            int64              `json:"status_2"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts_2             []byte             `json:"facts_2"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	QualityScore        interface{}        `json:"quality_score"`
}

func (q *Queries) GetPropertyVersions(ctx context.Context, arg GetPropertyVersionsParams) ([]GetPropertyVersionsRow, error) {
	rows, err := q.db.Query(ctx, getPropertyVersions,
		arg.Limit,
		arg.Offset,
		arg.IsLocal,
		arg.Usage,
		arg.LifeStyle,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertyVersionsRow
	for rows.Next() {
		var i GetPropertyVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified_2,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status_2,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy_2,
			&i.FromXml,
			&i.Facts_2,
			&i.Notes,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
			&i.QualityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyVersionsByPropertyId = `-- name: GetPropertyVersionsByPropertyId :many

select id, title, views_count, title_arabic, description, description_arabic, property_rank, property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at from property_versions where property_id=$1 
AND
     (
        $2::BIGINT = 0 
        OR c.id = $2::BIGINT
        AND cu.company_id = $2::BIGINT
    )
    AND 
    (
        $3::BIGINT = 0 
        OR pv.agent_id = $3::BIGINT
    )
`

type GetPropertyVersionsByPropertyIdParams struct {
	PropertyID int64 `json:"property_id"`
	CompanyID  int64 `json:"company_id"`
	AgentID    int64 `json:"agent_id"`
}

// -- name: GetAllGlobalPropertyByEntity :one
// select * from property where entity_id = $1 and entity_type_id = $2;
func (q *Queries) GetPropertyVersionsByPropertyId(ctx context.Context, arg GetPropertyVersionsByPropertyIdParams) ([]PropertyVersion, error) {
	rows, err := q.db.Query(ctx, getPropertyVersionsByPropertyId, arg.PropertyID, arg.CompanyID, arg.AgentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyVersion
	for rows.Next() {
		var i PropertyVersion
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyVersionsByPropertyIdOld = `-- name: GetPropertyVersionsByPropertyIdOld :one
select id, title, views_count, title_arabic, description, description_arabic, property_rank, property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at from property_versions where property_id=$1 
ORDER BY created_at asc
LIMIT 1
`

func (q *Queries) GetPropertyVersionsByPropertyIdOld(ctx context.Context, propertyID int64) (PropertyVersion, error) {
	row := q.db.QueryRow(ctx, getPropertyVersionsByPropertyIdOld, propertyID)
	var i PropertyVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const getPropertyVersionsByVerionId = `-- name: GetPropertyVersionsByVerionId :one
select property_versions.id, title, views_count, title_arabic, property_versions.description, property_versions.description_arabic, property_rank, property_id, property_versions.facts, property_versions.created_at, property_versions.updated_at, property_versions.updated_by, property_versions.status, agent_id, ref_no, category, has_gallery, has_plans, is_main, property_versions.is_verified, property_versions.exclusive, property_versions.start_date, property_versions.end_date, slug, is_hotdeal, refreshed_at, property.id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, property.is_verified, addresses_id, entity_type_id, entity_id, property.status, is_show_owner_info, property_name, property.description, property.description_arabic, owner_users_id, user_id, property.updated_by, from_xml, property.facts, notes, property.created_at, property.updated_at, notes_ar, is_public_note, is_project_property, property.exclusive, property.start_date, property.end_date from property_versions
INNER JOIN property ON property.id = property_versions.property_id
Where property_versions.id=$1
`

type GetPropertyVersionsByVerionIdRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts               []byte             `json:"facts"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	UpdatedBy           int64              `json:"updated_by"`
	Status              int64              `json:"status"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status_2            int64              `json:"status_2"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts_2             []byte             `json:"facts_2"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
}

func (q *Queries) GetPropertyVersionsByVerionId(ctx context.Context, id int64) (GetPropertyVersionsByVerionIdRow, error) {
	row := q.db.QueryRow(ctx, getPropertyVersionsByVerionId, id)
	var i GetPropertyVersionsByVerionIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
		&i.ID_2,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified_2,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status_2,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description_2,
		&i.DescriptionArabic_2,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy_2,
		&i.FromXml,
		&i.Facts_2,
		&i.Notes,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive_2,
		&i.StartDate_2,
		&i.EndDate_2,
	)
	return i, err
}

const getPropertyVersionsInternational = `-- name: GetPropertyVersionsInternational :many
select pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at,p.id, p.company_id, p.property_type_id, p.unit_type_id, p.property_title, p.property_title_arabic, p.is_verified, p.addresses_id, p.entity_type_id, p.entity_id, p.status, p.is_show_owner_info, p.property_name, p.description, p.description_arabic, p.owner_users_id, p.user_id, p.updated_by, p.from_xml, p.facts, p.notes, p.created_at, p.updated_at, p.notes_ar, p.is_public_note, p.is_project_property, p.exclusive, p.start_date, p.end_date,COALESCE(CAST(pq.quality_score AS FLOAT), 0.0) AS quality_score from property_versions pv
inner join property p on pv.property_id =p.id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN property_quality_score pq on pq.property_id = p.id
WHERE a.countries_id != $3
AND
     (
        $4::BIGINT = 0 
        OR c.id = $4::BIGINT
        AND cu.company_id = $4::BIGINT
    )
    AND 
    (
        $5::BIGINT = 0 
        OR pv.agent_id = $5::BIGINT
    )
AND p.status !=6 AND p.entity_type_id!=1 AND p.entity_type_id!=2 AND p.is_project_property IS FALSE AND pv.status!=6
ORDER BY p.id desc
LIMIT $1 OFFSET $2
`

type GetPropertyVersionsInternationalParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	CountriesID pgtype.Int8 `json:"countries_id"`
	CompanyID   int64       `json:"company_id"`
	AgentID     int64       `json:"agent_id"`
}

type GetPropertyVersionsInternationalRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts               []byte             `json:"facts"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	UpdatedBy           int64              `json:"updated_by"`
	Status              int64              `json:"status"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status_2            int64              `json:"status_2"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts_2             []byte             `json:"facts_2"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	QualityScore        interface{}        `json:"quality_score"`
}

func (q *Queries) GetPropertyVersionsInternational(ctx context.Context, arg GetPropertyVersionsInternationalParams) ([]GetPropertyVersionsInternationalRow, error) {
	rows, err := q.db.Query(ctx, getPropertyVersionsInternational,
		arg.Limit,
		arg.Offset,
		arg.CountriesID,
		arg.CompanyID,
		arg.AgentID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertyVersionsInternationalRow
	for rows.Next() {
		var i GetPropertyVersionsInternationalRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified_2,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status_2,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy_2,
			&i.FromXml,
			&i.Facts_2,
			&i.Notes,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
			&i.QualityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyVersionsLocal = `-- name: GetPropertyVersionsLocal :many
select pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at,p.id, p.company_id, p.property_type_id, p.unit_type_id, p.property_title, p.property_title_arabic, p.is_verified, p.addresses_id, p.entity_type_id, p.entity_id, p.status, p.is_show_owner_info, p.property_name, p.description, p.description_arabic, p.owner_users_id, p.user_id, p.updated_by, p.from_xml, p.facts, p.notes, p.created_at, p.updated_at, p.notes_ar, p.is_public_note, p.is_project_property, p.exclusive, p.start_date, p.end_date,COALESCE(CAST(pq.quality_score AS FLOAT), 0.0) AS quality_score from property_versions pv
inner join property p on pv.property_id =p.id
LEFT JOIN addresses a on p.addresses_id = a.id
LEFT JOIN property_quality_score pq on pq.property_id = p.id
WHERE a.countries_id = $3
AND
     (
        $4::BIGINT = 0 
        OR c.id = $4::BIGINT
        AND cu.company_id = $4::BIGINT
    )
    AND 
    (
        $5::BIGINT = 0 
        OR pv.agent_id = $5::BIGINT
    )
AND p.status !=6 AND p.entity_type_id!=1 AND p.entity_type_id!=2 AND p.is_project_property IS FALSE AND pv.status!=6
ORDER BY p.id desc
LIMIT $1 OFFSET $2
`

type GetPropertyVersionsLocalParams struct {
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	CountriesID pgtype.Int8 `json:"countries_id"`
	CompanyID   int64       `json:"company_id"`
	AgentID     int64       `json:"agent_id"`
}

type GetPropertyVersionsLocalRow struct {
	ID                  int64              `json:"id"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description         string             `json:"description"`
	DescriptionArabic   pgtype.Text        `json:"description_arabic"`
	PropertyRank        int64              `json:"property_rank"`
	PropertyID          int64              `json:"property_id"`
	Facts               []byte             `json:"facts"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	UpdatedBy           int64              `json:"updated_by"`
	Status              int64              `json:"status"`
	AgentID             int64              `json:"agent_id"`
	RefNo               string             `json:"ref_no"`
	Category            int64              `json:"category"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified          bool               `json:"is_verified"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                int64              `json:"id_2"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	PropertyTypeID      int64              `json:"property_type_id"`
	UnitTypeID          []int64            `json:"unit_type_id"`
	PropertyTitle       string             `json:"property_title"`
	PropertyTitleArabic pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2        pgtype.Bool        `json:"is_verified_2"`
	AddressesID         int64              `json:"addresses_id"`
	EntityTypeID        int64              `json:"entity_type_id"`
	EntityID            int64              `json:"entity_id"`
	Status_2            int64              `json:"status_2"`
	IsShowOwnerInfo     pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName        string             `json:"property_name"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	UserID              int64              `json:"user_id"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	Facts_2             []byte             `json:"facts_2"`
	Notes               pgtype.Text        `json:"notes"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	NotesAr             pgtype.Text        `json:"notes_ar"`
	IsPublicNote        bool               `json:"is_public_note"`
	IsProjectProperty   bool               `json:"is_project_property"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	QualityScore        interface{}        `json:"quality_score"`
}

func (q *Queries) GetPropertyVersionsLocal(ctx context.Context, arg GetPropertyVersionsLocalParams) ([]GetPropertyVersionsLocalRow, error) {
	rows, err := q.db.Query(ctx, getPropertyVersionsLocal,
		arg.Limit,
		arg.Offset,
		arg.CountriesID,
		arg.CompanyID,
		arg.AgentID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertyVersionsLocalRow
	for rows.Next() {
		var i GetPropertyVersionsLocalRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description,
			&i.DescriptionArabic,
			&i.PropertyRank,
			&i.PropertyID,
			&i.Facts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.AgentID,
			&i.RefNo,
			&i.Category,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
			&i.ID_2,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified_2,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status_2,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy_2,
			&i.FromXml,
			&i.Facts_2,
			&i.Notes,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
			&i.QualityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishByEntityIDsByEntityType = `-- name: GetPublishByEntityIDsByEntityType :one
SELECT id, share_id, is_internal, title, description, created_at, updated_at, created_by, webportal_id, is_enabled, entity_type_id, entity_id FROM publish_listing 
WHERE
CASE WHEN $1::bigint=0 THEN true ELSE publish_listing.created_by = $1::bigint END
AND publish_listing.entity_type_id = $2  AND  publish_listing.entity_Id = $3   LIMIT 1
`

type GetPublishByEntityIDsByEntityTypeParams struct {
	CreatedBy    int64 `json:"created_by"`
	EntityTypeID int64 `json:"entity_type_id"`
	EntityID     int64 `json:"entity_id"`
}

func (q *Queries) GetPublishByEntityIDsByEntityType(ctx context.Context, arg GetPublishByEntityIDsByEntityTypeParams) (PublishListing, error) {
	row := q.db.QueryRow(ctx, getPublishByEntityIDsByEntityType, arg.CreatedBy, arg.EntityTypeID, arg.EntityID)
	var i PublishListing
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.IsInternal,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.WebportalID,
		&i.IsEnabled,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}

const getSinglePropertyById = `-- name: GetSinglePropertyById :one
SELECT
    property.id, property.company_id, property.property_type_id, property.unit_type_id, property.property_title, property.property_title_arabic, property.is_verified, property.addresses_id, property.entity_type_id, property.entity_id, property.status, property.is_show_owner_info, property.property_name, property.description, property.description_arabic, property.owner_users_id, property.user_id, property.updated_by, property.from_xml, property.facts, property.notes, property.created_at, property.updated_at, property.notes_ar, property.is_public_note, property.is_project_property, property.exclusive, property.start_date, property.end_date,
    jsonb_agg(distinct 
        jsonb_build_object(
            'id', unit_type.id, 
            'type', unit_type."type",
            'type_ar', unit_type.type_ar

        )
    ) AS unit_type_obj,
    countries.id, countries.country, countries.flag, countries.created_at, countries.updated_at, countries.alpha2_code, countries.alpha3_code, countries.country_code, countries.lat, countries.lng, countries.name, countries.numcode, countries.default_settings, countries.status, countries.deleted_at, countries.updated_by, countries.country_ar,
     COALESCE(states.id, 0) AS state_id,
    COALESCE(states.state, '') AS state_name,
    COALESCE(states.countries_id, 0) AS state_countries_id,
    COALESCE(states.created_at, '1970-01-01'::timestamp) AS state_created_at,
    COALESCE(states.updated_at, '1970-01-01'::timestamp) AS state_updated_at,
    COALESCE(states.lat, 0.0) AS state_lat,
    COALESCE(states.lng, 0.0) AS state_lng,
    
    COALESCE(cities.id, 0) AS city_id,
    COALESCE(cities.city, '') AS city_name,
    COALESCE(cities.states_id, 0) AS city_states_id,
    COALESCE(cities.created_at, '1970-01-01'::timestamp) AS city_created_at,
    COALESCE(cities.updated_at, '1970-01-01'::timestamp) AS city_updated_at,
    COALESCE(cities.lat, 0.0) AS city_lat,
    COALESCE(cities.lng, 0.0) AS city_lng,
    COALESCE(communities.id,0) AS community_id,
COALESCE(communities.community,'') AS community,
COALESCE(sub_communities.id,0) AS sub_communities_id,
COALESCE(sub_communities.sub_community,'') AS sub_communities,
    locations.id AS location_id,
    locations.lat AS location_lat,
    locations.lng AS location_lng,
    jsonb_agg(distinct 
        jsonb_build_object(
            'id', facilities_amenities.id, 
            'icon_url', facilities_amenities.icon_url, 
            'title', facilities_amenities.title,
            'title_ar', facilities_amenities.title_ar,
            'type', facilities_amenities.type,
            'category', categories.category
            -- 'category', jsonb_build_object(    -- Add category as a nested JSON object
            --     'name', categories.category
            -- )
        )
    ) AS facilities_amenities_obj,
    jsonb_agg(distinct 
        jsonb_build_object(
            'id', v.id,
            'title', v.title,
            'title_ar', v.title_ar
        )
    ) AS views,
    companies.company_name,
    global_property_type."type",
    global_property_type.property_type_facts
FROM property
INNER JOIN addresses ON addresses.id = property.addresses_id
INNER JOIN countries ON countries.id = addresses.countries_id
LEFT JOIN states ON states.id = addresses.states_id
LEFT JOIN cities ON cities.id = addresses.cities_id
LEFT JOIN communities ON communities.id = addresses.communities_id
LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
LEFT JOIN locations ON locations.id = addresses.locations_id
INNER JOIN companies ON companies.id = property.company_id
INNER JOIN global_property_type ON global_property_type.id = property.property_type_id
LEFT JOIN unit_type ON unit_type.id = ANY(property.unit_type_id)
LEFT JOIN facilities_amenities_entity AS fe ON fe.entity_type_id = 3 AND fe.entity_id = property.id
LEFT JOIN facilities_amenities ON facilities_amenities.id = fe.facility_amenity_id
LEFT JOIN categories ON categories.id = facilities_amenities.categories  -- Join with category table
LEFT JOIN LATERAL jsonb_array_elements_text(property.facts->'views') AS view_id ON TRUE -- Extract view IDs
LEFT JOIN views v ON view_id::int = v.id -- Join with views table
WHERE property.id = $1 AND property.status != 6
GROUP BY property.id, countries.id, states.id, cities.id, communities.id, sub_communities.id, locations.id, companies.id, global_property_type.id
`

type GetSinglePropertyByIdRow struct {
	ID                     int64       `json:"id"`
	CompanyID              pgtype.Int8 `json:"company_id"`
	PropertyTypeID         int64       `json:"property_type_id"`
	UnitTypeID             []int64     `json:"unit_type_id"`
	PropertyTitle          string      `json:"property_title"`
	PropertyTitleArabic    pgtype.Text `json:"property_title_arabic"`
	IsVerified             pgtype.Bool `json:"is_verified"`
	AddressesID            int64       `json:"addresses_id"`
	EntityTypeID           int64       `json:"entity_type_id"`
	EntityID               int64       `json:"entity_id"`
	Status                 int64       `json:"status"`
	IsShowOwnerInfo        pgtype.Bool `json:"is_show_owner_info"`
	PropertyName           string      `json:"property_name"`
	Description            string      `json:"description"`
	DescriptionArabic      pgtype.Text `json:"description_arabic"`
	OwnerUsersID           pgtype.Int8 `json:"owner_users_id"`
	UserID                 int64       `json:"user_id"`
	UpdatedBy              int64       `json:"updated_by"`
	FromXml                pgtype.Bool `json:"from_xml"`
	Facts                  []byte      `json:"facts"`
	Notes                  pgtype.Text `json:"notes"`
	CreatedAt              time.Time   `json:"created_at"`
	UpdatedAt              time.Time   `json:"updated_at"`
	NotesAr                pgtype.Text `json:"notes_ar"`
	IsPublicNote           bool        `json:"is_public_note"`
	IsProjectProperty      bool        `json:"is_project_property"`
	Exclusive              bool        `json:"exclusive"`
	StartDate              pgtype.Date `json:"start_date"`
	EndDate                pgtype.Date `json:"end_date"`
	UnitTypeObj            []byte      `json:"unit_type_obj"`
	Country                Country     `json:"country"`
	StateID                int64       `json:"state_id"`
	StateName              string      `json:"state_name"`
	StateCountriesID       int64       `json:"state_countries_id"`
	StateCreatedAt         time.Time   `json:"state_created_at"`
	StateUpdatedAt         time.Time   `json:"state_updated_at"`
	StateLat               float64     `json:"state_lat"`
	StateLng               float64     `json:"state_lng"`
	CityID                 int64       `json:"city_id"`
	CityName               string      `json:"city_name"`
	CityStatesID           int64       `json:"city_states_id"`
	CityCreatedAt          time.Time   `json:"city_created_at"`
	CityUpdatedAt          time.Time   `json:"city_updated_at"`
	CityLat                float64     `json:"city_lat"`
	CityLng                float64     `json:"city_lng"`
	CommunityID            int64       `json:"community_id"`
	Community              string      `json:"community"`
	SubCommunitiesID       int64       `json:"sub_communities_id"`
	SubCommunities         string      `json:"sub_communities"`
	LocationID             pgtype.Int8 `json:"location_id"`
	LocationLat            pgtype.Text `json:"location_lat"`
	LocationLng            pgtype.Text `json:"location_lng"`
	FacilitiesAmenitiesObj []byte      `json:"facilities_amenities_obj"`
	Views                  []byte      `json:"views"`
	CompanyName            string      `json:"company_name"`
	Type                   string      `json:"type"`
	PropertyTypeFacts      []byte      `json:"property_type_facts"`
}

func (q *Queries) GetSinglePropertyById(ctx context.Context, id int64) (GetSinglePropertyByIdRow, error) {
	row := q.db.QueryRow(ctx, getSinglePropertyById, id)
	var i GetSinglePropertyByIdRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.UnitTypeObj,
		&i.Country.ID,
		&i.Country.Country,
		&i.Country.Flag,
		&i.Country.CreatedAt,
		&i.Country.UpdatedAt,
		&i.Country.Alpha2Code,
		&i.Country.Alpha3Code,
		&i.Country.CountryCode,
		&i.Country.Lat,
		&i.Country.Lng,
		&i.Country.Name,
		&i.Country.Numcode,
		&i.Country.DefaultSettings,
		&i.Country.Status,
		&i.Country.DeletedAt,
		&i.Country.UpdatedBy,
		&i.Country.CountryAr,
		&i.StateID,
		&i.StateName,
		&i.StateCountriesID,
		&i.StateCreatedAt,
		&i.StateUpdatedAt,
		&i.StateLat,
		&i.StateLng,
		&i.CityID,
		&i.CityName,
		&i.CityStatesID,
		&i.CityCreatedAt,
		&i.CityUpdatedAt,
		&i.CityLat,
		&i.CityLng,
		&i.CommunityID,
		&i.Community,
		&i.SubCommunitiesID,
		&i.SubCommunities,
		&i.LocationID,
		&i.LocationLat,
		&i.LocationLng,
		&i.FacilitiesAmenitiesObj,
		&i.Views,
		&i.CompanyName,
		&i.Type,
		&i.PropertyTypeFacts,
	)
	return i, err
}

const getSinglePropertyVersionsById = `-- name: GetSinglePropertyVersionsById :one
SELECT
    pv.id, pv.title, pv.views_count, pv.title_arabic, pv.description, pv.description_arabic, pv.property_rank, pv.property_id, pv.facts, pv.created_at, pv.updated_at, pv.updated_by, pv.status, pv.agent_id, pv.ref_no, pv.category, pv.has_gallery, pv.has_plans, pv.is_main, pv.is_verified, pv.exclusive, pv.start_date, pv.end_date, pv.slug, pv.is_hotdeal, pv.refreshed_at,
    p.id, p.company_id, p.property_type_id, p.unit_type_id, p.property_title, p.property_title_arabic, p.is_verified, p.addresses_id, p.entity_type_id, p.entity_id, p.status, p.is_show_owner_info, p.property_name, p.description, p.description_arabic, p.owner_users_id, p.user_id, p.updated_by, p.from_xml, p.facts, p.notes, p.created_at, p.updated_at, p.notes_ar, p.is_public_note, p.is_project_property, p.exclusive, p.start_date, p.end_date,
    jsonb_agg(distinct 
        jsonb_build_object(
            'id', unit_type.id, 
            'type', unit_type."type",
            'type_ar', unit_type.type_ar

        )
    ) AS unit_type_obj,
    countries.id, countries.country, countries.flag, countries.created_at, countries.updated_at, countries.alpha2_code, countries.alpha3_code, countries.country_code, countries.lat, countries.lng, countries.name, countries.numcode, countries.default_settings, countries.status, countries.deleted_at, countries.updated_by, countries.country_ar,
    COALESCE(states.id, 0) AS state_id,
    COALESCE(states.state, '') AS state_name,
    COALESCE(states.countries_id, 0) AS state_countries_id,
    COALESCE(states.created_at, '1970-01-01'::timestamp) AS state_created_at,
    COALESCE(states.updated_at, '1970-01-01'::timestamp) AS state_updated_at,
    COALESCE(states.lat, 0.0) AS state_lat,
    COALESCE(states.lng, 0.0) AS state_lng,
    
    COALESCE(cities.id, 0) AS city_id,
    COALESCE(cities.city, '') AS city_name,
    COALESCE(cities.states_id, 0) AS city_states_id,
    COALESCE(cities.created_at, '1970-01-01'::timestamp) AS city_created_at,
    COALESCE(cities.updated_at, '1970-01-01'::timestamp) AS city_updated_at,
    COALESCE(cities.lat, 0.0) AS city_lat,
    COALESCE(cities.lng, 0.0) AS city_lng,
    COALESCE(communities.id,0) AS community_id,
    COALESCE(communities.community,'') AS community,
    COALESCE(sub_communities.id,0) AS sub_communities_id,
    COALESCE(sub_communities.sub_community,'') AS sub_communities,
    locations.id AS location_id,
    locations.lat AS location_lat,
    locations.lng AS location_lng,
    jsonb_agg(distinct 
        jsonb_build_object(
            'id', facilities_amenities.id, 
            'icon_url', facilities_amenities.icon_url, 
            'title', facilities_amenities.title,
            'title_ar', facilities_amenities.title_ar,
            'type', facilities_amenities.type,
            'category', categories.category
            -- 'category', jsonb_build_object(    -- Add category as a nested JSON object
            --     'name', categories.category
            -- )
        )
    ) AS facilities_amenities_obj,
    jsonb_agg(distinct 
        jsonb_build_object(
            'id', v.id,
            'title', v.title,
            'title_ar', v.title_ar
        )
    ) AS views,
    companies.company_name,
    global_property_type."type",
    global_property_type.property_type_facts
FROM property_versions pv 
INNER JOIN property p on p.id =pv.property_id
INNER JOIN addresses ON addresses.id = p.addresses_id
INNER JOIN countries ON countries.id = addresses.countries_id
LEFT JOIN states ON states.id = addresses.states_id
LEFT JOIN cities ON cities.id = addresses.cities_id
LEFT JOIN communities ON communities.id = addresses.communities_id
LEFT JOIN sub_communities ON sub_communities.id = addresses.sub_communities_id
LEFT JOIN locations ON locations.id = addresses.locations_id
INNER JOIN companies ON companies.id = p.company_id
INNER JOIN global_property_type ON global_property_type.id = p.property_type_id
LEFT JOIN unit_type ON unit_type.id = ANY(p.unit_type_id)
LEFT JOIN facilities_amenities_entity AS fe ON fe.entity_type_id = 3 AND fe.entity_id = p.id
LEFT JOIN facilities_amenities ON facilities_amenities.id = fe.facility_amenity_id
LEFT JOIN categories ON categories.id = facilities_amenities.categories  -- Join with category table
LEFT JOIN LATERAL jsonb_array_elements_text(p.facts->'views') AS view_id ON TRUE -- Extract view IDs
LEFT JOIN views v ON view_id::int = v.id -- Join with views table
WHERE pv.id = $1 AND pv.status!=6 AND p.status != 6
GROUP BY p.id,pv.id,countries.id, states.id, cities.id, communities.id, sub_communities.id, locations.id, companies.id, global_property_type.id
`

type GetSinglePropertyVersionsByIdRow struct {
	ID                     int64              `json:"id"`
	Title                  string             `json:"title"`
	ViewsCount             int64              `json:"views_count"`
	TitleArabic            pgtype.Text        `json:"title_arabic"`
	Description            string             `json:"description"`
	DescriptionArabic      pgtype.Text        `json:"description_arabic"`
	PropertyRank           int64              `json:"property_rank"`
	PropertyID             int64              `json:"property_id"`
	Facts                  []byte             `json:"facts"`
	CreatedAt              time.Time          `json:"created_at"`
	UpdatedAt              time.Time          `json:"updated_at"`
	UpdatedBy              int64              `json:"updated_by"`
	Status                 int64              `json:"status"`
	AgentID                int64              `json:"agent_id"`
	RefNo                  string             `json:"ref_no"`
	Category               int64              `json:"category"`
	HasGallery             pgtype.Bool        `json:"has_gallery"`
	HasPlans               pgtype.Bool        `json:"has_plans"`
	IsMain                 bool               `json:"is_main"`
	IsVerified             bool               `json:"is_verified"`
	Exclusive              bool               `json:"exclusive"`
	StartDate              pgtype.Date        `json:"start_date"`
	EndDate                pgtype.Date        `json:"end_date"`
	Slug                   string             `json:"slug"`
	IsHotdeal              bool               `json:"is_hotdeal"`
	RefreshedAt            pgtype.Timestamptz `json:"refreshed_at"`
	ID_2                   int64              `json:"id_2"`
	CompanyID              pgtype.Int8        `json:"company_id"`
	PropertyTypeID         int64              `json:"property_type_id"`
	UnitTypeID             []int64            `json:"unit_type_id"`
	PropertyTitle          string             `json:"property_title"`
	PropertyTitleArabic    pgtype.Text        `json:"property_title_arabic"`
	IsVerified_2           pgtype.Bool        `json:"is_verified_2"`
	AddressesID            int64              `json:"addresses_id"`
	EntityTypeID           int64              `json:"entity_type_id"`
	EntityID               int64              `json:"entity_id"`
	Status_2               int64              `json:"status_2"`
	IsShowOwnerInfo        pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName           string             `json:"property_name"`
	Description_2          string             `json:"description_2"`
	DescriptionArabic_2    pgtype.Text        `json:"description_arabic_2"`
	OwnerUsersID           pgtype.Int8        `json:"owner_users_id"`
	UserID                 int64              `json:"user_id"`
	UpdatedBy_2            int64              `json:"updated_by_2"`
	FromXml                pgtype.Bool        `json:"from_xml"`
	Facts_2                []byte             `json:"facts_2"`
	Notes                  pgtype.Text        `json:"notes"`
	CreatedAt_2            time.Time          `json:"created_at_2"`
	UpdatedAt_2            time.Time          `json:"updated_at_2"`
	NotesAr                pgtype.Text        `json:"notes_ar"`
	IsPublicNote           bool               `json:"is_public_note"`
	IsProjectProperty      bool               `json:"is_project_property"`
	Exclusive_2            bool               `json:"exclusive_2"`
	StartDate_2            pgtype.Date        `json:"start_date_2"`
	EndDate_2              pgtype.Date        `json:"end_date_2"`
	UnitTypeObj            []byte             `json:"unit_type_obj"`
	Country                Country            `json:"country"`
	StateID                int64              `json:"state_id"`
	StateName              string             `json:"state_name"`
	StateCountriesID       int64              `json:"state_countries_id"`
	StateCreatedAt         time.Time          `json:"state_created_at"`
	StateUpdatedAt         time.Time          `json:"state_updated_at"`
	StateLat               float64            `json:"state_lat"`
	StateLng               float64            `json:"state_lng"`
	CityID                 int64              `json:"city_id"`
	CityName               string             `json:"city_name"`
	CityStatesID           int64              `json:"city_states_id"`
	CityCreatedAt          time.Time          `json:"city_created_at"`
	CityUpdatedAt          time.Time          `json:"city_updated_at"`
	CityLat                float64            `json:"city_lat"`
	CityLng                float64            `json:"city_lng"`
	CommunityID            int64              `json:"community_id"`
	Community              string             `json:"community"`
	SubCommunitiesID       int64              `json:"sub_communities_id"`
	SubCommunities         string             `json:"sub_communities"`
	LocationID             pgtype.Int8        `json:"location_id"`
	LocationLat            pgtype.Text        `json:"location_lat"`
	LocationLng            pgtype.Text        `json:"location_lng"`
	FacilitiesAmenitiesObj []byte             `json:"facilities_amenities_obj"`
	Views                  []byte             `json:"views"`
	CompanyName            string             `json:"company_name"`
	Type                   string             `json:"type"`
	PropertyTypeFacts      []byte             `json:"property_type_facts"`
}

func (q *Queries) GetSinglePropertyVersionsById(ctx context.Context, id int64) (GetSinglePropertyVersionsByIdRow, error) {
	row := q.db.QueryRow(ctx, getSinglePropertyVersionsById, id)
	var i GetSinglePropertyVersionsByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
		&i.ID_2,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified_2,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status_2,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description_2,
		&i.DescriptionArabic_2,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy_2,
		&i.FromXml,
		&i.Facts_2,
		&i.Notes,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive_2,
		&i.StartDate_2,
		&i.EndDate_2,
		&i.UnitTypeObj,
		&i.Country.ID,
		&i.Country.Country,
		&i.Country.Flag,
		&i.Country.CreatedAt,
		&i.Country.UpdatedAt,
		&i.Country.Alpha2Code,
		&i.Country.Alpha3Code,
		&i.Country.CountryCode,
		&i.Country.Lat,
		&i.Country.Lng,
		&i.Country.Name,
		&i.Country.Numcode,
		&i.Country.DefaultSettings,
		&i.Country.Status,
		&i.Country.DeletedAt,
		&i.Country.UpdatedBy,
		&i.Country.CountryAr,
		&i.StateID,
		&i.StateName,
		&i.StateCountriesID,
		&i.StateCreatedAt,
		&i.StateUpdatedAt,
		&i.StateLat,
		&i.StateLng,
		&i.CityID,
		&i.CityName,
		&i.CityStatesID,
		&i.CityCreatedAt,
		&i.CityUpdatedAt,
		&i.CityLat,
		&i.CityLng,
		&i.CommunityID,
		&i.Community,
		&i.SubCommunitiesID,
		&i.SubCommunities,
		&i.LocationID,
		&i.LocationLat,
		&i.LocationLng,
		&i.FacilitiesAmenitiesObj,
		&i.Views,
		&i.CompanyName,
		&i.Type,
		&i.PropertyTypeFacts,
	)
	return i, err
}

const getUnitTypeById = `-- name: GetUnitTypeById :one
select type from unit_type where id = $1
`

func (q *Queries) GetUnitTypeById(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getUnitTypeById, id)
	var type_ string
	err := row.Scan(&type_)
	return type_, err
}

const getUnitTypeVariationByID = `-- name: GetUnitTypeVariationByID :one
SELECT unit_type_variation.id, unit_type_variation.description, unit_type_variation.min_area, unit_type_variation.max_area, unit_type_variation.min_price, unit_type_variation.max_price, unit_type_variation.parking, unit_type_variation.balcony, unit_type_variation.bedrooms, unit_type_variation.bathroom, unit_type_variation.property_id, unit_type_variation.unit_type_id, unit_type_variation.title, unit_type_variation.image_url, unit_type_variation.description_ar, unit_type_variation.status, unit_type_variation.ref_no, unit_type_variation.created_at, unit_type_variation.updated_at, unit_type_variation.title_ar, unit_type.type AS unit_type_name, unit_type.type_ar AS unit_type_name_ar
FROM unit_type_variation
inner join unit_type on unit_type_variation.unit_type_id = unit_type.id
WHERE  unit_type_variation.id = $1::bigint
AND unit_type_variation.status != 6
LIMIT 1
`

type GetUnitTypeVariationByIDRow struct {
	ID             int64       `json:"id"`
	Description    string      `json:"description"`
	MinArea        float64     `json:"min_area"`
	MaxArea        float64     `json:"max_area"`
	MinPrice       float64     `json:"min_price"`
	MaxPrice       float64     `json:"max_price"`
	Parking        int64       `json:"parking"`
	Balcony        int64       `json:"balcony"`
	Bedrooms       pgtype.Text `json:"bedrooms"`
	Bathroom       pgtype.Text `json:"bathroom"`
	PropertyID     int64       `json:"property_id"`
	UnitTypeID     int64       `json:"unit_type_id"`
	Title          string      `json:"title"`
	ImageUrl       []string    `json:"image_url"`
	DescriptionAr  pgtype.Text `json:"description_ar"`
	Status         int64       `json:"status"`
	RefNo          string      `json:"ref_no"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	TitleAr        pgtype.Text `json:"title_ar"`
	UnitTypeName   string      `json:"unit_type_name"`
	UnitTypeNameAr pgtype.Text `json:"unit_type_name_ar"`
}

func (q *Queries) GetUnitTypeVariationByID(ctx context.Context, id int64) (GetUnitTypeVariationByIDRow, error) {
	row := q.db.QueryRow(ctx, getUnitTypeVariationByID, id)
	var i GetUnitTypeVariationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.MinArea,
		&i.MaxArea,
		&i.MinPrice,
		&i.MaxPrice,
		&i.Parking,
		&i.Balcony,
		&i.Bedrooms,
		&i.Bathroom,
		&i.PropertyID,
		&i.UnitTypeID,
		&i.Title,
		&i.ImageUrl,
		&i.DescriptionAr,
		&i.Status,
		&i.RefNo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
		&i.UnitTypeName,
		&i.UnitTypeNameAr,
	)
	return i, err
}

const getUnitTypeVariationById = `-- name: GetUnitTypeVariationById :one
SELECT id, description, min_area, max_area, min_price, max_price, parking, balcony, bedrooms, bathroom, property_id, unit_type_id, title, image_url, description_ar, status, ref_no, created_at, updated_at, title_ar from unit_type_variation where id=$1 and status!=6
`

func (q *Queries) GetUnitTypeVariationById(ctx context.Context, id int64) (UnitTypeVariation, error) {
	row := q.db.QueryRow(ctx, getUnitTypeVariationById, id)
	var i UnitTypeVariation
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.MinArea,
		&i.MaxArea,
		&i.MinPrice,
		&i.MaxPrice,
		&i.Parking,
		&i.Balcony,
		&i.Bedrooms,
		&i.Bathroom,
		&i.PropertyID,
		&i.UnitTypeID,
		&i.Title,
		&i.ImageUrl,
		&i.DescriptionAr,
		&i.Status,
		&i.RefNo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const getUnitTypeVariationByStatusID = `-- name: GetUnitTypeVariationByStatusID :many
SELECT unit_type_variation.id, unit_type_variation.description, unit_type_variation.min_area, unit_type_variation.max_area, unit_type_variation.min_price, unit_type_variation.max_price, unit_type_variation.parking, unit_type_variation.balcony, unit_type_variation.bedrooms, unit_type_variation.bathroom, unit_type_variation.property_id, unit_type_variation.unit_type_id, unit_type_variation.title, unit_type_variation.image_url, unit_type_variation.description_ar, unit_type_variation.status, unit_type_variation.ref_no, unit_type_variation.created_at, unit_type_variation.updated_at, unit_type_variation.title_ar,unit_type.type,unit_type.type_ar,property.property_name
FROM unit_type_variation
INNER JOIN unit_type ON unit_type.id = unit_type_variation.unit_type_id
INNER JOIN property ON property.id = unit_type_variation.property_id
WHERE 
    ($3 = '%%' OR 
        unit_type_variation.title % $3 OR 
        unit_type_variation.title_ar % $3 OR 
        unit_type_variation.description % $3 OR 
        unit_type_variation.ref_no % $3
    )
    AND unit_type_variation.status = $4::bigint
    AND CASE WHEN $5::bigint = 0 THEN true ELSE unit_type_variation.property_id = $5::bigint END
ORDER BY unit_type_variation.updated_at desc
LIMIT $1 OFFSET $2
`

type GetUnitTypeVariationByStatusIDParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	Search     interface{} `json:"search"`
	Status     int64       `json:"status"`
	PropertyID int64       `json:"property_id"`
}

type GetUnitTypeVariationByStatusIDRow struct {
	ID            int64       `json:"id"`
	Description   string      `json:"description"`
	MinArea       float64     `json:"min_area"`
	MaxArea       float64     `json:"max_area"`
	MinPrice      float64     `json:"min_price"`
	MaxPrice      float64     `json:"max_price"`
	Parking       int64       `json:"parking"`
	Balcony       int64       `json:"balcony"`
	Bedrooms      pgtype.Text `json:"bedrooms"`
	Bathroom      pgtype.Text `json:"bathroom"`
	PropertyID    int64       `json:"property_id"`
	UnitTypeID    int64       `json:"unit_type_id"`
	Title         string      `json:"title"`
	ImageUrl      []string    `json:"image_url"`
	DescriptionAr pgtype.Text `json:"description_ar"`
	Status        int64       `json:"status"`
	RefNo         string      `json:"ref_no"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	TitleAr       pgtype.Text `json:"title_ar"`
	Type          string      `json:"type"`
	TypeAr        pgtype.Text `json:"type_ar"`
	PropertyName  string      `json:"property_name"`
}

// SEARCH CRITERIA
func (q *Queries) GetUnitTypeVariationByStatusID(ctx context.Context, arg GetUnitTypeVariationByStatusIDParams) ([]GetUnitTypeVariationByStatusIDRow, error) {
	rows, err := q.db.Query(ctx, getUnitTypeVariationByStatusID,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.Status,
		arg.PropertyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitTypeVariationByStatusIDRow
	for rows.Next() {
		var i GetUnitTypeVariationByStatusIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.MinArea,
			&i.MaxArea,
			&i.MinPrice,
			&i.MaxPrice,
			&i.Parking,
			&i.Balcony,
			&i.Bedrooms,
			&i.Bathroom,
			&i.PropertyID,
			&i.UnitTypeID,
			&i.Title,
			&i.ImageUrl,
			&i.DescriptionAr,
			&i.Status,
			&i.RefNo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitleAr,
			&i.Type,
			&i.TypeAr,
			&i.PropertyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitTypeVariationCountByStatusID = `-- name: GetUnitTypeVariationCountByStatusID :one
SELECT COUNT(unit_type_variation.id)
FROM unit_type_variation
INNER JOIN unit_type ON unit_type.id = unit_type_variation.unit_type_id
INNER JOIN property ON property.id = unit_type_variation.property_id
WHERE 
    ($1 = '%%' OR 
        unit_type_variation.title % $1 OR 
        unit_type_variation.title_ar % $1 OR 
        unit_type_variation.description % $1 OR 
        unit_type_variation.ref_no % $1
    )
AND unit_type_variation.status = $2::bigint
AND CASE WHEN $3::bigint = 0 THEN true ELSE unit_type_variation.property_id = $3::bigint END
`

type GetUnitTypeVariationCountByStatusIDParams struct {
	Search     interface{} `json:"search"`
	Status     int64       `json:"status"`
	PropertyID int64       `json:"property_id"`
}

// SEARCH CRITERIA
func (q *Queries) GetUnitTypeVariationCountByStatusID(ctx context.Context, arg GetUnitTypeVariationCountByStatusIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUnitTypeVariationCountByStatusID, arg.Search, arg.Status, arg.PropertyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnitTypes = `-- name: GetUnitTypes :many
select id, type, code, facts, listing_facts, usage, created_at, updated_at, status, icon, type_ar from unit_type where status=1
`

func (q *Queries) GetUnitTypes(ctx context.Context) ([]UnitType, error) {
	rows, err := q.db.Query(ctx, getUnitTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitType
	for rows.Next() {
		var i UnitType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.Facts,
			&i.ListingFacts,
			&i.Usage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Icon,
			&i.TypeAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitTypesByPropertyID = `-- name: GetUnitTypesByPropertyID :many


SELECT 
    unit_type.id,
    unit_type.code,
    unit_type.facts,
    unit_type.usage,
    unit_type.created_at,
    unit_type.updated_at,
    unit_type.status,
    unit_type.icon,
    CASE 
        WHEN $2::varchar = 'ar' THEN COALESCE(unit_type.type_ar,unit_type."type")
    ELSE COALESCE(unit_type."type", '') END::varchar AS "type"
FROM property p
INNER JOIN unit_type 
    ON unit_type.id = ANY(p.unit_type_id)
WHERE p.id = $1
`

type GetUnitTypesByPropertyIDParams struct {
	ID   int64  `json:"id"`
	Lang string `json:"lang"`
}

type GetUnitTypesByPropertyIDRow struct {
	ID        int64       `json:"id"`
	Code      string      `json:"code"`
	Facts     []byte      `json:"facts"`
	Usage     int64       `json:"usage"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
	Status    int64       `json:"status"`
	Icon      pgtype.Text `json:"icon"`
	Type      string      `json:"type"`
}

// -- name: GetUnitTypesByPropertyType :many
// select u.id,u.type from property_type_unit_type ut
// inner join global_property_type p on ut.property_type_id = p.id
// inner join unit_type u on u.id=ut.unit_type_id
// where p.id = $1;
func (q *Queries) GetUnitTypesByPropertyID(ctx context.Context, arg GetUnitTypesByPropertyIDParams) ([]GetUnitTypesByPropertyIDRow, error) {
	rows, err := q.db.Query(ctx, getUnitTypesByPropertyID, arg.ID, arg.Lang)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitTypesByPropertyIDRow
	for rows.Next() {
		var i GetUnitTypesByPropertyIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Facts,
			&i.Usage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Icon,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitTypesByPropertyType = `-- name: GetUnitTypesByPropertyType :many
select ut.id, ut.type, ut.code, ut.facts, ut.listing_facts, ut.usage, ut.created_at, ut.updated_at, ut.status, ut.icon, ut.type_ar from property_type_unit_type pt
inner join global_property_type gp on pt.property_type_id = gp.id
inner join  unit_type ut on  pt.unit_type_id = ut.id where gp.id = $1
`

func (q *Queries) GetUnitTypesByPropertyType(ctx context.Context, id int64) ([]UnitType, error) {
	rows, err := q.db.Query(ctx, getUnitTypesByPropertyType, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitType
	for rows.Next() {
		var i UnitType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.Facts,
			&i.ListingFacts,
			&i.Usage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Icon,
			&i.TypeAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitTypesByUsage = `-- name: GetUnitTypesByUsage :many
select id, type, code, facts, listing_facts, usage, created_at, updated_at, status, icon, type_ar from unit_type where "usage" = (select global_property_type."usage" from property inner JOIN global_property_type 
ON property.property_type_id = global_property_type.id
where property.id = $1)
`

func (q *Queries) GetUnitTypesByUsage(ctx context.Context, id int64) ([]UnitType, error) {
	rows, err := q.db.Query(ctx, getUnitTypesByUsage, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitType
	for rows.Next() {
		var i UnitType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.Facts,
			&i.ListingFacts,
			&i.Usage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Icon,
			&i.TypeAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitTypesForUsageByPropertyID = `-- name: GetUnitTypesForUsageByPropertyID :many
select id, type, code, property_type_facts, listing_facts, usage, created_at, updated_at, status, icon, is_project, type_ar from global_property_type where "usage" =
(select global_property_type."usage" from property inner JOIN global_property_type 
ON property.property_type_id = global_property_type.id
where property.id = $1)
`

func (q *Queries) GetUnitTypesForUsageByPropertyID(ctx context.Context, id int64) ([]GlobalPropertyType, error) {
	rows, err := q.db.Query(ctx, getUnitTypesForUsageByPropertyID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GlobalPropertyType
	for rows.Next() {
		var i GlobalPropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.PropertyTypeFacts,
			&i.ListingFacts,
			&i.Usage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Icon,
			&i.IsProject,
			&i.TypeAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitTypesVariation = `-- name: GetUnitTypesVariation :many
select id, description, min_area, max_area, min_price, max_price, parking, balcony, bedrooms, bathroom, property_id, unit_type_id, title, image_url, description_ar, status, ref_no, created_at, updated_at, title_ar from unit_type_variation u
where u.property_id = $1 and u.unit_type_id = $2 and u.status != 6
and case when $3::varchar = ''::varchar then true else u.bedrooms = $3::varchar  end
`

type GetUnitTypesVariationParams struct {
	PropertyID int64  `json:"property_id"`
	UnitTypeID int64  `json:"unit_type_id"`
	Bedrooms   string `json:"bedrooms"`
}

func (q *Queries) GetUnitTypesVariation(ctx context.Context, arg GetUnitTypesVariationParams) ([]UnitTypeVariation, error) {
	rows, err := q.db.Query(ctx, getUnitTypesVariation, arg.PropertyID, arg.UnitTypeID, arg.Bedrooms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitTypeVariation
	for rows.Next() {
		var i UnitTypeVariation
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.MinArea,
			&i.MaxArea,
			&i.MinPrice,
			&i.MaxPrice,
			&i.Parking,
			&i.Balcony,
			&i.Bedrooms,
			&i.Bathroom,
			&i.PropertyID,
			&i.UnitTypeID,
			&i.Title,
			&i.ImageUrl,
			&i.DescriptionAr,
			&i.Status,
			&i.RefNo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TitleAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restorePropertyByID = `-- name: RestorePropertyByID :one
UPDATE property
SET status = 1
WHERE property.id = $1::bigint
AND property.status = 6
RETURNING id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date
`

func (q *Queries) RestorePropertyByID(ctx context.Context, id int64) (Property, error) {
	row := q.db.QueryRow(ctx, restorePropertyByID, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const restoreUnitTypeVariationsById = `-- name: RestoreUnitTypeVariationsById :exec
UPDATE unit_type_variation
SET status = 1,
updated_at=now()
WHERE unit_type_variation.id = $1::bigint
`

func (q *Queries) RestoreUnitTypeVariationsById(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, restoreUnitTypeVariationsById, id)
	return err
}

const updateDealPropertyVersion = `-- name: UpdateDealPropertyVersion :exec
update property_versions set is_hotdeal = $1 where id = $2
`

type UpdateDealPropertyVersionParams struct {
	IsHotdeal bool  `json:"is_hotdeal"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateDealPropertyVersion(ctx context.Context, arg UpdateDealPropertyVersionParams) error {
	_, err := q.db.Exec(ctx, updateDealPropertyVersion, arg.IsHotdeal, arg.ID)
	return err
}

const updateDealUnitVersion = `-- name: UpdateDealUnitVersion :exec
update unit_versions set is_hotdeal = $1 where id = $2
`

type UpdateDealUnitVersionParams struct {
	IsHotdeal bool  `json:"is_hotdeal"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateDealUnitVersion(ctx context.Context, arg UpdateDealUnitVersionParams) error {
	_, err := q.db.Exec(ctx, updateDealUnitVersion, arg.IsHotdeal, arg.ID)
	return err
}

const updateGlobalProperty = `-- name: UpdateGlobalProperty :one
UPDATE property
SET company_id = $1,
    property_type_id= $2,
    property_title = $3,
    property_title_arabic = $4,
    is_verified = $5,
    addresses_id = $7,
    status = $8,
    entity_type_id = $9,
    entity_id = $10,
    is_show_owner_info = $11,
    facts = $12,
    user_id = $13,
    property_name = $14,
    description = $15,
    description_arabic = $16,
    owner_users_id = $17,
    from_xml = $18,
    updated_by = $19,
    notes = $20,
    notes_ar= $21,
    is_public_note = $22,
    is_project_property = $23,
    unit_type_id = $24
WHERE id = $6
RETURNING id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date
`

type UpdateGlobalPropertyParams struct {
	CompanyID           pgtype.Int8 `json:"company_id"`
	PropertyTypeID      int64       `json:"property_type_id"`
	PropertyTitle       string      `json:"property_title"`
	PropertyTitleArabic pgtype.Text `json:"property_title_arabic"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	ID                  int64       `json:"id"`
	AddressesID         int64       `json:"addresses_id"`
	Status              int64       `json:"status"`
	EntityTypeID        int64       `json:"entity_type_id"`
	EntityID            int64       `json:"entity_id"`
	IsShowOwnerInfo     pgtype.Bool `json:"is_show_owner_info"`
	Facts               []byte      `json:"facts"`
	UserID              int64       `json:"user_id"`
	PropertyName        string      `json:"property_name"`
	Description         string      `json:"description"`
	DescriptionArabic   pgtype.Text `json:"description_arabic"`
	OwnerUsersID        pgtype.Int8 `json:"owner_users_id"`
	FromXml             pgtype.Bool `json:"from_xml"`
	UpdatedBy           int64       `json:"updated_by"`
	Notes               pgtype.Text `json:"notes"`
	NotesAr             pgtype.Text `json:"notes_ar"`
	IsPublicNote        bool        `json:"is_public_note"`
	IsProjectProperty   bool        `json:"is_project_property"`
	UnitTypeID          []int64     `json:"unit_type_id"`
}

func (q *Queries) UpdateGlobalProperty(ctx context.Context, arg UpdateGlobalPropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, updateGlobalProperty,
		arg.CompanyID,
		arg.PropertyTypeID,
		arg.PropertyTitle,
		arg.PropertyTitleArabic,
		arg.IsVerified,
		arg.ID,
		arg.AddressesID,
		arg.Status,
		arg.EntityTypeID,
		arg.EntityID,
		arg.IsShowOwnerInfo,
		arg.Facts,
		arg.UserID,
		arg.PropertyName,
		arg.Description,
		arg.DescriptionArabic,
		arg.OwnerUsersID,
		arg.FromXml,
		arg.UpdatedBy,
		arg.Notes,
		arg.NotesAr,
		arg.IsPublicNote,
		arg.IsProjectProperty,
		arg.UnitTypeID,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const updateGlobalPropertyStatus = `-- name: UpdateGlobalPropertyStatus :one
UPDATE property
SET status = $1,
	updated_by = $2,
 	updated_at = Now()
WHERE id = $3
RETURNING id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date
`

type UpdateGlobalPropertyStatusParams struct {
	Status    int64 `json:"status"`
	UpdatedBy int64 `json:"updated_by"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateGlobalPropertyStatus(ctx context.Context, arg UpdateGlobalPropertyStatusParams) (Property, error) {
	row := q.db.QueryRow(ctx, updateGlobalPropertyStatus, arg.Status, arg.UpdatedBy, arg.ID)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const updatePropertyRank = `-- name: UpdatePropertyRank :one
UPDATE property_versions
SET property_rank = $1
WHERE property_versions.id = $2::bigint
RETURNING id, title, views_count, title_arabic, description, description_arabic, property_rank, property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type UpdatePropertyRankParams struct {
	PropertyRank int64 `json:"property_rank"`
	ID           int64 `json:"id"`
}

func (q *Queries) UpdatePropertyRank(ctx context.Context, arg UpdatePropertyRankParams) (PropertyVersion, error) {
	row := q.db.QueryRow(ctx, updatePropertyRank, arg.PropertyRank, arg.ID)
	var i PropertyVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const updatePropertyVersion = `-- name: UpdatePropertyVersion :one
UPDATE property_versions
SET title = $1,
    title_arabic= $2,
    description = $3,
    description_arabic = $4,
    property_id = $5,
    property_rank = $6,
    facts = $7,
    updated_at = $8,
    updated_by = $9,
    status = $10,
    agent_id = $11,
    ref_no = $12,
    category = $13,
    has_gallery = $14,
    has_plans = $15,
    is_main = $16,
    is_verified = $17,
    exclusive = $18,
    start_date = $19,
    end_date = $20
WHERE id = $21
RETURNING id, title, views_count, title_arabic, description, description_arabic, property_rank, property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type UpdatePropertyVersionParams struct {
	Title             string      `json:"title"`
	TitleArabic       pgtype.Text `json:"title_arabic"`
	Description       string      `json:"description"`
	DescriptionArabic pgtype.Text `json:"description_arabic"`
	PropertyID        int64       `json:"property_id"`
	PropertyRank      int64       `json:"property_rank"`
	Facts             []byte      `json:"facts"`
	UpdatedAt         time.Time   `json:"updated_at"`
	UpdatedBy         int64       `json:"updated_by"`
	Status            int64       `json:"status"`
	AgentID           int64       `json:"agent_id"`
	RefNo             string      `json:"ref_no"`
	Category          int64       `json:"category"`
	HasGallery        pgtype.Bool `json:"has_gallery"`
	HasPlans          pgtype.Bool `json:"has_plans"`
	IsMain            bool        `json:"is_main"`
	IsVerified        bool        `json:"is_verified"`
	Exclusive         bool        `json:"exclusive"`
	StartDate         pgtype.Date `json:"start_date"`
	EndDate           pgtype.Date `json:"end_date"`
	ID                int64       `json:"id"`
}

func (q *Queries) UpdatePropertyVersion(ctx context.Context, arg UpdatePropertyVersionParams) (PropertyVersion, error) {
	row := q.db.QueryRow(ctx, updatePropertyVersion,
		arg.Title,
		arg.TitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.PropertyID,
		arg.PropertyRank,
		arg.Facts,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
		arg.AgentID,
		arg.RefNo,
		arg.Category,
		arg.HasGallery,
		arg.HasPlans,
		arg.IsMain,
		arg.IsVerified,
		arg.Exclusive,
		arg.StartDate,
		arg.EndDate,
		arg.ID,
	)
	var i PropertyVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const updatePropertyVersionCounterView = `-- name: UpdatePropertyVersionCounterView :exec
UPDATE property_versions
SET 
    views_count=views_count+$2 
WHERE
    id=$1
`

type UpdatePropertyVersionCounterViewParams struct {
	ID         int64 `json:"id"`
	ViewsCount int64 `json:"views_count"`
}

func (q *Queries) UpdatePropertyVersionCounterView(ctx context.Context, arg UpdatePropertyVersionCounterViewParams) error {
	_, err := q.db.Exec(ctx, updatePropertyVersionCounterView, arg.ID, arg.ViewsCount)
	return err
}

const updatePropertyVersionStatus = `-- name: UpdatePropertyVersionStatus :one
UPDATE property_versions
SET status = $1,
	updated_by = $2,
 	updated_at = Now()    
WHERE id = $3
RETURNING id, title, views_count, title_arabic, description, description_arabic, property_rank, property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type UpdatePropertyVersionStatusParams struct {
	Status    int64 `json:"status"`
	UpdatedBy int64 `json:"updated_by"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdatePropertyVersionStatus(ctx context.Context, arg UpdatePropertyVersionStatusParams) (PropertyVersion, error) {
	row := q.db.QueryRow(ctx, updatePropertyVersionStatus, arg.Status, arg.UpdatedBy, arg.ID)
	var i PropertyVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}

const updatePropertyVersionsStatusForAgent = `-- name: UpdatePropertyVersionsStatusForAgent :exec
UPDATE
    property_versions
SET
    status = $1::BIGINT
WHERE
    agent_id = $2::BIGINT
`

type UpdatePropertyVersionsStatusForAgentParams struct {
	Status  int64 `json:"status"`
	AgentID int64 `json:"agent_id"`
}

func (q *Queries) UpdatePropertyVersionsStatusForAgent(ctx context.Context, arg UpdatePropertyVersionsStatusForAgentParams) error {
	_, err := q.db.Exec(ctx, updatePropertyVersionsStatusForAgent, arg.Status, arg.AgentID)
	return err
}

const updateUnitTypeVariation = `-- name: UpdateUnitTypeVariation :one
UPDATE unit_type_variation
SET
    description= $1,
    description_ar= $2,
    min_area= $3,
    max_area= $4, 
    min_price= $5,
    max_price= $6, 
    parking= $7,
    balcony= $8,
    bedrooms= $9,
    bathroom= $10,
    property_id= $11,
    title= $12,
    title_ar= $13, 
    unit_type_id= $14,
    updated_at=$15,
    image_url=$16
WHERE id= $17
RETURNING id, description, min_area, max_area, min_price, max_price, parking, balcony, bedrooms, bathroom, property_id, unit_type_id, title, image_url, description_ar, status, ref_no, created_at, updated_at, title_ar
`

type UpdateUnitTypeVariationParams struct {
	Description   string      `json:"description"`
	DescriptionAr pgtype.Text `json:"description_ar"`
	MinArea       float64     `json:"min_area"`
	MaxArea       float64     `json:"max_area"`
	MinPrice      float64     `json:"min_price"`
	MaxPrice      float64     `json:"max_price"`
	Parking       int64       `json:"parking"`
	Balcony       int64       `json:"balcony"`
	Bedrooms      pgtype.Text `json:"bedrooms"`
	Bathroom      pgtype.Text `json:"bathroom"`
	PropertyID    int64       `json:"property_id"`
	Title         string      `json:"title"`
	TitleAr       pgtype.Text `json:"title_ar"`
	UnitTypeID    int64       `json:"unit_type_id"`
	UpdatedAt     time.Time   `json:"updated_at"`
	ImageUrl      []string    `json:"image_url"`
	ID            int64       `json:"id"`
}

func (q *Queries) UpdateUnitTypeVariation(ctx context.Context, arg UpdateUnitTypeVariationParams) (UnitTypeVariation, error) {
	row := q.db.QueryRow(ctx, updateUnitTypeVariation,
		arg.Description,
		arg.DescriptionAr,
		arg.MinArea,
		arg.MaxArea,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Parking,
		arg.Balcony,
		arg.Bedrooms,
		arg.Bathroom,
		arg.PropertyID,
		arg.Title,
		arg.TitleAr,
		arg.UnitTypeID,
		arg.UpdatedAt,
		arg.ImageUrl,
		arg.ID,
	)
	var i UnitTypeVariation
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.MinArea,
		&i.MaxArea,
		&i.MinPrice,
		&i.MaxPrice,
		&i.Parking,
		&i.Balcony,
		&i.Bedrooms,
		&i.Bathroom,
		&i.PropertyID,
		&i.UnitTypeID,
		&i.Title,
		&i.ImageUrl,
		&i.DescriptionAr,
		&i.Status,
		&i.RefNo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TitleAr,
	)
	return i, err
}

const updateXMLGlobalProperty = `-- name: UpdateXMLGlobalProperty :one
UPDATE property
SET company_id = $1,
    property_type_id= $2,
    property_title = $3,
    property_title_arabic = $4,
    facts = $5,
    property_name = $6,
    description = $7,
    description_arabic = $8,
    updated_by = $9,
    status = $11,
    entity_type_id = $12,
    is_project_property = $13
WHERE id = $10
RETURNING id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date
`

type UpdateXMLGlobalPropertyParams struct {
	CompanyID           pgtype.Int8 `json:"company_id"`
	PropertyTypeID      int64       `json:"property_type_id"`
	PropertyTitle       string      `json:"property_title"`
	PropertyTitleArabic pgtype.Text `json:"property_title_arabic"`
	Facts               []byte      `json:"facts"`
	PropertyName        string      `json:"property_name"`
	Description         string      `json:"description"`
	DescriptionArabic   pgtype.Text `json:"description_arabic"`
	UpdatedBy           int64       `json:"updated_by"`
	ID                  int64       `json:"id"`
	Status              int64       `json:"status"`
	EntityTypeID        int64       `json:"entity_type_id"`
	IsProjectProperty   bool        `json:"is_project_property"`
}

func (q *Queries) UpdateXMLGlobalProperty(ctx context.Context, arg UpdateXMLGlobalPropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, updateXMLGlobalProperty,
		arg.CompanyID,
		arg.PropertyTypeID,
		arg.PropertyTitle,
		arg.PropertyTitleArabic,
		arg.Facts,
		arg.PropertyName,
		arg.Description,
		arg.DescriptionArabic,
		arg.UpdatedBy,
		arg.ID,
		arg.Status,
		arg.EntityTypeID,
		arg.IsProjectProperty,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PropertyTypeID,
		&i.UnitTypeID,
		&i.PropertyTitle,
		&i.PropertyTitleArabic,
		&i.IsVerified,
		&i.AddressesID,
		&i.EntityTypeID,
		&i.EntityID,
		&i.Status,
		&i.IsShowOwnerInfo,
		&i.PropertyName,
		&i.Description,
		&i.DescriptionArabic,
		&i.OwnerUsersID,
		&i.UserID,
		&i.UpdatedBy,
		&i.FromXml,
		&i.Facts,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotesAr,
		&i.IsPublicNote,
		&i.IsProjectProperty,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const updateXMLPropertyVersion = `-- name: UpdateXMLPropertyVersion :one
UPDATE property_versions
SET title = $1,
    title_arabic= $2,
    description = $3,
    description_arabic = $4,
    facts = $5,
    updated_at = $6,
    updated_by = $7,
    agent_id = $8,
    ref_no = $9,
    category = $10,
    status = $12
WHERE id = $11
RETURNING id, title, views_count, title_arabic, description, description_arabic, property_rank, property_id, facts, created_at, updated_at, updated_by, status, agent_id, ref_no, category, has_gallery, has_plans, is_main, is_verified, exclusive, start_date, end_date, slug, is_hotdeal, refreshed_at
`

type UpdateXMLPropertyVersionParams struct {
	Title             string      `json:"title"`
	TitleArabic       pgtype.Text `json:"title_arabic"`
	Description       string      `json:"description"`
	DescriptionArabic pgtype.Text `json:"description_arabic"`
	Facts             []byte      `json:"facts"`
	UpdatedAt         time.Time   `json:"updated_at"`
	UpdatedBy         int64       `json:"updated_by"`
	AgentID           int64       `json:"agent_id"`
	RefNo             string      `json:"ref_no"`
	Category          int64       `json:"category"`
	ID                int64       `json:"id"`
	Status            int64       `json:"status"`
}

func (q *Queries) UpdateXMLPropertyVersion(ctx context.Context, arg UpdateXMLPropertyVersionParams) (PropertyVersion, error) {
	row := q.db.QueryRow(ctx, updateXMLPropertyVersion,
		arg.Title,
		arg.TitleArabic,
		arg.Description,
		arg.DescriptionArabic,
		arg.Facts,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.AgentID,
		arg.RefNo,
		arg.Category,
		arg.ID,
		arg.Status,
	)
	var i PropertyVersion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ViewsCount,
		&i.TitleArabic,
		&i.Description,
		&i.DescriptionArabic,
		&i.PropertyRank,
		&i.PropertyID,
		&i.Facts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.AgentID,
		&i.RefNo,
		&i.Category,
		&i.HasGallery,
		&i.HasPlans,
		&i.IsMain,
		&i.IsVerified,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.IsHotdeal,
		&i.RefreshedAt,
	)
	return i, err
}
