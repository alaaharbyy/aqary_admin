// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: openhouse.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOpenHouse = `-- name: CreateOpenHouse :one
INSERT INTO openhouse(
    ref_no,
    created_by,
    property_id,
    start_date,
    end_date,
    created_at,
    updated_at,
    sessions
) VALUES(
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, ref_no, created_by, property_id, start_date, end_date, created_at, updated_at, sessions
`

type CreateOpenHouseParams struct {
	RefNo      string    `json:"ref_no"`
	CreatedBy  int64     `json:"created_by"`
	PropertyID int64     `json:"property_id"`
	StartDate  time.Time `json:"start_date"`
	EndDate    time.Time `json:"end_date"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	Sessions   []byte    `json:"sessions"`
}

func (q *Queries) CreateOpenHouse(ctx context.Context, arg CreateOpenHouseParams) (Openhouse, error) {
	row := q.db.QueryRow(ctx, createOpenHouse,
		arg.RefNo,
		arg.CreatedBy,
		arg.PropertyID,
		arg.StartDate,
		arg.EndDate,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Sessions,
	)
	var i Openhouse
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CreatedBy,
		&i.PropertyID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Sessions,
	)
	return i, err
}

const createOpenhouseAppointment = `-- name: CreateOpenhouseAppointment :one
INSERT INTO appointment(
    -- openhouse_id,
    timeslots_id,
    -- agent_id,
    created_by,
    status,
    client_id,
    remarks,
    created_at,
    updated_at,
    -- appointment_type,
    background_color
)VALUES(
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id
`

type CreateOpenhouseAppointmentParams struct {
	TimeslotsID     int64       `json:"timeslots_id"`
	CreatedBy       int64       `json:"created_by"`
	Status          int64       `json:"status"`
	ClientID        pgtype.Int8 `json:"client_id"`
	Remarks         pgtype.Text `json:"remarks"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	BackgroundColor string      `json:"background_color"`
}

func (q *Queries) CreateOpenhouseAppointment(ctx context.Context, arg CreateOpenhouseAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createOpenhouseAppointment,
		arg.TimeslotsID,
		arg.CreatedBy,
		arg.Status,
		arg.ClientID,
		arg.Remarks,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.BackgroundColor,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const createTimeSlots = `-- name: CreateTimeSlots :one
INSERT INTO timeslots(
    date,
    start_time,
    end_time,
    status,
    entity_id,
    entity_type_id
    -- openhouse_id
)VALUES(
    $1, $2, $3, $4, $5, $6
) RETURNING id, date, start_time, end_time, status, entity_type_id, entity_id
`

type CreateTimeSlotsParams struct {
	Date         time.Time `json:"date"`
	StartTime    time.Time `json:"start_time"`
	EndTime      time.Time `json:"end_time"`
	Status       int64     `json:"status"`
	EntityID     int64     `json:"entity_id"`
	EntityTypeID int64     `json:"entity_type_id"`
}

func (q *Queries) CreateTimeSlots(ctx context.Context, arg CreateTimeSlotsParams) (Timeslot, error) {
	row := q.db.QueryRow(ctx, createTimeSlots,
		arg.Date,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.EntityID,
		arg.EntityTypeID,
	)
	var i Timeslot
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}

const getAllAvailableTimeSlotsByProjectProperty = `-- name: GetAllAvailableTimeSlotsByProjectProperty :many
SELECT timeslots.id, timeslots.date, timeslots.start_time, timeslots.end_time, timeslots.status, timeslots.entity_type_id, timeslots.entity_id 
FROM timeslots 
INNER JOIN openhouse ON timeslots.entity_id = openhouse.id
WHERE openhouse.property_id = $1 AND timeslots.status = 1 
AND timeslots.entity_type_id = 12
ORDER BY timeslots.start_time
`

func (q *Queries) GetAllAvailableTimeSlotsByProjectProperty(ctx context.Context, propertyID int64) ([]Timeslot, error) {
	rows, err := q.db.Query(ctx, getAllAvailableTimeSlotsByProjectProperty, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Timeslot
	for rows.Next() {
		var i Timeslot
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.EntityTypeID,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOHTimeSlotsAndAppointmentsByProjProp = `-- name: GetAllOHTimeSlotsAndAppointmentsByProjProp :many
SELECT 
timeslots.id AS time_slot_id,
timeslots."date",
timeslots.start_time,
timeslots.end_time,
timeslots.status AS time_slot_status,
appointment.id AS appointment_id,
appointment.status AS appointment_status,
appointment.background_color,
users.email,
profiles.first_name,
profiles.last_name,
users.phone_number,
profiles.profile_image_url,
openhouse.id AS open_house_id
FROM timeslots
LEFT JOIN openhouse ON openhouse.id = timeslots.entity_id
LEFT JOIN appointment ON appointment.timeslots_id = timeslots.id AND appointment.status != 5
LEFT JOIN users ON users.id = appointment.client_id
LEFT JOIN profiles ON profiles.users_id = users.id
WHERE openhouse.property_id = $1
AND timeslots.entity_type_id = 12
ORDER BY timeslots.start_time ASC
`

type GetAllOHTimeSlotsAndAppointmentsByProjPropRow struct {
	TimeSlotID        int64       `json:"time_slot_id"`
	Date              time.Time   `json:"date"`
	StartTime         time.Time   `json:"start_time"`
	EndTime           time.Time   `json:"end_time"`
	TimeSlotStatus    int64       `json:"time_slot_status"`
	AppointmentID     pgtype.Int8 `json:"appointment_id"`
	AppointmentStatus pgtype.Int8 `json:"appointment_status"`
	BackgroundColor   pgtype.Text `json:"background_color"`
	Email             pgtype.Text `json:"email"`
	FirstName         pgtype.Text `json:"first_name"`
	LastName          pgtype.Text `json:"last_name"`
	PhoneNumber       pgtype.Text `json:"phone_number"`
	ProfileImageUrl   pgtype.Text `json:"profile_image_url"`
	OpenHouseID       pgtype.Int8 `json:"open_house_id"`
}

// timeslots.openhouse_id,
// appointment.appointment_type,
// profiles.nic_no,
func (q *Queries) GetAllOHTimeSlotsAndAppointmentsByProjProp(ctx context.Context, propertyID int64) ([]GetAllOHTimeSlotsAndAppointmentsByProjPropRow, error) {
	rows, err := q.db.Query(ctx, getAllOHTimeSlotsAndAppointmentsByProjProp, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOHTimeSlotsAndAppointmentsByProjPropRow
	for rows.Next() {
		var i GetAllOHTimeSlotsAndAppointmentsByProjPropRow
		if err := rows.Scan(
			&i.TimeSlotID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.TimeSlotStatus,
			&i.AppointmentID,
			&i.AppointmentStatus,
			&i.BackgroundColor,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.ProfileImageUrl,
			&i.OpenHouseID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOpenhouseSessionsByProjProp = `-- name: GetAllOpenhouseSessionsByProjProp :many
SELECT openhouse.id,openhouse.sessions FROM openhouse
WHERE property_id = $1
`

type GetAllOpenhouseSessionsByProjPropRow struct {
	ID       int64  `json:"id"`
	Sessions []byte `json:"sessions"`
}

func (q *Queries) GetAllOpenhouseSessionsByProjProp(ctx context.Context, propertyID int64) ([]GetAllOpenhouseSessionsByProjPropRow, error) {
	rows, err := q.db.Query(ctx, getAllOpenhouseSessionsByProjProp, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOpenhouseSessionsByProjPropRow
	for rows.Next() {
		var i GetAllOpenhouseSessionsByProjPropRow
		if err := rows.Scan(&i.ID, &i.Sessions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertyOHAppointments = `-- name: GetAllProjectPropertyOHAppointments :many
SELECT 
openhouse.id AS openhouse_id,
appointment.id AS appointment_id,
appointment.status AS appointment_status,
appointment.background_color,
timeslots.id AS time_slot_id,
timeslots."date",
timeslots.start_time,
timeslots.end_time,
timeslots.status AS time_slot_status,
users.email,
profiles.first_name,
profiles.last_name,
users.phone_number,
profiles.profile_image_url
FROM appointment
INNER JOIN openhouse ON openhouse.id = appointment.openhouse_id
INNER JOIN timeslots ON timeslots.id = appointment.timeslots_id
LEFT JOIN users ON users.id = appointment.client_id
LEFT JOIN profiles ON profiles.users_id = users.id
WHERE openhouse.property_id = $1 AND appointment.status != 5
ORDER BY timeslots."date",start_time ASC
`

type GetAllProjectPropertyOHAppointmentsRow struct {
	OpenhouseID       int64       `json:"openhouse_id"`
	AppointmentID     int64       `json:"appointment_id"`
	AppointmentStatus int64       `json:"appointment_status"`
	BackgroundColor   string      `json:"background_color"`
	TimeSlotID        int64       `json:"time_slot_id"`
	Date              time.Time   `json:"date"`
	StartTime         time.Time   `json:"start_time"`
	EndTime           time.Time   `json:"end_time"`
	TimeSlotStatus    int64       `json:"time_slot_status"`
	Email             pgtype.Text `json:"email"`
	FirstName         pgtype.Text `json:"first_name"`
	LastName          pgtype.Text `json:"last_name"`
	PhoneNumber       pgtype.Text `json:"phone_number"`
	ProfileImageUrl   pgtype.Text `json:"profile_image_url"`
}

// appointment.appointment_type,
// profiles.nic_no
func (q *Queries) GetAllProjectPropertyOHAppointments(ctx context.Context, propertyID int64) ([]GetAllProjectPropertyOHAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertyOHAppointments, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPropertyOHAppointmentsRow
	for rows.Next() {
		var i GetAllProjectPropertyOHAppointmentsRow
		if err := rows.Scan(
			&i.OpenhouseID,
			&i.AppointmentID,
			&i.AppointmentStatus,
			&i.BackgroundColor,
			&i.TimeSlotID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.TimeSlotStatus,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTimeSlotsByProjectPropertyId = `-- name: GetAllTimeSlotsByProjectPropertyId :many
SELECT openhouse.id AS openhouse_id,timeslots.id,date,start_time,end_time,status 
FROM timeslots
INNER JOIN openhouse ON openhouse.id = openhouse_id
WHERE openhouse.property_id = $3
ORDER BY openhouse.start_date ASC
LIMIT $1 OFFSET $2
`

type GetAllTimeSlotsByProjectPropertyIdParams struct {
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	PropertyID int64 `json:"property_id"`
}

type GetAllTimeSlotsByProjectPropertyIdRow struct {
	OpenhouseID int64     `json:"openhouse_id"`
	ID          int64     `json:"id"`
	Date        time.Time `json:"date"`
	StartTime   time.Time `json:"start_time"`
	EndTime     time.Time `json:"end_time"`
	Status      int64     `json:"status"`
}

func (q *Queries) GetAllTimeSlotsByProjectPropertyId(ctx context.Context, arg GetAllTimeSlotsByProjectPropertyIdParams) ([]GetAllTimeSlotsByProjectPropertyIdRow, error) {
	rows, err := q.db.Query(ctx, getAllTimeSlotsByProjectPropertyId, arg.Limit, arg.Offset, arg.PropertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTimeSlotsByProjectPropertyIdRow
	for rows.Next() {
		var i GetAllTimeSlotsByProjectPropertyIdRow
		if err := rows.Scan(
			&i.OpenhouseID,
			&i.ID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTimeslotsByOpenhouseAndStatus = `-- name: GetAllTimeslotsByOpenhouseAndStatus :many
SELECT id, date, start_time, end_time, status, entity_type_id, entity_id FROM timeslots 
WHERE entity_id = $1 AND status = $2 
AND entity_type_id = $3
ORDER BY date ASC
`

type GetAllTimeslotsByOpenhouseAndStatusParams struct {
	EntityID     int64 `json:"entity_id"`
	Status       int64 `json:"status"`
	EntityTypeID int64 `json:"entity_type_id"`
}

func (q *Queries) GetAllTimeslotsByOpenhouseAndStatus(ctx context.Context, arg GetAllTimeslotsByOpenhouseAndStatusParams) ([]Timeslot, error) {
	rows, err := q.db.Query(ctx, getAllTimeslotsByOpenhouseAndStatus, arg.EntityID, arg.Status, arg.EntityTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Timeslot
	for rows.Next() {
		var i Timeslot
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.EntityTypeID,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableTimeSlots = `-- name: GetAvailableTimeSlots :one
SELECT id 
FROM timeslots 
WHERE id = $1 AND status = 1
`

func (q *Queries) GetAvailableTimeSlots(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAvailableTimeSlots, id)
	err := row.Scan(&id)
	return id, err
}

const getCountAllTimeSlotsByProjectPropertyId = `-- name: GetCountAllTimeSlotsByProjectPropertyId :one
SELECT COUNT(timeslots.id) 
FROM timeslots
INNER JOIN openhouse ON openhouse.id = openhouse_id
WHERE openhouse.property_id = $1
`

func (q *Queries) GetCountAllTimeSlotsByProjectPropertyId(ctx context.Context, propertyID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllTimeSlotsByProjectPropertyId, propertyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOpenHouse = `-- name: GetOpenHouse :one
SELECT openhouse.id, openhouse.ref_no, openhouse.created_by, openhouse.property_id, openhouse.start_date, openhouse.end_date, openhouse.created_at, openhouse.updated_at, openhouse.sessions, property.property_name 
FROM openhouse
INNER JOIN property ON property.id = openhouse.property_id
WHERE openhouse.id = $1 LIMIT 1
`

type GetOpenHouseRow struct {
	ID           int64     `json:"id"`
	RefNo        string    `json:"ref_no"`
	CreatedBy    int64     `json:"created_by"`
	PropertyID   int64     `json:"property_id"`
	StartDate    time.Time `json:"start_date"`
	EndDate      time.Time `json:"end_date"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	Sessions     []byte    `json:"sessions"`
	PropertyName string    `json:"property_name"`
}

func (q *Queries) GetOpenHouse(ctx context.Context, id int64) (GetOpenHouseRow, error) {
	row := q.db.QueryRow(ctx, getOpenHouse, id)
	var i GetOpenHouseRow
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.CreatedBy,
		&i.PropertyID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Sessions,
		&i.PropertyName,
	)
	return i, err
}

const getOpenhouseAppointment = `-- name: GetOpenhouseAppointment :one
SELECT id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id FROM appointment
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetOpenhouseAppointment(ctx context.Context, id int64) (Appointment, error) {
	row := q.db.QueryRow(ctx, getOpenhouseAppointment, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const rescheduleOpenhouseAppointment = `-- name: RescheduleOpenhouseAppointment :one
UPDATE appointment 
SET status = $2,
    remarks = $3,
    timeslots_id = $4
WHERE id = $1
RETURNING id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id
`

type RescheduleOpenhouseAppointmentParams struct {
	ID          int64       `json:"id"`
	Status      int64       `json:"status"`
	Remarks     pgtype.Text `json:"remarks"`
	TimeslotsID int64       `json:"timeslots_id"`
}

func (q *Queries) RescheduleOpenhouseAppointment(ctx context.Context, arg RescheduleOpenhouseAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, rescheduleOpenhouseAppointment,
		arg.ID,
		arg.Status,
		arg.Remarks,
		arg.TimeslotsID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const updateOpenhouseAppointmentStatus = `-- name: UpdateOpenhouseAppointmentStatus :one
UPDATE appointment 
SET status = $2
WHERE id = $1
RETURNING id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id
`

type UpdateOpenhouseAppointmentStatusParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

func (q *Queries) UpdateOpenhouseAppointmentStatus(ctx context.Context, arg UpdateOpenhouseAppointmentStatusParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateOpenhouseAppointmentStatus, arg.ID, arg.Status)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const updateOpenhouseAppointmentStatusAndRemarks = `-- name: UpdateOpenhouseAppointmentStatusAndRemarks :one
UPDATE appointment 
SET status = $2,
    remarks = $3
WHERE id = $1
RETURNING id, timeslots_id, created_by, status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id
`

type UpdateOpenhouseAppointmentStatusAndRemarksParams struct {
	ID      int64       `json:"id"`
	Status  int64       `json:"status"`
	Remarks pgtype.Text `json:"remarks"`
}

func (q *Queries) UpdateOpenhouseAppointmentStatusAndRemarks(ctx context.Context, arg UpdateOpenhouseAppointmentStatusAndRemarksParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateOpenhouseAppointmentStatusAndRemarks, arg.ID, arg.Status, arg.Remarks)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
	)
	return i, err
}

const updateTimeSlotsByStatus = `-- name: UpdateTimeSlotsByStatus :one
UPDATE timeslots
SET status = $2
WHERE id = $1
RETURNING id, date, start_time, end_time, status, entity_type_id, entity_id
`

type UpdateTimeSlotsByStatusParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

func (q *Queries) UpdateTimeSlotsByStatus(ctx context.Context, arg UpdateTimeSlotsByStatusParams) (Timeslot, error) {
	row := q.db.QueryRow(ctx, updateTimeSlotsByStatus, arg.ID, arg.Status)
	var i Timeslot
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}

const updateTimeslotsStatusByAppointment = `-- name: UpdateTimeslotsStatusByAppointment :one
UPDATE timeslots
SET status = $2
FROM appointment
WHERE appointment.timeslots_id = timeslots.id AND appointment.id = $1
RETURNING appointment.id, timeslots_id, created_by, appointment.status, client_id, remarks, created_at, updated_at, background_color, appoinment_type, appoinment_app, valid_id, timeslots.id, date, start_time, end_time, timeslots.status, entity_type_id, entity_id
`

type UpdateTimeslotsStatusByAppointmentParams struct {
	ID     int64 `json:"id"`
	Status int64 `json:"status"`
}

type UpdateTimeslotsStatusByAppointmentRow struct {
	ID              int64       `json:"id"`
	TimeslotsID     int64       `json:"timeslots_id"`
	CreatedBy       int64       `json:"created_by"`
	Status          int64       `json:"status"`
	ClientID        pgtype.Int8 `json:"client_id"`
	Remarks         pgtype.Text `json:"remarks"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	BackgroundColor string      `json:"background_color"`
	AppoinmentType  int64       `json:"appoinment_type"`
	AppoinmentApp   pgtype.Int8 `json:"appoinment_app"`
	ValidID         int64       `json:"valid_id"`
	ID_2            int64       `json:"id_2"`
	Date            time.Time   `json:"date"`
	StartTime       time.Time   `json:"start_time"`
	EndTime         time.Time   `json:"end_time"`
	Status_2        int64       `json:"status_2"`
	EntityTypeID    int64       `json:"entity_type_id"`
	EntityID        int64       `json:"entity_id"`
}

func (q *Queries) UpdateTimeslotsStatusByAppointment(ctx context.Context, arg UpdateTimeslotsStatusByAppointmentParams) (UpdateTimeslotsStatusByAppointmentRow, error) {
	row := q.db.QueryRow(ctx, updateTimeslotsStatusByAppointment, arg.ID, arg.Status)
	var i UpdateTimeslotsStatusByAppointmentRow
	err := row.Scan(
		&i.ID,
		&i.TimeslotsID,
		&i.CreatedBy,
		&i.Status,
		&i.ClientID,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BackgroundColor,
		&i.AppoinmentType,
		&i.AppoinmentApp,
		&i.ValidID,
		&i.ID_2,
		&i.Date,
		&i.StartTime,
		&i.EndTime,
		&i.Status_2,
		&i.EntityTypeID,
		&i.EntityID,
	)
	return i, err
}
