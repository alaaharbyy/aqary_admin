// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: unit_type.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUnitType = `-- name: AddUnitType :exec
INSERT INTO unit_type (
 type,
 type_ar,
 code,
 facts,
 usage,
 created_at,
 updated_at,
 status,
 icon,
  listing_facts
)VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
`

type AddUnitTypeParams struct {
	Type         string      `json:"type"`
	TypeAr       pgtype.Text `json:"type_ar"`
	Code         string      `json:"code"`
	Facts        []byte      `json:"facts"`
	Usage        int64       `json:"usage"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Status       int64       `json:"status"`
	Icon         pgtype.Text `json:"icon"`
	ListingFacts []int64     `json:"listing_facts"`
}

func (q *Queries) AddUnitType(ctx context.Context, arg AddUnitTypeParams) error {
	_, err := q.db.Exec(ctx, addUnitType,
		arg.Type,
		arg.TypeAr,
		arg.Code,
		arg.Facts,
		arg.Usage,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.Icon,
		arg.ListingFacts,
	)
	return err
}

const changeStatusForUnitType = `-- name: ChangeStatusForUnitType :exec
UPDATE unit_type
SET
    status= $2, 
    updated_at=$3
WHERE id=$1
`

type ChangeStatusForUnitTypeParams struct {
	ID        int64     `json:"id"`
	Status    int64     `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) ChangeStatusForUnitType(ctx context.Context, arg ChangeStatusForUnitTypeParams) error {
	_, err := q.db.Exec(ctx, changeStatusForUnitType, arg.ID, arg.Status, arg.UpdatedAt)
	return err
}

const checkUnitTypeIfExists = `-- name: CheckUnitTypeIfExists :many
SELECT id from unit_type 
WHERE status != 6 AND id = ANY($1::bigint[])
`

func (q *Queries) CheckUnitTypeIfExists(ctx context.Context, unitTypeIds []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, checkUnitTypeIfExists, unitTypeIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActiveUnitTypes = `-- name: GetAllActiveUnitTypes :many
SELECT id, type, code, facts, listing_facts, usage, created_at, updated_at, status, icon, type_ar FROM unit_type WHERE status = 2
`

func (q *Queries) GetAllActiveUnitTypes(ctx context.Context) ([]UnitType, error) {
	rows, err := q.db.Query(ctx, getAllActiveUnitTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnitType
	for rows.Next() {
		var i UnitType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.Facts,
			&i.ListingFacts,
			&i.Usage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Icon,
			&i.TypeAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitTypeSettings = `-- name: GetUnitTypeSettings :one
SELECT id, type, code, facts, listing_facts, usage, created_at, updated_at, status, icon, type_ar FROM unit_type WHERE id=$1 AND status!=6
`

func (q *Queries) GetUnitTypeSettings(ctx context.Context, id int64) (UnitType, error) {
	row := q.db.QueryRow(ctx, getUnitTypeSettings, id)
	var i UnitType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.Facts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.TypeAr,
	)
	return i, err
}

const getUnitsTypeSettingsCount = `-- name: GetUnitsTypeSettingsCount :one
SELECT
    COUNT(id)
FROM
    unit_type
WHERE CASE
        WHEN $1::BIGINT = 6 THEN status = 6
        ELSE status != 6
    END
`

func (q *Queries) GetUnitsTypeSettingsCount(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUnitsTypeSettingsCount, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnitsTypeSittings = `-- name: GetUnitsTypeSittings :many
SELECT
    id,
    type,
    type_ar,
    code,
    usage,
    icon,
    status, 
    updated_at
FROM
    unit_type
WHERE   CASE
        WHEN $1::BIGINT = 6 THEN status = 6
        ELSE status != 6
    END
ORDER BY updated_at DESC
LIMIT $3
OFFSET $2
`

type GetUnitsTypeSittingsParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetUnitsTypeSittingsRow struct {
	ID        int64       `json:"id"`
	Type      string      `json:"type"`
	TypeAr    pgtype.Text `json:"type_ar"`
	Code      string      `json:"code"`
	Usage     int64       `json:"usage"`
	Icon      pgtype.Text `json:"icon"`
	Status    int64       `json:"status"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) GetUnitsTypeSittings(ctx context.Context, arg GetUnitsTypeSittingsParams) ([]GetUnitsTypeSittingsRow, error) {
	rows, err := q.db.Query(ctx, getUnitsTypeSittings, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitsTypeSittingsRow
	for rows.Next() {
		var i GetUnitsTypeSittingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.TypeAr,
			&i.Code,
			&i.Usage,
			&i.Icon,
			&i.Status,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unitTypeExistsInTables = `-- name: UnitTypeExistsInTables :one
SELECT 
    CAST(
        (
            (SELECT COUNT(*) FROM property WHERE $1::BIGINT[] && property.unit_type_id) + 
            (SELECT COUNT(*) FROM property_type_unit_type WHERE property_type_unit_type.unit_type_id = ANY($1::BIGINT[])) + 
            (SELECT COUNT(*) FROM units WHERE units.unit_type_id = ANY($1::BIGINT[]))
        ) AS BIGINT
    ) AS total_count
`

func (q *Queries) UnitTypeExistsInTables(ctx context.Context, unitTypeID []int64) (int64, error) {
	row := q.db.QueryRow(ctx, unitTypeExistsInTables, unitTypeID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const updateUnitTypeSettings = `-- name: UpdateUnitTypeSettings :exec
UPDATE unit_type
SET 
    type = $1, 
    code =  $2,
    facts = $3,
    usage = $4,
    updated_at = $5,
    icon = $6,
    type_ar=$7,
    listing_facts=$8
WHERE 
    id = $9::BIGINT AND status!=6
`

type UpdateUnitTypeSettingsParams struct {
	Type         string      `json:"type"`
	Code         string      `json:"code"`
	Facts        []byte      `json:"facts"`
	Usage        int64       `json:"usage"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Icon         pgtype.Text `json:"icon"`
	TypeAr       pgtype.Text `json:"type_ar"`
	ListingFacts []int64     `json:"listing_facts"`
	UnitTypeID   int64       `json:"unit_type_id"`
}

func (q *Queries) UpdateUnitTypeSettings(ctx context.Context, arg UpdateUnitTypeSettingsParams) error {
	_, err := q.db.Exec(ctx, updateUnitTypeSettings,
		arg.Type,
		arg.Code,
		arg.Facts,
		arg.Usage,
		arg.UpdatedAt,
		arg.Icon,
		arg.TypeAr,
		arg.ListingFacts,
		arg.UnitTypeID,
	)
	return err
}
