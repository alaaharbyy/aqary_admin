// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: property_types.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPropertyType = `-- name: CreatePropertyType :one
INSERT INTO property_types (
    type,
    code,
    is_residential,
    is_commercial,
    created_at,
    updated_at,
    property_type_facts_id,
    category,
    status,
    unit_types,
    icon
)VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon
`

type CreatePropertyTypeParams struct {
	Type                string      `json:"type"`
	Code                string      `json:"code"`
	IsResidential       pgtype.Bool `json:"is_residential"`
	IsCommercial        pgtype.Bool `json:"is_commercial"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	PropertyTypeFactsID []int64     `json:"property_type_facts_id"`
	Category            string      `json:"category"`
	Status              int64       `json:"status"`
	UnitTypes           []int64     `json:"unit_types"`
	Icon                pgtype.Text `json:"icon"`
}

func (q *Queries) CreatePropertyType(ctx context.Context, arg CreatePropertyTypeParams) (PropertyType, error) {
	row := q.db.QueryRow(ctx, createPropertyType,
		arg.Type,
		arg.Code,
		arg.IsResidential,
		arg.IsCommercial,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.PropertyTypeFactsID,
		arg.Category,
		arg.Status,
		arg.UnitTypes,
		arg.Icon,
	)
	var i PropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.IsResidential,
		&i.IsCommercial,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyTypeFactsID,
		&i.Category,
		&i.Status,
		&i.UnitTypes,
		&i.Icon,
	)
	return i, err
}

const deletePropertyType = `-- name: DeletePropertyType :exec
DELETE FROM property_types
Where id = $1
`

func (q *Queries) DeletePropertyType(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePropertyType, id)
	return err
}

const getAllPropertyByResidential = `-- name: GetAllPropertyByResidential :many
SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types
Where is_residential = true
LIMIT $1
OFFSET $2
`

type GetAllPropertyByResidentialParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPropertyByResidential(ctx context.Context, arg GetAllPropertyByResidentialParams) ([]PropertyType, error) {
	rows, err := q.db.Query(ctx, getAllPropertyByResidential, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyType
	for rows.Next() {
		var i PropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsResidential,
			&i.IsCommercial,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTypeFactsID,
			&i.Category,
			&i.Status,
			&i.UnitTypes,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertyType = `-- name: GetAllPropertyType :many
SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllPropertyTypeParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPropertyType(ctx context.Context, arg GetAllPropertyTypeParams) ([]PropertyType, error) {
	rows, err := q.db.Query(ctx, getAllPropertyType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyType
	for rows.Next() {
		var i PropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsResidential,
			&i.IsCommercial,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTypeFactsID,
			&i.Category,
			&i.Status,
			&i.UnitTypes,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertyTypeByCode = `-- name: GetAllPropertyTypeByCode :one
SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types
Where code = $1
LIMIT $2
OFFSET $3
`

type GetAllPropertyTypeByCodeParams struct {
	Code   string `json:"code"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetAllPropertyTypeByCode(ctx context.Context, arg GetAllPropertyTypeByCodeParams) (PropertyType, error) {
	row := q.db.QueryRow(ctx, getAllPropertyTypeByCode, arg.Code, arg.Limit, arg.Offset)
	var i PropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.IsResidential,
		&i.IsCommercial,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyTypeFactsID,
		&i.Category,
		&i.Status,
		&i.UnitTypes,
		&i.Icon,
	)
	return i, err
}

const getAllPropertyTypeByCommercial = `-- name: GetAllPropertyTypeByCommercial :many
SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types
Where is_commercial = true
LIMIT $1
OFFSET $2
`

type GetAllPropertyTypeByCommercialParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPropertyTypeByCommercial(ctx context.Context, arg GetAllPropertyTypeByCommercialParams) ([]PropertyType, error) {
	rows, err := q.db.Query(ctx, getAllPropertyTypeByCommercial, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyType
	for rows.Next() {
		var i PropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsResidential,
			&i.IsCommercial,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTypeFactsID,
			&i.Category,
			&i.Status,
			&i.UnitTypes,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertyTypeByType = `-- name: GetAllPropertyTypeByType :one
SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types
Where type = $1
LIMIT $2
OFFSET $3
`

type GetAllPropertyTypeByTypeParams struct {
	Type   string `json:"type"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetAllPropertyTypeByType(ctx context.Context, arg GetAllPropertyTypeByTypeParams) (PropertyType, error) {
	row := q.db.QueryRow(ctx, getAllPropertyTypeByType, arg.Type, arg.Limit, arg.Offset)
	var i PropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.IsResidential,
		&i.IsCommercial,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyTypeFactsID,
		&i.Category,
		&i.Status,
		&i.UnitTypes,
		&i.Icon,
	)
	return i, err
}

const getAllPropertyTypesByPropertyId = `-- name: GetAllPropertyTypesByPropertyId :many
SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types
WHERE id = ANY(SELECT unnest(project_properties.property_types_id) FROM project_properties WHERE project_properties.id=$1)
`

func (q *Queries) GetAllPropertyTypesByPropertyId(ctx context.Context, id int64) ([]PropertyType, error) {
	rows, err := q.db.Query(ctx, getAllPropertyTypesByPropertyId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyType
	for rows.Next() {
		var i PropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsResidential,
			&i.IsCommercial,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTypeFactsID,
			&i.Category,
			&i.Status,
			&i.UnitTypes,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertyTypesByids = `-- name: GetAllPropertyTypesByids :many
SELECT  id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetAllPropertyTypesByids(ctx context.Context, dollar_1 []int64) ([]PropertyType, error) {
	rows, err := q.db.Query(ctx, getAllPropertyTypesByids, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyType
	for rows.Next() {
		var i PropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsResidential,
			&i.IsCommercial,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTypeFactsID,
			&i.Category,
			&i.Status,
			&i.UnitTypes,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertypesByPropertyTypesIds = `-- name: GetAllPropertypesByPropertyTypesIds :many

SELECT global_property_type.id, global_property_type."type",global_property_type.icon, COUNT(*) AS count
FROM global_property_type
JOIN unnest($1::bigint[]) AS ids(id) ON global_property_type.id = ids.id
GROUP BY global_property_type.id, global_property_type."type"
`

type GetAllPropertypesByPropertyTypesIdsRow struct {
	ID    int64       `json:"id"`
	Type  string      `json:"type"`
	Icon  pgtype.Text `json:"icon"`
	Count int64       `json:"count"`
}

// SELECT property_types.id,property_types."type", COUNT(*) AS count
// FROM property_types
// JOIN unnest($1::bigint[]) AS ids(id) ON property_types.id = ids.id
// GROUP BY property_types."type";
func (q *Queries) GetAllPropertypesByPropertyTypesIds(ctx context.Context, dollar_1 []int64) ([]GetAllPropertypesByPropertyTypesIdsRow, error) {
	rows, err := q.db.Query(ctx, getAllPropertypesByPropertyTypesIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPropertypesByPropertyTypesIdsRow
	for rows.Next() {
		var i GetAllPropertypesByPropertyTypesIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Icon,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUniqueProperyTypes = `-- name: GetAllUniqueProperyTypes :many
SELECT DISTINCT on (type) id, type, code, is_commercial, icon FROM property_types
where property_types.category = $1
`

type GetAllUniqueProperyTypesRow struct {
	ID           int64       `json:"id"`
	Type         string      `json:"type"`
	Code         string      `json:"code"`
	IsCommercial pgtype.Bool `json:"is_commercial"`
	Icon         pgtype.Text `json:"icon"`
}

func (q *Queries) GetAllUniqueProperyTypes(ctx context.Context, category string) ([]GetAllUniqueProperyTypesRow, error) {
	rows, err := q.db.Query(ctx, getAllUniqueProperyTypes, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUniqueProperyTypesRow
	for rows.Next() {
		var i GetAllUniqueProperyTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsCommercial,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnitTypesByProjectPropertyAndCategory = `-- name: GetAllUnitTypesByProjectPropertyAndCategory :many



WITH x AS(
    SELECT property_types.id, property_types.type, property_types.code, property_types.is_residential, property_types.is_commercial, property_types.created_at, property_types.updated_at, property_types.property_type_facts_id, property_types.category, property_types.status, property_types.unit_types, property_types.icon FROM property_types
 LEFT JOIN project_properties ON property_types.id=ANY(project_properties.property_types_id)WHERE project_properties.id=$1)
 SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types WHERE property_types.type IN (SELECT x.type FROM x)AND property_types.category=LOWER($2) ORDER BY id
`

type GetAllUnitTypesByProjectPropertyAndCategoryParams struct {
	ID    int64  `json:"id"`
	Lower string `json:"lower"`
}

// -- name: GetAllUnitTypesByPropertyType :many
// SELECT property_types.*
// FROM property_types
// WHERE property_types.id = ANY (SELECT unnest(unit_types) FROM property_types WHERE property_types.id = $1);
func (q *Queries) GetAllUnitTypesByProjectPropertyAndCategory(ctx context.Context, arg GetAllUnitTypesByProjectPropertyAndCategoryParams) ([]PropertyType, error) {
	rows, err := q.db.Query(ctx, getAllUnitTypesByProjectPropertyAndCategory, arg.ID, arg.Lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyType
	for rows.Next() {
		var i PropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsResidential,
			&i.IsCommercial,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTypeFactsID,
			&i.Category,
			&i.Status,
			&i.UnitTypes,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnitTypesByProjectPropertyAndProjectCategory = `-- name: GetAllUnitTypesByProjectPropertyAndProjectCategory :many
WITH x AS(
    SELECT property_types.id, property_types.type, property_types.code, property_types.is_residential, property_types.is_commercial, property_types.created_at, property_types.updated_at, property_types.property_type_facts_id, property_types.category, property_types.status, property_types.unit_types, property_types.icon FROM property_types
 LEFT JOIN project_properties ON property_types.id=ANY(project_properties.property_types_id)WHERE project_properties.id=$1)
 SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types WHERE property_types.type IN (SELECT x.type FROM x)AND property_types.category ILIKE 'Project%' ORDER BY id
`

func (q *Queries) GetAllUnitTypesByProjectPropertyAndProjectCategory(ctx context.Context, id int64) ([]PropertyType, error) {
	rows, err := q.db.Query(ctx, getAllUnitTypesByProjectPropertyAndProjectCategory, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyType
	for rows.Next() {
		var i PropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsResidential,
			&i.IsCommercial,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTypeFactsID,
			&i.Category,
			&i.Status,
			&i.UnitTypes,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyType = `-- name: GetPropertyType :one
SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetPropertyType(ctx context.Context, limit int32) (PropertyType, error) {
	row := q.db.QueryRow(ctx, getPropertyType, limit)
	var i PropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.IsResidential,
		&i.IsCommercial,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyTypeFactsID,
		&i.Category,
		&i.Status,
		&i.UnitTypes,
		&i.Icon,
	)
	return i, err
}

const getPropertyTypeByCategory = `-- name: GetPropertyTypeByCategory :many
SELECT id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon FROM property_types 
WHERE category = $1
`

func (q *Queries) GetPropertyTypeByCategory(ctx context.Context, category string) ([]PropertyType, error) {
	rows, err := q.db.Query(ctx, getPropertyTypeByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertyType
	for rows.Next() {
		var i PropertyType
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Code,
			&i.IsResidential,
			&i.IsCommercial,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTypeFactsID,
			&i.Category,
			&i.Status,
			&i.UnitTypes,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyTypesIdCatCode = `-- name: GetPropertyTypesIdCatCode :many
SELECT property_types.id,LOWER(code) AS code,LOWER(category) AS category FROM property_types WHERE LOWER(category) = 'sale' OR LOWER(category) = 'rent' OR LOWER(category) = 'property hub' ORDER BY category
`

type GetPropertyTypesIdCatCodeRow struct {
	ID       int64  `json:"id"`
	Code     string `json:"code"`
	Category string `json:"category"`
}

func (q *Queries) GetPropertyTypesIdCatCode(ctx context.Context) ([]GetPropertyTypesIdCatCodeRow, error) {
	rows, err := q.db.Query(ctx, getPropertyTypesIdCatCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPropertyTypesIdCatCodeRow
	for rows.Next() {
		var i GetPropertyTypesIdCatCodeRow
		if err := rows.Scan(&i.ID, &i.Code, &i.Category); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePropertyType = `-- name: UpdatePropertyType :one
UPDATE property_types
SET  type = $2,
    code = $3,
    is_residential = $4,
    is_commercial = $5,
    created_at = $6,
    updated_at = $7,
    property_type_facts_id = $8,
    category = $9,
    status  = $10,
    unit_types  = $11,
    icon  = $12
Where id = $1
RETURNING id, type, code, is_residential, is_commercial, created_at, updated_at, property_type_facts_id, category, status, unit_types, icon
`

type UpdatePropertyTypeParams struct {
	ID                  int64       `json:"id"`
	Type                string      `json:"type"`
	Code                string      `json:"code"`
	IsResidential       pgtype.Bool `json:"is_residential"`
	IsCommercial        pgtype.Bool `json:"is_commercial"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	PropertyTypeFactsID []int64     `json:"property_type_facts_id"`
	Category            string      `json:"category"`
	Status              int64       `json:"status"`
	UnitTypes           []int64     `json:"unit_types"`
	Icon                pgtype.Text `json:"icon"`
}

func (q *Queries) UpdatePropertyType(ctx context.Context, arg UpdatePropertyTypeParams) (PropertyType, error) {
	row := q.db.QueryRow(ctx, updatePropertyType,
		arg.ID,
		arg.Type,
		arg.Code,
		arg.IsResidential,
		arg.IsCommercial,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.PropertyTypeFactsID,
		arg.Category,
		arg.Status,
		arg.UnitTypes,
		arg.Icon,
	)
	var i PropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.IsResidential,
		&i.IsCommercial,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyTypeFactsID,
		&i.Category,
		&i.Status,
		&i.UnitTypes,
		&i.Icon,
	)
	return i, err
}
