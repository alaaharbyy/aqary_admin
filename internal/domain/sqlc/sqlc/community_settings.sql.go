// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: community_settings.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCommunitySettings = `-- name: CreateCommunitySettings :one
INSERT INTO
    communities (
        community,
        community_ar,
        cities_id,
        created_at,
        updated_at,
        status,
        updated_by
    )
SELECT
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
FROM 
	cities WHERE id= $8::BIGINT and status !=6 RETURNING 1
`

type CreateCommunitySettingsParams struct {
	Community   string      `json:"community"`
	CommunityAr pgtype.Text `json:"community_ar"`
	CitiesID    pgtype.Int8 `json:"cities_id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Status      int64       `json:"status"`
	UpdatedBy   int64       `json:"updated_by"`
	CityID      int64       `json:"city_id"`
}

func (q *Queries) CreateCommunitySettings(ctx context.Context, arg CreateCommunitySettingsParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, createCommunitySettings,
		arg.Community,
		arg.CommunityAr,
		arg.CitiesID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.UpdatedBy,
		arg.CityID,
	)
	var column_1 pgtype.Int8
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteRestoreCommunitySettings = `-- name: DeleteRestoreCommunitySettings :exec
UPDATE communities 
SET 
    status = $4::BIGINT,
    updated_at = $2, 
    updated_by=$3
WHERE 
    id = $1
`

type DeleteRestoreCommunitySettingsParams struct {
	ID        int64     `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
	UpdatedBy int64     `json:"updated_by"`
	Status    int64     `json:"status"`
}

func (q *Queries) DeleteRestoreCommunitySettings(ctx context.Context, arg DeleteRestoreCommunitySettingsParams) error {
	_, err := q.db.Exec(ctx, deleteRestoreCommunitySettings,
		arg.ID,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Status,
	)
	return err
}

const getAllCommunitiesSettings = `-- name: GetAllCommunitiesSettings :many
SELECT
    communities.id AS "community_id",
    communities.community,
    communities.community_ar,
    cities.city,
    cities.city_ar,
    states."state",
    states.state_ar,
    countries.country,
    countries.country_ar
FROM
    communities
    INNER JOIN cities ON cities.id = communities.cities_id
    INNER JOIN states ON states.id = cities.states_id
    INNER JOIN countries ON countries.id = states.countries_id
WHERE 
    ($1::BIGINT = 6 AND communities.status = 6) 
    OR ($1::BIGINT != 6 AND communities.status IN (1, 2))
ORDER BY
    communities.updated_at DESC
LIMIT $3 OFFSET $2
`

type GetAllCommunitiesSettingsParams struct {
	Status int64       `json:"status"`
	Offset pgtype.Int4 `json:"offset"`
	Limit  pgtype.Int4 `json:"limit"`
}

type GetAllCommunitiesSettingsRow struct {
	CommunityID int64       `json:"community_id"`
	Community   string      `json:"community"`
	CommunityAr pgtype.Text `json:"community_ar"`
	City        string      `json:"city"`
	CityAr      pgtype.Text `json:"city_ar"`
	State       string      `json:"state"`
	StateAr     pgtype.Text `json:"state_ar"`
	Country     string      `json:"country"`
	CountryAr   pgtype.Text `json:"country_ar"`
}

func (q *Queries) GetAllCommunitiesSettings(ctx context.Context, arg GetAllCommunitiesSettingsParams) ([]GetAllCommunitiesSettingsRow, error) {
	rows, err := q.db.Query(ctx, getAllCommunitiesSettings, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCommunitiesSettingsRow
	for rows.Next() {
		var i GetAllCommunitiesSettingsRow
		if err := rows.Scan(
			&i.CommunityID,
			&i.Community,
			&i.CommunityAr,
			&i.City,
			&i.CityAr,
			&i.State,
			&i.StateAr,
			&i.Country,
			&i.CountryAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunitySettingsByID = `-- name: GetCommunitySettingsByID :one
SELECT
    communities.id AS "community_id",
    communities.community,
    communities.community_ar,
    cities.id AS "city_id",
    cities.city,
    cities.city_ar,
    states.id AS "state_id",
    states."state",
    states.state_ar,
    countries.id AS "country_id",
    countries.country,
    countries.country_ar
FROM
    communities
    INNER JOIN cities ON cities.id = communities.cities_id
    INNER JOIN states ON states.id = cities.states_id
    INNER JOIN countries ON countries.id = states.countries_id
WHERE
    communities.id = $1
    AND communities.status != 6
`

type GetCommunitySettingsByIDRow struct {
	CommunityID int64       `json:"community_id"`
	Community   string      `json:"community"`
	CommunityAr pgtype.Text `json:"community_ar"`
	CityID      int64       `json:"city_id"`
	City        string      `json:"city"`
	CityAr      pgtype.Text `json:"city_ar"`
	StateID     int64       `json:"state_id"`
	State       string      `json:"state"`
	StateAr     pgtype.Text `json:"state_ar"`
	CountryID   int64       `json:"country_id"`
	Country     string      `json:"country"`
	CountryAr   pgtype.Text `json:"country_ar"`
}

func (q *Queries) GetCommunitySettingsByID(ctx context.Context, id int64) (GetCommunitySettingsByIDRow, error) {
	row := q.db.QueryRow(ctx, getCommunitySettingsByID, id)
	var i GetCommunitySettingsByIDRow
	err := row.Scan(
		&i.CommunityID,
		&i.Community,
		&i.CommunityAr,
		&i.CityID,
		&i.City,
		&i.CityAr,
		&i.StateID,
		&i.State,
		&i.StateAr,
		&i.CountryID,
		&i.Country,
		&i.CountryAr,
	)
	return i, err
}

const getCommunitySettingsForUpdate = `-- name: GetCommunitySettingsForUpdate :one
SELECT id,community,community_ar, cities_id 
FROM 
    communities
WHERE 
    id=$1 AND status!=6
`

type GetCommunitySettingsForUpdateRow struct {
	ID          int64       `json:"id"`
	Community   string      `json:"community"`
	CommunityAr pgtype.Text `json:"community_ar"`
	CitiesID    pgtype.Int8 `json:"cities_id"`
}

func (q *Queries) GetCommunitySettingsForUpdate(ctx context.Context, id int64) (GetCommunitySettingsForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getCommunitySettingsForUpdate, id)
	var i GetCommunitySettingsForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.Community,
		&i.CommunityAr,
		&i.CitiesID,
	)
	return i, err
}

const getNumberOfCommunitiesSettings = `-- name: GetNumberOfCommunitiesSettings :one
SELECT COUNT(*)
FROM
    communities
    INNER JOIN cities ON cities.id = communities.cities_id
    INNER JOIN states ON states.id = cities.states_id
    INNER JOIN countries ON countries.id = states.countries_id
WHERE 
    ($1::BIGINT = 6 AND communities.status = 6) 
    OR ($1::BIGINT != 6 AND communities.status IN (1, 2))
`

func (q *Queries) GetNumberOfCommunitiesSettings(ctx context.Context, status int64) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOfCommunitiesSettings, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateCommunitySettings = `-- name: UpdateCommunitySettings :exec
Update
    communities
SET
    community = $2,
    cities_id = $3,
    updated_at = $4,
    updated_by = $5,
    community_ar = $6

WHERE
    communities.id = $1
    AND communities.status != 6
    AND (
        
        $3 = cities_id
        OR EXISTS (SELECT 1 FROM cities WHERE id = $3 AND status != 6)
        
    )
`

type UpdateCommunitySettingsParams struct {
	ID          int64       `json:"id"`
	Community   string      `json:"community"`
	CitiesID    pgtype.Int8 `json:"cities_id"`
	UpdatedAt   time.Time   `json:"updated_at"`
	UpdatedBy   int64       `json:"updated_by"`
	CommunityAr pgtype.Text `json:"community_ar"`
}

func (q *Queries) UpdateCommunitySettings(ctx context.Context, arg UpdateCommunitySettingsParams) error {
	_, err := q.db.Exec(ctx, updateCommunitySettings,
		arg.ID,
		arg.Community,
		arg.CitiesID,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.CommunityAr,
	)
	return err
}
