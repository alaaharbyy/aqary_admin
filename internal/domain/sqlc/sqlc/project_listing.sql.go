// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_listing.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProjectReview = `-- name: CreateProjectReview :one
INSERT INTO project_reviews (
    ref_no,
	is_project,
	projects_id,
	project_clean,
	project_location,
	project_facilities,
	project_securities,
	description,
	reviewer,
	review_date,
	proof_images,
	title
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, ref_no, is_project, projects_id, project_clean, project_location, project_facilities, project_securities, description, reviewer, review_date, proof_images, title
`

type CreateProjectReviewParams struct {
	RefNo             string      `json:"ref_no"`
	IsProject         pgtype.Bool `json:"is_project"`
	ProjectsID        int64       `json:"projects_id"`
	ProjectClean      float64     `json:"project_clean"`
	ProjectLocation   float64     `json:"project_location"`
	ProjectFacilities float64     `json:"project_facilities"`
	ProjectSecurities float64     `json:"project_securities"`
	Description       string      `json:"description"`
	Reviewer          int64       `json:"reviewer"`
	ReviewDate        time.Time   `json:"review_date"`
	ProofImages       []string    `json:"proof_images"`
	Title             pgtype.Text `json:"title"`
}

func (q *Queries) CreateProjectReview(ctx context.Context, arg CreateProjectReviewParams) (ProjectReview, error) {
	row := q.db.QueryRow(ctx, createProjectReview,
		arg.RefNo,
		arg.IsProject,
		arg.ProjectsID,
		arg.ProjectClean,
		arg.ProjectLocation,
		arg.ProjectFacilities,
		arg.ProjectSecurities,
		arg.Description,
		arg.Reviewer,
		arg.ReviewDate,
		arg.ProofImages,
		arg.Title,
	)
	var i ProjectReview
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.IsProject,
		&i.ProjectsID,
		&i.ProjectClean,
		&i.ProjectLocation,
		&i.ProjectFacilities,
		&i.ProjectSecurities,
		&i.Description,
		&i.Reviewer,
		&i.ReviewDate,
		&i.ProofImages,
		&i.Title,
	)
	return i, err
}

const filterCountProjects = `-- name: FilterCountProjects :one
WITH property_types_agg AS (
    SELECT 
        property.entity_id,
        array_agg(gpt.type ORDER BY gpt.type) AS property_types  -- Assuming ` + "`" + `type` + "`" + ` is the column in ` + "`" + `global_property_type` + "`" + `
    FROM 
        property
    LEFT JOIN 
        global_property_type gpt ON gpt.id = property.property_type_id  -- Join to get the global_property_type
    WHERE 
        property.entity_type_id = 1  -- Assuming 1 indicates a project-related entity
    GROUP BY 
        property.entity_id
),
project_properties_agg AS (
    SELECT
        properties_with_types.entity_id, 
        array_agg(property_types ORDER BY property_types) AS property_types_agg
    FROM (
        SELECT
            property.entity_id,
            global_property_type."type" AS property_types
        FROM
            property
        LEFT JOIN
            global_property_type ON global_property_type.id = property.property_type_id
    ) AS properties_with_types
    GROUP BY
        properties_with_types.entity_id
),
project_media_agg AS (
    SELECT
        projects_id,
        array_agg(DISTINCT media_type ORDER BY media_type) AS media
    FROM 
        project_media
    GROUP BY 
        projects_id
)
SELECT 
   count(projects.*)
FROM
    projects  
LEFT JOIN
    addresses ON projects.addresses_id = addresses.id
LEFT JOIN
    cities ON addresses.cities_id = cities.id
LEFT JOIN
    communities ON addresses.communities_id = communities.id
LEFT JOIN
    sub_communities ON addresses.sub_communities_id = sub_communities.id
LEFT JOIN 
    property_types_agg ON projects.id = property_types_agg.entity_id
LEFT JOIN 
    project_properties_agg ON projects.id = project_properties_agg.entity_id
LEFT JOIN 
    project_media_agg ON projects.id = project_media_agg.projects_id
WHERE
    addresses.countries_id = $1::bigint
	--         -- city
	AND cities.city ILIKE $2::varchar
    -- AND CASE WHEN @developer_companies_id::bigint IS NULL THEN
	-- 	TRUE
	-- WHEN @developer_companies_id::bigint = 0 THEN
	-- 	TRUE
	-- ELSE
	-- 	projects.developer_companies_id = @developer_companies_id::bigint
	-- END
	--project Type
	-- -- date posted
	-- AND (CASE
    --     WHEN @date_filter::bigint = 1 THEN DATE(projects.created_at) = CURRENT_DATE
    --     WHEN @date_filter::bigint = 2 THEN projects.created_at >= CURRENT_DATE - INTERVAL '7 DAY' 
    --     WHEN @date_filter::bigint = 3 THEN projects.created_at >= CURRENT_DATE - INTERVAL '1 month'
	-- 	WHEN @date_filter::bigint = 4 THEN projects.created_at >= CURRENT_DATE - INTERVAL '6 month'
    --     -- Add more cases for additional filters
    --     ELSE TRUE
    -- END)
	--      	-- completion status
	AND CASE WHEN $3::bigint IS NULL THEN
		TRUE
	WHEN $3::bigint = 0 THEN
		TRUE
	ELSE
    CAST(projects.facts ->> 'completion_status' AS bigint) = $3::bigint
	END
	 -- ownership
	   AND (
    ARRAY_LENGTH($4::bigint[], 1) IS NULL
    OR CAST(projects.facts ->> 'ownership' AS bigint) = ANY ($4::bigint[])
   )
		--  	     --  service charges
	 AND (
    CASE
        WHEN $5::bigint IS NULL THEN
            TRUE
        WHEN $5::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) <= $5::bigint
    END
    -- max service charges
    AND CASE
        WHEN $6::bigint IS NULL THEN
            TRUE
        WHEN $6::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) >= $6::bigint
    END
)

	--  	     --  furnishing
    AND(ARRAY_LENGTH($7::bigint [],
			1) IS NULL
		OR CAST(projects.facts ->> 'furnished' AS bigint) = ANY ($7::bigint[])) -- properties_facts.furnished = ANY (@furnished::bigint []))
	--  amenities
	AND(
		CASE WHEN ARRAY_LENGTH($8::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.amenities_id && $8::bigint []
		END)
    --  facilities
	AND(
		CASE WHEN ARRAY_LENGTH($9::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.facilities_id && $9::bigint []
		END)
	--  unit views
    AND (
    CASE
        WHEN ARRAY_LENGTH($10::bigint[], 1) IS NULL THEN
            TRUE
        ELSE
            -- Extracting 'view' from JSONB and converting it to an array of bigint for comparison
            (SELECT array_agg(CAST(value AS bigint))
             FROM jsonb_array_elements_text(projects.facts->'views')) && $10::bigint[]
    END
)
	-- media
	AND($11::bigint = 0
		OR(array_length(media,
				$12) IS NOT NULL)
		OR(array_length(media,
				$13) IS NOT NULL)
		OR(array_length(media,
				$14) IS NOT NULL)
		OR(array_length(media,
				$15) IS NOT NULL))

	---------------------- from here normal project section --------------------------
	AND(ARRAY_LENGTH($16::bigint [], 1) IS NULL
	OR projects.project_rank = ANY ($16::bigint []))
	AND(communities.community ILIKE $17::varchar OR communities.community IS NULL)
	AND(sub_communities.sub_community ILIKE $18::varchar OR sub_communities.sub_community IS NULL)
	AND($19::bool IS null OR projects.is_verified = $19::bool)
    AND (
        projects.project_name ILIKE $20::varchar
        OR cities.city ILIKE $20::varchar
        OR communities.community ILIKE $20::varchar
        OR sub_communities.sub_community ILIKE $20::varchar
    )
    AND projects.status != 5 AND projects.status != 6
`

type FilterCountProjectsParams struct {
	CountryID         int64       `json:"country_id"`
	City              string      `json:"city"`
	CompletionStatus  int64       `json:"completion_status"`
	Ownership         []int64     `json:"ownership"`
	MinServiceCharges int64       `json:"min_service_charges"`
	MaxServiceCharges int64       `json:"max_service_charges"`
	Furnished         []int64     `json:"furnished"`
	Amenities         []int64     `json:"amenities"`
	Facilities        []int64     `json:"facilities"`
	Views             []int64     `json:"views"`
	Media             int64       `json:"media"`
	ImageUrl          int32       `json:"image_url"`
	Image360Url       int32       `json:"image360_url"`
	VideoUrl          int32       `json:"video_url"`
	PanaromaUrl       int32       `json:"panaroma_url"`
	ProjectRank       []int64     `json:"project_rank"`
	Community         string      `json:"community"`
	SubCommunity      string      `json:"sub_community"`
	IsVerified        pgtype.Bool `json:"is_verified"`
	Search            string      `json:"search"`
}

// LEFT JOIN
//
//	    companies ON projects.developer_companies_id = companies.id
//		AND CASE
//	    WHEN @property_type::text[] IS NULL THEN TRUE
//	    ELSE EXISTS (
//	        SELECT 1
//	        FROM unnest(project_properties_agg.property_types_agg) AS pt
//	        WHERE EXISTS (
//	            SELECT 1
//	            FROM unnest(@property_type::text[]) AS search_terms
//	            WHERE pt ILIKE '%' || search_terms || '%'
//	        )
//	    )
//
// END
func (q *Queries) FilterCountProjects(ctx context.Context, arg FilterCountProjectsParams) (int64, error) {
	row := q.db.QueryRow(ctx, filterCountProjects,
		arg.CountryID,
		arg.City,
		arg.CompletionStatus,
		arg.Ownership,
		arg.MinServiceCharges,
		arg.MaxServiceCharges,
		arg.Furnished,
		arg.Amenities,
		arg.Facilities,
		arg.Views,
		arg.Media,
		arg.ImageUrl,
		arg.Image360Url,
		arg.VideoUrl,
		arg.PanaromaUrl,
		arg.ProjectRank,
		arg.Community,
		arg.SubCommunity,
		arg.IsVerified,
		arg.Search,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterCountProjectsCommunity = `-- name: FilterCountProjectsCommunity :one

WITH property_types_agg AS (
    SELECT 
        property.entity_id,
        array_agg(gpt.id ORDER BY gpt.id) AS property_types  -- Assuming ` + "`" + `type` + "`" + ` is the column in ` + "`" + `global_property_type` + "`" + `
    FROM 
        property
    LEFT JOIN 
        global_property_type gpt ON gpt.id = property.property_type_id  -- Join to get the global_property_type
    WHERE 
        property.entity_type_id = 1  -- Assuming 1 indicates a project-related entity
    GROUP BY 
        property.entity_id
),
project_properties_agg AS (
    SELECT
        properties_with_types.entity_id, 
        array_agg(property_types ORDER BY property_types) AS property_types_agg
    FROM (
        SELECT
            property.entity_id,
            global_property_type."type" AS property_types
        FROM
            property
        LEFT JOIN
            global_property_type ON global_property_type.id = property.property_type_id
    ) AS properties_with_types
    GROUP BY
        properties_with_types.entity_id
),
project_media_agg AS (
    SELECT
        projects_id,
        array_agg(DISTINCT media_type ORDER BY media_type) AS media
    FROM 
        project_media
    GROUP BY 
        projects_id
)
SELECT 
   count(projects.*)
    -- property_types_agg.property_types,
    -- properties_facts.starting_price 
FROM
    projects  
INNER JOIN
    addresses ON projects.addresses_id = addresses.id
LEFT JOIN
    cities ON addresses.cities_id = cities.id
LEFT JOIN
    companies ON projects.developer_companies_id = companies.id
LEFT JOIN
    communities ON addresses.communities_id = communities.id
LEFT JOIN
    sub_communities ON addresses.sub_communities_id = sub_communities.id
LEFT JOIN
    properties_facts ON projects.id = properties_facts.project_id and properties_facts.is_project_fact = true
LEFT JOIN 
    property_types_agg ON projects.id = property_types_agg.entity_id
LEFT JOIN 
    project_properties_agg ON projects.id = project_properties_agg.entity_id
LEFT JOIN 
    project_media_agg ON projects.id = project_media_agg.projects_id
WHERE
    addresses.cities_id = $1 AND
	addresses.communities_id = $2::bigint
    AND (CASE WHEN $3::bigint IS NULL THEN
		TRUE
	WHEN $3::bigint = 0 THEN
		TRUE
	ELSE
		projects.developer_companies_id = $3::bigint
	END)
	--project Type
	--      	-- completion status
	AND CASE WHEN $4::bigint IS NULL THEN
		TRUE
	WHEN $4::bigint = 0 THEN
		TRUE
	ELSE
    CAST(projects.facts ->> 'completion_status' AS bigint) = $4::bigint
	END
	 -- ownership
	   AND (
    ARRAY_LENGTH($5::bigint[], 1) IS NULL
    OR CAST(projects.facts ->> 'ownership' AS bigint) = ANY ($5::bigint[])
   )
		--  	     --  service charges
	 AND (
    CASE
        WHEN $6::bigint IS NULL THEN
            TRUE
        WHEN $6::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) <= $6::bigint
    END
    -- max service charges
    AND CASE
        WHEN $7::bigint IS NULL THEN
            TRUE
        WHEN $7::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) >= $7::bigint
    END
)

	--  	     --  furnishing
    AND(ARRAY_LENGTH($8::bigint [],
			1) IS NULL
		OR CAST(projects.facts ->> 'furnished' AS bigint) = ANY ($8::bigint[])) -- properties_facts.furnished = ANY (@furnished::bigint []))
	--  amenities
	AND(
		CASE WHEN ARRAY_LENGTH($9::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.amenities_id && $9::bigint []
		END)
    --  facilities
	AND(
		CASE WHEN ARRAY_LENGTH($10::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.facilities_id && $10::bigint []
		END)
	--  unit views
    AND (
    CASE
        WHEN ARRAY_LENGTH($11::bigint[], 1) IS NULL THEN
            TRUE
        ELSE
            -- Extracting 'view' from JSONB and converting it to an array of bigint for comparison
            (SELECT array_agg(CAST(value AS bigint))
             FROM jsonb_array_elements_text(projects.facts->'views')) && $11::bigint[]
    END
)
	-- media
	AND($12::bigint = 0
		OR(array_length(media,
				$13) IS NOT NULL)
		OR(array_length(media,
				$14) IS NOT NULL)
		OR(array_length(media,
				$15) IS NOT NULL)
		OR(array_length(media,
				$16) IS NOT NULL))

	---------------------- from here normal project section --------------------------
	AND(ARRAY_LENGTH($17::bigint [], 1) IS NULL
	OR projects.project_rank = ANY ($17::bigint []))
	AND(communities.community ILIKE $18::varchar OR communities.community IS NULL)
	AND(sub_communities.sub_community ILIKE $19::varchar OR sub_communities.sub_community IS NULL)
	AND($20::bool IS null OR projects.is_verified = $20::bool)
    AND (
        projects.project_name ILIKE $21::varchar
        OR cities.city ILIKE $21::varchar
        OR communities.community ILIKE $21::varchar
        OR sub_communities.sub_community ILIKE $21::varchar
    )
    AND projects.status != 5 AND projects.status != 6
`

type FilterCountProjectsCommunityParams struct {
	CitiesID             pgtype.Int8 `json:"cities_id"`
	CommunitiesID        int64       `json:"communities_id"`
	DeveloperCompaniesID int64       `json:"developer_companies_id"`
	CompletionStatus     int64       `json:"completion_status"`
	Ownership            []int64     `json:"ownership"`
	MinServiceCharges    int64       `json:"min_service_charges"`
	MaxServiceCharges    int64       `json:"max_service_charges"`
	Furnished            []int64     `json:"furnished"`
	Amenities            []int64     `json:"amenities"`
	Facilities           []int64     `json:"facilities"`
	Views                []int64     `json:"views"`
	Media                int64       `json:"media"`
	ImageUrl             int32       `json:"image_url"`
	Image360Url          int32       `json:"image360_url"`
	VideoUrl             int32       `json:"video_url"`
	PanaromaUrl          int32       `json:"panaroma_url"`
	ProjectRank          []int64     `json:"project_rank"`
	Community            string      `json:"community"`
	SubCommunity         string      `json:"sub_community"`
	IsVerified           pgtype.Bool `json:"is_verified"`
	Search               string      `json:"search"`
}

// AND companies.status != 6;
//
//		AND CASE
//	    WHEN @property_type::text[] IS NULL THEN TRUE
//	    ELSE EXISTS (
//	        SELECT 1
//	        FROM unnest(project_properties_agg.property_types_agg) AS pt
//	        WHERE EXISTS (
//	            SELECT 1
//	            FROM unnest(@property_type::text[]) AS search_terms
//	            WHERE pt ILIKE '%' || search_terms || '%'
//	        )
//	    )
//
// END
func (q *Queries) FilterCountProjectsCommunity(ctx context.Context, arg FilterCountProjectsCommunityParams) (int64, error) {
	row := q.db.QueryRow(ctx, filterCountProjectsCommunity,
		arg.CitiesID,
		arg.CommunitiesID,
		arg.DeveloperCompaniesID,
		arg.CompletionStatus,
		arg.Ownership,
		arg.MinServiceCharges,
		arg.MaxServiceCharges,
		arg.Furnished,
		arg.Amenities,
		arg.Facilities,
		arg.Views,
		arg.Media,
		arg.ImageUrl,
		arg.Image360Url,
		arg.VideoUrl,
		arg.PanaromaUrl,
		arg.ProjectRank,
		arg.Community,
		arg.SubCommunity,
		arg.IsVerified,
		arg.Search,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterCountProjectsState = `-- name: FilterCountProjectsState :one
WITH property_types_agg AS (
    SELECT 
        property.entity_id,
        array_agg(gpt.id ORDER BY gpt.id) AS property_types  -- Assuming ` + "`" + `type` + "`" + ` is the column in ` + "`" + `global_property_type` + "`" + `
    FROM 
        property
    LEFT JOIN 
        global_property_type gpt ON gpt.id = property.property_type_id  -- Join to get the global_property_type
    WHERE 
        property.entity_type_id = 1  -- Assuming 1 indicates a project-related entity
    GROUP BY 
        property.entity_id
),
project_properties_agg AS (
    SELECT
        properties_with_types.entity_id, 
        array_agg(property_types ORDER BY property_types) AS property_types_agg
    FROM (
        SELECT
            property.entity_id,
            global_property_type."type" AS property_types
        FROM
            property
        LEFT JOIN
            global_property_type ON global_property_type.id = property.property_type_id
    ) AS properties_with_types
    GROUP BY
        properties_with_types.entity_id
),
project_media_agg AS (
    SELECT
        projects_id,
        array_agg(DISTINCT media_type ORDER BY media_type) AS media
    FROM 
        project_media
    GROUP BY 
        projects_id
)
SELECT 
   count(projects.*)
FROM
    projects  
LEFT JOIN
    addresses ON projects.addresses_id = addresses.id
LEFT JOIN
    cities ON addresses.cities_id = cities.id
LEFT JOIN
    companies ON projects.developer_companies_id = companies.id
LEFT JOIN
    communities ON addresses.communities_id = communities.id
LEFT JOIN
    sub_communities ON addresses.sub_communities_id = sub_communities.id
LEFT JOIN 
    property_types_agg ON projects.id = property_types_agg.entity_id
LEFT JOIN 
    project_properties_agg ON projects.id = project_properties_agg.entity_id
LEFT JOIN 
    project_media_agg ON projects.id = project_media_agg.projects_id
WHERE
     addresses.countries_id = $1::bigint  AND
     cities.id = $2::bigint
     AND (CASE WHEN $3::bigint IS NULL THEN
		TRUE
	WHEN $3::bigint = 0 THEN
		TRUE
	ELSE
		projects.developer_companies_id = $3::bigint
	END)
	--      	-- completion status
	AND CASE WHEN $4::bigint IS NULL THEN
		TRUE
	WHEN $4::bigint = 0 THEN
		TRUE
	ELSE
    CAST(projects.facts ->> 'completion_status' AS bigint) = $4::bigint
	END
	 -- ownership
	   AND (
    ARRAY_LENGTH($5::bigint[], 1) IS NULL
    OR CAST(projects.facts ->> 'ownership' AS bigint) = ANY ($5::bigint[])
   )
		--  	     --  service charges
	 AND (
    CASE
        WHEN $6::bigint IS NULL THEN
            TRUE
        WHEN $6::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) <= $6::bigint
    END
    -- max service charges
    AND CASE
        WHEN $7::bigint IS NULL THEN
            TRUE
        WHEN $7::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) >= $7::bigint
    END
)

	--  	     --  furnishing
    AND(ARRAY_LENGTH($8::bigint [],
			1) IS NULL
		OR CAST(projects.facts ->> 'furnished' AS bigint) = ANY ($8::bigint[])) -- properties_facts.furnished = ANY (@furnished::bigint []))
	--  amenities
	AND(
		CASE WHEN ARRAY_LENGTH($9::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.amenities_id && $9::bigint []
		END)
    --  facilities
	AND(
		CASE WHEN ARRAY_LENGTH($10::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.facilities_id && $10::bigint []
		END)
	--  unit views
    AND (
    CASE
        WHEN ARRAY_LENGTH($11::bigint[], 1) IS NULL THEN
            TRUE
        ELSE
            -- Extracting 'view' from JSONB and converting it to an array of bigint for comparison
            (SELECT array_agg(CAST(value AS bigint))
             FROM jsonb_array_elements_text(projects.facts->'views')) && $11::bigint[]
    END
)
	-- media
	AND($12::bigint = 0
		OR(array_length(media,
				$13) IS NOT NULL)
		OR(array_length(media,
				$14) IS NOT NULL)
		OR(array_length(media,
				$15) IS NOT NULL)
		OR(array_length(media,
				$16) IS NOT NULL))

	---------------------- from here normal project section --------------------------
	AND(ARRAY_LENGTH($17::bigint [], 1) IS NULL
	OR projects.project_rank = ANY ($17::bigint []))
	AND(communities.community ILIKE $18::varchar OR communities.community IS NULL)
	AND(sub_communities.sub_community ILIKE $19::varchar OR sub_communities.sub_community IS NULL)
	AND($20::bool IS null OR projects.is_verified = $20::bool)
    AND (
        projects.project_name ILIKE $21::varchar
        OR cities.city ILIKE $21::varchar
        OR communities.community ILIKE $21::varchar
        OR sub_communities.sub_community ILIKE $21::varchar
    )
    AND projects.status != 5 AND projects.status != 6
`

type FilterCountProjectsStateParams struct {
	CountryID            int64       `json:"country_id"`
	CitiesID             int64       `json:"cities_id"`
	DeveloperCompaniesID int64       `json:"developer_companies_id"`
	CompletionStatus     int64       `json:"completion_status"`
	Ownership            []int64     `json:"ownership"`
	MinServiceCharges    int64       `json:"min_service_charges"`
	MaxServiceCharges    int64       `json:"max_service_charges"`
	Furnished            []int64     `json:"furnished"`
	Amenities            []int64     `json:"amenities"`
	Facilities           []int64     `json:"facilities"`
	Views                []int64     `json:"views"`
	Media                int64       `json:"media"`
	ImageUrl             int32       `json:"image_url"`
	Image360Url          int32       `json:"image360_url"`
	VideoUrl             int32       `json:"video_url"`
	PanaromaUrl          int32       `json:"panaroma_url"`
	ProjectRank          []int64     `json:"project_rank"`
	Community            string      `json:"community"`
	SubCommunity         string      `json:"sub_community"`
	IsVerified           pgtype.Bool `json:"is_verified"`
	Search               string      `json:"search"`
}

// project Type
//
//		AND CASE
//	    WHEN @property_type::text[] IS NULL THEN TRUE
//	    ELSE EXISTS (
//	        SELECT 1
//	        FROM unnest(project_properties_agg.property_types_agg) AS pt
//	        WHERE EXISTS (
//	            SELECT 1
//	            FROM unnest(@property_type::text[]) AS search_terms
//	            WHERE pt ILIKE '%' || search_terms || '%'
//	        )
//	    )
//
// END
func (q *Queries) FilterCountProjectsState(ctx context.Context, arg FilterCountProjectsStateParams) (int64, error) {
	row := q.db.QueryRow(ctx, filterCountProjectsState,
		arg.CountryID,
		arg.CitiesID,
		arg.DeveloperCompaniesID,
		arg.CompletionStatus,
		arg.Ownership,
		arg.MinServiceCharges,
		arg.MaxServiceCharges,
		arg.Furnished,
		arg.Amenities,
		arg.Facilities,
		arg.Views,
		arg.Media,
		arg.ImageUrl,
		arg.Image360Url,
		arg.VideoUrl,
		arg.PanaromaUrl,
		arg.ProjectRank,
		arg.Community,
		arg.SubCommunity,
		arg.IsVerified,
		arg.Search,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterCountProjectsSubCommunity = `-- name: FilterCountProjectsSubCommunity :one


WITH property_types_agg AS (
    SELECT 
        property.entity_id,
        array_agg(gpt.id ORDER BY gpt.id) AS property_types  -- Assuming ` + "`" + `type` + "`" + ` is the column in ` + "`" + `global_property_type` + "`" + `
    FROM 
        property
    LEFT JOIN 
        global_property_type gpt ON gpt.id = property.property_type_id  -- Join to get the global_property_type
    WHERE 
        property.entity_type_id = 1  -- Assuming 1 indicates a project-related entity
    GROUP BY 
        property.entity_id
),
project_properties_agg AS (
    SELECT
        properties_with_types.entity_id, 
        array_agg(property_types ORDER BY property_types) AS property_types_agg
    FROM (
        SELECT
            property.entity_id,
            global_property_type."type" AS property_types
        FROM
            property
        LEFT JOIN
            global_property_type ON global_property_type.id = property.property_type_id
    ) AS properties_with_types
    GROUP BY
        properties_with_types.entity_id
),
project_media_agg AS (
    SELECT
        projects_id,
        array_agg(DISTINCT media_type ORDER BY media_type) AS media
    FROM 
        project_media
    GROUP BY 
        projects_id
)
SELECT 
   count(projects.*)
    -- property_types_agg.property_types,
    -- properties_facts.starting_price 
FROM
    projects  
LEFT JOIN
    addresses ON projects.addresses_id = addresses.id
LEFT JOIN
    companies ON projects.developer_companies_id = companies.id
LEFT JOIN
    cities ON addresses.cities_id = cities.id
LEFT JOIN
    communities ON addresses.communities_id = communities.id
LEFT JOIN
    sub_communities ON addresses.sub_communities_id = sub_communities.id
LEFT JOIN 
    property_types_agg ON projects.id = property_types_agg.entity_id
LEFT JOIN 
    project_properties_agg ON projects.id = project_properties_agg.entity_id
LEFT JOIN 
    project_media_agg ON projects.id = project_media_agg.projects_id
WHERE
    addresses.sub_communities_id = $1::bigint
    AND (CASE WHEN $2::bigint IS NULL THEN
		TRUE
	WHEN $2::bigint = 0 THEN
		TRUE
	ELSE
		projects.developer_companies_id = $2::bigint
	END)
	--project Type
      	-- completion status
	AND CASE WHEN $3::bigint IS NULL THEN
		TRUE
	WHEN $3::bigint = 0 THEN
		TRUE
	ELSE
    CAST(projects.facts ->> 'completion_status' AS bigint) = $3::bigint
	END
	 -- ownership
	   AND (
    ARRAY_LENGTH($4::bigint[], 1) IS NULL
    OR CAST(projects.facts ->> 'ownership' AS bigint) = ANY ($4::bigint[])
   )
		--  	     --  service charges
    AND (
    CASE
        WHEN $5::bigint IS NULL THEN
            TRUE
        WHEN $5::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) <= $5::bigint
    END
    -- max service charges
    AND CASE
        WHEN $6::bigint IS NULL THEN
            TRUE
        WHEN $6::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) >= $6::bigint
    END
)

	--  	     --  furnishing
    AND(ARRAY_LENGTH($7::bigint [],
			1) IS NULL
		OR CAST(projects.facts ->> 'ownership' AS bigint) = ANY ($4::bigint[])) -- properties_facts.furnished = ANY (@furnished::bigint []))
	--  amenities
	AND(
		CASE WHEN ARRAY_LENGTH($8::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.amenities_id && $8::bigint []
		END)
    --  facilities
	AND(
		CASE WHEN ARRAY_LENGTH($9::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.facilities_id && $9::bigint []
		END)
	--  unit views
    AND (
    CASE
        WHEN ARRAY_LENGTH($10::bigint[], 1) IS NULL THEN
            TRUE
        ELSE
            -- Extracting 'view' from JSONB and converting it to an array of bigint for comparison
            (SELECT array_agg(CAST(value AS bigint))
             FROM jsonb_array_elements_text(projects.facts->'view')) && $10::bigint[]
    END
)
	-- media
	AND($11::bigint = 0
		OR(array_length(media,
				$12) IS NOT NULL)
		OR(array_length(media,
				$13) IS NOT NULL)
		OR(array_length(media,
				$14) IS NOT NULL)
		OR(array_length(media,
				$15) IS NOT NULL))

	---------------------- from here normal project section --------------------------
	AND(ARRAY_LENGTH($16::bigint [], 1) IS NULL
	OR projects.project_rank = ANY ($16::bigint []))
	AND(communities.community ILIKE $17::varchar OR communities.community IS NULL)
	AND(sub_communities.sub_community ILIKE $18::varchar OR sub_communities.sub_community IS NULL)
	AND($19::bool IS null OR projects.is_verified = $19::bool)
    AND (
        projects.project_name ILIKE $20::varchar
        OR cities.city ILIKE $20::varchar
        OR communities.community ILIKE $20::varchar
        OR sub_communities.sub_community ILIKE $20::varchar
    )
    AND projects.status != 5 AND projects.status != 6
`

type FilterCountProjectsSubCommunityParams struct {
	SubCommunitiesID     int64       `json:"sub_communities_id"`
	DeveloperCompaniesID int64       `json:"developer_companies_id"`
	CompletionStatus     int64       `json:"completion_status"`
	Ownership            []int64     `json:"ownership"`
	MinServiceCharges    int64       `json:"min_service_charges"`
	MaxServiceCharges    int64       `json:"max_service_charges"`
	Furnished            []int64     `json:"furnished"`
	Amenities            []int64     `json:"amenities"`
	Facilities           []int64     `json:"facilities"`
	Views                []int64     `json:"views"`
	Media                int64       `json:"media"`
	ImageUrl             int32       `json:"image_url"`
	Image360Url          int32       `json:"image360_url"`
	VideoUrl             int32       `json:"video_url"`
	PanaromaUrl          int32       `json:"panaroma_url"`
	ProjectRank          []int64     `json:"project_rank"`
	Community            string      `json:"community"`
	SubCommunity         string      `json:"sub_community"`
	IsVerified           pgtype.Bool `json:"is_verified"`
	Search               string      `json:"search"`
}

// AND companies.status != 6;
// LEFT JOIN
//
//	    properties_facts ON projects.id = properties_facts.project_id and properties_facts.is_project_fact = true
//		AND CASE
//	    WHEN @property_type::text[] IS NULL THEN TRUE
//	    ELSE EXISTS (
//	        SELECT 1
//	        FROM unnest(project_properties_agg.property_types_agg) AS pt
//	        WHERE EXISTS (
//	            SELECT 1
//	            FROM unnest(@property_type::text[]) AS search_terms
//	            WHERE pt ILIKE '%' || search_terms || '%'
//	        )
//	    )
//
// END
func (q *Queries) FilterCountProjectsSubCommunity(ctx context.Context, arg FilterCountProjectsSubCommunityParams) (int64, error) {
	row := q.db.QueryRow(ctx, filterCountProjectsSubCommunity,
		arg.SubCommunitiesID,
		arg.DeveloperCompaniesID,
		arg.CompletionStatus,
		arg.Ownership,
		arg.MinServiceCharges,
		arg.MaxServiceCharges,
		arg.Furnished,
		arg.Amenities,
		arg.Facilities,
		arg.Views,
		arg.Media,
		arg.ImageUrl,
		arg.Image360Url,
		arg.VideoUrl,
		arg.PanaromaUrl,
		arg.ProjectRank,
		arg.Community,
		arg.SubCommunity,
		arg.IsVerified,
		arg.Search,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterProjects = `-- name: FilterProjects :many
WITH property_types_agg AS (
    SELECT 
        property.entity_id,
        array_agg(gpt.id ORDER BY gpt.id) AS property_types  -- Assuming ` + "`" + `type` + "`" + ` is the column in ` + "`" + `global_property_type` + "`" + `
    FROM 
        property
    LEFT JOIN 
        global_property_type gpt ON gpt.id = property.property_type_id  -- Join to get the global_property_type
    WHERE 
        property.entity_type_id = 1  -- Assuming 1 indicates a project-related entity
    GROUP BY 
        property.entity_id
),
project_properties_agg AS (
    SELECT
        properties_with_types.entity_id, 
        array_agg(property_types ORDER BY property_types) AS property_types_agg
    FROM (
        SELECT
            property.entity_id,
            global_property_type."type" AS property_types
        FROM
            property
        LEFT JOIN
            global_property_type ON global_property_type.id = property.property_type_id
    ) AS properties_with_types
    GROUP BY
        properties_with_types.entity_id
),
 project_media_agg AS (
    SELECT
        projects_id,
        array_agg(DISTINCT media_type ORDER BY media_type) AS media
    FROM 
        project_media
    GROUP BY 
        projects_id
),
project_reviews AS (
    SELECT projects_id, 
    ROUND(
        (CAST(AVG(project_clean) AS numeric) + 
         CAST(AVG(project_location) AS numeric) + 
         CAST(AVG(project_facilities) AS numeric) + 
         CAST(AVG(project_securities) AS numeric)) / 4.0, 
        2
    ) AS average_rating
    FROM project_reviews
    GROUP BY projects_id
)
SELECT 
    projects.id, projects.project_name, projects.ref_number, projects.no_of_views, projects.is_verified, projects.project_rank, projects.addresses_id, projects.status, projects.developer_companies_id, projects.developer_company_branches_id, projects.countries_id, projects.created_at, projects.updated_at, projects.is_multiphase, projects.live_status, projects.project_no, projects.license_no, projects.users_id, projects.description, projects.description_arabic, projects.rating, projects.polygon_coords, projects.facts, projects.exclusive, projects.start_date, projects.end_date, projects.slug, projects.deleted_at, projects.bank_name, projects.registration_date, projects.escrow_number, projects.refreshed_at,
	property_types_agg.property_types,
    -- properties_facts.starting_price,
	project_properties_agg.property_types_agg,
	project_media_agg.media,
    COALESCE(NULLIF((projects.facts->>'starting_price')::bigint, NULL), 0) AS starting_price,
	COALESCE(project_reviews.average_rating, 0.0)::float AS average_rating
FROM
    projects  
LEFT JOIN
    addresses ON projects.addresses_id = addresses.id
LEFT JOIN
    cities ON addresses.cities_id = cities.id
LEFT JOIN
    communities ON addresses.communities_id = communities.id
LEFT JOIN
    sub_communities ON addresses.sub_communities_id = sub_communities.id
LEFT JOIN 
    property_types_agg ON projects.id = property_types_agg.entity_id
LEFT JOIN 
    project_properties_agg ON projects.id = project_properties_agg.entity_id
LEFT JOIN 
    project_media_agg ON projects.id = project_media_agg.projects_id
LEFT JOIN 
    project_reviews ON project_reviews.projects_id = projects.id
WHERE

    addresses.countries_id = $3::bigint
    
	--         -- city
	AND cities.city ILIKE $4::varchar
    -- AND (CASE WHEN @developer_companies_id::bigint IS NULL THEN
	-- 	TRUE
	-- WHEN @developer_companies_id::bigint = 0 THEN
	-- 	TRUE
	-- ELSE
	-- 	projects.developer_companies_id = @developer_companies_id::bigint
	-- END)
	--project Type
	-- AND CASE
    --     -- If @property_type is NULL, we skip the filter and return all results
    --     WHEN @property_type::text[] IS NULL THEN TRUE
    --     -- Otherwise, check if any element in project_properties_agg.property_types_agg matches @property_type
    --     ELSE EXISTS (
    --         SELECT 1
    --         FROM unnest(project_properties_agg.property_types_agg) AS pt
    --         WHERE EXISTS (
    --             SELECT 1
    --             FROM unnest(@property_type::text[]) AS search_terms
    --             WHERE pt ILIKE '%' || search_terms || '%'
    --         )
    --     )
    -- END
	-- -- date posted
	-- AND (CASE
    --     WHEN @date_filter::bigint = 1 THEN DATE(projects.created_at) = CURRENT_DATE
    --     WHEN @date_filter::bigint = 2 THEN projects.created_at >= CURRENT_DATE - INTERVAL '7 DAY' 
    --     WHEN @date_filter::bigint = 3 THEN projects.created_at >= CURRENT_DATE - INTERVAL '1 month'
	-- 	WHEN @date_filter::bigint = 4 THEN projects.created_at >= CURRENT_DATE - INTERVAL '6 month'
    --     -- Add more cases for additional filters
    --     ELSE TRUE
    -- END)
	--      	-- completion status
	AND CASE WHEN $5::bigint IS NULL THEN
		TRUE
	WHEN $5::bigint = 0 THEN
		TRUE
	ELSE
    CAST(projects.facts ->> 'completion_status' AS bigint) = $5::bigint
	END
	 -- ownership
	   AND (
    ARRAY_LENGTH($6::bigint[], 1) IS NULL
    OR CAST(projects.facts ->> 'ownership' AS bigint) = ANY ($6::bigint[])
   )
		--  	     --  service charges
	 AND (
    CASE
        WHEN $7::bigint IS NULL THEN
            TRUE
        WHEN $7::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) >= $7::bigint
    END
    -- max service charges
    AND CASE
        WHEN $8::bigint IS NULL THEN
            TRUE
        WHEN $8::bigint = 0 THEN
            TRUE
        ELSE
            CAST(projects.facts ->> 'service_charge' AS bigint) <= $8::bigint
    END
)

	--  	     --  furnishing
    AND(ARRAY_LENGTH($9::bigint [],
			1) IS NULL
		OR CAST(projects.facts ->> 'furnished' AS bigint) = ANY ($9::bigint[])) -- properties_facts.furnished = ANY (@furnished::bigint []))
	--  amenities
	AND(
		CASE WHEN ARRAY_LENGTH($10::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.amenities_id && $10::bigint []
		END)
    --  facilities
	AND(
		CASE WHEN ARRAY_LENGTH($11::bigint [],
			1) IS NULL THEN
			TRUE
		ELSE
			projects.facilities_id && $11::bigint []
		END)
	--  unit views
    AND (
    CASE
        WHEN ARRAY_LENGTH($12::bigint[], 1) IS NULL THEN
            TRUE
        ELSE
            -- Extracting 'view' from JSONB and converting it to an array of bigint for comparison
            (SELECT array_agg(CAST(value AS bigint))
             FROM jsonb_array_elements_text(projects.facts->'views')) && $12::bigint[]
    END
)
	-- media
	AND($13::bigint = 0
		OR(array_length(media,
				$14) IS NOT NULL)
		OR(array_length(media,
				$15) IS NOT NULL)
		OR(array_length(media,
				$16) IS NOT NULL)
		OR(array_length(media,
				$17) IS NOT NULL))

	---------------------- from here normal project section --------------------------
	AND(ARRAY_LENGTH($18::bigint [], 1) IS NULL
	OR projects.project_rank = ANY ($18::bigint []))
	AND(communities.community ILIKE $19::varchar OR communities.community IS NULL)
	AND(sub_communities.sub_community ILIKE $20::varchar OR sub_communities.sub_community IS NULL)
	AND($21::bool IS null OR projects.is_verified = $21::bool)
    AND (
        projects.project_name ILIKE $22::varchar
        OR cities.city ILIKE $22::varchar
        OR communities.community ILIKE $22::varchar
        OR sub_communities.sub_community ILIKE $22::varchar
    )
    AND projects.status != 5 AND projects.status != 6 --AND companies.status != 6
	ORDER BY
   CASE 
        WHEN $23::bigint = 3 THEN COALESCE(NULLIF((projects.facts->>'starting_price')::bigint, NULL), 0)
    END DESC,
    CASE 
        WHEN $23::bigint = 4 THEN COALESCE(NULLIF((projects.facts->>'starting_price')::bigint, NULL), 0)
    END ASC,
CASE 
    WHEN $23::bigint = 2 THEN projects.created_at
    END DESC,
CASE 
    WHEN $23::bigint = 1 THEN COALESCE(average_rating, 0.0) 
    END DESC,
	project_rank DESC,
	is_verified DESC,
	RANDOM()
   LIMIT $1 OFFSET $2
`

type FilterProjectsParams struct {
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
	CountryID         int64       `json:"country_id"`
	City              string      `json:"city"`
	CompletionStatus  int64       `json:"completion_status"`
	Ownership         []int64     `json:"ownership"`
	MinServiceCharges int64       `json:"min_service_charges"`
	MaxServiceCharges int64       `json:"max_service_charges"`
	Furnished         []int64     `json:"furnished"`
	Amenities         []int64     `json:"amenities"`
	Facilities        []int64     `json:"facilities"`
	Views             []int64     `json:"views"`
	Media             int64       `json:"media"`
	ImageUrl          int32       `json:"image_url"`
	Image360Url       int32       `json:"image360_url"`
	VideoUrl          int32       `json:"video_url"`
	PanaromaUrl       int32       `json:"panaroma_url"`
	ProjectRank       []int64     `json:"project_rank"`
	Community         string      `json:"community"`
	SubCommunity      string      `json:"sub_community"`
	IsVerified        pgtype.Bool `json:"is_verified"`
	Search            string      `json:"search"`
	Rank              int64       `json:"rank"`
}

type FilterProjectsRow struct {
	ID                         int64              `json:"id"`
	ProjectName                string             `json:"project_name"`
	RefNumber                  string             `json:"ref_number"`
	NoOfViews                  int64              `json:"no_of_views"`
	IsVerified                 pgtype.Bool        `json:"is_verified"`
	ProjectRank                int64              `json:"project_rank"`
	AddressesID                int64              `json:"addresses_id"`
	Status                     int64              `json:"status"`
	DeveloperCompaniesID       int64              `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8        `json:"developer_company_branches_id"`
	CountriesID                int64              `json:"countries_id"`
	CreatedAt                  time.Time          `json:"created_at"`
	UpdatedAt                  time.Time          `json:"updated_at"`
	IsMultiphase               pgtype.Bool        `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool        `json:"live_status"`
	ProjectNo                  string             `json:"project_no"`
	LicenseNo                  string             `json:"license_no"`
	UsersID                    int64              `json:"users_id"`
	Description                string             `json:"description"`
	DescriptionArabic          pgtype.Text        `json:"description_arabic"`
	Rating                     float64            `json:"rating"`
	PolygonCoords              []byte             `json:"polygon_coords"`
	Facts                      []byte             `json:"facts"`
	Exclusive                  bool               `json:"exclusive"`
	StartDate                  pgtype.Date        `json:"start_date"`
	EndDate                    pgtype.Date        `json:"end_date"`
	Slug                       string             `json:"slug"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
	BankName                   pgtype.Text        `json:"bank_name"`
	RegistrationDate           pgtype.Date        `json:"registration_date"`
	EscrowNumber               pgtype.Text        `json:"escrow_number"`
	RefreshedAt                pgtype.Timestamptz `json:"refreshed_at"`
	PropertyTypes              interface{}        `json:"property_types"`
	PropertyTypesAgg           interface{}        `json:"property_types_agg"`
	Media                      interface{}        `json:"media"`
	StartingPrice              interface{}        `json:"starting_price"`
	AverageRating              float64            `json:"average_rating"`
}

// LEFT JOIN
//
//	    companies ON projects.developer_companies_id = companies.id
//		AND CASE
//	    WHEN @property_type::text[] IS NULL THEN TRUE
//	    ELSE EXISTS (
//	        SELECT 1
//	        FROM unnest(project_properties_agg.property_types_agg) AS pt
//	        WHERE EXISTS (
//	            SELECT 1
//	            FROM unnest(@property_type::text[]) AS search_terms
//	            WHERE pt ILIKE '%' || search_terms || '%'
//	        )
//	    )
//
// END
func (q *Queries) FilterProjects(ctx context.Context, arg FilterProjectsParams) ([]FilterProjectsRow, error) {
	rows, err := q.db.Query(ctx, filterProjects,
		arg.Limit,
		arg.Offset,
		arg.CountryID,
		arg.City,
		arg.CompletionStatus,
		arg.Ownership,
		arg.MinServiceCharges,
		arg.MaxServiceCharges,
		arg.Furnished,
		arg.Amenities,
		arg.Facilities,
		arg.Views,
		arg.Media,
		arg.ImageUrl,
		arg.Image360Url,
		arg.VideoUrl,
		arg.PanaromaUrl,
		arg.ProjectRank,
		arg.Community,
		arg.SubCommunity,
		arg.IsVerified,
		arg.Search,
		arg.Rank,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterProjectsRow
	for rows.Next() {
		var i FilterProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
			&i.PropertyTypes,
			&i.PropertyTypesAgg,
			&i.Media,
			&i.StartingPrice,
			&i.AverageRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPhasesByProjectGraph = `-- name: GetAllPhasesByProjectGraph :many
SELECT
	phases.id, phases.phase_name, phases.addresses_id, phases.created_at, phases.updated_at, phases.status, phases.live_status, phases.ref_no, phases.projects_id, phases.rating, phases.description, phases.description_ar, phases.polygon_coords, phases.facts, phases.exclusive, phases.start_date, phases.end_date, phases.bank_name, phases.registration_date, phases.escrow_number
FROM
	phases
   LEFT JOIN projects ON projects.id = phases.projects_id
WHERE
	 projects.id = $3 AND (phases.status != 5 AND phases.status != 6)
ORDER BY
	phases.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllPhasesByProjectGraphParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	ID     int64 `json:"id"`
}

func (q *Queries) GetAllPhasesByProjectGraph(ctx context.Context, arg GetAllPhasesByProjectGraphParams) ([]Phase, error) {
	rows, err := q.db.Query(ctx, getAllPhasesByProjectGraph, arg.Limit, arg.Offset, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Phase
	for rows.Next() {
		var i Phase
		if err := rows.Scan(
			&i.ID,
			&i.PhaseName,
			&i.AddressesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.LiveStatus,
			&i.RefNo,
			&i.ProjectsID,
			&i.Rating,
			&i.Description,
			&i.DescriptionAr,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPhasesMediaByMainMediaSectionAndId = `-- name: GetAllPhasesMediaByMainMediaSectionAndId :one
with x As (
 SELECT id, file_urls, gallery_type, media_type, entity_id, entity_type_id, created_at, updated_at, gallery_type_ar FROM global_media
 WHERE gallery_type = $2 AND entity_id = $1 AND entity_type_id = 2
) SELECT id, file_urls, gallery_type, media_type, entity_id, entity_type_id, created_at, updated_at, gallery_type_ar From x
`

type GetAllPhasesMediaByMainMediaSectionAndIdParams struct {
	EntityID    int64  `json:"entity_id"`
	GalleryType string `json:"gallery_type"`
}

type GetAllPhasesMediaByMainMediaSectionAndIdRow struct {
	ID            int64       `json:"id"`
	FileUrls      []string    `json:"file_urls"`
	GalleryType   string      `json:"gallery_type"`
	MediaType     int64       `json:"media_type"`
	EntityID      int64       `json:"entity_id"`
	EntityTypeID  int64       `json:"entity_type_id"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	GalleryTypeAr pgtype.Text `json:"gallery_type_ar"`
}

func (q *Queries) GetAllPhasesMediaByMainMediaSectionAndId(ctx context.Context, arg GetAllPhasesMediaByMainMediaSectionAndIdParams) (GetAllPhasesMediaByMainMediaSectionAndIdRow, error) {
	row := q.db.QueryRow(ctx, getAllPhasesMediaByMainMediaSectionAndId, arg.EntityID, arg.GalleryType)
	var i GetAllPhasesMediaByMainMediaSectionAndIdRow
	err := row.Scan(
		&i.ID,
		&i.FileUrls,
		&i.GalleryType,
		&i.MediaType,
		&i.EntityID,
		&i.EntityTypeID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GalleryTypeAr,
	)
	return i, err
}

const getAllPhasesMediaByPhaseId = `-- name: GetAllPhasesMediaByPhaseId :many

SELECT id, file_urls, gallery_type, media_type, entity_id, entity_type_id, created_at, updated_at, gallery_type_ar FROM global_media WHERE entity_id = $1 AND entity_type_id = 2 ORDER BY id DESC
`

// -- name: GetProjectAmenitiesForPhase :one
// select amenities from projects
// left join phases on phases.projects_id = projects.id
// where projects.id = $1;
func (q *Queries) GetAllPhasesMediaByPhaseId(ctx context.Context, entityID int64) ([]GlobalMedium, error) {
	rows, err := q.db.Query(ctx, getAllPhasesMediaByPhaseId, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GlobalMedium
	for rows.Next() {
		var i GlobalMedium
		if err := rows.Scan(
			&i.ID,
			&i.FileUrls,
			&i.GalleryType,
			&i.MediaType,
			&i.EntityID,
			&i.EntityTypeID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GalleryTypeAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPhasesMediaGalleryTypeById = `-- name: GetAllPhasesMediaGalleryTypeById :many
With x As (
 SELECT  gallery_type,gallery_type_ar FROM global_media
 WHERE entity_id = $1 AND entity_type_id = 2
) SELECT gallery_type, gallery_type_ar From x
`

type GetAllPhasesMediaGalleryTypeByIdRow struct {
	GalleryType   string      `json:"gallery_type"`
	GalleryTypeAr pgtype.Text `json:"gallery_type_ar"`
}

func (q *Queries) GetAllPhasesMediaGalleryTypeById(ctx context.Context, entityID int64) ([]GetAllPhasesMediaGalleryTypeByIdRow, error) {
	rows, err := q.db.Query(ctx, getAllPhasesMediaGalleryTypeById, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPhasesMediaGalleryTypeByIdRow
	for rows.Next() {
		var i GetAllPhasesMediaGalleryTypeByIdRow
		if err := rows.Scan(&i.GalleryType, &i.GalleryTypeAr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectMediaByGalleryTypeAndId = `-- name: GetAllProjectMediaByGalleryTypeAndId :one
with x As (
 SELECT id, file_urls, gallery_type, media_type, entity_id, entity_type_id, created_at, updated_at, gallery_type_ar FROM global_media
 WHERE entity_id = $1 AND gallery_type = $2 AND entity_type_id = 1
) SELECT id, file_urls, gallery_type, media_type, entity_id, entity_type_id, created_at, updated_at, gallery_type_ar From x
`

type GetAllProjectMediaByGalleryTypeAndIdParams struct {
	EntityID    int64  `json:"entity_id"`
	GalleryType string `json:"gallery_type"`
}

type GetAllProjectMediaByGalleryTypeAndIdRow struct {
	ID            int64       `json:"id"`
	FileUrls      []string    `json:"file_urls"`
	GalleryType   string      `json:"gallery_type"`
	MediaType     int64       `json:"media_type"`
	EntityID      int64       `json:"entity_id"`
	EntityTypeID  int64       `json:"entity_type_id"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	GalleryTypeAr pgtype.Text `json:"gallery_type_ar"`
}

func (q *Queries) GetAllProjectMediaByGalleryTypeAndId(ctx context.Context, arg GetAllProjectMediaByGalleryTypeAndIdParams) (GetAllProjectMediaByGalleryTypeAndIdRow, error) {
	row := q.db.QueryRow(ctx, getAllProjectMediaByGalleryTypeAndId, arg.EntityID, arg.GalleryType)
	var i GetAllProjectMediaByGalleryTypeAndIdRow
	err := row.Scan(
		&i.ID,
		&i.FileUrls,
		&i.GalleryType,
		&i.MediaType,
		&i.EntityID,
		&i.EntityTypeID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GalleryTypeAr,
	)
	return i, err
}

const getAllProjectMediaByProjectIdAndGalleryType = `-- name: GetAllProjectMediaByProjectIdAndGalleryType :many
With x As (
 SELECT  gallery_type,gallery_type_ar FROM global_media
 WHERE entity_id = $1 AND entity_type_id = 1
) SELECT gallery_type, gallery_type_ar From x
`

type GetAllProjectMediaByProjectIdAndGalleryTypeRow struct {
	GalleryType   string      `json:"gallery_type"`
	GalleryTypeAr pgtype.Text `json:"gallery_type_ar"`
}

func (q *Queries) GetAllProjectMediaByProjectIdAndGalleryType(ctx context.Context, entityID int64) ([]GetAllProjectMediaByProjectIdAndGalleryTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectMediaByProjectIdAndGalleryType, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectMediaByProjectIdAndGalleryTypeRow
	for rows.Next() {
		var i GetAllProjectMediaByProjectIdAndGalleryTypeRow
		if err := rows.Scan(&i.GalleryType, &i.GalleryTypeAr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertiesByProjectIdAndPhaseId = `-- name: GetAllProjectPropertiesByProjectIdAndPhaseId :many
SELECT id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date from property
Where property.entity_id = $1 AND property.entity_type_id = 2 LIMIT $2 OFFSET $3
`

type GetAllProjectPropertiesByProjectIdAndPhaseIdParams struct {
	EntityID int64 `json:"entity_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

func (q *Queries) GetAllProjectPropertiesByProjectIdAndPhaseId(ctx context.Context, arg GetAllProjectPropertiesByProjectIdAndPhaseIdParams) ([]Property, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertiesByProjectIdAndPhaseId, arg.EntityID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description,
			&i.DescriptionArabic,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy,
			&i.FromXml,
			&i.Facts,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertiesByProjectIdAndPropertyTypesId = `-- name: GetAllProjectPropertiesByProjectIdAndPropertyTypesId :many
    -- AND properties_facts.starting_price = min_starting_prices.min_starting_price;



SELECT 
    pp.id, 
    pp.property_name,
    COALESCE(units.unit_count, 0) AS total_unit_count
FROM property pp
LEFT JOIN (
    SELECT units.entity_id, units.entity_type_id, units.is_project_unit, COUNT(*) AS unit_count
    FROM units
    WHERE units.entity_type_id = 3
    GROUP BY units.entity_id, units.entity_type_id, units.is_project_unit
) units ON pp.id = units.entity_id AND units.is_project_unit = true
WHERE pp.entity_id = $1 
  AND pp.entity_type_id = $2
  AND pp.property_type_id = $3::bigint
`

type GetAllProjectPropertiesByProjectIdAndPropertyTypesIdParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
	Column3      int64 `json:"column_3"`
}

type GetAllProjectPropertiesByProjectIdAndPropertyTypesIdRow struct {
	ID             int64  `json:"id"`
	PropertyName   string `json:"property_name"`
	TotalUnitCount int64  `json:"total_unit_count"`
}

// AND companies.status != 6;
func (q *Queries) GetAllProjectPropertiesByProjectIdAndPropertyTypesId(ctx context.Context, arg GetAllProjectPropertiesByProjectIdAndPropertyTypesIdParams) ([]GetAllProjectPropertiesByProjectIdAndPropertyTypesIdRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertiesByProjectIdAndPropertyTypesId, arg.EntityID, arg.EntityTypeID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPropertiesByProjectIdAndPropertyTypesIdRow
	for rows.Next() {
		var i GetAllProjectPropertiesByProjectIdAndPropertyTypesIdRow
		if err := rows.Scan(&i.ID, &i.PropertyName, &i.TotalUnitCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseId = `-- name: GetAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseId :many
SELECT pp.id, 
       pp.property_name,
       COALESCE(units.unit_count, 0) AS total_unit_count
FROM property pp
LEFT JOIN (
    SELECT units.entity_id, units.entity_type_id, units.is_project_unit, COUNT(*) AS unit_count
    FROM units
    GROUP BY units.entity_id, units.entity_type_id, units.is_project_unit
) units ON pp.id = units.entity_id AND units.is_project_unit = true
WHERE pp.entity_id = $1
AND pp.entity_type_id = $2
AND pp.property_type_id = $3::bigint
`

type GetAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseIdParams struct {
	EntityID       int64 `json:"entity_id"`
	EntityTypeID   int64 `json:"entity_type_id"`
	PropertyTypeID int64 `json:"property_type_id"`
}

type GetAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseIdRow struct {
	ID             int64  `json:"id"`
	PropertyName   string `json:"property_name"`
	TotalUnitCount int64  `json:"total_unit_count"`
}

func (q *Queries) GetAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseId(ctx context.Context, arg GetAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseIdParams) ([]GetAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseIdRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseId, arg.EntityID, arg.EntityTypeID, arg.PropertyTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseIdRow
	for rows.Next() {
		var i GetAllProjectPropertiesByProjectIdAndPropertyTypesIdAnsPhaseIdRow
		if err := rows.Scan(&i.ID, &i.PropertyName, &i.TotalUnitCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertiesTypesByProjectsIds = `-- name: GetAllPropertiesTypesByProjectsIds :one
SELECT
    array_agg(property_type_id)::bigint[] AS LIST
FROM
    property
WHERE
    property.entity_id = $1
    AND property.entity_type_id = $2
`

type GetAllPropertiesTypesByProjectsIdsParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
}

func (q *Queries) GetAllPropertiesTypesByProjectsIds(ctx context.Context, arg GetAllPropertiesTypesByProjectsIdsParams) ([]int64, error) {
	row := q.db.QueryRow(ctx, getAllPropertiesTypesByProjectsIds, arg.EntityID, arg.EntityTypeID)
	var list []int64
	err := row.Scan(&list)
	return list, err
}

const getAllPropertiesTypesByProjectsIdsAndPhaseId = `-- name: GetAllPropertiesTypesByProjectsIdsAndPhaseId :one
SELECT
    array_agg(property_type_id)::bigint[] AS LIST
FROM
    property
WHERE
    property.entity_id = $1 
    AND property.entity_type_id = 2
`

func (q *Queries) GetAllPropertiesTypesByProjectsIdsAndPhaseId(ctx context.Context, entityID int64) ([]int64, error) {
	row := q.db.QueryRow(ctx, getAllPropertiesTypesByProjectsIdsAndPhaseId, entityID)
	var list []int64
	err := row.Scan(&list)
	return list, err
}

const getAllPropertyMediaByGalleryTypeAndId = `-- name: GetAllPropertyMediaByGalleryTypeAndId :one
with x As (
SELECT id, file_urls, gallery_type, media_type, entity_id, entity_type_id, created_at, updated_at, gallery_type_ar FROM global_media
WHERE gallery_type = $1 AND entity_id = $2 AND media_type = $3 AND entity_type_id = 3
) SELECT id, file_urls, gallery_type, media_type, entity_id, entity_type_id, created_at, updated_at, gallery_type_ar From x
`

type GetAllPropertyMediaByGalleryTypeAndIdParams struct {
	GalleryType string `json:"gallery_type"`
	EntityID    int64  `json:"entity_id"`
	MediaType   int64  `json:"media_type"`
}

type GetAllPropertyMediaByGalleryTypeAndIdRow struct {
	ID            int64       `json:"id"`
	FileUrls      []string    `json:"file_urls"`
	GalleryType   string      `json:"gallery_type"`
	MediaType     int64       `json:"media_type"`
	EntityID      int64       `json:"entity_id"`
	EntityTypeID  int64       `json:"entity_type_id"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	GalleryTypeAr pgtype.Text `json:"gallery_type_ar"`
}

func (q *Queries) GetAllPropertyMediaByGalleryTypeAndId(ctx context.Context, arg GetAllPropertyMediaByGalleryTypeAndIdParams) (GetAllPropertyMediaByGalleryTypeAndIdRow, error) {
	row := q.db.QueryRow(ctx, getAllPropertyMediaByGalleryTypeAndId, arg.GalleryType, arg.EntityID, arg.MediaType)
	var i GetAllPropertyMediaByGalleryTypeAndIdRow
	err := row.Scan(
		&i.ID,
		&i.FileUrls,
		&i.GalleryType,
		&i.MediaType,
		&i.EntityID,
		&i.EntityTypeID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GalleryTypeAr,
	)
	return i, err
}

const getAllPropertyMediaByPropertyIdAndGalleryType = `-- name: GetAllPropertyMediaByPropertyIdAndGalleryType :many

SELECT  gallery_type,gallery_type_ar,media_type FROM global_media
WHERE entity_id = $1 AND entity_type_id = 3
`

type GetAllPropertyMediaByPropertyIdAndGalleryTypeRow struct {
	GalleryType   string      `json:"gallery_type"`
	GalleryTypeAr pgtype.Text `json:"gallery_type_ar"`
	MediaType     int64       `json:"media_type"`
}

// -- name: GetPaymentPlansForProjectPropertyByPropertyId :many
// select * from payment_plans_packages
// where payment_plans_packages.properties_id = $1 AND payment_plans_packages.property = 1;
func (q *Queries) GetAllPropertyMediaByPropertyIdAndGalleryType(ctx context.Context, entityID int64) ([]GetAllPropertyMediaByPropertyIdAndGalleryTypeRow, error) {
	rows, err := q.db.Query(ctx, getAllPropertyMediaByPropertyIdAndGalleryType, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPropertyMediaByPropertyIdAndGalleryTypeRow
	for rows.Next() {
		var i GetAllPropertyMediaByPropertyIdAndGalleryTypeRow
		if err := rows.Scan(&i.GalleryType, &i.GalleryTypeAr, &i.MediaType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPropertyTypeFactsNew = `-- name: GetAllPropertyTypeFactsNew :many
WITH unnested AS (
  SELECT 
    t.id AS table_id, 
    (
      jsonb_each(t.property_type_facts :: jsonb)
    ).key AS key, 
    (
      jsonb_each(t.property_type_facts :: jsonb)
    ).value AS value 
  FROM 
    global_property_type t
), 
filtered as(
  SELECT 
    u.table_id, 
    u.key, 
    j ->> 'id' AS fact_id, 
    j ->> 'icon' AS icon, 
    j ->> 'slug' AS slug, 
    j ->> 'title' as title 
  FROM 
    unnested u, 
    jsonb_array_elements(u.value) AS j
) 
SELECT 
  DISTINCT(f.slug::varchar), 
  f.fact_id::varchar, 
  f.title::varchar, 
  f.icon::varchar 
FROM 
  filtered f
`

type GetAllPropertyTypeFactsNewRow struct {
	FSlug   string `json:"f_slug"`
	FFactID string `json:"f_fact_id"`
	FTitle  string `json:"f_title"`
	FIcon   string `json:"f_icon"`
}

func (q *Queries) GetAllPropertyTypeFactsNew(ctx context.Context) ([]GetAllPropertyTypeFactsNewRow, error) {
	rows, err := q.db.Query(ctx, getAllPropertyTypeFactsNew)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPropertyTypeFactsNewRow
	for rows.Next() {
		var i GetAllPropertyTypeFactsNewRow
		if err := rows.Scan(
			&i.FSlug,
			&i.FFactID,
			&i.FTitle,
			&i.FIcon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnitMediaByGalleryTypeAndId = `-- name: GetAllUnitMediaByGalleryTypeAndId :one
with x As (
 SELECT id, file_urls, gallery_type, media_type, units_id, created_at, updated_at FROM unit_media
 WHERE gallery_type = $2 AND units_id = $1
) SELECT id, file_urls, gallery_type, media_type, units_id, created_at, updated_at From x
`

type GetAllUnitMediaByGalleryTypeAndIdParams struct {
	UnitsID     int64  `json:"units_id"`
	GalleryType string `json:"gallery_type"`
}

type GetAllUnitMediaByGalleryTypeAndIdRow struct {
	ID          int64     `json:"id"`
	FileUrls    []string  `json:"file_urls"`
	GalleryType string    `json:"gallery_type"`
	MediaType   int64     `json:"media_type"`
	UnitsID     int64     `json:"units_id"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) GetAllUnitMediaByGalleryTypeAndId(ctx context.Context, arg GetAllUnitMediaByGalleryTypeAndIdParams) (GetAllUnitMediaByGalleryTypeAndIdRow, error) {
	row := q.db.QueryRow(ctx, getAllUnitMediaByGalleryTypeAndId, arg.UnitsID, arg.GalleryType)
	var i GetAllUnitMediaByGalleryTypeAndIdRow
	err := row.Scan(
		&i.ID,
		&i.FileUrls,
		&i.GalleryType,
		&i.MediaType,
		&i.UnitsID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllUnitMediaByUnitIdAndGalleryType = `-- name: GetAllUnitMediaByUnitIdAndGalleryType :many
With x As (
 SELECT  gallery_type FROM unit_media
 WHERE units_id = $1
) SELECT gallery_type From x
`

func (q *Queries) GetAllUnitMediaByUnitIdAndGalleryType(ctx context.Context, unitsID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllUnitMediaByUnitIdAndGalleryType, unitsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var gallery_type string
		if err := rows.Scan(&gallery_type); err != nil {
			return nil, err
		}
		items = append(items, gallery_type)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyLicenseByCompanyId = `-- name: GetCompanyLicenseByCompanyId :many



select license.id, license.license_file_url, license.license_no, license.license_issue_date, license.license_registration_date, license.license_expiry_date, license.license_type_id, license.state_id, license.entity_type_id, license.entity_id, license.metadata, license_type.name from license
LEFT JOIN license_type on license.license_type_id = license_type.id
where  entity_id = $1 AND entity_type_id = 6
`

type GetCompanyLicenseByCompanyIdRow struct {
	ID                      int64              `json:"id"`
	LicenseFileUrl          pgtype.Text        `json:"license_file_url"`
	LicenseNo               string             `json:"license_no"`
	LicenseIssueDate        pgtype.Timestamptz `json:"license_issue_date"`
	LicenseRegistrationDate pgtype.Timestamptz `json:"license_registration_date"`
	LicenseExpiryDate       pgtype.Timestamptz `json:"license_expiry_date"`
	LicenseTypeID           int64              `json:"license_type_id"`
	StateID                 int64              `json:"state_id"`
	EntityTypeID            int64              `json:"entity_type_id"`
	EntityID                int64              `json:"entity_id"`
	Metadata                []byte             `json:"metadata"`
	Name                    pgtype.Text        `json:"name"`
}

// -- name: GetProjectFacilitiesForSinglePhase :one
// select facilities_id from projects
// where projects.id = $1;
// -- name: GetProjectFacilitiesForMultiplePhase :one
// select phases.facilities from phases
// where phases.id = $1;
// -- name: GetOpenHouseAppointmentByEmail :one
// select * from appointment
// inner join users on users.id = client_id
// where  users.email = $1 and appointment.openhouse_id = $2;
func (q *Queries) GetCompanyLicenseByCompanyId(ctx context.Context, entityID int64) ([]GetCompanyLicenseByCompanyIdRow, error) {
	rows, err := q.db.Query(ctx, getCompanyLicenseByCompanyId, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyLicenseByCompanyIdRow
	for rows.Next() {
		var i GetCompanyLicenseByCompanyIdRow
		if err := rows.Scan(
			&i.ID,
			&i.LicenseFileUrl,
			&i.LicenseNo,
			&i.LicenseIssueDate,
			&i.LicenseRegistrationDate,
			&i.LicenseExpiryDate,
			&i.LicenseTypeID,
			&i.StateID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Metadata,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectMediaByIdAndMediaType = `-- name: GetProjectMediaByIdAndMediaType :many
SELECT id, file_urls, gallery_type, media_type, projects_id, phases_id, project_properties_id, created_at, updated_at FROM project_media WHERE projects_id = $1 AND media_type = $2
`

type GetProjectMediaByIdAndMediaTypeParams struct {
	ProjectsID pgtype.Int8 `json:"projects_id"`
	MediaType  int64       `json:"media_type"`
}

func (q *Queries) GetProjectMediaByIdAndMediaType(ctx context.Context, arg GetProjectMediaByIdAndMediaTypeParams) ([]ProjectMedium, error) {
	rows, err := q.db.Query(ctx, getProjectMediaByIdAndMediaType, arg.ProjectsID, arg.MediaType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectMedium
	for rows.Next() {
		var i ProjectMedium
		if err := rows.Scan(
			&i.ID,
			&i.FileUrls,
			&i.GalleryType,
			&i.MediaType,
			&i.ProjectsID,
			&i.PhasesID,
			&i.ProjectPropertiesID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectPropertiesByProjectIdGraph = `-- name: GetProjectPropertiesByProjectIdGraph :many
select id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date from property
where property.entity_id = $1 AND property.entity_type_id = 1
`

func (q *Queries) GetProjectPropertiesByProjectIdGraph(ctx context.Context, entityID int64) ([]Property, error) {
	rows, err := q.db.Query(ctx, getProjectPropertiesByProjectIdGraph, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description,
			&i.DescriptionArabic,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy,
			&i.FromXml,
			&i.Facts,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectPropertiesBySameArea = `-- name: GetProjectPropertiesBySameArea :many
select property.id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, property.status, is_show_owner_info, property_name, property.description, description_arabic, owner_users_id, user_id, property.updated_by, from_xml, facts, notes, property.created_at, property.updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date, addresses.id, countries_id, addresses.states_id, addresses.cities_id, addresses.communities_id, sub_communities_id, locations_id, addresses.created_at, addresses.updated_at, property_map_location_id, full_address, full_address_ar, cities.id, city, cities.states_id, cities.created_at, cities.updated_at, cities.lat, cities.lng, cities.status, cities.deleted_at, cities.updated_by, city_ar, cover_image, cities.description, communities.id, community, communities.cities_id, communities.created_at, communities.updated_at, communities.lat, communities.lng, communities.status, communities.deleted_at, communities.updated_by, community_ar, sub_communities.id, sub_community, sub_communities.communities_id, sub_communities.created_at, sub_communities.updated_at, sub_communities.lng, sub_communities.lat, sub_communities.status, sub_communities.deleted_at, sub_communities.updated_by, sub_community_ar from property
LEFT JOIN
    addresses ON property.addresses_id = addresses.id
LEFT JOIN
    cities ON addresses.cities_id = cities.id
INNER JOIN
    communities ON addresses.communities_id = communities.id
LEFT JOIN
    sub_communities ON addresses.sub_communities_id = sub_communities.id
where property.id != $1 and addresses.communities_id = $2 and  status != 5 and status != 6
LIMIT 10 OFFSET 0
`

type GetProjectPropertiesBySameAreaParams struct {
	ID            int64       `json:"id"`
	CommunitiesID pgtype.Int8 `json:"communities_id"`
}

type GetProjectPropertiesBySameAreaRow struct {
	ID                    int64              `json:"id"`
	CompanyID             pgtype.Int8        `json:"company_id"`
	PropertyTypeID        int64              `json:"property_type_id"`
	UnitTypeID            []int64            `json:"unit_type_id"`
	PropertyTitle         string             `json:"property_title"`
	PropertyTitleArabic   pgtype.Text        `json:"property_title_arabic"`
	IsVerified            pgtype.Bool        `json:"is_verified"`
	AddressesID           int64              `json:"addresses_id"`
	EntityTypeID          int64              `json:"entity_type_id"`
	EntityID              int64              `json:"entity_id"`
	Status                int64              `json:"status"`
	IsShowOwnerInfo       pgtype.Bool        `json:"is_show_owner_info"`
	PropertyName          string             `json:"property_name"`
	Description           string             `json:"description"`
	DescriptionArabic     pgtype.Text        `json:"description_arabic"`
	OwnerUsersID          pgtype.Int8        `json:"owner_users_id"`
	UserID                int64              `json:"user_id"`
	UpdatedBy             int64              `json:"updated_by"`
	FromXml               pgtype.Bool        `json:"from_xml"`
	Facts                 []byte             `json:"facts"`
	Notes                 pgtype.Text        `json:"notes"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
	NotesAr               pgtype.Text        `json:"notes_ar"`
	IsPublicNote          bool               `json:"is_public_note"`
	IsProjectProperty     bool               `json:"is_project_property"`
	Exclusive             bool               `json:"exclusive"`
	StartDate             pgtype.Date        `json:"start_date"`
	EndDate               pgtype.Date        `json:"end_date"`
	ID_2                  pgtype.Int8        `json:"id_2"`
	CountriesID           pgtype.Int8        `json:"countries_id"`
	StatesID              pgtype.Int8        `json:"states_id"`
	CitiesID              pgtype.Int8        `json:"cities_id"`
	CommunitiesID         pgtype.Int8        `json:"communities_id"`
	SubCommunitiesID      pgtype.Int8        `json:"sub_communities_id"`
	LocationsID           pgtype.Int8        `json:"locations_id"`
	CreatedAt_2           pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2           pgtype.Timestamptz `json:"updated_at_2"`
	PropertyMapLocationID pgtype.Int8        `json:"property_map_location_id"`
	FullAddress           pgtype.Text        `json:"full_address"`
	FullAddressAr         pgtype.Text        `json:"full_address_ar"`
	ID_3                  pgtype.Int8        `json:"id_3"`
	City                  pgtype.Text        `json:"city"`
	StatesID_2            pgtype.Int8        `json:"states_id_2"`
	CreatedAt_3           pgtype.Timestamptz `json:"created_at_3"`
	UpdatedAt_3           pgtype.Timestamptz `json:"updated_at_3"`
	Lat                   pgtype.Float8      `json:"lat"`
	Lng                   pgtype.Float8      `json:"lng"`
	Status_2              pgtype.Int8        `json:"status_2"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy_2           pgtype.Int8        `json:"updated_by_2"`
	CityAr                pgtype.Text        `json:"city_ar"`
	CoverImage            pgtype.Text        `json:"cover_image"`
	Description_2         pgtype.Text        `json:"description_2"`
	ID_4                  int64              `json:"id_4"`
	Community             string             `json:"community"`
	CitiesID_2            pgtype.Int8        `json:"cities_id_2"`
	CreatedAt_4           time.Time          `json:"created_at_4"`
	UpdatedAt_4           time.Time          `json:"updated_at_4"`
	Lat_2                 pgtype.Float8      `json:"lat_2"`
	Lng_2                 pgtype.Float8      `json:"lng_2"`
	Status_3              int64              `json:"status_3"`
	DeletedAt_2           pgtype.Timestamptz `json:"deleted_at_2"`
	UpdatedBy_3           int64              `json:"updated_by_3"`
	CommunityAr           pgtype.Text        `json:"community_ar"`
	ID_5                  pgtype.Int8        `json:"id_5"`
	SubCommunity          pgtype.Text        `json:"sub_community"`
	CommunitiesID_2       pgtype.Int8        `json:"communities_id_2"`
	CreatedAt_5           pgtype.Timestamptz `json:"created_at_5"`
	UpdatedAt_5           pgtype.Timestamptz `json:"updated_at_5"`
	Lng_3                 pgtype.Float8      `json:"lng_3"`
	Lat_3                 pgtype.Float8      `json:"lat_3"`
	Status_4              pgtype.Int8        `json:"status_4"`
	DeletedAt_3           pgtype.Timestamptz `json:"deleted_at_3"`
	UpdatedBy_4           pgtype.Int8        `json:"updated_by_4"`
	SubCommunityAr        pgtype.Text        `json:"sub_community_ar"`
}

func (q *Queries) GetProjectPropertiesBySameArea(ctx context.Context, arg GetProjectPropertiesBySameAreaParams) ([]GetProjectPropertiesBySameAreaRow, error) {
	rows, err := q.db.Query(ctx, getProjectPropertiesBySameArea, arg.ID, arg.CommunitiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectPropertiesBySameAreaRow
	for rows.Next() {
		var i GetProjectPropertiesBySameAreaRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description,
			&i.DescriptionArabic,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy,
			&i.FromXml,
			&i.Facts,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.ID_2,
			&i.CountriesID,
			&i.StatesID,
			&i.CitiesID,
			&i.CommunitiesID,
			&i.SubCommunitiesID,
			&i.LocationsID,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.PropertyMapLocationID,
			&i.FullAddress,
			&i.FullAddressAr,
			&i.ID_3,
			&i.City,
			&i.StatesID_2,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
			&i.Lat,
			&i.Lng,
			&i.Status_2,
			&i.DeletedAt,
			&i.UpdatedBy_2,
			&i.CityAr,
			&i.CoverImage,
			&i.Description_2,
			&i.ID_4,
			&i.Community,
			&i.CitiesID_2,
			&i.CreatedAt_4,
			&i.UpdatedAt_4,
			&i.Lat_2,
			&i.Lng_2,
			&i.Status_3,
			&i.DeletedAt_2,
			&i.UpdatedBy_3,
			&i.CommunityAr,
			&i.ID_5,
			&i.SubCommunity,
			&i.CommunitiesID_2,
			&i.CreatedAt_5,
			&i.UpdatedAt_5,
			&i.Lng_3,
			&i.Lat_3,
			&i.Status_4,
			&i.DeletedAt_3,
			&i.UpdatedBy_4,
			&i.SubCommunityAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectPropertyMediaByPropertyId = `-- name: GetProjectPropertyMediaByPropertyId :many
SELECT id, file_urls, gallery_type, media_type, properties_id, property, created_at, updated_at FROM properties_media 
WHERE properties_id = $1 and property = 1 and media_type = 1
`

func (q *Queries) GetProjectPropertyMediaByPropertyId(ctx context.Context, propertiesID int64) ([]PropertiesMedium, error) {
	rows, err := q.db.Query(ctx, getProjectPropertyMediaByPropertyId, propertiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PropertiesMedium
	for rows.Next() {
		var i PropertiesMedium
		if err := rows.Scan(
			&i.ID,
			&i.FileUrls,
			&i.GalleryType,
			&i.MediaType,
			&i.PropertiesID,
			&i.Property,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRentUnitListingBySameArea = `-- name: GetProjectRentUnitListingBySameArea :many
With x As (
select units.id, units.unit_no, units.unitno_is_public, units.notes, units.unit_title, units.description, units.description_arabic, units.unit_title_arabic, units.notes_arabic, units.notes_public, units.is_verified, units.entity_type_id, units.entity_id, units.created_at, units.updated_at, units.addresses_id, units.unit_type_id, units.created_by, units.updated_by, units.type_name_id, units.owner_users_id, units.from_xml, units.company_id, units.status, units.facts, units.is_project_unit, units.exclusive, units.start_date, units.end_date, rent_unit.title, rent_unit.title_arabic, rent_unit.description, rent_unit.description_arabic, rent_unit.unit_id, rent_unit.status, rent_unit.unit_facts_id from units
LEFT JOIN
    addresses ON units.addresses_id = addresses.id
LEFT JOIN
    cities ON addresses.cities_id = cities.id
INNER JOIN
    communities ON addresses.communities_id = communities.id
LEFT JOIN
    sub_communities ON addresses.sub_communities_id = sub_communities.id
inner join rent_unit on rent_unit.unit_id = units.id
where rent_unit.unit_id != $1 and addresses.communities_id = $2 and  status != 5 and status != 6
) SELECT id, unit_no, unitno_is_public, notes, unit_title, x.description, x.description_arabic, unit_title_arabic, notes_arabic, notes_public, is_verified, entity_type_id, entity_id, created_at, updated_at, addresses_id, unit_type_id, created_by, updated_by, type_name_id, owner_users_id, from_xml, company_id, x.status, facts, is_project_unit, exclusive, start_date, end_date, title, title_arabic, x.description, x.description_arabic, unit_id, x.status, unit_facts_id from x LIMIT 10 OFFSET 0
`

type GetProjectRentUnitListingBySameAreaParams struct {
	UnitID        int64       `json:"unit_id"`
	CommunitiesID pgtype.Int8 `json:"communities_id"`
}

type GetProjectRentUnitListingBySameAreaRow struct {
	ID                  int64       `json:"id"`
	UnitNo              string      `json:"unit_no"`
	UnitnoIsPublic      pgtype.Bool `json:"unitno_is_public"`
	Notes               string      `json:"notes"`
	UnitTitle           string      `json:"unit_title"`
	Description         string      `json:"description"`
	DescriptionArabic   string      `json:"description_arabic"`
	UnitTitleArabic     string      `json:"unit_title_arabic"`
	NotesArabic         string      `json:"notes_arabic"`
	NotesPublic         pgtype.Bool `json:"notes_public"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	EntityTypeID        pgtype.Int8 `json:"entity_type_id"`
	EntityID            pgtype.Int8 `json:"entity_id"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	AddressesID         int64       `json:"addresses_id"`
	UnitTypeID          int64       `json:"unit_type_id"`
	CreatedBy           int64       `json:"created_by"`
	UpdatedBy           int64       `json:"updated_by"`
	TypeNameID          pgtype.Int8 `json:"type_name_id"`
	OwnerUsersID        pgtype.Int8 `json:"owner_users_id"`
	FromXml             pgtype.Bool `json:"from_xml"`
	CompanyID           pgtype.Int8 `json:"company_id"`
	Status              int64       `json:"status"`
	Facts               []byte      `json:"facts"`
	IsProjectUnit       pgtype.Bool `json:"is_project_unit"`
	Exclusive           bool        `json:"exclusive"`
	StartDate           pgtype.Date `json:"start_date"`
	EndDate             pgtype.Date `json:"end_date"`
	Title               string      `json:"title"`
	TitleArabic         pgtype.Text `json:"title_arabic"`
	Description_2       string      `json:"description_2"`
	DescriptionArabic_2 pgtype.Text `json:"description_arabic_2"`
	UnitID              int64       `json:"unit_id"`
	Status_2            int64       `json:"status_2"`
	UnitFactsID         pgtype.Int8 `json:"unit_facts_id"`
}

func (q *Queries) GetProjectRentUnitListingBySameArea(ctx context.Context, arg GetProjectRentUnitListingBySameAreaParams) ([]GetProjectRentUnitListingBySameAreaRow, error) {
	rows, err := q.db.Query(ctx, getProjectRentUnitListingBySameArea, arg.UnitID, arg.CommunitiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectRentUnitListingBySameAreaRow
	for rows.Next() {
		var i GetProjectRentUnitListingBySameAreaRow
		if err := rows.Scan(
			&i.ID,
			&i.UnitNo,
			&i.UnitnoIsPublic,
			&i.Notes,
			&i.UnitTitle,
			&i.Description,
			&i.DescriptionArabic,
			&i.UnitTitleArabic,
			&i.NotesArabic,
			&i.NotesPublic,
			&i.IsVerified,
			&i.EntityTypeID,
			&i.EntityID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AddressesID,
			&i.UnitTypeID,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.TypeNameID,
			&i.OwnerUsersID,
			&i.FromXml,
			&i.CompanyID,
			&i.Status,
			&i.Facts,
			&i.IsProjectUnit,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Title,
			&i.TitleArabic,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.UnitID,
			&i.Status_2,
			&i.UnitFactsID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectReviewByProjectAndUserId = `-- name: GetProjectReviewByProjectAndUserId :one
SELECT id, ref_no, is_project, projects_id, project_clean, project_location, project_facilities, project_securities, description, reviewer, review_date, proof_images, title FROM project_reviews
WHERE projects_id = $1 AND reviewer = $2
`

type GetProjectReviewByProjectAndUserIdParams struct {
	ProjectsID int64 `json:"projects_id"`
	Reviewer   int64 `json:"reviewer"`
}

func (q *Queries) GetProjectReviewByProjectAndUserId(ctx context.Context, arg GetProjectReviewByProjectAndUserIdParams) (ProjectReview, error) {
	row := q.db.QueryRow(ctx, getProjectReviewByProjectAndUserId, arg.ProjectsID, arg.Reviewer)
	var i ProjectReview
	err := row.Scan(
		&i.ID,
		&i.RefNo,
		&i.IsProject,
		&i.ProjectsID,
		&i.ProjectClean,
		&i.ProjectLocation,
		&i.ProjectFacilities,
		&i.ProjectSecurities,
		&i.Description,
		&i.Reviewer,
		&i.ReviewDate,
		&i.ProofImages,
		&i.Title,
	)
	return i, err
}

const getProjectReviewsByProjectId = `-- name: GetProjectReviewsByProjectId :many
SELECT id, ref_no, is_project, projects_id, project_clean, project_location, project_facilities, project_securities, description, reviewer, review_date, proof_images, title FROM project_reviews
WHERE projects_id = $1
LIMIT $2 OFFSET $3
`

type GetProjectReviewsByProjectIdParams struct {
	ProjectsID int64 `json:"projects_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) GetProjectReviewsByProjectId(ctx context.Context, arg GetProjectReviewsByProjectIdParams) ([]ProjectReview, error) {
	rows, err := q.db.Query(ctx, getProjectReviewsByProjectId, arg.ProjectsID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectReview
	for rows.Next() {
		var i ProjectReview
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.IsProject,
			&i.ProjectsID,
			&i.ProjectClean,
			&i.ProjectLocation,
			&i.ProjectFacilities,
			&i.ProjectSecurities,
			&i.Description,
			&i.Reviewer,
			&i.ReviewDate,
			&i.ProofImages,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectReviewsByProjectIdWithIndividualAverages = `-- name: GetProjectReviewsByProjectIdWithIndividualAverages :many

















WITH ReviewAverages AS (
    SELECT
        AVG(project_clean) AS avg_clean,
        AVG(project_location) AS avg_location,
        AVG(project_facilities) AS avg_facilities,
        AVG(project_securities) AS avg_securities,
        AVG((project_clean + project_location + project_facilities + project_securities) / 4.0)::float AS overall_avg
    FROM
        project_reviews
    WHERE
        projects_id = $1
)
SELECT
    project_reviews.id,
    project_reviews.ref_no,
    project_reviews.is_project,
    project_reviews.project_clean,
    project_reviews.project_location,
    project_reviews.project_facilities,
    project_reviews.project_securities,
    project_reviews.description,
    project_reviews.reviewer,
    project_reviews.review_date,
    project_reviews.proof_images,
    project_reviews.title,
    ra.avg_clean,
    ra.avg_location,
    ra.avg_facilities,
    ra.avg_securities,
    ra.overall_avg,
    ((project_reviews.project_clean + project_reviews.project_location + project_reviews.project_facilities + project_reviews.project_securities) / 4.0)::float AS avg,
    COUNT(*) OVER() AS total_count
FROM
    project_reviews
JOIN
    ReviewAverages ra ON true
WHERE
    project_reviews.projects_id = $1
LIMIT $2 OFFSET $3
`

type GetProjectReviewsByProjectIdWithIndividualAveragesParams struct {
	ProjectsID int64 `json:"projects_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetProjectReviewsByProjectIdWithIndividualAveragesRow struct {
	ID                int64       `json:"id"`
	RefNo             string      `json:"ref_no"`
	IsProject         pgtype.Bool `json:"is_project"`
	ProjectClean      float64     `json:"project_clean"`
	ProjectLocation   float64     `json:"project_location"`
	ProjectFacilities float64     `json:"project_facilities"`
	ProjectSecurities float64     `json:"project_securities"`
	Description       string      `json:"description"`
	Reviewer          int64       `json:"reviewer"`
	ReviewDate        time.Time   `json:"review_date"`
	ProofImages       []string    `json:"proof_images"`
	Title             pgtype.Text `json:"title"`
	AvgClean          float64     `json:"avg_clean"`
	AvgLocation       float64     `json:"avg_location"`
	AvgFacilities     float64     `json:"avg_facilities"`
	AvgSecurities     float64     `json:"avg_securities"`
	OverallAvg        float64     `json:"overall_avg"`
	Avg               float64     `json:"avg"`
	TotalCount        int64       `json:"total_count"`
}

// -- name: FilterCountSaleUnitListingStatus :one
// with x as (
//
//	    select count(units.id) as cnt
//		from units
//		inner join sale_unit on  units.id = sale_unit.unit_id
//		INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'sale'
//		AND ($3::bigint[] is NULL OR units.property_unit_rank = ANY($3::bigint[]))
//	    AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
//	    where units.properties_id = $1
//		and sale_unit.status = $2
//		and section = 'project'
//		and units.property = 1
//	    AND unit_facts.bedroom IS NOT NULL
//
// )
// select sum(cnt) as total_count from x;
// -- name: FilterCountRentUnitListingStatus :one
// with x as (
//
//		select count(units.id) as cnt
//		from units
//		inner join rent_unit on  units.id = rent_unit.unit_id
//		INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'rent'
//		AND ($3::bigint[] is NULL OR units.property_unit_rank = ANY($3::bigint[]))
//	    AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
//	    where units.properties_id = $1
//		and rent_unit.status = $2
//		and section = 'project'
//		and units.property = 1
//	    AND unit_facts.bedroom IS NOT NULL
//
// )
// select sum(cnt) as total_count from x;
// -- name: FilterCountUnitListingStatus :one
// with x as (
//
//	    select count(units.id) as cnt
//		from units
//		inner join sale_unit on  units.id = sale_unit.unit_id
//		INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'sale'
//	    where units.properties_id = $1
//		and sale_unit.status = $2
//		and section = 'project'
//		and units.property = 1
//	    AND unit_facts.bedroom IS NOT NULL
//		union all
//		select count(units.id) as cnt
//		from units
//		inner join rent_unit on  units.id = rent_unit.unit_id
//		INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'rent'
//	    where units.properties_id = $1
//		and rent_unit.status = $2
//		and section = 'project'
//		and units.property = 1
//	    AND unit_facts.bedroom IS NOT NULL
//
// )
// select sum(cnt) as total_count from x;
// -- name: FilterCountSaleUnitListingBedroom :many
// WITH x AS (
//
//	SELECT unit_facts.bedroom
//
// FROM units
// INNER JOIN sale_unit ON sale_unit.unit_id = units.id
// INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'sale'
// AND (@rank_list::bigint[] is NULL OR units.property_unit_rank = ANY(@rank_list::bigint[]))
// AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
// WHERE units.properties_id = $1
//
//	AND units.property = 1
//	AND unit_facts.bedroom IS NOT NULL
//
// )
// SELECT bedroom, COUNT(*) AS total_count
// FROM x
// GROUP BY bedroom
// ORDER BY bedroom;
// -- name: FilterCountRentUnitListingBedroom :many
// WITH x AS (
//
//	select unit_facts.bedroom
//	from units
//
// inner join rent_unit on rent_unit.unit_id = units.id
// INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'rent'
// AND (@rank_list::bigint[] is NULL OR units.property_unit_rank = ANY(@rank_list::bigint[]))
// AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
// where units.properties_id = $1
// and units.property = 1
// AND unit_facts.bedroom IS NOT NULL
// )
// SELECT bedroom, COUNT(*) AS total_count
// FROM x
// GROUP BY bedroom
// ORDER BY bedroom;
// -- name: GetProjectPropertySaleUnits :many
// SELECT units.*, sale_unit.*
// FROM units
// INNER JOIN sale_unit ON sale_unit.unit_id = units.id
// INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'sale'
// WHERE units.properties_id = $1
//
//	AND units.property = 1
//	AND units."section" = $2
//	AND (@bedrooms::varchar[] IS NULL OR unit_facts.bedroom = ANY(@bedrooms::varchar[]))
//	AND (@status_list::int[] IS NULL OR sale_unit.status = ANY(@status_list::int[]))
//	AND (@rank_list::bigint[] IS NULL OR units.property_unit_rank = ANY(@rank_list::bigint[]))
//	AND (@is_verified::bool IS NULL OR units.is_verified = @is_verified::bool)
//	AND unit_facts.bedroom IS NOT NULL
//
// ORDER BY
//
//	CASE
//	  WHEN $3 = 1 THEN units.created_at
//	  ELSE NULL
//	END DESC,
//	CASE
//	  WHEN $3 = 2 THEN unit_facts.price
//	  ELSE NULL
//	END ASC,
//	CASE
//	  WHEN $3 = 3 THEN unit_facts.price
//	  ELSE NULL
//	END DESC,
//	units.created_at DESC
//	LIMIT $4 OFFSET $5;
//
// -- name: GetCountProjectPropertySaleUnits :one
// SELECT count(units.*)
// FROM units
// INNER JOIN sale_unit ON sale_unit.unit_id = units.id
// INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'sale'
// WHERE units.properties_id = $1
//
//	AND units.property = 1
//	AND units."section" = $2
//	AND (@bedrooms::varchar[] IS NULL OR unit_facts.bedroom = ANY(@bedrooms::varchar[]))
//	AND (@status_list::int[] IS NULL OR sale_unit.status = ANY(@status_list::int[]))
//	AND (@rank_list::bigint[] is NULL OR units.property_unit_rank = ANY(@rank_list::bigint[]))
//	AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
//	AND unit_facts.bedroom IS NOT NULL;
//
// -- name: GetProjectPropertyRentUnits :many
// select *, rent_unit.* from units
// inner join rent_unit on rent_unit.unit_id = units.id
// INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'rent'
// where units.properties_id = $1 and units.property = 1 and units. "section" = $2
// AND (@bedrooms::varchar[] IS NULL OR unit_facts.bedroom = ANY(@bedrooms::varchar[]))
// AND (@status_list::int[] IS NULL OR rent_unit.status = ANY(@status_list::int[]))
// AND (@rank_list::bigint[] is NULL OR units.property_unit_rank = ANY(@rank_list::bigint[]))
// AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
// AND unit_facts.bedroom IS NOT NULL
// ORDER BY
//
//	CASE
//	  WHEN COALESCE($3, 0) = 1 THEN units.created_at
//	  WHEN COALESCE($3, 0) = 2 THEN NULL
//	  WHEN COALESCE($3, 0) = 3 THEN NULL
//	  ELSE units.created_at  -- Default sorting by created_at if no parameter is passed
//	END DESC,
//	CASE
//	  WHEN COALESCE($3, 0) = 2 THEN unit_facts.price
//	  ELSE NULL
//	END ASC,
//	CASE
//	  WHEN COALESCE($3, 0) = 3 THEN unit_facts.price
//	  ELSE NULL
//	END DESC,
//	units.created_at DESC
//	LIMIT $4 OFFSET $5;
//
// -- name: GetCountProjectPropertyRentUnits :one
// select count(*) from units
// inner join rent_unit on rent_unit.unit_id = units.id
// INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'rent'
// where units.properties_id = $1 and units.property = 1 and units. "section" = $2
// AND (@bedrooms::varchar[] IS NULL OR unit_facts.bedroom = ANY(@bedrooms::varchar[]))
// AND (@status_list::int[] IS NULL OR rent_unit.status = ANY(@status_list::int[]))
// AND (@rank_list::bigint[] is NULL OR units.property_unit_rank = ANY(@rank_list::bigint[]))
// AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
// AND unit_facts.bedroom IS NOT NULL;
// -- name: GetProjectSaleUnitCount :one
// with x as (
//
//	    select count(units.id) as cnt
//		from units
//		inner join sale_unit on  units.id = sale_unit.unit_id
//		INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'sale'
//		AND (@bedrooms::varchar[] IS NULL OR unit_facts.bedroom = ANY(@bedrooms::varchar[]))
//	    AND (@status_list::int[] IS NULL OR sale_unit.status = ANY(@status_list::int[]))
//		AND (@rank_list::bigint[] is NULL OR units.property_unit_rank = ANY(@rank_list::bigint[]))
//	    AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
//	    where units.properties_id = $1
//		and section = 'project'
//		and units.property = 1
//	    AND unit_facts.bedroom IS NOT NULL
//
// )
// select sum(cnt) as total_count from x;
// -- name: GetProjectRentUnitCount :one
// with x as (
//
//		select count(units.id) as cnt
//		from units
//		inner join rent_unit on  units.id = rent_unit.unit_id
//		INNER JOIN unit_facts ON units.id = unit_facts.unit_id and unit_facts.category = 'rent'
//		AND (@bedrooms::varchar[] IS NULL OR unit_facts.bedroom = ANY(@bedrooms::varchar[]))
//	    AND (@status_list::int[] IS NULL OR sale_unit.status = ANY(@status_list::int[]))
//		AND (@rank_list::bigint[] is NULL OR units.property_unit_rank = ANY(@rank_list::bigint[]))
//	    AND (@is_verified::bool IS null OR units.is_verified = @is_verified::bool)
//	    where units.properties_id = $1
//		and section = 'project'
//		and units.property = 1
//	    AND unit_facts.bedroom IS NOT NULL
//
// )
// select sum(cnt) as total_count from x;
// -- name: GetSingleSaleUnits :one
// select units.*, sale_unit.title, sale_unit.title_arabic, sale_unit.description, sale_unit.description_arabic, sale_unit.unit_id, sale_unit.status, sale_unit.unit_facts_id, sale_unit.contract_start_datetime, sale_unit.contract_end_datetime, sale_unit.contract_amount, sale_unit.contract_currency, projects.facilities_id from units
// inner join sale_unit on sale_unit.unit_id = units.id
// left join project_properties on units.properties_id  = project_properties.id and units.property = 1
// left join projects on projects.id = project_properties.projects_id
// where sale_unit.unit_id = $1 and units.is_branch = false;
// -- name: GetSingleRentUnits :one
// select units.*, rent_unit.title, rent_unit.title_arabic, rent_unit.description, rent_unit.description_arabic, rent_unit.unit_id, rent_unit.status, rent_unit.unit_facts_id, projects.facilities_id from units
// inner join rent_unit on rent_unit.unit_id = units.id
// left join project_properties on units.properties_id  = project_properties.id and units.property = 1
// left join projects on projects.id = project_properties.projects_id
// where rent_unit.unit_id = $1 and units.is_branch = false;
func (q *Queries) GetProjectReviewsByProjectIdWithIndividualAverages(ctx context.Context, arg GetProjectReviewsByProjectIdWithIndividualAveragesParams) ([]GetProjectReviewsByProjectIdWithIndividualAveragesRow, error) {
	rows, err := q.db.Query(ctx, getProjectReviewsByProjectIdWithIndividualAverages, arg.ProjectsID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectReviewsByProjectIdWithIndividualAveragesRow
	for rows.Next() {
		var i GetProjectReviewsByProjectIdWithIndividualAveragesRow
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.IsProject,
			&i.ProjectClean,
			&i.ProjectLocation,
			&i.ProjectFacilities,
			&i.ProjectSecurities,
			&i.Description,
			&i.Reviewer,
			&i.ReviewDate,
			&i.ProofImages,
			&i.Title,
			&i.AvgClean,
			&i.AvgLocation,
			&i.AvgFacilities,
			&i.AvgSecurities,
			&i.OverallAvg,
			&i.Avg,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectSaleUnitListingBySameArea = `-- name: GetProjectSaleUnitListingBySameArea :many



With x As (
select units.id, units.unit_no, units.unitno_is_public, units.notes, units.unit_title, units.description, units.description_arabic, units.unit_title_arabic, units.notes_arabic, units.notes_public, units.is_verified, units.entity_type_id, units.entity_id, units.created_at, units.updated_at, units.addresses_id, units.unit_type_id, units.created_by, units.updated_by, units.type_name_id, units.owner_users_id, units.from_xml, units.company_id, units.status, units.facts, units.is_project_unit, units.exclusive, units.start_date, units.end_date, sale_unit.title, sale_unit.title_arabic, sale_unit.description, sale_unit.description_arabic, sale_unit.unit_id, sale_unit.status, sale_unit.unit_facts_id, sale_unit.contract_start_datetime, sale_unit.contract_end_datetime, sale_unit.contract_amount, sale_unit.contract_currency from units
LEFT JOIN
    addresses ON units.addresses_id = addresses.id
LEFT JOIN
    cities ON addresses.cities_id = cities.id
INNER JOIN
    communities ON addresses.communities_id = communities.id
LEFT JOIN
    sub_communities ON addresses.sub_communities_id = sub_communities.id
inner join sale_unit on sale_unit.unit_id = units.id
where sale_unit.unit_id != $1 and addresses.communities_id = $2 and  status != 5 and status != 6
) SELECT id, unit_no, unitno_is_public, notes, unit_title, x.description, x.description_arabic, unit_title_arabic, notes_arabic, notes_public, is_verified, entity_type_id, entity_id, created_at, updated_at, addresses_id, unit_type_id, created_by, updated_by, type_name_id, owner_users_id, from_xml, company_id, x.status, facts, is_project_unit, exclusive, start_date, end_date, title, title_arabic, x.description, x.description_arabic, unit_id, x.status, unit_facts_id, contract_start_datetime, contract_end_datetime, contract_amount, contract_currency from x LIMIT 10 OFFSET 0
`

type GetProjectSaleUnitListingBySameAreaParams struct {
	UnitID        int64       `json:"unit_id"`
	CommunitiesID pgtype.Int8 `json:"communities_id"`
}

type GetProjectSaleUnitListingBySameAreaRow struct {
	ID                    int64              `json:"id"`
	UnitNo                string             `json:"unit_no"`
	UnitnoIsPublic        pgtype.Bool        `json:"unitno_is_public"`
	Notes                 string             `json:"notes"`
	UnitTitle             string             `json:"unit_title"`
	Description           string             `json:"description"`
	DescriptionArabic     string             `json:"description_arabic"`
	UnitTitleArabic       string             `json:"unit_title_arabic"`
	NotesArabic           string             `json:"notes_arabic"`
	NotesPublic           pgtype.Bool        `json:"notes_public"`
	IsVerified            pgtype.Bool        `json:"is_verified"`
	EntityTypeID          pgtype.Int8        `json:"entity_type_id"`
	EntityID              pgtype.Int8        `json:"entity_id"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
	AddressesID           int64              `json:"addresses_id"`
	UnitTypeID            int64              `json:"unit_type_id"`
	CreatedBy             int64              `json:"created_by"`
	UpdatedBy             int64              `json:"updated_by"`
	TypeNameID            pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID          pgtype.Int8        `json:"owner_users_id"`
	FromXml               pgtype.Bool        `json:"from_xml"`
	CompanyID             pgtype.Int8        `json:"company_id"`
	Status                int64              `json:"status"`
	Facts                 []byte             `json:"facts"`
	IsProjectUnit         pgtype.Bool        `json:"is_project_unit"`
	Exclusive             bool               `json:"exclusive"`
	StartDate             pgtype.Date        `json:"start_date"`
	EndDate               pgtype.Date        `json:"end_date"`
	Title                 string             `json:"title"`
	TitleArabic           pgtype.Text        `json:"title_arabic"`
	Description_2         string             `json:"description_2"`
	DescriptionArabic_2   pgtype.Text        `json:"description_arabic_2"`
	UnitID                int64              `json:"unit_id"`
	Status_2              int64              `json:"status_2"`
	UnitFactsID           pgtype.Int8        `json:"unit_facts_id"`
	ContractStartDatetime pgtype.Timestamptz `json:"contract_start_datetime"`
	ContractEndDatetime   pgtype.Timestamptz `json:"contract_end_datetime"`
	ContractAmount        pgtype.Int8        `json:"contract_amount"`
	ContractCurrency      pgtype.Int8        `json:"contract_currency"`
}

// -- name: TopDealProjectSaleUnitListing :many
// With x As (
// select units.*, sale_unit.title, sale_unit.title_arabic, sale_unit.description, sale_unit.description_arabic, sale_unit.unit_id, sale_unit.status, sale_unit.unit_facts_id, sale_unit.contract_start_datetime, sale_unit.contract_end_datetime, sale_unit.contract_amount, sale_unit.contract_currency from units
// inner join sale_unit on sale_unit.unit_id = units.id
// where sale_unit.unit_id != $1 and units.property_unit_rank = $2
// ) SELECT * from x LIMIT 10 OFFSET 0;
// -- name: TopDealProjectRentUnitListing :many
// With x As (
// select units.*, rent_unit.title, rent_unit.title_arabic, rent_unit.description, rent_unit.description_arabic, rent_unit.unit_id, rent_unit.status, rent_unit.unit_facts_id from units
// inner join rent_unit on rent_unit.unit_id = units.id
// where rent_unit.unit_id != $1 and units.property_unit_rank = $2
// ) SELECT * from x LIMIT 10 OFFSET 0;
func (q *Queries) GetProjectSaleUnitListingBySameArea(ctx context.Context, arg GetProjectSaleUnitListingBySameAreaParams) ([]GetProjectSaleUnitListingBySameAreaRow, error) {
	rows, err := q.db.Query(ctx, getProjectSaleUnitListingBySameArea, arg.UnitID, arg.CommunitiesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectSaleUnitListingBySameAreaRow
	for rows.Next() {
		var i GetProjectSaleUnitListingBySameAreaRow
		if err := rows.Scan(
			&i.ID,
			&i.UnitNo,
			&i.UnitnoIsPublic,
			&i.Notes,
			&i.UnitTitle,
			&i.Description,
			&i.DescriptionArabic,
			&i.UnitTitleArabic,
			&i.NotesArabic,
			&i.NotesPublic,
			&i.IsVerified,
			&i.EntityTypeID,
			&i.EntityID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AddressesID,
			&i.UnitTypeID,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.TypeNameID,
			&i.OwnerUsersID,
			&i.FromXml,
			&i.CompanyID,
			&i.Status,
			&i.Facts,
			&i.IsProjectUnit,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Title,
			&i.TitleArabic,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.UnitID,
			&i.Status_2,
			&i.UnitFactsID,
			&i.ContractStartDatetime,
			&i.ContractEndDatetime,
			&i.ContractAmount,
			&i.ContractCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyTypeNew = `-- name: GetPropertyTypeNew :one
SELECT id, type, code, property_type_facts, listing_facts, usage, created_at, updated_at, status, icon, is_project, type_ar FROM global_property_type 
WHERE id = $1 LIMIT $1
`

func (q *Queries) GetPropertyTypeNew(ctx context.Context, limit int32) (GlobalPropertyType, error) {
	row := q.db.QueryRow(ctx, getPropertyTypeNew, limit)
	var i GlobalPropertyType
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Code,
		&i.PropertyTypeFacts,
		&i.ListingFacts,
		&i.Usage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Icon,
		&i.IsProject,
		&i.TypeAr,
	)
	return i, err
}

const getSingleProject = `-- name: GetSingleProject :one

WITH property_types_agg AS (
    SELECT 
        property.entity_id,
        array_agg(gpt.id ORDER BY gpt.id) AS property_types  -- Assuming ` + "`" + `type` + "`" + ` is the column in ` + "`" + `global_property_type` + "`" + `
    FROM 
        property
    LEFT JOIN 
        global_property_type gpt ON gpt.id = property.property_type_id  -- Join to get the global_property_type
    WHERE 
        property.entity_type_id = 1  -- Assuming 1 indicates a project-related entity
    GROUP BY 
        property.entity_id
)
SELECT
    projects.id, projects.project_name, projects.ref_number, projects.no_of_views, projects.is_verified, projects.project_rank, projects.addresses_id, projects.status, projects.developer_companies_id, projects.developer_company_branches_id, projects.countries_id, projects.created_at, projects.updated_at, projects.is_multiphase, projects.live_status, projects.project_no, projects.license_no, projects.users_id, projects.description, projects.description_arabic, projects.rating, projects.polygon_coords, projects.facts, projects.exclusive, projects.start_date, projects.end_date, projects.slug, projects.deleted_at, projects.bank_name, projects.registration_date, projects.escrow_number, projects.refreshed_at,
    property_types_agg.property_types,
    COUNT(phases.id) AS no_of_phases
FROM
    projects
LEFT JOIN
    phases ON projects.id = phases.projects_id
LEFT JOIN 
    property_types_agg ON projects.id = property_types_agg.entity_id
WHERE
    projects.id = $1
GROUP BY
    projects.id,
    property_types_agg.property_types
`

type GetSingleProjectRow struct {
	ID                         int64              `json:"id"`
	ProjectName                string             `json:"project_name"`
	RefNumber                  string             `json:"ref_number"`
	NoOfViews                  int64              `json:"no_of_views"`
	IsVerified                 pgtype.Bool        `json:"is_verified"`
	ProjectRank                int64              `json:"project_rank"`
	AddressesID                int64              `json:"addresses_id"`
	Status                     int64              `json:"status"`
	DeveloperCompaniesID       int64              `json:"developer_companies_id"`
	DeveloperCompanyBranchesID pgtype.Int8        `json:"developer_company_branches_id"`
	CountriesID                int64              `json:"countries_id"`
	CreatedAt                  time.Time          `json:"created_at"`
	UpdatedAt                  time.Time          `json:"updated_at"`
	IsMultiphase               pgtype.Bool        `json:"is_multiphase"`
	LiveStatus                 pgtype.Bool        `json:"live_status"`
	ProjectNo                  string             `json:"project_no"`
	LicenseNo                  string             `json:"license_no"`
	UsersID                    int64              `json:"users_id"`
	Description                string             `json:"description"`
	DescriptionArabic          pgtype.Text        `json:"description_arabic"`
	Rating                     float64            `json:"rating"`
	PolygonCoords              []byte             `json:"polygon_coords"`
	Facts                      []byte             `json:"facts"`
	Exclusive                  bool               `json:"exclusive"`
	StartDate                  pgtype.Date        `json:"start_date"`
	EndDate                    pgtype.Date        `json:"end_date"`
	Slug                       string             `json:"slug"`
	DeletedAt                  pgtype.Timestamptz `json:"deleted_at"`
	BankName                   pgtype.Text        `json:"bank_name"`
	RegistrationDate           pgtype.Date        `json:"registration_date"`
	EscrowNumber               pgtype.Text        `json:"escrow_number"`
	RefreshedAt                pgtype.Timestamptz `json:"refreshed_at"`
	PropertyTypes              interface{}        `json:"property_types"`
	NoOfPhases                 int64              `json:"no_of_phases"`
}

// AND companies.status != 6;
func (q *Queries) GetSingleProject(ctx context.Context, id int64) (GetSingleProjectRow, error) {
	row := q.db.QueryRow(ctx, getSingleProject, id)
	var i GetSingleProjectRow
	err := row.Scan(
		&i.ID,
		&i.ProjectName,
		&i.RefNumber,
		&i.NoOfViews,
		&i.IsVerified,
		&i.ProjectRank,
		&i.AddressesID,
		&i.Status,
		&i.DeveloperCompaniesID,
		&i.DeveloperCompanyBranchesID,
		&i.CountriesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMultiphase,
		&i.LiveStatus,
		&i.ProjectNo,
		&i.LicenseNo,
		&i.UsersID,
		&i.Description,
		&i.DescriptionArabic,
		&i.Rating,
		&i.PolygonCoords,
		&i.Facts,
		&i.Exclusive,
		&i.StartDate,
		&i.EndDate,
		&i.Slug,
		&i.DeletedAt,
		&i.BankName,
		&i.RegistrationDate,
		&i.EscrowNumber,
		&i.RefreshedAt,
		&i.PropertyTypes,
		&i.NoOfPhases,
	)
	return i, err
}

const getUnitsProject = `-- name: GetUnitsProject :many
select units.id, units.unit_no, units.unitno_is_public, units.notes, units.unit_title, units.description, units.description_arabic, units.unit_title_arabic, units.notes_arabic, units.notes_public, units.is_verified, units.entity_type_id, units.entity_id, units.created_at, units.updated_at, units.addresses_id, units.unit_type_id, units.created_by, units.updated_by, units.type_name_id, units.owner_users_id, units.from_xml, units.company_id, units.status, units.facts, units.is_project_unit, units.exclusive, units.start_date, units.end_date, unit_versions.id, unit_versions.title, unit_versions.views_count, unit_versions.title_arabic, unit_versions.description, unit_versions.description_arabic, unit_versions.unit_id, unit_versions.ref_no, unit_versions.status, unit_versions.type, unit_versions.unit_rank, unit_versions.created_at, unit_versions.updated_at, unit_versions.created_by, unit_versions.updated_by, unit_versions.facts, unit_versions.listed_by, unit_versions.has_gallery, unit_versions.has_plans, unit_versions.is_main, unit_versions.is_verified, unit_versions.exclusive, unit_versions.start_date, unit_versions.end_date, unit_versions.slug, unit_versions.is_hotdeal, unit_versions.refreshed_at from units
inner join unit_versions on unit_versions.unit_id = units.id
where units.entity_id = $1 AND units.entity_type_id = $2 AND unit_versions.type = $3
`

type GetUnitsProjectParams struct {
	EntityID     pgtype.Int8 `json:"entity_id"`
	EntityTypeID pgtype.Int8 `json:"entity_type_id"`
	Type         int64       `json:"type"`
}

type GetUnitsProjectRow struct {
	ID                  int64              `json:"id"`
	UnitNo              string             `json:"unit_no"`
	UnitnoIsPublic      pgtype.Bool        `json:"unitno_is_public"`
	Notes               string             `json:"notes"`
	UnitTitle           string             `json:"unit_title"`
	Description         string             `json:"description"`
	DescriptionArabic   string             `json:"description_arabic"`
	UnitTitleArabic     string             `json:"unit_title_arabic"`
	NotesArabic         string             `json:"notes_arabic"`
	NotesPublic         pgtype.Bool        `json:"notes_public"`
	IsVerified          pgtype.Bool        `json:"is_verified"`
	EntityTypeID        pgtype.Int8        `json:"entity_type_id"`
	EntityID            pgtype.Int8        `json:"entity_id"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	AddressesID         int64              `json:"addresses_id"`
	UnitTypeID          int64              `json:"unit_type_id"`
	CreatedBy           int64              `json:"created_by"`
	UpdatedBy           int64              `json:"updated_by"`
	TypeNameID          pgtype.Int8        `json:"type_name_id"`
	OwnerUsersID        pgtype.Int8        `json:"owner_users_id"`
	FromXml             pgtype.Bool        `json:"from_xml"`
	CompanyID           pgtype.Int8        `json:"company_id"`
	Status              int64              `json:"status"`
	Facts               []byte             `json:"facts"`
	IsProjectUnit       pgtype.Bool        `json:"is_project_unit"`
	Exclusive           bool               `json:"exclusive"`
	StartDate           pgtype.Date        `json:"start_date"`
	EndDate             pgtype.Date        `json:"end_date"`
	ID_2                int64              `json:"id_2"`
	Title               string             `json:"title"`
	ViewsCount          int64              `json:"views_count"`
	TitleArabic         pgtype.Text        `json:"title_arabic"`
	Description_2       string             `json:"description_2"`
	DescriptionArabic_2 pgtype.Text        `json:"description_arabic_2"`
	UnitID              int64              `json:"unit_id"`
	RefNo               string             `json:"ref_no"`
	Status_2            int64              `json:"status_2"`
	Type                int64              `json:"type"`
	UnitRank            int64              `json:"unit_rank"`
	CreatedAt_2         time.Time          `json:"created_at_2"`
	UpdatedAt_2         time.Time          `json:"updated_at_2"`
	CreatedBy_2         int64              `json:"created_by_2"`
	UpdatedBy_2         int64              `json:"updated_by_2"`
	Facts_2             []byte             `json:"facts_2"`
	ListedBy            int64              `json:"listed_by"`
	HasGallery          pgtype.Bool        `json:"has_gallery"`
	HasPlans            pgtype.Bool        `json:"has_plans"`
	IsMain              bool               `json:"is_main"`
	IsVerified_2        bool               `json:"is_verified_2"`
	Exclusive_2         bool               `json:"exclusive_2"`
	StartDate_2         pgtype.Date        `json:"start_date_2"`
	EndDate_2           pgtype.Date        `json:"end_date_2"`
	Slug                string             `json:"slug"`
	IsHotdeal           bool               `json:"is_hotdeal"`
	RefreshedAt         pgtype.Timestamptz `json:"refreshed_at"`
}

func (q *Queries) GetUnitsProject(ctx context.Context, arg GetUnitsProjectParams) ([]GetUnitsProjectRow, error) {
	rows, err := q.db.Query(ctx, getUnitsProject, arg.EntityID, arg.EntityTypeID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitsProjectRow
	for rows.Next() {
		var i GetUnitsProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.UnitNo,
			&i.UnitnoIsPublic,
			&i.Notes,
			&i.UnitTitle,
			&i.Description,
			&i.DescriptionArabic,
			&i.UnitTitleArabic,
			&i.NotesArabic,
			&i.NotesPublic,
			&i.IsVerified,
			&i.EntityTypeID,
			&i.EntityID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AddressesID,
			&i.UnitTypeID,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.TypeNameID,
			&i.OwnerUsersID,
			&i.FromXml,
			&i.CompanyID,
			&i.Status,
			&i.Facts,
			&i.IsProjectUnit,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.ID_2,
			&i.Title,
			&i.ViewsCount,
			&i.TitleArabic,
			&i.Description_2,
			&i.DescriptionArabic_2,
			&i.UnitID,
			&i.RefNo,
			&i.Status_2,
			&i.Type,
			&i.UnitRank,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
			&i.Facts_2,
			&i.ListedBy,
			&i.HasGallery,
			&i.HasPlans,
			&i.IsMain,
			&i.IsVerified_2,
			&i.Exclusive_2,
			&i.StartDate_2,
			&i.EndDate_2,
			&i.Slug,
			&i.IsHotdeal,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const topDealProjectPropertiesByProjectListing = `-- name: TopDealProjectPropertiesByProjectListing :many
select id, company_id, property_type_id, unit_type_id, property_title, property_title_arabic, is_verified, addresses_id, entity_type_id, entity_id, status, is_show_owner_info, property_name, description, description_arabic, owner_users_id, user_id, updated_by, from_xml, facts, notes, created_at, updated_at, notes_ar, is_public_note, is_project_property, exclusive, start_date, end_date from property
where entity_id = $1 and entity_type_id = $2 and id != $3 and status != 5 and status != 6
LIMIT 10 OFFSET 0
`

type TopDealProjectPropertiesByProjectListingParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int64 `json:"entity_type_id"`
	ID           int64 `json:"id"`
}

func (q *Queries) TopDealProjectPropertiesByProjectListing(ctx context.Context, arg TopDealProjectPropertiesByProjectListingParams) ([]Property, error) {
	rows, err := q.db.Query(ctx, topDealProjectPropertiesByProjectListing, arg.EntityID, arg.EntityTypeID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PropertyTypeID,
			&i.UnitTypeID,
			&i.PropertyTitle,
			&i.PropertyTitleArabic,
			&i.IsVerified,
			&i.AddressesID,
			&i.EntityTypeID,
			&i.EntityID,
			&i.Status,
			&i.IsShowOwnerInfo,
			&i.PropertyName,
			&i.Description,
			&i.DescriptionArabic,
			&i.OwnerUsersID,
			&i.UserID,
			&i.UpdatedBy,
			&i.FromXml,
			&i.Facts,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotesAr,
			&i.IsPublicNote,
			&i.IsProjectProperty,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
