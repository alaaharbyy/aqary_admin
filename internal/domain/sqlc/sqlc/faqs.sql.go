// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: faqs.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const convertExistingReaction = `-- name: ConvertExistingReaction :one
UPDATE faq_user_reactions
SET reaction = $1, updated_at = CURRENT_TIMESTAMP
WHERE user_id = $2 AND faq_id = $3
RETURNING id, user_id, faq_id, reaction, created_at, updated_at
`

type ConvertExistingReactionParams struct {
	Reaction string `json:"reaction"`
	UserID   int32  `json:"user_id"`
	FaqID    int32  `json:"faq_id"`
}

func (q *Queries) ConvertExistingReaction(ctx context.Context, arg ConvertExistingReactionParams) (FaqUserReaction, error) {
	row := q.db.QueryRow(ctx, convertExistingReaction, arg.Reaction, arg.UserID, arg.FaqID)
	var i FaqUserReaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FaqID,
		&i.Reaction,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNewFaq = `-- name: CreateNewFaq :one
INSERT INTO faqs (
    company_id,
    section_id, 
    platform_id,
    tags, 
    questions, 
    answers, 
    questions_ar, 
    answers_ar,
    media_urls,
    created_at, 
    updated_at,
	created_by,
    status
) VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13
)RETURNING id, company_id, section_id, platform_id, tags, questions, answers, questions_ar, answers_ar, media_urls, created_at, updated_at, status, created_by, likes, dislikes
`

type CreateNewFaqParams struct {
	CompanyID   pgtype.Int8 `json:"company_id"`
	SectionID   pgtype.Int8 `json:"section_id"`
	PlatformID  int64       `json:"platform_id"`
	Tags        []string    `json:"tags"`
	Questions   string      `json:"questions"`
	Answers     string      `json:"answers"`
	QuestionsAr pgtype.Text `json:"questions_ar"`
	AnswersAr   pgtype.Text `json:"answers_ar"`
	MediaUrls   []string    `json:"media_urls"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	CreatedBy   int64       `json:"created_by"`
	Status      int64       `json:"status"`
}

func (q *Queries) CreateNewFaq(ctx context.Context, arg CreateNewFaqParams) (Faq, error) {
	row := q.db.QueryRow(ctx, createNewFaq,
		arg.CompanyID,
		arg.SectionID,
		arg.PlatformID,
		arg.Tags,
		arg.Questions,
		arg.Answers,
		arg.QuestionsAr,
		arg.AnswersAr,
		arg.MediaUrls,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.Status,
	)
	var i Faq
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SectionID,
		&i.PlatformID,
		&i.Tags,
		&i.Questions,
		&i.Answers,
		&i.QuestionsAr,
		&i.AnswersAr,
		&i.MediaUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CreatedBy,
		&i.Likes,
		&i.Dislikes,
	)
	return i, err
}

const getCountAllFaqsByComp = `-- name: GetCountAllFaqsByComp :one
select COUNT(*) from faqs where status = $1 and company_id = $2 and platform_id = $3
`

type GetCountAllFaqsByCompParams struct {
	Status     int64       `json:"status"`
	CompanyID  pgtype.Int8 `json:"company_id"`
	PlatformID int64       `json:"platform_id"`
}

func (q *Queries) GetCountAllFaqsByComp(ctx context.Context, arg GetCountAllFaqsByCompParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllFaqsByComp, arg.Status, arg.CompanyID, arg.PlatformID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountAllFaqsByStatus = `-- name: GetCountAllFaqsByStatus :one
select COUNT(*) from faqs where status = $1 and platform_id = $2
`

type GetCountAllFaqsByStatusParams struct {
	Status     int64 `json:"status"`
	PlatformID int64 `json:"platform_id"`
}

func (q *Queries) GetCountAllFaqsByStatus(ctx context.Context, arg GetCountAllFaqsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllFaqsByStatus, arg.Status, arg.PlatformID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getExistingReaction = `-- name: GetExistingReaction :one
SELECT reaction FROM faq_user_reactions WHERE user_id = $1 AND faq_id = $2
`

type GetExistingReactionParams struct {
	UserID int32 `json:"user_id"`
	FaqID  int32 `json:"faq_id"`
}

func (q *Queries) GetExistingReaction(ctx context.Context, arg GetExistingReactionParams) (string, error) {
	row := q.db.QueryRow(ctx, getExistingReaction, arg.UserID, arg.FaqID)
	var reaction string
	err := row.Scan(&reaction)
	return reaction, err
}

const getFaqByID = `-- name: GetFaqByID :one


select id, company_id, section_id, platform_id, tags, questions, answers, questions_ar, answers_ar, media_urls, created_at, updated_at, status, created_by, likes, dislikes from faqs where id = $1
`

// -- name: DeleteAllFaqMedia :one
// update faqs set media_urls = "" where id = $1 returning *;
func (q *Queries) GetFaqByID(ctx context.Context, id int64) (Faq, error) {
	row := q.db.QueryRow(ctx, getFaqByID, id)
	var i Faq
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SectionID,
		&i.PlatformID,
		&i.Tags,
		&i.Questions,
		&i.Answers,
		&i.QuestionsAr,
		&i.AnswersAr,
		&i.MediaUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CreatedBy,
		&i.Likes,
		&i.Dislikes,
	)
	return i, err
}

const getFaqsByID = `-- name: GetFaqsByID :one
select f.id, f.company_id, f.section_id, f.platform_id, f.tags, f.questions, f.answers, f.questions_ar, f.answers_ar, f.media_urls, f.created_at, f.updated_at, f.status, f.created_by, f.likes, f.dislikes, fu.reaction from faqs f
left join faq_user_reactions fu on fu.faq_id = f.id and fu.user_id = $2
where f.id = $1
`

type GetFaqsByIDParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetFaqsByIDRow struct {
	ID          int64       `json:"id"`
	CompanyID   pgtype.Int8 `json:"company_id"`
	SectionID   pgtype.Int8 `json:"section_id"`
	PlatformID  int64       `json:"platform_id"`
	Tags        []string    `json:"tags"`
	Questions   string      `json:"questions"`
	Answers     string      `json:"answers"`
	QuestionsAr pgtype.Text `json:"questions_ar"`
	AnswersAr   pgtype.Text `json:"answers_ar"`
	MediaUrls   []string    `json:"media_urls"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Status      int64       `json:"status"`
	CreatedBy   int64       `json:"created_by"`
	Likes       pgtype.Int8 `json:"likes"`
	Dislikes    pgtype.Int8 `json:"dislikes"`
	Reaction    pgtype.Text `json:"reaction"`
}

func (q *Queries) GetFaqsByID(ctx context.Context, arg GetFaqsByIDParams) (GetFaqsByIDRow, error) {
	row := q.db.QueryRow(ctx, getFaqsByID, arg.ID, arg.UserID)
	var i GetFaqsByIDRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SectionID,
		&i.PlatformID,
		&i.Tags,
		&i.Questions,
		&i.Answers,
		&i.QuestionsAr,
		&i.AnswersAr,
		&i.MediaUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CreatedBy,
		&i.Likes,
		&i.Dislikes,
		&i.Reaction,
	)
	return i, err
}

const getListingSectionWeb = `-- name: GetListingSectionWeb :one
SELECT id, section_key, title, subtitle, title_ar, sub_title_ar, sort, properties, is_external, is_coming_soon, show_on, platforms, color, icon_path, image_url, view_all_image, created_at, updated_at FROM listing_sections WHERE section_key = $1
`

func (q *Queries) GetListingSectionWeb(ctx context.Context, sectionKey int64) (ListingSection, error) {
	row := q.db.QueryRow(ctx, getListingSectionWeb, sectionKey)
	var i ListingSection
	err := row.Scan(
		&i.ID,
		&i.SectionKey,
		&i.Title,
		&i.Subtitle,
		&i.TitleAr,
		&i.SubTitleAr,
		&i.Sort,
		&i.Properties,
		&i.IsExternal,
		&i.IsComingSoon,
		&i.ShowOn,
		&i.Platforms,
		&i.Color,
		&i.IconPath,
		&i.ImageUrl,
		&i.ViewAllImage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSectionsByID = `-- name: GetSectionsByID :one
SELECT id, title, sub_title, indicator, created_at, updated_at FROM section_permission WHERE id = $1
`

func (q *Queries) GetSectionsByID(ctx context.Context, id int64) (SectionPermission, error) {
	row := q.db.QueryRow(ctx, getSectionsByID, id)
	var i SectionPermission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.SubTitle,
		&i.Indicator,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getfaqsByStatus = `-- name: GetfaqsByStatus :many
select f.id, f.company_id, f.section_id, f.platform_id, f.tags, f.questions, f.answers, f.questions_ar, f.answers_ar, f.media_urls, f.created_at, f.updated_at, f.status, f.created_by, f.likes, f.dislikes, fu.reaction from faqs f 
left join faq_user_reactions fu on fu.faq_id = f.id and fu.user_id = $4
where f.status = $1 
ORDER BY f.updated_at DESC
LIMIT $2
OFFSET $3
`

type GetfaqsByStatusParams struct {
	Status int64 `json:"status"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	UserID int32 `json:"user_id"`
}

type GetfaqsByStatusRow struct {
	ID          int64       `json:"id"`
	CompanyID   pgtype.Int8 `json:"company_id"`
	SectionID   pgtype.Int8 `json:"section_id"`
	PlatformID  int64       `json:"platform_id"`
	Tags        []string    `json:"tags"`
	Questions   string      `json:"questions"`
	Answers     string      `json:"answers"`
	QuestionsAr pgtype.Text `json:"questions_ar"`
	AnswersAr   pgtype.Text `json:"answers_ar"`
	MediaUrls   []string    `json:"media_urls"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Status      int64       `json:"status"`
	CreatedBy   int64       `json:"created_by"`
	Likes       pgtype.Int8 `json:"likes"`
	Dislikes    pgtype.Int8 `json:"dislikes"`
	Reaction    pgtype.Text `json:"reaction"`
}

func (q *Queries) GetfaqsByStatus(ctx context.Context, arg GetfaqsByStatusParams) ([]GetfaqsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getfaqsByStatus,
		arg.Status,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetfaqsByStatusRow
	for rows.Next() {
		var i GetfaqsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.SectionID,
			&i.PlatformID,
			&i.Tags,
			&i.Questions,
			&i.Answers,
			&i.QuestionsAr,
			&i.AnswersAr,
			&i.MediaUrls,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.CreatedBy,
			&i.Likes,
			&i.Dislikes,
			&i.Reaction,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getfaqsByStatusByCompID = `-- name: GetfaqsByStatusByCompID :many
select f.id, f.company_id, f.section_id, f.platform_id, f.tags, f.questions, f.answers, f.questions_ar, f.answers_ar, f.media_urls, f.created_at, f.updated_at, f.status, f.created_by, f.likes, f.dislikes, fu.reaction from faqs f
left join faq_user_reactions fu on fu.faq_id = f.id and fu.user_id = $6
where f.status = $1 and f.company_id = $2 and platform_id = $3
ORDER BY f.updated_at DESC
LIMIT $4
OFFSET $5
`

type GetfaqsByStatusByCompIDParams struct {
	Status     int64       `json:"status"`
	CompanyID  pgtype.Int8 `json:"company_id"`
	PlatformID int64       `json:"platform_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	UserID     int32       `json:"user_id"`
}

type GetfaqsByStatusByCompIDRow struct {
	ID          int64       `json:"id"`
	CompanyID   pgtype.Int8 `json:"company_id"`
	SectionID   pgtype.Int8 `json:"section_id"`
	PlatformID  int64       `json:"platform_id"`
	Tags        []string    `json:"tags"`
	Questions   string      `json:"questions"`
	Answers     string      `json:"answers"`
	QuestionsAr pgtype.Text `json:"questions_ar"`
	AnswersAr   pgtype.Text `json:"answers_ar"`
	MediaUrls   []string    `json:"media_urls"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Status      int64       `json:"status"`
	CreatedBy   int64       `json:"created_by"`
	Likes       pgtype.Int8 `json:"likes"`
	Dislikes    pgtype.Int8 `json:"dislikes"`
	Reaction    pgtype.Text `json:"reaction"`
}

func (q *Queries) GetfaqsByStatusByCompID(ctx context.Context, arg GetfaqsByStatusByCompIDParams) ([]GetfaqsByStatusByCompIDRow, error) {
	rows, err := q.db.Query(ctx, getfaqsByStatusByCompID,
		arg.Status,
		arg.CompanyID,
		arg.PlatformID,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetfaqsByStatusByCompIDRow
	for rows.Next() {
		var i GetfaqsByStatusByCompIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.SectionID,
			&i.PlatformID,
			&i.Tags,
			&i.Questions,
			&i.Answers,
			&i.QuestionsAr,
			&i.AnswersAr,
			&i.MediaUrls,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.CreatedBy,
			&i.Likes,
			&i.Dislikes,
			&i.Reaction,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFaqReaction = `-- name: InsertFaqReaction :one
INSERT INTO faq_user_reactions (user_id, faq_id, reaction)
VALUES ($1, $2, $3)
RETURNING id, user_id, faq_id, reaction, created_at, updated_at
`

type InsertFaqReactionParams struct {
	UserID   int32  `json:"user_id"`
	FaqID    int32  `json:"faq_id"`
	Reaction string `json:"reaction"`
}

func (q *Queries) InsertFaqReaction(ctx context.Context, arg InsertFaqReactionParams) (FaqUserReaction, error) {
	row := q.db.QueryRow(ctx, insertFaqReaction, arg.UserID, arg.FaqID, arg.Reaction)
	var i FaqUserReaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FaqID,
		&i.Reaction,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateExistingReaction = `-- name: UpdateExistingReaction :one
UPDATE faq_user_reactions
SET reaction = 'none', updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND faq_id = $2
RETURNING id, user_id, faq_id, reaction, created_at, updated_at
`

type UpdateExistingReactionParams struct {
	UserID int32 `json:"user_id"`
	FaqID  int32 `json:"faq_id"`
}

func (q *Queries) UpdateExistingReaction(ctx context.Context, arg UpdateExistingReactionParams) (FaqUserReaction, error) {
	row := q.db.QueryRow(ctx, updateExistingReaction, arg.UserID, arg.FaqID)
	var i FaqUserReaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FaqID,
		&i.Reaction,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFaqByID = `-- name: UpdateFaqByID :one
UPDATE faqs 
SET 
    company_id = $1,
    section_id = $2,
    platform_id = $14,
    tags = $3,
    questions = $4,
    answers = $5,
    media_urls = $6,
    created_at = $7,
    updated_at = $8,
    created_by = $9,
    status = $10,
    questions_ar = $11,
    answers_ar = $12
WHERE id = $13
RETURNING id, company_id, section_id, platform_id, tags, questions, answers, questions_ar, answers_ar, media_urls, created_at, updated_at, status, created_by, likes, dislikes
`

type UpdateFaqByIDParams struct {
	CompanyID   pgtype.Int8 `json:"company_id"`
	SectionID   pgtype.Int8 `json:"section_id"`
	Tags        []string    `json:"tags"`
	Questions   string      `json:"questions"`
	Answers     string      `json:"answers"`
	MediaUrls   []string    `json:"media_urls"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	CreatedBy   int64       `json:"created_by"`
	Status      int64       `json:"status"`
	QuestionsAr pgtype.Text `json:"questions_ar"`
	AnswersAr   pgtype.Text `json:"answers_ar"`
	ID          int64       `json:"id"`
	PlatformID  int64       `json:"platform_id"`
}

func (q *Queries) UpdateFaqByID(ctx context.Context, arg UpdateFaqByIDParams) (Faq, error) {
	row := q.db.QueryRow(ctx, updateFaqByID,
		arg.CompanyID,
		arg.SectionID,
		arg.Tags,
		arg.Questions,
		arg.Answers,
		arg.MediaUrls,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.Status,
		arg.QuestionsAr,
		arg.AnswersAr,
		arg.ID,
		arg.PlatformID,
	)
	var i Faq
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SectionID,
		&i.PlatformID,
		&i.Tags,
		&i.Questions,
		&i.Answers,
		&i.QuestionsAr,
		&i.AnswersAr,
		&i.MediaUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CreatedBy,
		&i.Likes,
		&i.Dislikes,
	)
	return i, err
}

const updateFaqMedia = `-- name: UpdateFaqMedia :one
update faqs set media_urls = $1 where id = $2 returning id, company_id, section_id, platform_id, tags, questions, answers, questions_ar, answers_ar, media_urls, created_at, updated_at, status, created_by, likes, dislikes
`

type UpdateFaqMediaParams struct {
	MediaUrls []string `json:"media_urls"`
	ID        int64    `json:"id"`
}

func (q *Queries) UpdateFaqMedia(ctx context.Context, arg UpdateFaqMediaParams) (Faq, error) {
	row := q.db.QueryRow(ctx, updateFaqMedia, arg.MediaUrls, arg.ID)
	var i Faq
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SectionID,
		&i.PlatformID,
		&i.Tags,
		&i.Questions,
		&i.Answers,
		&i.QuestionsAr,
		&i.AnswersAr,
		&i.MediaUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CreatedBy,
		&i.Likes,
		&i.Dislikes,
	)
	return i, err
}

const updateFaqReactionCounts = `-- name: UpdateFaqReactionCounts :one
UPDATE faqs
SET 
  likes = likes + $1,
  dislikes = dislikes + $2
WHERE id = $3
RETURNING id, company_id, section_id, platform_id, tags, questions, answers, questions_ar, answers_ar, media_urls, created_at, updated_at, status, created_by, likes, dislikes
`

type UpdateFaqReactionCountsParams struct {
	LikeDelta    pgtype.Int8 `json:"like_delta"`
	DislikeDelta pgtype.Int8 `json:"dislike_delta"`
	ID           int64       `json:"id"`
}

func (q *Queries) UpdateFaqReactionCounts(ctx context.Context, arg UpdateFaqReactionCountsParams) (Faq, error) {
	row := q.db.QueryRow(ctx, updateFaqReactionCounts, arg.LikeDelta, arg.DislikeDelta, arg.ID)
	var i Faq
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SectionID,
		&i.PlatformID,
		&i.Tags,
		&i.Questions,
		&i.Answers,
		&i.QuestionsAr,
		&i.AnswersAr,
		&i.MediaUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CreatedBy,
		&i.Likes,
		&i.Dislikes,
	)
	return i, err
}

const updateFaqStatus = `-- name: UpdateFaqStatus :one
UPDATE faqs
SET status = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, company_id, section_id, platform_id, tags, questions, answers, questions_ar, answers_ar, media_urls, created_at, updated_at, status, created_by, likes, dislikes
`

type UpdateFaqStatusParams struct {
	Status int64 `json:"status"`
	ID     int64 `json:"id"`
}

func (q *Queries) UpdateFaqStatus(ctx context.Context, arg UpdateFaqStatusParams) (Faq, error) {
	row := q.db.QueryRow(ctx, updateFaqStatus, arg.Status, arg.ID)
	var i Faq
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.SectionID,
		&i.PlatformID,
		&i.Tags,
		&i.Questions,
		&i.Answers,
		&i.QuestionsAr,
		&i.AnswersAr,
		&i.MediaUrls,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.CreatedBy,
		&i.Likes,
		&i.Dislikes,
	)
	return i, err
}
