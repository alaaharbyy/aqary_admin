// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: refresh_schedules.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpdateProjectsRefreshedAt = `-- name: BulkUpdateProjectsRefreshedAt :one
WITH updated AS ( 
  UPDATE projects 
  SET refreshed_at = $1 
  WHERE id = ANY($2::bigint[]) 
  RETURNING id 
) 
SELECT array_agg(id)::bigint[] AS updated_ids 
FROM updated
`

type BulkUpdateProjectsRefreshedAtParams struct {
	RefreshedAt pgtype.Timestamptz `json:"refreshed_at"`
	EntityIds   []int64            `json:"entity_ids"`
}

func (q *Queries) BulkUpdateProjectsRefreshedAt(ctx context.Context, arg BulkUpdateProjectsRefreshedAtParams) ([]int64, error) {
	row := q.db.QueryRow(ctx, bulkUpdateProjectsRefreshedAt, arg.RefreshedAt, arg.EntityIds)
	var updated_ids []int64
	err := row.Scan(&updated_ids)
	return updated_ids, err
}

const bulkUpdatePropertyVersionsRefreshedAt = `-- name: BulkUpdatePropertyVersionsRefreshedAt :one
WITH updated AS ( 
  UPDATE property_versions 
  SET refreshed_at = $1 
  WHERE id = ANY($2::bigint[]) 
  RETURNING id 
) 
SELECT array_agg(id)::bigint[] AS updated_ids 
FROM updated
`

type BulkUpdatePropertyVersionsRefreshedAtParams struct {
	RefreshedAt pgtype.Timestamptz `json:"refreshed_at"`
	EntityIds   []int64            `json:"entity_ids"`
}

func (q *Queries) BulkUpdatePropertyVersionsRefreshedAt(ctx context.Context, arg BulkUpdatePropertyVersionsRefreshedAtParams) ([]int64, error) {
	row := q.db.QueryRow(ctx, bulkUpdatePropertyVersionsRefreshedAt, arg.RefreshedAt, arg.EntityIds)
	var updated_ids []int64
	err := row.Scan(&updated_ids)
	return updated_ids, err
}

const bulkUpdateRefreshSchedule = `-- name: BulkUpdateRefreshSchedule :exec
UPDATE refresh_schedules 
SET  
    schedule_type = $1, 
    next_run_at = $2, 
    last_run_at = COALESCE($8,next_run_at), 
    preferred_hour = $3, 
    preferred_minute = $4, 
    week_days = $5, 
    updated_at = $6,
    status=$7
WHERE id = ANY($9::bigint[])
`

type BulkUpdateRefreshScheduleParams struct {
	ScheduleType    string             `json:"schedule_type"`
	NextRunAt       time.Time          `json:"next_run_at"`
	PreferredHour   int32              `json:"preferred_hour"`
	PreferredMinute int32              `json:"preferred_minute"`
	WeekDays        []int16            `json:"week_days"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	Status          int64              `json:"status"`
	LastRunAt       pgtype.Timestamptz `json:"last_run_at"`
	Ids             []int64            `json:"ids"`
}

func (q *Queries) BulkUpdateRefreshSchedule(ctx context.Context, arg BulkUpdateRefreshScheduleParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateRefreshSchedule,
		arg.ScheduleType,
		arg.NextRunAt,
		arg.PreferredHour,
		arg.PreferredMinute,
		arg.WeekDays,
		arg.UpdatedAt,
		arg.Status,
		arg.LastRunAt,
		arg.Ids,
	)
	return err
}

const bulkUpdateUnitVersionsRefreshedAt = `-- name: BulkUpdateUnitVersionsRefreshedAt :one
WITH updated AS ( 
  UPDATE unit_versions 
  SET refreshed_at = $1 
  WHERE id = ANY($2::bigint[]) 
  RETURNING id 
) 
SELECT array_agg(id)::bigint[] AS updated_ids 
FROM updated
`

type BulkUpdateUnitVersionsRefreshedAtParams struct {
	RefreshedAt pgtype.Timestamptz `json:"refreshed_at"`
	EntityIds   []int64            `json:"entity_ids"`
}

func (q *Queries) BulkUpdateUnitVersionsRefreshedAt(ctx context.Context, arg BulkUpdateUnitVersionsRefreshedAtParams) ([]int64, error) {
	row := q.db.QueryRow(ctx, bulkUpdateUnitVersionsRefreshedAt, arg.RefreshedAt, arg.EntityIds)
	var updated_ids []int64
	err := row.Scan(&updated_ids)
	return updated_ids, err
}

const checkExistingRefreshSchedule = `-- name: CheckExistingRefreshSchedule :one
WITH existing AS (
  SELECT id, status
  FROM refresh_schedules 
  WHERE entity_id = $1 AND entity_type_id = $2 
  LIMIT 1
)
SELECT 
  COALESCE((SELECT id FROM existing)::bigint, -1)::bigint AS result_id,
  COALESCE((SELECT status FROM existing)::bigint, 0)::bigint AS result_status
`

type CheckExistingRefreshScheduleParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int32 `json:"entity_type_id"`
}

type CheckExistingRefreshScheduleRow struct {
	ResultID     int64 `json:"result_id"`
	ResultStatus int64 `json:"result_status"`
}

func (q *Queries) CheckExistingRefreshSchedule(ctx context.Context, arg CheckExistingRefreshScheduleParams) (CheckExistingRefreshScheduleRow, error) {
	row := q.db.QueryRow(ctx, checkExistingRefreshSchedule, arg.EntityID, arg.EntityTypeID)
	var i CheckExistingRefreshScheduleRow
	err := row.Scan(&i.ResultID, &i.ResultStatus)
	return i, err
}

const createRefreshSchedule = `-- name: CreateRefreshSchedule :one
INSERT INTO refresh_schedules ( entity_id, entity_type_id, schedule_type, next_run_at,last_run_at, preferred_hour, preferred_minute, week_days, status, created_by ) 
VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9,$10) RETURNING id
`

type CreateRefreshScheduleParams struct {
	EntityID        int64              `json:"entity_id"`
	EntityTypeID    int32              `json:"entity_type_id"`
	ScheduleType    string             `json:"schedule_type"`
	NextRunAt       time.Time          `json:"next_run_at"`
	LastRunAt       pgtype.Timestamptz `json:"last_run_at"`
	PreferredHour   int32              `json:"preferred_hour"`
	PreferredMinute int32              `json:"preferred_minute"`
	WeekDays        []int16            `json:"week_days"`
	Status          int64              `json:"status"`
	CreatedBy       int64              `json:"created_by"`
}

func (q *Queries) CreateRefreshSchedule(ctx context.Context, arg CreateRefreshScheduleParams) (int64, error) {
	row := q.db.QueryRow(ctx, createRefreshSchedule,
		arg.EntityID,
		arg.EntityTypeID,
		arg.ScheduleType,
		arg.NextRunAt,
		arg.LastRunAt,
		arg.PreferredHour,
		arg.PreferredMinute,
		arg.WeekDays,
		arg.Status,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getExistingRefreshSchedules = `-- name: GetExistingRefreshSchedules :many
SELECT id, entity_id, entity_type_id, schedule_type, next_run_at, last_run_at, preferred_hour, preferred_minute, week_days, status, created_by, created_at, updated_at FROM refresh_schedules WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetExistingRefreshSchedules(ctx context.Context, ids []int64) ([]RefreshSchedule, error) {
	rows, err := q.db.Query(ctx, getExistingRefreshSchedules, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RefreshSchedule
	for rows.Next() {
		var i RefreshSchedule
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.EntityTypeID,
			&i.ScheduleType,
			&i.NextRunAt,
			&i.LastRunAt,
			&i.PreferredHour,
			&i.PreferredMinute,
			&i.WeekDays,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefreshScheduleByID = `-- name: GetRefreshScheduleByID :one
SELECT id, entity_id, entity_type_id, schedule_type, next_run_at, last_run_at, preferred_hour, preferred_minute, week_days, status, created_by, created_at, updated_at FROM refresh_schedules WHERE id = $1
`

func (q *Queries) GetRefreshScheduleByID(ctx context.Context, id int64) (RefreshSchedule, error) {
	row := q.db.QueryRow(ctx, getRefreshScheduleByID, id)
	var i RefreshSchedule
	err := row.Scan(
		&i.ID,
		&i.EntityID,
		&i.EntityTypeID,
		&i.ScheduleType,
		&i.NextRunAt,
		&i.LastRunAt,
		&i.PreferredHour,
		&i.PreferredMinute,
		&i.WeekDays,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRefreshScheduleIdsMap = `-- name: GetRefreshScheduleIdsMap :many
SELECT entity_id, id,last_run_at FROM refresh_schedules WHERE entity_type_id = $1 AND entity_id = ANY($2::bigint[])
`

type GetRefreshScheduleIdsMapParams struct {
	EntityTypeID int32   `json:"entity_type_id"`
	Column2      []int64 `json:"column_2"`
}

type GetRefreshScheduleIdsMapRow struct {
	EntityID  int64              `json:"entity_id"`
	ID        int64              `json:"id"`
	LastRunAt pgtype.Timestamptz `json:"last_run_at"`
}

func (q *Queries) GetRefreshScheduleIdsMap(ctx context.Context, arg GetRefreshScheduleIdsMapParams) ([]GetRefreshScheduleIdsMapRow, error) {
	rows, err := q.db.Query(ctx, getRefreshScheduleIdsMap, arg.EntityTypeID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRefreshScheduleIdsMapRow
	for rows.Next() {
		var i GetRefreshScheduleIdsMapRow
		if err := rows.Scan(&i.EntityID, &i.ID, &i.LastRunAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulesByEntity = `-- name: GetSchedulesByEntity :many
SELECT refresh_schedules.id, refresh_schedules.entity_id, refresh_schedules.entity_type_id, refresh_schedules.schedule_type, refresh_schedules.next_run_at, refresh_schedules.last_run_at, refresh_schedules.preferred_hour, refresh_schedules.preferred_minute, refresh_schedules.week_days, refresh_schedules.status, refresh_schedules.created_by, refresh_schedules.created_at, refresh_schedules.updated_at FROM refresh_schedules 
WHERE entity_id = $1 AND entity_type_id = $2
`

type GetSchedulesByEntityParams struct {
	EntityID     int64 `json:"entity_id"`
	EntityTypeID int32 `json:"entity_type_id"`
}

type GetSchedulesByEntityRow struct {
	RefreshSchedule RefreshSchedule `json:"refresh_schedule"`
}

func (q *Queries) GetSchedulesByEntity(ctx context.Context, arg GetSchedulesByEntityParams) ([]GetSchedulesByEntityRow, error) {
	rows, err := q.db.Query(ctx, getSchedulesByEntity, arg.EntityID, arg.EntityTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchedulesByEntityRow
	for rows.Next() {
		var i GetSchedulesByEntityRow
		if err := rows.Scan(
			&i.RefreshSchedule.ID,
			&i.RefreshSchedule.EntityID,
			&i.RefreshSchedule.EntityTypeID,
			&i.RefreshSchedule.ScheduleType,
			&i.RefreshSchedule.NextRunAt,
			&i.RefreshSchedule.LastRunAt,
			&i.RefreshSchedule.PreferredHour,
			&i.RefreshSchedule.PreferredMinute,
			&i.RefreshSchedule.WeekDays,
			&i.RefreshSchedule.Status,
			&i.RefreshSchedule.CreatedBy,
			&i.RefreshSchedule.CreatedAt,
			&i.RefreshSchedule.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingSchedules = `-- name: GetUpcomingSchedules :many
SELECT refresh_schedules.id, refresh_schedules.entity_id, refresh_schedules.entity_type_id, refresh_schedules.schedule_type, refresh_schedules.next_run_at, refresh_schedules.last_run_at, refresh_schedules.preferred_hour, refresh_schedules.preferred_minute, refresh_schedules.week_days, refresh_schedules.status, refresh_schedules.created_by, refresh_schedules.created_at, refresh_schedules.updated_at FROM refresh_schedules 
WHERE next_run_at  <= NOW() 
ORDER BY next_run_at ASC
`

type GetUpcomingSchedulesRow struct {
	RefreshSchedule RefreshSchedule `json:"refresh_schedule"`
}

// AT TIME ZONE 'Asia/Dubai'
func (q *Queries) GetUpcomingSchedules(ctx context.Context) ([]GetUpcomingSchedulesRow, error) {
	rows, err := q.db.Query(ctx, getUpcomingSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUpcomingSchedulesRow
	for rows.Next() {
		var i GetUpcomingSchedulesRow
		if err := rows.Scan(
			&i.RefreshSchedule.ID,
			&i.RefreshSchedule.EntityID,
			&i.RefreshSchedule.EntityTypeID,
			&i.RefreshSchedule.ScheduleType,
			&i.RefreshSchedule.NextRunAt,
			&i.RefreshSchedule.LastRunAt,
			&i.RefreshSchedule.PreferredHour,
			&i.RefreshSchedule.PreferredMinute,
			&i.RefreshSchedule.WeekDays,
			&i.RefreshSchedule.Status,
			&i.RefreshSchedule.CreatedBy,
			&i.RefreshSchedule.CreatedAt,
			&i.RefreshSchedule.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshProject = `-- name: RefreshProject :exec
UPDATE projects SET refreshed_at = $2 WHERE id = $1 AND status= $3::bigint
`

type RefreshProjectParams struct {
	ID              int64              `json:"id"`
	RefreshedAt     pgtype.Timestamptz `json:"refreshed_at"`
	AvailableStatus int64              `json:"available_status"`
}

func (q *Queries) RefreshProject(ctx context.Context, arg RefreshProjectParams) error {
	_, err := q.db.Exec(ctx, refreshProject, arg.ID, arg.RefreshedAt, arg.AvailableStatus)
	return err
}

const refreshPropertyVersion = `-- name: RefreshPropertyVersion :exec
UPDATE property_versions SET refreshed_at = $2 WHERE id = $1 AND status= $3::bigint
`

type RefreshPropertyVersionParams struct {
	ID              int64              `json:"id"`
	RefreshedAt     pgtype.Timestamptz `json:"refreshed_at"`
	AvailableStatus int64              `json:"available_status"`
}

func (q *Queries) RefreshPropertyVersion(ctx context.Context, arg RefreshPropertyVersionParams) error {
	_, err := q.db.Exec(ctx, refreshPropertyVersion, arg.ID, arg.RefreshedAt, arg.AvailableStatus)
	return err
}

const refreshUnitVersion = `-- name: RefreshUnitVersion :exec
UPDATE unit_versions SET refreshed_at = $2 WHERE id = $1 AND status= $3::bigint
`

type RefreshUnitVersionParams struct {
	ID              int64              `json:"id"`
	RefreshedAt     pgtype.Timestamptz `json:"refreshed_at"`
	AvailableStatus int64              `json:"available_status"`
}

func (q *Queries) RefreshUnitVersion(ctx context.Context, arg RefreshUnitVersionParams) error {
	_, err := q.db.Exec(ctx, refreshUnitVersion, arg.ID, arg.RefreshedAt, arg.AvailableStatus)
	return err
}

const updateRefreshSchedule = `-- name: UpdateRefreshSchedule :exec
UPDATE refresh_schedules 
SET  
    schedule_type = $2, 
    next_run_at = $3, 
    last_run_at = $4, 
    preferred_hour = $5, 
    preferred_minute = $6, 
    week_days = $7, 
    updated_at = $8,
    status=$9
WHERE id = $1
`

type UpdateRefreshScheduleParams struct {
	ID              int64              `json:"id"`
	ScheduleType    string             `json:"schedule_type"`
	NextRunAt       time.Time          `json:"next_run_at"`
	LastRunAt       pgtype.Timestamptz `json:"last_run_at"`
	PreferredHour   int32              `json:"preferred_hour"`
	PreferredMinute int32              `json:"preferred_minute"`
	WeekDays        []int16            `json:"week_days"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	Status          int64              `json:"status"`
}

func (q *Queries) UpdateRefreshSchedule(ctx context.Context, arg UpdateRefreshScheduleParams) error {
	_, err := q.db.Exec(ctx, updateRefreshSchedule,
		arg.ID,
		arg.ScheduleType,
		arg.NextRunAt,
		arg.LastRunAt,
		arg.PreferredHour,
		arg.PreferredMinute,
		arg.WeekDays,
		arg.UpdatedAt,
		arg.Status,
	)
	return err
}

const updateRefreshScheduleStatus = `-- name: UpdateRefreshScheduleStatus :exec
UPDATE refresh_schedules 
SET status = $2,
    updated_at = $3
WHERE id = $1
`

type UpdateRefreshScheduleStatusParams struct {
	ID        int64              `json:"id"`
	Status    int64              `json:"status"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateRefreshScheduleStatus(ctx context.Context, arg UpdateRefreshScheduleStatusParams) error {
	_, err := q.db.Exec(ctx, updateRefreshScheduleStatus, arg.ID, arg.Status, arg.UpdatedAt)
	return err
}

const updateScheduleRunTimes = `-- name: UpdateScheduleRunTimes :exec
UPDATE refresh_schedules 
SET next_run_at = $2, last_run_at = $3, updated_at = $4
WHERE id = $1
`

type UpdateScheduleRunTimesParams struct {
	ID        int64              `json:"id"`
	NextRunAt time.Time          `json:"next_run_at"`
	LastRunAt pgtype.Timestamptz `json:"last_run_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateScheduleRunTimes(ctx context.Context, arg UpdateScheduleRunTimesParams) error {
	_, err := q.db.Exec(ctx, updateScheduleRunTimes,
		arg.ID,
		arg.NextRunAt,
		arg.LastRunAt,
		arg.UpdatedAt,
	)
	return err
}
