// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_promotions.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProjectPromotions = `-- name: CreateProjectPromotions :one
INSERT INTO project_promotions (
    promotion_types_id,
    description,
    expiry_date,
    status,
    projects_id,
    created_at,
    updated_at, 
    live_status,
    ref_no,
    phases_id,
    is_phase
)VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, promotion_types_id, description, expiry_date, status, projects_id, phases_id, created_at, updated_at, live_status, ref_no, is_phase
`

type CreateProjectPromotionsParams struct {
	PromotionTypesID int64       `json:"promotion_types_id"`
	Description      string      `json:"description"`
	ExpiryDate       time.Time   `json:"expiry_date"`
	Status           int64       `json:"status"`
	ProjectsID       int64       `json:"projects_id"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	LiveStatus       pgtype.Bool `json:"live_status"`
	RefNo            string      `json:"ref_no"`
	PhasesID         pgtype.Int8 `json:"phases_id"`
	IsPhase          pgtype.Bool `json:"is_phase"`
}

func (q *Queries) CreateProjectPromotions(ctx context.Context, arg CreateProjectPromotionsParams) (ProjectPromotion, error) {
	row := q.db.QueryRow(ctx, createProjectPromotions,
		arg.PromotionTypesID,
		arg.Description,
		arg.ExpiryDate,
		arg.Status,
		arg.ProjectsID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LiveStatus,
		arg.RefNo,
		arg.PhasesID,
		arg.IsPhase,
	)
	var i ProjectPromotion
	err := row.Scan(
		&i.ID,
		&i.PromotionTypesID,
		&i.Description,
		&i.ExpiryDate,
		&i.Status,
		&i.ProjectsID,
		&i.PhasesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LiveStatus,
		&i.RefNo,
		&i.IsPhase,
	)
	return i, err
}

const deleteAllProjectPromotionsByPromotionTypeId = `-- name: DeleteAllProjectPromotionsByPromotionTypeId :exec
DELETE FROM project_promotions
Where promotion_types_id = $1
`

func (q *Queries) DeleteAllProjectPromotionsByPromotionTypeId(ctx context.Context, promotionTypesID int64) error {
	_, err := q.db.Exec(ctx, deleteAllProjectPromotionsByPromotionTypeId, promotionTypesID)
	return err
}

const deleteProjectPromotions = `-- name: DeleteProjectPromotions :exec
DELETE FROM project_promotions
Where id = $1
`

func (q *Queries) DeleteProjectPromotions(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectPromotions, id)
	return err
}

const getAllProjectPromotionByProjectID = `-- name: GetAllProjectPromotionByProjectID :many
SELECT pp.id, pp.promotion_types_id, pp.description, pp.expiry_date, pp.status, pp.projects_id, pp.phases_id, pp.created_at, pp.updated_at, pp.live_status, pp.ref_no, pp.is_phase FROM project_promotions pp
INNER JOIN projects p ON p.id = pp.projects_id 
INNER JOIN addresses a ON a.id = p.addresses_id
WHERE
CASE WHEN projects_id = $3 AND is_phase = FALSE AND phases_id IS NULL THEN TRUE
ELSE is_phase = TRUE AND phases_id = $4 
AND a.countries_id = $5::bigint AND CASE WHEN $6::bigint = 0 Then true ELSE a.cities_id = $6::bigint END AND CASE WHEN $7::bigint = 0 THEN true ELSE a.communities_id = $7::bigint END
 AND CASE WHEN $8::bigint = 0 THEN true ELSE a.sub_communities_id = $8::bigint END
AND pp.status !=5 AND pp.status != 6 END ORDER BY PP.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllProjectPromotionByProjectIDParams struct {
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
	ProjectsID     int64       `json:"projects_id"`
	PhasesID       pgtype.Int8 `json:"phases_id"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
}

func (q *Queries) GetAllProjectPromotionByProjectID(ctx context.Context, arg GetAllProjectPromotionByProjectIDParams) ([]ProjectPromotion, error) {
	rows, err := q.db.Query(ctx, getAllProjectPromotionByProjectID,
		arg.Limit,
		arg.Offset,
		arg.ProjectsID,
		arg.PhasesID,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectPromotion
	for rows.Next() {
		var i ProjectPromotion
		if err := rows.Scan(
			&i.ID,
			&i.PromotionTypesID,
			&i.Description,
			&i.ExpiryDate,
			&i.Status,
			&i.ProjectsID,
			&i.PhasesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LiveStatus,
			&i.RefNo,
			&i.IsPhase,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPromotionByProjectIDWithoutPagination = `-- name: GetAllProjectPromotionByProjectIDWithoutPagination :many
SELECT pp.id, pp.promotion_types_id, pp.description, pp.expiry_date, pp.status, pp.projects_id, pp.phases_id, pp.created_at, pp.updated_at, pp.live_status, pp.ref_no, pp.is_phase FROM project_promotions pp
INNER JOIN projects p ON p.id = pp.projects_id 
INNER JOIN addresses a ON a.id = p.addresses_id
WHERE projects_id = $1
AND pp.status !=5 AND pp.status != 6
ORDER BY PP.created_at DESC
`

// AND a.countries_id = @country_id::bigint
// AND CASE WHEN @city_id::bigint = 0 Then true ELSE a.cities_id = @city_id::bigint END
// AND CASE WHEN @community_id::bigint = 0 THEN true ELSE a.communities_id = @community_id::bigint END
// AND CASE WHEN @sub_community_id::bigint = 0 THEN true ELSE a.sub_communities_id = @sub_community_id::bigint END
func (q *Queries) GetAllProjectPromotionByProjectIDWithoutPagination(ctx context.Context, projectsID int64) ([]ProjectPromotion, error) {
	rows, err := q.db.Query(ctx, getAllProjectPromotionByProjectIDWithoutPagination, projectsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectPromotion
	for rows.Next() {
		var i ProjectPromotion
		if err := rows.Scan(
			&i.ID,
			&i.PromotionTypesID,
			&i.Description,
			&i.ExpiryDate,
			&i.Status,
			&i.ProjectsID,
			&i.PhasesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LiveStatus,
			&i.RefNo,
			&i.IsPhase,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectPromotions = `-- name: GetAllProjectPromotions :many
SELECT id, promotion_types_id, description, expiry_date, status, projects_id, phases_id, created_at, updated_at, live_status, ref_no, is_phase FROM project_promotions
ORDER BY id
LIMIT $1
OFFSET $2
`

type GetAllProjectPromotionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProjectPromotions(ctx context.Context, arg GetAllProjectPromotionsParams) ([]ProjectPromotion, error) {
	rows, err := q.db.Query(ctx, getAllProjectPromotions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectPromotion
	for rows.Next() {
		var i ProjectPromotion
		if err := rows.Scan(
			&i.ID,
			&i.PromotionTypesID,
			&i.Description,
			&i.ExpiryDate,
			&i.Status,
			&i.ProjectsID,
			&i.PhasesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LiveStatus,
			&i.RefNo,
			&i.IsPhase,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectsByPromotion = `-- name: GetAllProjectsByPromotion :many
SELECT p.id, p.project_name, p.ref_number, p.no_of_views, p.is_verified, p.project_rank, p.addresses_id, p.status, p.developer_companies_id, p.developer_company_branches_id, p.countries_id, p.created_at, p.updated_at, p.is_multiphase, p.live_status, p.project_no, p.license_no, p.users_id, p.description, p.description_arabic, p.rating, p.polygon_coords, p.facts, p.exclusive, p.start_date, p.end_date, p.slug, p.deleted_at, p.bank_name, p.registration_date, p.escrow_number, p.refreshed_at FROM projects p JOIN project_promotions pp ON p.id = pp.projects_id LIMIT $1 OFFSET $2
`

type GetAllProjectsByPromotionParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProjectsByPromotion(ctx context.Context, arg GetAllProjectsByPromotionParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getAllProjectsByPromotion, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ProjectName,
			&i.RefNumber,
			&i.NoOfViews,
			&i.IsVerified,
			&i.ProjectRank,
			&i.AddressesID,
			&i.Status,
			&i.DeveloperCompaniesID,
			&i.DeveloperCompanyBranchesID,
			&i.CountriesID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMultiphase,
			&i.LiveStatus,
			&i.ProjectNo,
			&i.LicenseNo,
			&i.UsersID,
			&i.Description,
			&i.DescriptionArabic,
			&i.Rating,
			&i.PolygonCoords,
			&i.Facts,
			&i.Exclusive,
			&i.StartDate,
			&i.EndDate,
			&i.Slug,
			&i.DeletedAt,
			&i.BankName,
			&i.RegistrationDate,
			&i.EscrowNumber,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountAllProjectPromotionByProjectID = `-- name: GetCountAllProjectPromotionByProjectID :one
SELECT COUNT(pp.id) FROM project_promotions pp
INNER JOIN projects p ON p.id = pp.projects_id 
INNER JOIN addresses a ON a.id = p.addresses_id
WHERE
CASE WHEN pp.projects_id = $1 AND pp.is_phase = FALSE AND pp.phases_id IS NULL THEN TRUE
ELSE pp.is_phase = TRUE AND pp.phases_id = $2 END
AND a.countries_id = $3::bigint AND CASE WHEN $4::bigint = 0 Then true ELSE a.cities_id = $4::bigint END 
AND CASE WHEN $5::bigint = 0 THEN true ELSE a.communities_id = $5::bigint END
AND CASE WHEN $6::bigint = 0 THEN true ELSE a.sub_communities_id = $6::bigint END
AND pp.status !=5 AND pp.status != 6
`

type GetCountAllProjectPromotionByProjectIDParams struct {
	ProjectsID     int64       `json:"projects_id"`
	PhasesID       pgtype.Int8 `json:"phases_id"`
	CountryID      int64       `json:"country_id"`
	CityID         int64       `json:"city_id"`
	CommunityID    int64       `json:"community_id"`
	SubCommunityID int64       `json:"sub_community_id"`
}

func (q *Queries) GetCountAllProjectPromotionByProjectID(ctx context.Context, arg GetCountAllProjectPromotionByProjectIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountAllProjectPromotionByProjectID,
		arg.ProjectsID,
		arg.PhasesID,
		arg.CountryID,
		arg.CityID,
		arg.CommunityID,
		arg.SubCommunityID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCountPromotionsByProjects = `-- name: GetCountPromotionsByProjects :one
SELECT COUNT(DISTINCT projects_id) AS project_count FROM project_promotions
`

func (q *Queries) GetCountPromotionsByProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountPromotionsByProjects)
	var project_count int64
	err := row.Scan(&project_count)
	return project_count, err
}

const getProjectPromotionByProjectAndPhaseID = `-- name: GetProjectPromotionByProjectAndPhaseID :one
SELECT id, promotion_types_id, description, expiry_date, status, projects_id, phases_id, created_at, updated_at, live_status, ref_no, is_phase FROM project_promotions
WHERE
CASE WHEN projects_id = $1 AND is_phase = FALSE AND phases_id IS NULL THEN TRUE
ELSE is_phase = TRUE AND phases_id = $2 END
`

type GetProjectPromotionByProjectAndPhaseIDParams struct {
	ProjectsID int64       `json:"projects_id"`
	PhasesID   pgtype.Int8 `json:"phases_id"`
}

func (q *Queries) GetProjectPromotionByProjectAndPhaseID(ctx context.Context, arg GetProjectPromotionByProjectAndPhaseIDParams) (ProjectPromotion, error) {
	row := q.db.QueryRow(ctx, getProjectPromotionByProjectAndPhaseID, arg.ProjectsID, arg.PhasesID)
	var i ProjectPromotion
	err := row.Scan(
		&i.ID,
		&i.PromotionTypesID,
		&i.Description,
		&i.ExpiryDate,
		&i.Status,
		&i.ProjectsID,
		&i.PhasesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LiveStatus,
		&i.RefNo,
		&i.IsPhase,
	)
	return i, err
}

const getProjectPromotions = `-- name: GetProjectPromotions :one
SELECT project_promotions.id, project_promotions.promotion_types_id, project_promotions.description, project_promotions.expiry_date, project_promotions.status, project_promotions.projects_id, project_promotions.phases_id, project_promotions.created_at, project_promotions.updated_at, project_promotions.live_status, project_promotions.ref_no, project_promotions.is_phase,
CASE WHEN phases_id IS NULL THEN projects.project_name::VARCHAR ELSE phases.phase_name::VARCHAR END AS project_phase_name,
promotion_types.types AS promotion_type
FROM project_promotions
LEFT JOIN projects ON projects.id = project_promotions.projects_id AND  phases_id IS NULL
LEFT JOIN phases ON phases.id = project_promotions.phases_id
INNER JOIN promotion_types ON promotion_types.id = project_promotions.promotion_types_id
WHERE project_promotions.id = $1 LIMIT 1
`

type GetProjectPromotionsRow struct {
	ID               int64       `json:"id"`
	PromotionTypesID int64       `json:"promotion_types_id"`
	Description      string      `json:"description"`
	ExpiryDate       time.Time   `json:"expiry_date"`
	Status           int64       `json:"status"`
	ProjectsID       int64       `json:"projects_id"`
	PhasesID         pgtype.Int8 `json:"phases_id"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	LiveStatus       pgtype.Bool `json:"live_status"`
	RefNo            string      `json:"ref_no"`
	IsPhase          pgtype.Bool `json:"is_phase"`
	ProjectPhaseName string      `json:"project_phase_name"`
	PromotionType    string      `json:"promotion_type"`
}

func (q *Queries) GetProjectPromotions(ctx context.Context, id int64) (GetProjectPromotionsRow, error) {
	row := q.db.QueryRow(ctx, getProjectPromotions, id)
	var i GetProjectPromotionsRow
	err := row.Scan(
		&i.ID,
		&i.PromotionTypesID,
		&i.Description,
		&i.ExpiryDate,
		&i.Status,
		&i.ProjectsID,
		&i.PhasesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LiveStatus,
		&i.RefNo,
		&i.IsPhase,
		&i.ProjectPhaseName,
		&i.PromotionType,
	)
	return i, err
}

const updateProjectPromotionLiveStatus = `-- name: UpdateProjectPromotionLiveStatus :one
UPDATE project_promotions
SET live_status = $2
WHERE projects_id = $1
RETURNING id, promotion_types_id, description, expiry_date, status, projects_id, phases_id, created_at, updated_at, live_status, ref_no, is_phase
`

type UpdateProjectPromotionLiveStatusParams struct {
	ProjectsID int64       `json:"projects_id"`
	LiveStatus pgtype.Bool `json:"live_status"`
}

func (q *Queries) UpdateProjectPromotionLiveStatus(ctx context.Context, arg UpdateProjectPromotionLiveStatusParams) (ProjectPromotion, error) {
	row := q.db.QueryRow(ctx, updateProjectPromotionLiveStatus, arg.ProjectsID, arg.LiveStatus)
	var i ProjectPromotion
	err := row.Scan(
		&i.ID,
		&i.PromotionTypesID,
		&i.Description,
		&i.ExpiryDate,
		&i.Status,
		&i.ProjectsID,
		&i.PhasesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LiveStatus,
		&i.RefNo,
		&i.IsPhase,
	)
	return i, err
}

const updateProjectPromotions = `-- name: UpdateProjectPromotions :one
UPDATE project_promotions
SET    promotion_types_id = $2,
    description = $3,
    expiry_date = $4,
    status = $5,
    projects_id = $6,
    created_at = $7,
    updated_at = $8, 
    live_status = $9,
    ref_no = $10,
    phases_id = $11,
    is_phase = $12
Where id = $1
RETURNING id, promotion_types_id, description, expiry_date, status, projects_id, phases_id, created_at, updated_at, live_status, ref_no, is_phase
`

type UpdateProjectPromotionsParams struct {
	ID               int64       `json:"id"`
	PromotionTypesID int64       `json:"promotion_types_id"`
	Description      string      `json:"description"`
	ExpiryDate       time.Time   `json:"expiry_date"`
	Status           int64       `json:"status"`
	ProjectsID       int64       `json:"projects_id"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	LiveStatus       pgtype.Bool `json:"live_status"`
	RefNo            string      `json:"ref_no"`
	PhasesID         pgtype.Int8 `json:"phases_id"`
	IsPhase          pgtype.Bool `json:"is_phase"`
}

func (q *Queries) UpdateProjectPromotions(ctx context.Context, arg UpdateProjectPromotionsParams) (ProjectPromotion, error) {
	row := q.db.QueryRow(ctx, updateProjectPromotions,
		arg.ID,
		arg.PromotionTypesID,
		arg.Description,
		arg.ExpiryDate,
		arg.Status,
		arg.ProjectsID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LiveStatus,
		arg.RefNo,
		arg.PhasesID,
		arg.IsPhase,
	)
	var i ProjectPromotion
	err := row.Scan(
		&i.ID,
		&i.PromotionTypesID,
		&i.Description,
		&i.ExpiryDate,
		&i.Status,
		&i.ProjectsID,
		&i.PhasesID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LiveStatus,
		&i.RefNo,
		&i.IsPhase,
	)
	return i, err
}
