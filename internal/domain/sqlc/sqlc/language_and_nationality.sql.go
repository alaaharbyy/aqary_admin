// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: language_and_nationality.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkProfileLanguageExists = `-- name: CheckProfileLanguageExists :one
SELECT profile_languages.id, profiles_id, all_languages_id, all_languages.id, language, created_at, updated_at, code, flag FROM profile_languages 
INNER JOIN all_languages ON profile_languages.all_languages_id = all_languages.id
WHERE profile_languages.profiles_id = $1 AND profile_languages.all_languages_id = $2
`

type CheckProfileLanguageExistsParams struct {
	ProfileID  int64 `json:"profile_id"`
	LanguageID int64 `json:"language_id"`
}

type CheckProfileLanguageExistsRow struct {
	ID             int64       `json:"id"`
	ProfilesID     int64       `json:"profiles_id"`
	AllLanguagesID int64       `json:"all_languages_id"`
	ID_2           int64       `json:"id_2"`
	Language       string      `json:"language"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	Code           pgtype.Text `json:"code"`
	Flag           pgtype.Text `json:"flag"`
}

func (q *Queries) CheckProfileLanguageExists(ctx context.Context, arg CheckProfileLanguageExistsParams) (CheckProfileLanguageExistsRow, error) {
	row := q.db.QueryRow(ctx, checkProfileLanguageExists, arg.ProfileID, arg.LanguageID)
	var i CheckProfileLanguageExistsRow
	err := row.Scan(
		&i.ID,
		&i.ProfilesID,
		&i.AllLanguagesID,
		&i.ID_2,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Code,
		&i.Flag,
	)
	return i, err
}

const checkProfileNationalityExists = `-- name: CheckProfileNationalityExists :one
SELECT profile_nationalities.id, profiles_id, country_id, countries.id, country, flag, created_at, updated_at, alpha2_code, alpha3_code, country_code, lat, lng, name, numcode, default_settings, status, deleted_at, updated_by, country_ar FROM profile_nationalities
INNER JOIN countries ON profile_nationalities.country_id = countries.id
WHERE profile_nationalities.profiles_id = $1 AND profile_nationalities.country_id = $2
`

type CheckProfileNationalityExistsParams struct {
	ProfileID int64 `json:"profile_id"`
	CountryID int64 `json:"country_id"`
}

type CheckProfileNationalityExistsRow struct {
	ID              int64              `json:"id"`
	ProfilesID      int64              `json:"profiles_id"`
	CountryID       int64              `json:"country_id"`
	ID_2            int64              `json:"id_2"`
	Country         string             `json:"country"`
	Flag            string             `json:"flag"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	Alpha2Code      pgtype.Text        `json:"alpha2_code"`
	Alpha3Code      pgtype.Text        `json:"alpha3_code"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	Lat             pgtype.Float8      `json:"lat"`
	Lng             pgtype.Float8      `json:"lng"`
	Name            string             `json:"name"`
	Numcode         pgtype.Int8        `json:"numcode"`
	DefaultSettings []byte             `json:"default_settings"`
	Status          int64              `json:"status"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy       int64              `json:"updated_by"`
	CountryAr       pgtype.Text        `json:"country_ar"`
}

func (q *Queries) CheckProfileNationalityExists(ctx context.Context, arg CheckProfileNationalityExistsParams) (CheckProfileNationalityExistsRow, error) {
	row := q.db.QueryRow(ctx, checkProfileNationalityExists, arg.ProfileID, arg.CountryID)
	var i CheckProfileNationalityExistsRow
	err := row.Scan(
		&i.ID,
		&i.ProfilesID,
		&i.CountryID,
		&i.ID_2,
		&i.Country,
		&i.Flag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Alpha2Code,
		&i.Alpha3Code,
		&i.CountryCode,
		&i.Lat,
		&i.Lng,
		&i.Name,
		&i.Numcode,
		&i.DefaultSettings,
		&i.Status,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.CountryAr,
	)
	return i, err
}

const createProfileLanguage = `-- name: CreateProfileLanguage :one
INSERT INTO profile_languages(
    profiles_id,
    all_languages_id
)VALUES (
    $1, $2
)RETURNING id, profiles_id, all_languages_id
`

type CreateProfileLanguageParams struct {
	ProfilesID     int64 `json:"profiles_id"`
	AllLanguagesID int64 `json:"all_languages_id"`
}

func (q *Queries) CreateProfileLanguage(ctx context.Context, arg CreateProfileLanguageParams) (ProfileLanguage, error) {
	row := q.db.QueryRow(ctx, createProfileLanguage, arg.ProfilesID, arg.AllLanguagesID)
	var i ProfileLanguage
	err := row.Scan(&i.ID, &i.ProfilesID, &i.AllLanguagesID)
	return i, err
}

const createProfileNationalities = `-- name: CreateProfileNationalities :one
INSERT INTO profile_nationalities(
    profiles_id,
    country_id
)VALUES (
    $1, $2
)RETURNING id, profiles_id, country_id
`

type CreateProfileNationalitiesParams struct {
	ProfilesID int64 `json:"profiles_id"`
	CountryID  int64 `json:"country_id"`
}

func (q *Queries) CreateProfileNationalities(ctx context.Context, arg CreateProfileNationalitiesParams) (ProfileNationality, error) {
	row := q.db.QueryRow(ctx, createProfileNationalities, arg.ProfilesID, arg.CountryID)
	var i ProfileNationality
	err := row.Scan(&i.ID, &i.ProfilesID, &i.CountryID)
	return i, err
}

const deleteProfileLanguage = `-- name: DeleteProfileLanguage :many
DELETE FROM profile_languages
WHERE profiles_id = $1 
RETURNING id, profiles_id, all_languages_id
`

func (q *Queries) DeleteProfileLanguage(ctx context.Context, profilesID int64) ([]ProfileLanguage, error) {
	rows, err := q.db.Query(ctx, deleteProfileLanguage, profilesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfileLanguage
	for rows.Next() {
		var i ProfileLanguage
		if err := rows.Scan(&i.ID, &i.ProfilesID, &i.AllLanguagesID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteProfileLanguageList = `-- name: DeleteProfileLanguageList :exec
DELETE FROM profile_languages
WHERE profiles_id = $1 AND all_languages_id=any($2::BIGINT[])
`

type DeleteProfileLanguageListParams struct {
	ProfilesID   int64   `json:"profiles_id"`
	LanguagesIds []int64 `json:"languages_ids"`
}

func (q *Queries) DeleteProfileLanguageList(ctx context.Context, arg DeleteProfileLanguageListParams) error {
	_, err := q.db.Exec(ctx, deleteProfileLanguageList, arg.ProfilesID, arg.LanguagesIds)
	return err
}

const deleteProfileNationalities = `-- name: DeleteProfileNationalities :many
DELETE FROM profile_nationalities
WHERE profiles_id = $1 
RETURNING id, profiles_id, country_id
`

func (q *Queries) DeleteProfileNationalities(ctx context.Context, profilesID int64) ([]ProfileNationality, error) {
	rows, err := q.db.Query(ctx, deleteProfileNationalities, profilesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfileNationality
	for rows.Next() {
		var i ProfileNationality
		if err := rows.Scan(&i.ID, &i.ProfilesID, &i.CountryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteProfileNationalityList = `-- name: DeleteProfileNationalityList :exec
DELETE FROM profile_nationalities
WHERE profiles_id = $1 AND country_id=any($2::BIGINT[])
`

type DeleteProfileNationalityListParams struct {
	ProfilesID int64   `json:"profiles_id"`
	Countries  []int64 `json:"countries"`
}

func (q *Queries) DeleteProfileNationalityList(ctx context.Context, arg DeleteProfileNationalityListParams) error {
	_, err := q.db.Exec(ctx, deleteProfileNationalityList, arg.ProfilesID, arg.Countries)
	return err
}

const getAllLanguagesByID = `-- name: GetAllLanguagesByID :one
SELECT profile_languages.id, profiles_id, all_languages_id, all_languages.id, language, created_at, updated_at, code, flag FROM profile_languages
INNER JOIN all_languages ON profile_languages.all_languages_id = all_languages.id
WHERE profile_languages.id = $1
`

type GetAllLanguagesByIDRow struct {
	ID             int64       `json:"id"`
	ProfilesID     int64       `json:"profiles_id"`
	AllLanguagesID int64       `json:"all_languages_id"`
	ID_2           int64       `json:"id_2"`
	Language       string      `json:"language"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	Code           pgtype.Text `json:"code"`
	Flag           pgtype.Text `json:"flag"`
}

func (q *Queries) GetAllLanguagesByID(ctx context.Context, id int64) (GetAllLanguagesByIDRow, error) {
	row := q.db.QueryRow(ctx, getAllLanguagesByID, id)
	var i GetAllLanguagesByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProfilesID,
		&i.AllLanguagesID,
		&i.ID_2,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Code,
		&i.Flag,
	)
	return i, err
}

const getAllLanguagesByUserID = `-- name: GetAllLanguagesByUserID :many
SELECT profile_languages.id, profiles_id, all_languages_id, all_languages.id, language, created_at, updated_at, code, flag FROM profile_languages
INNER JOIN all_languages ON profile_languages.all_languages_id = all_languages.id
WHERE profile_languages.profiles_id = $1
`

type GetAllLanguagesByUserIDRow struct {
	ID             int64       `json:"id"`
	ProfilesID     int64       `json:"profiles_id"`
	AllLanguagesID int64       `json:"all_languages_id"`
	ID_2           int64       `json:"id_2"`
	Language       string      `json:"language"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	Code           pgtype.Text `json:"code"`
	Flag           pgtype.Text `json:"flag"`
}

func (q *Queries) GetAllLanguagesByUserID(ctx context.Context, profileID int64) ([]GetAllLanguagesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getAllLanguagesByUserID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllLanguagesByUserIDRow
	for rows.Next() {
		var i GetAllLanguagesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfilesID,
			&i.AllLanguagesID,
			&i.ID_2,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Code,
			&i.Flag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllNationalitiesByProfileID = `-- name: GetAllNationalitiesByProfileID :many
SELECT profile_nationalities.id, profiles_id, country_id, countries.id, country, flag, created_at, updated_at, alpha2_code, alpha3_code, country_code, lat, lng, name, numcode, default_settings, status, deleted_at, updated_by, country_ar FROM profile_nationalities
INNER JOIN countries ON profile_nationalities.country_id =  countries.id
WHERE profile_nationalities.profiles_id = $1
`

type GetAllNationalitiesByProfileIDRow struct {
	ID              int64              `json:"id"`
	ProfilesID      int64              `json:"profiles_id"`
	CountryID       int64              `json:"country_id"`
	ID_2            int64              `json:"id_2"`
	Country         string             `json:"country"`
	Flag            string             `json:"flag"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	Alpha2Code      pgtype.Text        `json:"alpha2_code"`
	Alpha3Code      pgtype.Text        `json:"alpha3_code"`
	CountryCode     pgtype.Int8        `json:"country_code"`
	Lat             pgtype.Float8      `json:"lat"`
	Lng             pgtype.Float8      `json:"lng"`
	Name            string             `json:"name"`
	Numcode         pgtype.Int8        `json:"numcode"`
	DefaultSettings []byte             `json:"default_settings"`
	Status          int64              `json:"status"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	UpdatedBy       int64              `json:"updated_by"`
	CountryAr       pgtype.Text        `json:"country_ar"`
}

func (q *Queries) GetAllNationalitiesByProfileID(ctx context.Context, profileID int64) ([]GetAllNationalitiesByProfileIDRow, error) {
	rows, err := q.db.Query(ctx, getAllNationalitiesByProfileID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllNationalitiesByProfileIDRow
	for rows.Next() {
		var i GetAllNationalitiesByProfileIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfilesID,
			&i.CountryID,
			&i.ID_2,
			&i.Country,
			&i.Flag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Alpha2Code,
			&i.Alpha3Code,
			&i.CountryCode,
			&i.Lat,
			&i.Lng,
			&i.Name,
			&i.Numcode,
			&i.DefaultSettings,
			&i.Status,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.CountryAr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLanguagesIDsByProfile = `-- name: GetLanguagesIDsByProfile :one
SELECT ARRAY_AGG(all_languages_id::BIGINT)::BIGINT[] AS languages_ids 
FROM profile_languages WHERE profiles_id= $1 
GROUP BY profiles_id
`

func (q *Queries) GetLanguagesIDsByProfile(ctx context.Context, profileID int64) ([]int64, error) {
	row := q.db.QueryRow(ctx, getLanguagesIDsByProfile, profileID)
	var languages_ids []int64
	err := row.Scan(&languages_ids)
	return languages_ids, err
}

const getNationalitiesIDsByProfile = `-- name: GetNationalitiesIDsByProfile :one
SELECT ARRAY_AGG(country_id::BIGINT)::BIGINT[] AS nationality_ids 
FROM profile_nationalities WHERE profiles_id= $1 
GROUP BY profiles_id
`

func (q *Queries) GetNationalitiesIDsByProfile(ctx context.Context, profileID int64) ([]int64, error) {
	row := q.db.QueryRow(ctx, getNationalitiesIDsByProfile, profileID)
	var nationality_ids []int64
	err := row.Scan(&nationality_ids)
	return nationality_ids, err
}

const updateProfileLanguage = `-- name: UpdateProfileLanguage :one
Update profile_languages
SET all_languages_id = $2
WHERE profiles_id = $1 and id = $3
RETURNING id, profiles_id, all_languages_id
`

type UpdateProfileLanguageParams struct {
	ProfilesID     int64 `json:"profiles_id"`
	AllLanguagesID int64 `json:"all_languages_id"`
	ID             int64 `json:"id"`
}

func (q *Queries) UpdateProfileLanguage(ctx context.Context, arg UpdateProfileLanguageParams) (ProfileLanguage, error) {
	row := q.db.QueryRow(ctx, updateProfileLanguage, arg.ProfilesID, arg.AllLanguagesID, arg.ID)
	var i ProfileLanguage
	err := row.Scan(&i.ID, &i.ProfilesID, &i.AllLanguagesID)
	return i, err
}

const updateProfileNationalies = `-- name: UpdateProfileNationalies :one
Update profile_nationalities
SET country_id = $2
WHERE profiles_id = $1
RETURNING id, profiles_id, country_id
`

type UpdateProfileNationaliesParams struct {
	ProfilesID int64 `json:"profiles_id"`
	CountryID  int64 `json:"country_id"`
}

func (q *Queries) UpdateProfileNationalies(ctx context.Context, arg UpdateProfileNationaliesParams) (ProfileNationality, error) {
	row := q.db.QueryRow(ctx, updateProfileNationalies, arg.ProfilesID, arg.CountryID)
	var i ProfileNationality
	err := row.Scan(&i.ID, &i.ProfilesID, &i.CountryID)
	return i, err
}
