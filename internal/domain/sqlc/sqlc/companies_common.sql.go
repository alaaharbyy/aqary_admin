// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: companies_common.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllCompanyNameWithBranches = `-- name: GetAllCompanyNameWithBranches :many
SELECT
    "company_name",
    "id",
    'services_companies' AS label,
    3 AS category,
    false AS is_branch
FROM
    "public"."services_companies"
UNION
SELECT
    "company_name",
    "id",
    'service_company_branches' AS label,
    3 AS category,
    true AS is_branch
FROM
    "public"."service_company_branches"
UNION
SELECT
    "company_name",
    "id",
    'broker_companies_branches' AS label,
    1 AS category,
    true AS is_branch
FROM
    "public"."broker_companies_branches"
UNION
SELECT
    "company_name",
    "id",
    'broker_companies' AS label,
    1 AS category,
    false AS is_branch
FROM
    "public"."broker_companies"
UNION
SELECT
    "company_name",
    "id",
    'developer_company_branches' AS label,
    2 AS category,
    true AS is_branch
FROM
    "public"."developer_company_branches"
UNION
SELECT
    "company_name",
    "id",
    'developer_companies' AS label,
    2 AS category,
    false AS is_branch
FROM
    "public"."developer_companies"
`

type GetAllCompanyNameWithBranchesRow struct {
	CompanyName string      `json:"company_name"`
	ID          int64       `json:"id"`
	Label       string      `json:"label"`
	Category    pgtype.Int8 `json:"category"`
	IsBranch    pgtype.Bool `json:"is_branch"`
}

func (q *Queries) GetAllCompanyNameWithBranches(ctx context.Context) ([]GetAllCompanyNameWithBranchesRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyNameWithBranches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyNameWithBranchesRow
	for rows.Next() {
		var i GetAllCompanyNameWithBranchesRow
		if err := rows.Scan(
			&i.CompanyName,
			&i.ID,
			&i.Label,
			&i.Category,
			&i.IsBranch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyNamesWithSearch = `-- name: GetAllCompanyNamesWithSearch :many
SELECT id, ref_no, company_name, company_activities_id, company_parent_id, tag_line, description, description_ar, logo_url, email, phone_number, whatsapp_number, is_verified, website_url, cover_image_url, no_of_employees, company_rank, status, company_type, addresses_id, users_id, created_by, created_at, updated_at, updated_by, location_url, vat_no, vat_status, vat_file_url FROM companies
WHERE 
    ($1::TEXT =''
     OR companies.company_name % $1::TEXT)
	 AND companies.company_type  = 1 
LIMIT 10
`

func (q *Queries) GetAllCompanyNamesWithSearch(ctx context.Context, search string) ([]Company, error) {
	rows, err := q.db.Query(ctx, getAllCompanyNamesWithSearch, search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.RefNo,
			&i.CompanyName,
			&i.CompanyActivitiesID,
			&i.CompanyParentID,
			&i.TagLine,
			&i.Description,
			&i.DescriptionAr,
			&i.LogoUrl,
			&i.Email,
			&i.PhoneNumber,
			&i.WhatsappNumber,
			&i.IsVerified,
			&i.WebsiteUrl,
			&i.CoverImageUrl,
			&i.NoOfEmployees,
			&i.CompanyRank,
			&i.Status,
			&i.CompanyType,
			&i.AddressesID,
			&i.UsersID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.LocationUrl,
			&i.VatNo,
			&i.VatStatus,
			&i.VatFileUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCompanyUsersByCompanyIdWithSearch = `-- name: GetAllCompanyUsersByCompanyIdWithSearch :many
SELECT 
    company_users.users_id,
    profiles.first_name,
    profiles.last_name
FROM company_users
INNER JOIN users ON users.id = company_users.users_id
INNER JOIN profiles ON profiles.users_id = users.id
WHERE 
    company_users.company_id = $1
    AND (
        $2::TEXT = '%%'
        OR CONCAT(profiles.first_name, ' ', profiles.last_name) ILIKE  $2::TEXT
    ) LIMIT 20
`

type GetAllCompanyUsersByCompanyIdWithSearchParams struct {
	CompanyID int64  `json:"company_id"`
	Search    string `json:"search"`
}

type GetAllCompanyUsersByCompanyIdWithSearchRow struct {
	UsersID   int64  `json:"users_id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
}

func (q *Queries) GetAllCompanyUsersByCompanyIdWithSearch(ctx context.Context, arg GetAllCompanyUsersByCompanyIdWithSearchParams) ([]GetAllCompanyUsersByCompanyIdWithSearchRow, error) {
	rows, err := q.db.Query(ctx, getAllCompanyUsersByCompanyIdWithSearch, arg.CompanyID, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCompanyUsersByCompanyIdWithSearchRow
	for rows.Next() {
		var i GetAllCompanyUsersByCompanyIdWithSearchRow
		if err := rows.Scan(&i.UsersID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersByCompanyType = `-- name: GetAllUsersByCompanyType :many
select users_id from developer_companies where $1 = 2 and $2 = false
UNION ALL 
select users_id from developer_company_branches where $1 = 2 and $2 = true
UNION ALL
select users_id from services_companies where $1 = 3 and $2 = false
UNION ALL 
select users_id from service_company_branches where $1 = 3 and $2 = true
UNION ALL
select users_id from broker_companies where $1 = 1 and $2 = false
UNION ALL 
select users_id from broker_companies_branches where $1 = 1 and $2 = true
`

type GetAllUsersByCompanyTypeParams struct {
	CompanyType interface{} `json:"company_type"`
	IsBranch    interface{} `json:"is_branch"`
}

func (q *Queries) GetAllUsersByCompanyType(ctx context.Context, arg GetAllUsersByCompanyTypeParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllUsersByCompanyType, arg.CompanyType, arg.IsBranch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var users_id int64
		if err := rows.Scan(&users_id); err != nil {
			return nil, err
		}
		items = append(items, users_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompaniesForAdmin = `-- name: GetCompaniesForAdmin :many
SELECT 
    'broker_companies' AS table_name,
    bc.id,
    bc.company_type,
    bc.is_branch,
    bc.company_name,
    bc.is_verified,
    bc.no_of_employees,
    bc.email,
    bc.website_url,
    bc.phone_number,
    bc.commercial_license_no
 
FROM 
    broker_companies bc
WHERE 
    bc.users_id = $1
UNION 
SELECT 
    'broker_companies_branches' AS table_name,
    bcb.id,
    bcb.company_type,
    bcb.is_branch,
    bcb.company_name,
    bcb.is_verified,
    bcb.no_of_employees,
    bcb.email,
    bcb.website_url,
    bcb.phone_number,
    bcb.commercial_license_no
FROM 
    broker_companies_branches bcb
JOIN 
    addresses a ON bcb.addresses_id = a.id
JOIN
    locations l ON a.locations_id = l.id
WHERE 
    bcb.users_id = $1
UNION 
SELECT 
    'developer_companies' AS table_name,
    dc.id,
    dc.company_type,
    dc.is_branch,
    dc.company_name,
    dc.is_verified,
    dc.no_of_employees,
    dc.email,
    dc.website_url,
    dc.phone_number,
    dc.commercial_license_no
FROM 
    developer_companies dc
WHERE 
    dc.users_id =$1
UNION 
SELECT 
    'developer_company_branches' AS table_name,
    dcb.id,
    dcb.company_type,
    dcb.is_branch,
    dcb.company_name,
    dcb.is_verified,
    dcb.no_of_employees,
    dcb.email,   
    dcb.website_url,
    dcb.phone_number,
    dcb.commercial_license_no
FROM 
    developer_company_branches dcb
WHERE 
    dcb.users_id = $1
UNION 
SELECT 
    'services_companies' AS table_name,
    sc.id,
    sc.company_type,
    sc.is_branch,
    sc.company_name,
    sc.is_verified,
    sc.no_of_employees,
    sc.email,
    sc.website_url,
    sc.phone_number,
    sc.commercial_license_no
 
FROM 
    services_companies sc
WHERE 
    sc.users_id =$1
UNION 
SELECT 
    'service_company_branches' AS table_name,
    scb.id,
    scb.company_type,
    scb.is_branch,
    scb.company_name,
    scb.is_verified,
    scb.no_of_employees,
    scb.email,
    scb.website_url,
    scb.phone_number,
    scb.commercial_license_no
FROM 
    service_company_branches scb
WHERE 
    scb.users_id =$1
UNION 
SELECT 
    'product_company' AS table_name,
    pc.id,
    pc.company_type,
    pc.is_branch,
    pc.company_name,
    pc.is_verified,
    pc.no_of_employees,
    pc.email,
    pc.website_url,
    pc.phone_number,
    pc.commercial_license_no
FROM 
    product_companies pc
WHERE 
    pc.users_id =$1
UNION 
SELECT 
    'product_company_branch' AS table_name,
    pcb.id,
    pcb.company_type,
    pcb.is_branch,
    pcb.company_name,
    pcb.is_verified,
    pcb.no_of_employees,
    pcb.email,
    pcb.website_url,
    pcb.phone_number,
    pcb.commercial_license_no
FROM 
    product_companies_branches pcb
WHERE 
    pcb.users_id = $1
`

type GetCompaniesForAdminRow struct {
	TableName           string      `json:"table_name"`
	ID                  int64       `json:"id"`
	CompanyType         int64       `json:"company_type"`
	IsBranch            pgtype.Bool `json:"is_branch"`
	CompanyName         string      `json:"company_name"`
	IsVerified          pgtype.Bool `json:"is_verified"`
	NoOfEmployees       pgtype.Int8 `json:"no_of_employees"`
	Email               pgtype.Text `json:"email"`
	WebsiteUrl          pgtype.Text `json:"website_url"`
	PhoneNumber         pgtype.Text `json:"phone_number"`
	CommercialLicenseNo string      `json:"commercial_license_no"`
}

func (q *Queries) GetCompaniesForAdmin(ctx context.Context, usersID int64) ([]GetCompaniesForAdminRow, error) {
	rows, err := q.db.Query(ctx, getCompaniesForAdmin, usersID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompaniesForAdminRow
	for rows.Next() {
		var i GetCompaniesForAdminRow
		if err := rows.Scan(
			&i.TableName,
			&i.ID,
			&i.CompanyType,
			&i.IsBranch,
			&i.CompanyName,
			&i.IsVerified,
			&i.NoOfEmployees,
			&i.Email,
			&i.WebsiteUrl,
			&i.PhoneNumber,
			&i.CommercialLicenseNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyNameByCompanyId = `-- name: GetCompanyNameByCompanyId :one

WITH x AS (
SELECT
    "company_name",
    "id",
    'services_companies' AS label,
    3 AS category,
    false AS is_branch 
FROM
    "public"."services_companies" WHERE services_companies.id = $1 AND 3 = $2 And false = $3
UNION
SELECT
    "company_name",
    "id",
    'service_company_branches' AS label,
    3 AS category,
    true AS is_branch
FROM
    "public"."service_company_branches" WHERE service_company_branches.id = $1 AND 3 = $2 And true = $3
UNION
SELECT
    "company_name",
    "id",
    'broker_companies_branches' AS label,
    1 AS category,
    true AS is_branch
FROM
    "public"."broker_companies_branches" WHERE broker_companies_branches.id = $1 AND 1 = $2 And true = $3
UNION
SELECT
    "company_name",
    "id",
    'broker_companies' AS label,
    1 AS category,
    false AS is_branch
FROM
    "public"."broker_companies" WHERE broker_companies.id = $1 AND 1 = $2 And false = $3
UNION
SELECT
    "company_name",
    "id",
    'developer_company_branches' AS label,
    2 AS category,
    true AS is_branch
FROM
    "public"."developer_company_branches" WHERE developer_company_branches.id = $1 AND 2 = $2 And true = $3
UNION
SELECT
    "company_name",
    "id",
    'developer_companies' AS label,
    2 AS category,
    false AS is_branch
FROM
    "public"."developer_companies" WHERE developer_companies.id = $1 AND 2 = $2 And false = $3
    ) SELECT company_name, id, label, category, is_branch FROM x LIMIT 1
`

type GetCompanyNameByCompanyIdParams struct {
	ID      int64       `json:"id"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
}

type GetCompanyNameByCompanyIdRow struct {
	CompanyName string      `json:"company_name"`
	ID          int64       `json:"id"`
	Label       string      `json:"label"`
	Category    pgtype.Int8 `json:"category"`
	IsBranch    pgtype.Bool `json:"is_branch"`
}

// -- name: GetAllCompanyNamesWithSearch :many
// SELECT * FROM companies
// WHERE
//
//	    (@search::TEXT ='')
//	     OR companies.company_name % @search::TEXT
//		AND companies.company_type  = 1
//
// ORDER BY companies.created_at DESC
// LIMIT 10;
func (q *Queries) GetCompanyNameByCompanyId(ctx context.Context, arg GetCompanyNameByCompanyIdParams) (GetCompanyNameByCompanyIdRow, error) {
	row := q.db.QueryRow(ctx, getCompanyNameByCompanyId, arg.ID, arg.Column2, arg.Column3)
	var i GetCompanyNameByCompanyIdRow
	err := row.Scan(
		&i.CompanyName,
		&i.ID,
		&i.Label,
		&i.Category,
		&i.IsBranch,
	)
	return i, err
}

const getCountForAdminCompaniesAndUserCompanies = `-- name: GetCountForAdminCompaniesAndUserCompanies :one
WITH user_companies AS (
    SELECT 
        count(*) AS user_company_count
    FROM company_users AS cu
    LEFT JOIN broker_companies bc ON cu.company_id = bc.id AND cu.is_branch = false AND cu.company_type = 1
    LEFT JOIN broker_companies_branches bcb ON cu.company_id = bcb.id AND cu.is_branch = true AND cu.company_type = 1
    LEFT JOIN developer_companies dc ON cu.company_id = dc.id AND cu.is_branch = false AND cu.company_type = 2
    LEFT JOIN developer_company_branches dcb ON cu.company_id = dcb.id AND cu.is_branch = true AND cu.company_type = 2
    LEFT JOIN services_companies sc ON cu.company_id = sc.id AND cu.is_branch = false AND cu.company_type = 3
    LEFT JOIN service_company_branches scb ON cu.company_id = scb.id AND cu.is_branch = true AND cu.company_type = 3
    LEFT JOIN product_companies pc ON cu.company_id = pc.id AND cu.is_branch = false AND cu.company_type = 4
    WHERE cu.users_id = $1
),
admin_companies AS (
    SELECT 
        count(*) AS admin_company_count
    FROM (
        SELECT bc.id
        FROM broker_companies bc
        WHERE bc.users_id = $1
        UNION ALL
        SELECT bcb.id
        FROM broker_companies_branches bcb
        WHERE bcb.users_id = $1
        UNION ALL
        SELECT dc.id
        FROM developer_companies dc
        WHERE dc.users_id = $1
        UNION ALL
        SELECT dcb.id
        FROM developer_company_branches dcb
        WHERE dcb.users_id = $1
        UNION ALL
        SELECT sc.id
        FROM services_companies sc
        WHERE sc.users_id = $1
        UNION ALL
        SELECT scb.id
        FROM service_company_branches scb
        WHERE scb.users_id = $1
        UNION ALL
        SELECT pc.id
        FROM product_companies pc
        WHERE pc.users_id = $1
        UNION ALL
        SELECT pcb.id
        FROM product_companies_branches pcb
        WHERE pcb.users_id = $1
    ) AS all_admin_companies
)
SELECT 
    uc.user_company_count, 
    ac.admin_company_count
FROM 
    user_companies uc,
    admin_companies ac
`

type GetCountForAdminCompaniesAndUserCompaniesRow struct {
	UserCompanyCount  int64 `json:"user_company_count"`
	AdminCompanyCount int64 `json:"admin_company_count"`
}

func (q *Queries) GetCountForAdminCompaniesAndUserCompanies(ctx context.Context, usersID int64) (GetCountForAdminCompaniesAndUserCompaniesRow, error) {
	row := q.db.QueryRow(ctx, getCountForAdminCompaniesAndUserCompanies, usersID)
	var i GetCountForAdminCompaniesAndUserCompaniesRow
	err := row.Scan(&i.UserCompanyCount, &i.AdminCompanyCount)
	return i, err
}

const getSingleCompanyName = `-- name: GetSingleCompanyName :one
SELECT
    company_name
FROM
    services_companies
WHERE
    services_companies.id = $1
    AND services_companies.company_type = $2
    AND services_companies.is_branch = $3
UNION
SELECT
    company_name
FROM
    service_company_branches
WHERE
   service_company_branches.id = $1
    AND service_company_branches.company_type = $2
    AND service_company_branches.is_branch = $3
UNION
SELECT
    company_name
FROM
    broker_companies_branches
WHERE
   broker_companies_branches.id = $1
    AND broker_companies_branches.company_type = $2
    AND broker_companies_branches.is_branch = $3
UNION
SELECT
    company_name
FROM
    broker_companies
WHERE
    broker_companies.id = $1
    AND broker_companies.company_type = $2
    AND broker_companies.is_branch = $3
UNION
SELECT
    company_name
FROM
    developer_company_branches
WHERE
    developer_company_branches.id = $1
    AND developer_company_branches.company_type = $2
    AND developer_company_branches.is_branch = $3
UNION
SELECT
    company_name
FROM
    developer_companies
WHERE
    developer_companies.id = $1
    AND developer_companies.company_type = $2
    AND developer_companies.is_branch = $3
LIMIT 1
`

type GetSingleCompanyNameParams struct {
	ID          int64       `json:"id"`
	CompanyType int64       `json:"company_type"`
	IsBranch    pgtype.Bool `json:"is_branch"`
}

func (q *Queries) GetSingleCompanyName(ctx context.Context, arg GetSingleCompanyNameParams) (string, error) {
	row := q.db.QueryRow(ctx, getSingleCompanyName, arg.ID, arg.CompanyType, arg.IsBranch)
	var company_name string
	err := row.Scan(&company_name)
	return company_name, err
}
